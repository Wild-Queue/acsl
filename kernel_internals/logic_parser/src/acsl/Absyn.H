/* File generated by the BNF Converter (bnfc 2.9.4.1). */

#ifndef ACSL_ABSYN_HEADER
#define ACSL_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.
namespace acsl
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string EXT_GLOBAL;
typedef std::string EXT_GLOBAL_BLOCK;
typedef std::string EXT_CODE_ANNOT;
typedef std::string EXT_CONTRACT;
typedef std::string STRING_LITERAL;
typedef std::string WSTRING_CONSTANT;
typedef std::string TYPENAME;


/********************   Forward Declarations    ********************/

class LexprEOF;
class LexprList;
class LexprOption;
class Lexpr;
class LexprBinder;
class LexprRelInner;
class Relation;
class Range;
class FieldInitElt;
class ArrayInitElt;
class UpdateElt;
class PathElt;
class Binders;
class BindersReentrance;
class VarSpec;
class ArraySize;
class AbsParamTypeList;
class AbsParam;
class Parameter;
class LogicTypeGenOFTYPENAME;
class LogicTypeGenOFIdentifierOrTypename;
class CV;
class TypeSpecCVOFTYPENAME;
class CastLogicType;
class LogicRtType;
class AbsSpecOption;
class AbsSpecCVOption;
class AbsSpec;
class AbsSpecCV;
class Stars;
class StarsCV;
class Tabs;
class TypeSpecSimple;
class TypeSpecOFTYPENAME;
class TypeSpecOFIdentifierOrTypename;
class FullIdentifier;
class ExtSpec;
class ExtGlobalClausesOpt;
class ExtGlobalClause;
class ExtGlobalSpecsOpt;
class ExtGlobalSpec;
class ExtModuleSpecsOpt;
class ExtModuleSpec;
class ExtFunctionSpecsOpt;
class ExtFunctionSpecs;
class ExtFunctionSpec;
class ExtFunSpec;
class ExtIdentifierOpt;
class StmtMarkup;
class Spec;
class Contract;
class ClauseKW;
class Requires;
class NERequires;
class Terminates;
class NETerminates;
class Decreases;
class NEDecreases;
class Variant;
class SimpleClauses;
class Allocation;
class NESimpleClauses;
class ExtensionContent;
class Behaviors;
class NEBehaviors;
class BehaviorBody;
class Assumes;
class CompleteOrDisjoint;
class NECompleteOrDisjoint;
class Assigns;
class Zones;
class Annot;
class Annotation;
class LoopAnnotStack;
class LoopAnnotOpt;
class LoopEffects;
class LoopAllocation;
class LoopInvariant;
class LoopVariant;
class LoopGrammarExtension;
class LoopPragma;
class BegPragmaOrCodeAnnotation;
class PragmaOrCodeAnnotation;
class CodeAnnotation;
class SlicePragma;
class ImpactPragma;
class Decl;
class ExtDecl;
class VolatileOpt;
class TypeAnnot;
class OptSemicolon;
class ModelAnnot;
class PolyIdType;
class PolyId;
class OptParameters;
class Parameters;
class LogicDef;
class DeprecatedLogicDecl;
class LogicDecl;
class ReadsClause;
class Typedef;
class DataconsWithSeparator;
class Datacons;
class Indcase;
class OptLabel;
class OptLabelList;
class LabelName;
class BehaviorNameList;
class BehaviorName;
class AnyIdentifier;
class IdentifierOrTypename;
class IdentifierOrTypenameFull;
class Identifier;
class BoundedVar;
class CKeyword;
class ACSLCKeyword;
class PostCond;
class IsACSLSpec;
class IsACSLDeclOrCodeAnnot;
class IsACSLTypename;
class IsExtSpec;
class Keyword;
class BSKeyword;
class Wildcard;
class LexprEof;
class EmptyLexprList;
class NonEmptyLexprList;
class NoLexprOption;
class SomeLexprOption;
class NoLexpr;
class ImplLexpr;
class IffLexpr;
class OrLexpr;
class AndLexpr;
class HatHatLexpr;
class AmpLexpr;
class PipeLexpr;
class HatLexpr;
class BimpliesLexpr;
class BiffLexpr;
class InLexpr;
class TernaryLexpr;
class IdAssignLexpr;
class StrAssignLexpr;
class RelationLexpr;
class BinderLexpr;
class NotBinderLexpr;
class LetBinderLexpr;
class ForallBinderLexpr;
class ExistBinderLexpr;
class LambdaBinderLexpr;
class RelInnerLexpr;
class LessRel;
class GreaterRel;
class LessEqRel;
class GreaterEqRel;
class EqRel;
class NotEqRel;
class EQUALRel;
class StringLexpr;
class NotLexprInner;
class TrueLexpr;
class FalseLexpr;
class PointerLexpr;
class ValidLexpr;
class ValidReadLexpr;
class ValidFuncLexpr;
class ValidIndxLexpr;
class ValidRangeLexpr;
class InitializedLexpr;
class DanglingLexpr;
class FreshLexpr;
class BaseAddrLexpr;
class BlockLengthLexpr;
class OffsetLexpr;
class AllocableLexpr;
class FreeableLexpr;
class AllocationLexpr;
class AutomaticLexpr;
class DynamicLexpr;
class RegisterLexpr;
class StaticLexpr;
class UnallocatedLexpr;
class NullLexpr;
class IntConst;
class FloatConst;
class StringConst;
class WStringConst;
class AddLexpr;
class SubtrLexpr;
class MultLexpr;
class DivLexpr;
class ModLexpr;
class StarHatLexpr;
class ArrowLexpr;
class DotLexpr;
class SquaresRangeLexpr;
class SquaresLexpr;
class SquaresPipeLexpr;
class MinusLexpr;
class PlusLexpr;
class TildeLexpr;
class StarLexpr;
class AmpUnaryLexpr;
class SizeOfLexpr;
class SizeOfLogicTypeLexpr;
class OldLexpr;
class AtLexpr;
class ResultLexpr;
class SeparatedLexpr;
class FullIdParenLexpr;
class FullIdBraceParenLexpr;
class FullIdBracesLexpr;
class FullId;
class PiLexpr;
class LessLessLexpr;
class GreaterGreaterLexpr;
class ParenRangeLexpr;
class CastLexpr;
class TypeOfLexpr;
class TypeLexpr;
class TypeWithStarsLexpr;
class EmptyLexpr;
class UnionLexpr;
class InterLexpr;
class BraceLexprList;
class BraceBinderLexpr;
class BraceBinderLexprLexpr;
class FieldInitLexpr;
class ArrayInitLexpr;
class UpdateBraceLexpr;
class LexprRange;
class AFieldInitElt;
class AnArrayInitElt;
class ArrayInitRangeElt;
class AnUpdateElt;
class UpdateEltWith;
class FieldElt;
class ArrayElt;
class ArrayRangeElt;
class TheBinders;
class BindersReentranceDeclSpec;
class BindersReentranceVarSpec;
class StartVarSpec;
class IntConstArraySize;
class SomeArraySize;
class NoSize;
class SimpleSpec;
class ArraySpec;
class FunctionSpec;
class EmptyTypeParam;
class SomeTypeParam;
class InfTypeParam;
class AbsParamsElement;
class Prartemer;
class LogicTypeGenTypemane;
class LogicTypeGenIdOrTypename;
class ConstCV;
class VolatileCV;
class GhostCV;
class TypeSpecCVTypename;
class AnCastLogicType;
class LogicRTType;
class NoAbsSpec;
class SomeAbsSpec;
class NoAbsSpecCV;
class SomeAbsSpecCV;
class AbsSpecTabs;
class AbsSpecStars;
class AbsSpecStarsTabs;
class AbsSpecBitsStars;
class AbsSpecBitsStarsTabs;
class AbsSpecBitsTabs;
class AbsSpecBits;
class AbsSpecCVTabs;
class AbsSpecCVStars;
class AbsSpecCVStarsTabs;
class AbsSpecCVBitsStars;
class AbsSpecCVBitsStarsTabs;
class AbsSpecCVBitsTabs;
class AbsSpecCVBits;
class AbsSpecBitsParams;
class AbsSpecBitsCVParams;
class Star;
class StarCV;
class StarCVWithCV;
class Tab;
class TypeSpecIntegerKeyWord;
class TypeSpecRealKeyWord;
class TypeSpecBooleanKeyWord;
class TypeSpecVoidKeyWord;
class TypeSpecBoolKeyWord;
class TypeSpecCharKeyWord;
class TypeSpecSignedCharKeyWord;
class TypeSpecUnsignedCharKeyWord;
class TypeSpecIntKeyWord;
class TypeSpecSignedIntKeyWord;
class TypeSpecUnsignedIntKeyWord;
class TypeSpecUnsignedKeyWord;
class TypeSpecShortKeyWord;
class TypeSpecSignedShortKeyWord;
class TypeSpecUnsignedShortKeyWord;
class TypeSpecShortIntKeyWord;
class TypeSpecSignedShortIntKeyWord;
class TypeSpecUnsignedShortIntKeyWord;
class TypeSpecLongKeyWord;
class TypeSpecSignedLongKeyWord;
class TypeSpecUnsignedLongKeyWord;
class TypeSpecSignedLongIntKeyWord;
class TypeSpecLongIntKeyWord;
class TypeSpecUnsignedLongIntKeyWord;
class TypeSpecLongLongKeyWord;
class TypeSpecSignedLongLongKeyWord;
class TypeSpecUnsignedLongLongKeyWord;
class TypeSpecLongLongIntKeyWord;
class TypeSpecSignedLongLongIntKeyWord;
class TypeSpecUnsignedLongLongIntKeyWord;
class TypeSpecFloatKeyWord;
class TypeSpecDoubleKeyWord;
class TypeSpecLongDoubleKeyWord;
class TypeSpecStruct;
class TypeSpecEnum;
class TypeSpecUnion;
class TYPENAME;
class TypeSpecTYPENAME;
class TypeSpecSimpleFromTypenameTypeSpec;
class TypeSpecIdentifierOrTypename;
class TypeSpecIdentifierOrTypenameAngles;
class TypeSpecSimpleFromIdTypenameTypeSpec;
class SimpleIdentifierFull;
class AdmitKeyWordFullIdent;
class AllocatesKeyWordFullIdent;
class AssertKeyWordFullIdent;
class AssignsKeyWordFullIdent;
class AssumesKeyWordFullIdent;
class AtKeyWordFullIdent;
class AxiomKeyWordFullIdent;
class AxiomaticKeyWordFullIdent;
class BehaviorKeyWordFullIdent;
class BreaksKeyWordFullIdent;
class CheckKeyWordFullIdent;
class CompleteKeyWordFullIdent;
class ContinuesKeyWordFullIdent;
class ContractKeyWordFullIdent;
class DecreasesKeyWordFullIdent;
class DisjointKeyWordFullIdent;
class EnsuresKeyWordFullIdent;
class ExitsKeyWordFullIdent;
class FreesKeyWordFullIdent;
class FunctionKeyWordFullIdent;
class GlobalKeyWordFullIdent;
class ImpactKeyWordFullIdent;
class InductiveKeyWordFullIdent;
class IncludeKeyWordFullIdent;
class InvariantKeyWordFullIdent;
class LemmaKeyWordFullIdent;
class LetKeyWordFullIdent;
class LogicKeyWordFullIdent;
class LoopKeyWordFullIdent;
class ModelKeyWordFullIdent;
class ModuleKeyWordFullIdent;
class PragmaKeyWordFullIdent;
class PredicateKeyWordFullIdent;
class RequiresKeyWordFullIdent;
class ReturnsKeyWordFullIdent;
class SliceKeyWordFullIdent;
class TerminatesKeyWordFullIdent;
class TypeKeyWordFullIdent;
class VariantKeyWordFullIdent;
class IdentExtCodeAnnotFullIdent;
class IdentExtContractFullIdent;
class IdentExtGlobalFullIdent;
class IdentExtGlobalBlockFullIdent;
class ExrSpec;
class EmptyExtGlobalClauses;
class SomeExtGlobalClauses;
class DeclClause;
class LetClause;
class GlobalLetClause;
class IncludeClause;
class EmptyExtGlobalSpecs;
class SomeExtGlobalSpecs;
class ExtGlobalSpecClauseModule;
class ExtGlobalSpecModule;
class ExtGlobalSpecClause;
class ExtGlobalSpecSimple;
class EmptyExtModuleSpecs;
class ListExtModuleSpecs;
class FunSpecExtModuleSpecs;
class FunSpecWithListModules;
class AnExtModuleSpec;
class NoExtFunctionSpecs;
class SomeExtFunctionSpecs;
class AtMarkup;
class ListFunctionSpecs;
class ListFunctionSpecsAtMarkup;
class AnExtGlobalClause;
class AnExtFunSpec;
class FunSpecAtAnnotation;
class FunSpecAtContract;
class FunSpecContract;
class ExtIdentifierEmpty;
class ExtIdentifierSome;
class MarkupStmtIdentifier;
class MarkupIntConstant;
class SpecConstract;
class SimpleContract;
class TerminatesRequiresContract;
class DecreasesRequiresContract;
class DecreasesTerminatesContract;
class ClausesRequiresContract;
class ClausesTerminatesContract;
class ClausesDecreasesContract;
class BehaviorsTerminatesContract;
class BehaviorsDecreasesContract;
class ComplDisjRequiresContract;
class ComplDisjTerminatesContract;
class ComplDisjDecreasesContract;
class ComplDisjBehaviorContract;
class ComplDisjAssignsContract;
class ComplDisjAllocatesContract;
class ComplDisjFreesContract;
class ComplDisjPostCondContract;
class AdmitRequiresClause;
class AdmitInvariantClause;
class AdmitLemmaClause;
class AdmitLoopClause;
class CheckRequiresClause;
class CheckInvariantClause;
class CheckLemmaClause;
class CheckLoopClause;
class RequiresClause;
class AssumesClause;
class AssignsClause;
class PostCondClause;
class DecreasesClause;
class BehaviorClause;
class AllocatesClause;
class FreesClause;
class CompleteClause;
class DisjointClause;
class ClauseExtConstract;
class EmptyClauseKW;
class NoRequires;
class SomeRequires;
class SimpleRequires;
class CheckRequires;
class AdimtRequires;
class ClauseSimpleRequires;
class ClauseCheckRequires;
class ClauseAdimtRequires;
class NoTerminate;
class SomeTerminate;
class SimpleTerminates;
class ClauseTerminates;
class NoDecreases;
class SomeDecreases;
class SimpleDecreases;
class ClauseDecreases;
class ForVariant;
class LexprVariant;
class NoSimpleClauses;
class SomeSimpleClauses;
class AllocatesZones;
class FreesZones;
class PostCondSimpleClauses;
class AllocationSimpleClauses;
class AssignsSimpleClauses;
class ExtContractSimpleClauses;
class ClausesPostCondSimpleClauses;
class ClausesAllocationSimpleClauses;
class ClausesAssignsSimpleClauses;
class ExtConClausestractSimpleClauses;
class NoExtensionContent;
class SomeExtensionContent;
class NoBehaviors;
class SomeBehaviors;
class TheBehaviors;
class SimpleClausesBehavior;
class RequiresAssumes;
class SimpleClausesAssumes;
class RequiresRequires;
class NoAssumes;
class SimpleAssumes;
class ClauseAssumes;
class NoComplDisj;
class SomeComplDisj;
class CompleteBehavior;
class DisjointBehavior;
class CompleteBehaviorClause;
class DisjointBehaviorClause;
class AssignZone;
class AssignZoneFromZone;
class SomeZone;
class NoZone;
class AnAnnotation;
class ACSLSpec;
class AnnotDecl;
class LoopAnnotation;
class ForContractAnnotation;
class ForCodeAnnotation;
class SimplePragmaOrCodeAnnotation;
class PragmaOrCodeAnnotationBeg;
class IdentifierAnnotation;
class GhostAnnotation;
class LoopAnnotStackInvariant;
class LoopAnnotStackEffects;
class LoopAnnotStackAllocation;
class LoopAnnotStackForBehavior;
class LoopAnnotStackVariant;
class LoopAnnotStackPragma;
class LoopAnnotStackGrammarExten;
class NoLoopAnnot;
class SomeLoopAnnot;
class LoopAssigns;
class SimpleLoopAllocation;
class SimpleLoopInvariant;
class CheckLoopInvariant;
class AdmitLoopInvariant;
class SimpleLoopVariant;
class SimpleLoopGrammarExten;
class PragmaLoop;
class ImpactKeyWordBegPragma;
class SliceKeyWordBegPragma;
class ForKeyWordBegPragma;
class AssertKeyWordBegPragma;
class CheckKeyWordBegPragma;
class AdmitKeyWordBegPragma;
class InvariantKeyWordBegPragma;
class CheckInvariantKeyWordBegPragma;
class AdmitInvariantKeyWordBegPragma;
class CheckLoopKeyWordBegPragma;
class AdmitLoopKeyWordBegPragma;
class BegExtCodeAnnotBegPragma;
class PragmaCodeAnnotSlice;
class PragmaCodeAnnotImpact;
class CodeAnnot;
class AssertCodeAnnot;
class CheckCodeAnnot;
class AdmitCodeAnnot;
class InvariantCodeAnnot;
class CheckInvariantCodeAnnot;
class AdmitInvariantCodeAnnot;
class ExtCodeAnnotCodeAnnot;
class PragmaSliceLexpr;
class PragmaSlice;
class ImpactPragmaLexpr;
class AnImpactPragma;
class DeclGlobalInvariant;
class DeclVolatile;
class DeclTypeAnnot;
class DeclModelAnnot;
class DeclLogicDef;
class DeclExt;
class DeclDeprecatedLogic;
class ExtGlobalDecl;
class ExtGlobalBlockDecl;
class ReadVolotile;
class WriteVolotile;
class TypeInvariant;
class NoSemicolon;
class Semicolon;
class ModelAnnotation;
class SimplePolyIdType;
class PolyIdTypeAngles;
class PolyTypeId;
class PolyIdTypeSquares;
class PolyIdTypeSquaresAngles;
class NoParameters;
class SomeParameters;
class AParameters;
class SimpleLogicDef;
class PredicateLogicDef;
class InductiveLogicDef;
class LemmaLogicDef;
class CheckLemmaLogicDef;
class AdmitLemmaLogicDef;
class AxiomaticLogicDef;
class TypeLogicDef;
class SimpleDeprecatedLogicDecl;
class PredicateDeprecatedLogicDecl;
class TypeDeprecatedLogicDecl;
class AxiomDeprecatedLogicDecl;
class LocidDeclDef;
class SimpleLogicDecl;
class PredicateLogicDecl;
class TypeLogicDecl;
class AxiomLogicDecl;
class NoReadsClause;
class SomeReadsClause;
class ListOfDatacons;
class TypedefLogicTypeGen;
class SimpleDataCons;
class DataConsWithPipe;
class DataConsFullIdentifier;
class DataConsFullIdentifierFun;
class IndCase;
class OptLabelOne;
class OptLabelTwo;
class NoLableList;
class LableList;
class LableName;
class EmptyBehaviorNameList;
class AnBehaviorNameList;
class BehaviorNameAnyIdent;
class SimpleIdentifierAny;
class ACSLTypenameIdentifier;
class TypenameIdentifier;
class KeywordIdentifier;
class Typename;
class AnFullIdentifier;
class ACSLTypename;
class AnIdentifierOrTypename;
class IdentifierIdent;
class BehaviorsKeyWord;
class LabelKeyWord;
class ReadsKeyWord;
class WritesKeyWord;
class BoendedVarFullIdentifier;
class BoendedVarACSLTypename;
class BoendedVarTypename;
class CharKeyWord;
class BooleanKeyWord;
class BoolKeyWord;
class ConstKeyWord;
class DoubleKeyWord;
class EnumKeyWord;
class ElseKeyWord;
class FloatKeyWord;
class IfKeyWord;
class IntKeyWord;
class LongKeyWord;
class ShortKeyWord;
class SignedKeyWord;
class SizeofKeyWord;
class StaticKeyWord;
class StructKeyWord;
class UnionKeyWord;
class UnsignedKeyWord;
class VoidKeyWord;
class CaseKeyWord;
class ForKeyWord;
class VolatileKeyWord;
class EnsuresKeyWord;
class ExitsKeyWord;
class BreaksKeyWord;
class ContinuesKeyWord;
class ReturnsKeyWord;
class CheckEnsuresKeyWord;
class CheckExitsKeyWord;
class CheckBreaksKeyWord;
class CheckContinuesKeyWord;
class CheckReturnsKeyWord;
class AdmitEnsuresKeyWord;
class AdmitExitsKeyWord;
class AdmitBreaksKeyWord;
class AdmitContinuesKeyWord;
class AdmitReturnsKeyWord;
class PostCondKeyWord;
class ExtContractKeyWord;
class AssignsKeyWord;
class AllocatesKeyWord;
class FreesKeyWord;
class BehaviorKeyWord;
class RequiresKeyWord;
class CheckRequiresKeyWord;
class AdmitRequiresKeyWord;
class TerminatesKeyWord;
class CompleteKeyWord;
class DecreasesKeyWord;
class DisjointKeyWord;
class ExtCodeAnnotKeyWord;
class ExtGlobalKeyWord;
class ExtGlobalBlockKeyWord;
class AssumesKeyWord;
class AssertKeyWord;
class CheckKeyWord;
class AdmitKeyWord;
class GlobalKeyWord;
class ImpactKeyWord;
class InductiveKeyWord;
class InvariantKeyWord;
class AdmitInvariantKeyWord;
class CheckInvariantKeyWord;
class LemmaKeyWord;
class AdmitLemmaKeyWord;
class CheckLemmaKeyWord;
class LoopKeyWord;
class AdmitLoopKeyWord;
class CheckLoopKeyWord;
class PragmaKeyWord;
class PredicateKeyWord;
class SliceKeyWord;
class TypeKeyWord;
class ModelKeyWord;
class AxiomKeyWord;
class VariantKeyWord;
class AxiomaticKeyWord;
class Integer;
class Real;
class ContractKeyWord;
class FunctionKeyWord;
class ModuleKeyWord;
class IncludeKeyWord;
class AtKeyWord;
class LetKeyWord;
class LogicKeyWord;
class CKeyWord;
class ACSLCKeyWord;
class ExtSpecKeyWord;
class ACSLSpecKeyWord;
class ACSLDeclCodeAnnotKeyWord;
class SlashAllocableKeyWord;
class SlashAllocationKeyWord;
class SlashAutomaticKeyWord;
class SlashAtKeyWord;
class SlashBaseAddrKeyWord;
class SlashBlockLengthKeyWord;
class SlashGhostKeyWord;
class SlashDynamicKeyWord;
class SlashEmptyKeyWord;
class SlashFalseKeyWord;
class SlashForallKeyWord;
class SlashFreeableKeyWord;
class SlashFreshKeyWord;
class SlashFromKeyWord;
class SlashInterKeyWord;
class SlashLambdaKeyWord;
class SlashLetKeyWord;
class SlashNothingKeyWord;
class SlashNullKeyWord;
class SlashOldKeyWord;
class SlashOffsetKeyWord;
class SlashRegisterKeyWord;
class SlashResultKeyWord;
class SlashSeparatedKeyWord;
class SlashTrueKeyWord;
class SlashTypeKeyWord;
class SlashTypeofKeyWord;
class SlashUnionKeyWord;
class SlashUnallocatedKeyWord;
class SlashObjectPointerKeyWord;
class SlashValidKeyWord;
class SlashValidIndexKeyWord;
class SlashValidRangeKeyWord;
class SlashValidReadKeyWord;
class SlashValidFunctionKeyWord;
class SlashInitializedKeyWord;
class SlashDanglingKeyWord;
class SlashWithKeyWord;
class WildCardAnyIdent;
class WildCardBSKeyWord;
class Amp;
class And;
class Arrow;
class BIff;
class BImplicate;
class Colon;
class ColonColon;
class Comma;
class IntConstant;
class FloatConstant;
class StringConstant;
class WstringConstant;
class Dollar;
class Dot;
class DotDot;
class DotDotDot;
class EQ;
class Equal;
class ExistsKeyWord;
class GreaterEq;
class GhostKeyWord;
class Greater;
class GreaterGreater;
class Hat;
class HatHat;
class Iff;
class Implicate;
class LeftBrace;
class LessEq;
class LeftPar;
class LeftSquare;
class LeftSquarePipe;
class Less;
class LessLess;
class Minus;
class NotEq;
class Not;
class PipePipe;
class Mod;
class PiKeyWord;
class Pipe;
class Plus;
class Question;
class RightBrace;
class RightPar;
class RightSquare;
class RightSquarePipe;
class SemiColon;
class Divide;
class Mult;
class MultHat;
class StringLiteral;
class TildeKeyWord;
class InKeyWord;
class ListLexpr;
class ListLexprRelInner;
class ListSTRING_LITERAL;
class ListFieldInitElt;
class ListArrayInitElt;
class ListUpdateElt;
class ListPathElt;
class ListBindersReentrance;
class ListAbsParam;
class ListParameter;
class ListLogicTypeGenOFTYPENAME;
class ListLogicTypeGenOFIdentifierOrTypename;
class ListCV;
class ListStars;
class ListStarsCV;
class ListTabs;
class ListFullIdentifier;
class ListExtGlobalClause;
class ListExtGlobalSpec;
class ListExtModuleSpec;
class ListExtFunctionSpec;
class ListExtFunSpec;
class ListStmtMarkup;
class ListDecl;
class ListExtDecl;
class ListVolatileOpt;
class ListLogicDecl;
class ListDataconsWithSeparator;
class ListIndcase;
class ListLabelName;
class ListBehaviorName;
class ListIdentifierOrTypenameFull;
class ListWildcard;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitLexprEOF(LexprEOF *p) = 0;
  virtual void visitLexprList(LexprList *p) = 0;
  virtual void visitLexprOption(LexprOption *p) = 0;
  virtual void visitLexpr(Lexpr *p) = 0;
  virtual void visitLexprBinder(LexprBinder *p) = 0;
  virtual void visitLexprRelInner(LexprRelInner *p) = 0;
  virtual void visitRelation(Relation *p) = 0;
  virtual void visitRange(Range *p) = 0;
  virtual void visitFieldInitElt(FieldInitElt *p) = 0;
  virtual void visitArrayInitElt(ArrayInitElt *p) = 0;
  virtual void visitUpdateElt(UpdateElt *p) = 0;
  virtual void visitPathElt(PathElt *p) = 0;
  virtual void visitBinders(Binders *p) = 0;
  virtual void visitBindersReentrance(BindersReentrance *p) = 0;
  virtual void visitVarSpec(VarSpec *p) = 0;
  virtual void visitArraySize(ArraySize *p) = 0;
  virtual void visitAbsParamTypeList(AbsParamTypeList *p) = 0;
  virtual void visitAbsParam(AbsParam *p) = 0;
  virtual void visitParameter(Parameter *p) = 0;
  virtual void visitLogicTypeGenOFTYPENAME(LogicTypeGenOFTYPENAME *p) = 0;
  virtual void visitLogicTypeGenOFIdentifierOrTypename(LogicTypeGenOFIdentifierOrTypename *p) = 0;
  virtual void visitCV(CV *p) = 0;
  virtual void visitTypeSpecCVOFTYPENAME(TypeSpecCVOFTYPENAME *p) = 0;
  virtual void visitCastLogicType(CastLogicType *p) = 0;
  virtual void visitLogicRtType(LogicRtType *p) = 0;
  virtual void visitAbsSpecOption(AbsSpecOption *p) = 0;
  virtual void visitAbsSpecCVOption(AbsSpecCVOption *p) = 0;
  virtual void visitAbsSpec(AbsSpec *p) = 0;
  virtual void visitAbsSpecCV(AbsSpecCV *p) = 0;
  virtual void visitStars(Stars *p) = 0;
  virtual void visitStarsCV(StarsCV *p) = 0;
  virtual void visitTabs(Tabs *p) = 0;
  virtual void visitTypeSpecSimple(TypeSpecSimple *p) = 0;
  virtual void visitTypeSpecOFTYPENAME(TypeSpecOFTYPENAME *p) = 0;
  virtual void visitTypeSpecOFIdentifierOrTypename(TypeSpecOFIdentifierOrTypename *p) = 0;
  virtual void visitFullIdentifier(FullIdentifier *p) = 0;
  virtual void visitExtSpec(ExtSpec *p) = 0;
  virtual void visitExtGlobalClausesOpt(ExtGlobalClausesOpt *p) = 0;
  virtual void visitExtGlobalClause(ExtGlobalClause *p) = 0;
  virtual void visitExtGlobalSpecsOpt(ExtGlobalSpecsOpt *p) = 0;
  virtual void visitExtGlobalSpec(ExtGlobalSpec *p) = 0;
  virtual void visitExtModuleSpecsOpt(ExtModuleSpecsOpt *p) = 0;
  virtual void visitExtModuleSpec(ExtModuleSpec *p) = 0;
  virtual void visitExtFunctionSpecsOpt(ExtFunctionSpecsOpt *p) = 0;
  virtual void visitExtFunctionSpecs(ExtFunctionSpecs *p) = 0;
  virtual void visitExtFunctionSpec(ExtFunctionSpec *p) = 0;
  virtual void visitExtFunSpec(ExtFunSpec *p) = 0;
  virtual void visitExtIdentifierOpt(ExtIdentifierOpt *p) = 0;
  virtual void visitStmtMarkup(StmtMarkup *p) = 0;
  virtual void visitSpec(Spec *p) = 0;
  virtual void visitContract(Contract *p) = 0;
  virtual void visitClauseKW(ClauseKW *p) = 0;
  virtual void visitRequires(Requires *p) = 0;
  virtual void visitNERequires(NERequires *p) = 0;
  virtual void visitTerminates(Terminates *p) = 0;
  virtual void visitNETerminates(NETerminates *p) = 0;
  virtual void visitDecreases(Decreases *p) = 0;
  virtual void visitNEDecreases(NEDecreases *p) = 0;
  virtual void visitVariant(Variant *p) = 0;
  virtual void visitSimpleClauses(SimpleClauses *p) = 0;
  virtual void visitAllocation(Allocation *p) = 0;
  virtual void visitNESimpleClauses(NESimpleClauses *p) = 0;
  virtual void visitExtensionContent(ExtensionContent *p) = 0;
  virtual void visitBehaviors(Behaviors *p) = 0;
  virtual void visitNEBehaviors(NEBehaviors *p) = 0;
  virtual void visitBehaviorBody(BehaviorBody *p) = 0;
  virtual void visitAssumes(Assumes *p) = 0;
  virtual void visitCompleteOrDisjoint(CompleteOrDisjoint *p) = 0;
  virtual void visitNECompleteOrDisjoint(NECompleteOrDisjoint *p) = 0;
  virtual void visitAssigns(Assigns *p) = 0;
  virtual void visitZones(Zones *p) = 0;
  virtual void visitAnnot(Annot *p) = 0;
  virtual void visitAnnotation(Annotation *p) = 0;
  virtual void visitLoopAnnotStack(LoopAnnotStack *p) = 0;
  virtual void visitLoopAnnotOpt(LoopAnnotOpt *p) = 0;
  virtual void visitLoopEffects(LoopEffects *p) = 0;
  virtual void visitLoopAllocation(LoopAllocation *p) = 0;
  virtual void visitLoopInvariant(LoopInvariant *p) = 0;
  virtual void visitLoopVariant(LoopVariant *p) = 0;
  virtual void visitLoopGrammarExtension(LoopGrammarExtension *p) = 0;
  virtual void visitLoopPragma(LoopPragma *p) = 0;
  virtual void visitBegPragmaOrCodeAnnotation(BegPragmaOrCodeAnnotation *p) = 0;
  virtual void visitPragmaOrCodeAnnotation(PragmaOrCodeAnnotation *p) = 0;
  virtual void visitCodeAnnotation(CodeAnnotation *p) = 0;
  virtual void visitSlicePragma(SlicePragma *p) = 0;
  virtual void visitImpactPragma(ImpactPragma *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitExtDecl(ExtDecl *p) = 0;
  virtual void visitVolatileOpt(VolatileOpt *p) = 0;
  virtual void visitTypeAnnot(TypeAnnot *p) = 0;
  virtual void visitOptSemicolon(OptSemicolon *p) = 0;
  virtual void visitModelAnnot(ModelAnnot *p) = 0;
  virtual void visitPolyIdType(PolyIdType *p) = 0;
  virtual void visitPolyId(PolyId *p) = 0;
  virtual void visitOptParameters(OptParameters *p) = 0;
  virtual void visitParameters(Parameters *p) = 0;
  virtual void visitLogicDef(LogicDef *p) = 0;
  virtual void visitDeprecatedLogicDecl(DeprecatedLogicDecl *p) = 0;
  virtual void visitLogicDecl(LogicDecl *p) = 0;
  virtual void visitReadsClause(ReadsClause *p) = 0;
  virtual void visitTypedef(Typedef *p) = 0;
  virtual void visitDataconsWithSeparator(DataconsWithSeparator *p) = 0;
  virtual void visitDatacons(Datacons *p) = 0;
  virtual void visitIndcase(Indcase *p) = 0;
  virtual void visitOptLabel(OptLabel *p) = 0;
  virtual void visitOptLabelList(OptLabelList *p) = 0;
  virtual void visitLabelName(LabelName *p) = 0;
  virtual void visitBehaviorNameList(BehaviorNameList *p) = 0;
  virtual void visitBehaviorName(BehaviorName *p) = 0;
  virtual void visitAnyIdentifier(AnyIdentifier *p) = 0;
  virtual void visitIdentifierOrTypename(IdentifierOrTypename *p) = 0;
  virtual void visitIdentifierOrTypenameFull(IdentifierOrTypenameFull *p) = 0;
  virtual void visitIdentifier(Identifier *p) = 0;
  virtual void visitBoundedVar(BoundedVar *p) = 0;
  virtual void visitCKeyword(CKeyword *p) = 0;
  virtual void visitACSLCKeyword(ACSLCKeyword *p) = 0;
  virtual void visitPostCond(PostCond *p) = 0;
  virtual void visitIsACSLSpec(IsACSLSpec *p) = 0;
  virtual void visitIsACSLDeclOrCodeAnnot(IsACSLDeclOrCodeAnnot *p) = 0;
  virtual void visitIsACSLTypename(IsACSLTypename *p) = 0;
  virtual void visitIsExtSpec(IsExtSpec *p) = 0;
  virtual void visitKeyword(Keyword *p) = 0;
  virtual void visitBSKeyword(BSKeyword *p) = 0;
  virtual void visitWildcard(Wildcard *p) = 0;
  virtual void visitLexprEof(LexprEof *p) = 0;
  virtual void visitEmptyLexprList(EmptyLexprList *p) = 0;
  virtual void visitNonEmptyLexprList(NonEmptyLexprList *p) = 0;
  virtual void visitNoLexprOption(NoLexprOption *p) = 0;
  virtual void visitSomeLexprOption(SomeLexprOption *p) = 0;
  virtual void visitNoLexpr(NoLexpr *p) = 0;
  virtual void visitImplLexpr(ImplLexpr *p) = 0;
  virtual void visitIffLexpr(IffLexpr *p) = 0;
  virtual void visitOrLexpr(OrLexpr *p) = 0;
  virtual void visitAndLexpr(AndLexpr *p) = 0;
  virtual void visitHatHatLexpr(HatHatLexpr *p) = 0;
  virtual void visitAmpLexpr(AmpLexpr *p) = 0;
  virtual void visitPipeLexpr(PipeLexpr *p) = 0;
  virtual void visitHatLexpr(HatLexpr *p) = 0;
  virtual void visitBimpliesLexpr(BimpliesLexpr *p) = 0;
  virtual void visitBiffLexpr(BiffLexpr *p) = 0;
  virtual void visitInLexpr(InLexpr *p) = 0;
  virtual void visitTernaryLexpr(TernaryLexpr *p) = 0;
  virtual void visitIdAssignLexpr(IdAssignLexpr *p) = 0;
  virtual void visitStrAssignLexpr(StrAssignLexpr *p) = 0;
  virtual void visitRelationLexpr(RelationLexpr *p) = 0;
  virtual void visitBinderLexpr(BinderLexpr *p) = 0;
  virtual void visitNotBinderLexpr(NotBinderLexpr *p) = 0;
  virtual void visitLetBinderLexpr(LetBinderLexpr *p) = 0;
  virtual void visitForallBinderLexpr(ForallBinderLexpr *p) = 0;
  virtual void visitExistBinderLexpr(ExistBinderLexpr *p) = 0;
  virtual void visitLambdaBinderLexpr(LambdaBinderLexpr *p) = 0;
  virtual void visitRelInnerLexpr(RelInnerLexpr *p) = 0;
  virtual void visitLessRel(LessRel *p) = 0;
  virtual void visitGreaterRel(GreaterRel *p) = 0;
  virtual void visitLessEqRel(LessEqRel *p) = 0;
  virtual void visitGreaterEqRel(GreaterEqRel *p) = 0;
  virtual void visitEqRel(EqRel *p) = 0;
  virtual void visitNotEqRel(NotEqRel *p) = 0;
  virtual void visitEQUALRel(EQUALRel *p) = 0;
  virtual void visitStringLexpr(StringLexpr *p) = 0;
  virtual void visitNotLexprInner(NotLexprInner *p) = 0;
  virtual void visitTrueLexpr(TrueLexpr *p) = 0;
  virtual void visitFalseLexpr(FalseLexpr *p) = 0;
  virtual void visitPointerLexpr(PointerLexpr *p) = 0;
  virtual void visitValidLexpr(ValidLexpr *p) = 0;
  virtual void visitValidReadLexpr(ValidReadLexpr *p) = 0;
  virtual void visitValidFuncLexpr(ValidFuncLexpr *p) = 0;
  virtual void visitValidIndxLexpr(ValidIndxLexpr *p) = 0;
  virtual void visitValidRangeLexpr(ValidRangeLexpr *p) = 0;
  virtual void visitInitializedLexpr(InitializedLexpr *p) = 0;
  virtual void visitDanglingLexpr(DanglingLexpr *p) = 0;
  virtual void visitFreshLexpr(FreshLexpr *p) = 0;
  virtual void visitBaseAddrLexpr(BaseAddrLexpr *p) = 0;
  virtual void visitBlockLengthLexpr(BlockLengthLexpr *p) = 0;
  virtual void visitOffsetLexpr(OffsetLexpr *p) = 0;
  virtual void visitAllocableLexpr(AllocableLexpr *p) = 0;
  virtual void visitFreeableLexpr(FreeableLexpr *p) = 0;
  virtual void visitAllocationLexpr(AllocationLexpr *p) = 0;
  virtual void visitAutomaticLexpr(AutomaticLexpr *p) = 0;
  virtual void visitDynamicLexpr(DynamicLexpr *p) = 0;
  virtual void visitRegisterLexpr(RegisterLexpr *p) = 0;
  virtual void visitStaticLexpr(StaticLexpr *p) = 0;
  virtual void visitUnallocatedLexpr(UnallocatedLexpr *p) = 0;
  virtual void visitNullLexpr(NullLexpr *p) = 0;
  virtual void visitIntConst(IntConst *p) = 0;
  virtual void visitFloatConst(FloatConst *p) = 0;
  virtual void visitStringConst(StringConst *p) = 0;
  virtual void visitWStringConst(WStringConst *p) = 0;
  virtual void visitAddLexpr(AddLexpr *p) = 0;
  virtual void visitSubtrLexpr(SubtrLexpr *p) = 0;
  virtual void visitMultLexpr(MultLexpr *p) = 0;
  virtual void visitDivLexpr(DivLexpr *p) = 0;
  virtual void visitModLexpr(ModLexpr *p) = 0;
  virtual void visitStarHatLexpr(StarHatLexpr *p) = 0;
  virtual void visitArrowLexpr(ArrowLexpr *p) = 0;
  virtual void visitDotLexpr(DotLexpr *p) = 0;
  virtual void visitSquaresRangeLexpr(SquaresRangeLexpr *p) = 0;
  virtual void visitSquaresLexpr(SquaresLexpr *p) = 0;
  virtual void visitSquaresPipeLexpr(SquaresPipeLexpr *p) = 0;
  virtual void visitMinusLexpr(MinusLexpr *p) = 0;
  virtual void visitPlusLexpr(PlusLexpr *p) = 0;
  virtual void visitTildeLexpr(TildeLexpr *p) = 0;
  virtual void visitStarLexpr(StarLexpr *p) = 0;
  virtual void visitAmpUnaryLexpr(AmpUnaryLexpr *p) = 0;
  virtual void visitSizeOfLexpr(SizeOfLexpr *p) = 0;
  virtual void visitSizeOfLogicTypeLexpr(SizeOfLogicTypeLexpr *p) = 0;
  virtual void visitOldLexpr(OldLexpr *p) = 0;
  virtual void visitAtLexpr(AtLexpr *p) = 0;
  virtual void visitResultLexpr(ResultLexpr *p) = 0;
  virtual void visitSeparatedLexpr(SeparatedLexpr *p) = 0;
  virtual void visitFullIdParenLexpr(FullIdParenLexpr *p) = 0;
  virtual void visitFullIdBraceParenLexpr(FullIdBraceParenLexpr *p) = 0;
  virtual void visitFullIdBracesLexpr(FullIdBracesLexpr *p) = 0;
  virtual void visitFullId(FullId *p) = 0;
  virtual void visitPiLexpr(PiLexpr *p) = 0;
  virtual void visitLessLessLexpr(LessLessLexpr *p) = 0;
  virtual void visitGreaterGreaterLexpr(GreaterGreaterLexpr *p) = 0;
  virtual void visitParenRangeLexpr(ParenRangeLexpr *p) = 0;
  virtual void visitCastLexpr(CastLexpr *p) = 0;
  virtual void visitTypeOfLexpr(TypeOfLexpr *p) = 0;
  virtual void visitTypeLexpr(TypeLexpr *p) = 0;
  virtual void visitTypeWithStarsLexpr(TypeWithStarsLexpr *p) = 0;
  virtual void visitEmptyLexpr(EmptyLexpr *p) = 0;
  virtual void visitUnionLexpr(UnionLexpr *p) = 0;
  virtual void visitInterLexpr(InterLexpr *p) = 0;
  virtual void visitBraceLexprList(BraceLexprList *p) = 0;
  virtual void visitBraceBinderLexpr(BraceBinderLexpr *p) = 0;
  virtual void visitBraceBinderLexprLexpr(BraceBinderLexprLexpr *p) = 0;
  virtual void visitFieldInitLexpr(FieldInitLexpr *p) = 0;
  virtual void visitArrayInitLexpr(ArrayInitLexpr *p) = 0;
  virtual void visitUpdateBraceLexpr(UpdateBraceLexpr *p) = 0;
  virtual void visitLexprRange(LexprRange *p) = 0;
  virtual void visitAFieldInitElt(AFieldInitElt *p) = 0;
  virtual void visitAnArrayInitElt(AnArrayInitElt *p) = 0;
  virtual void visitArrayInitRangeElt(ArrayInitRangeElt *p) = 0;
  virtual void visitAnUpdateElt(AnUpdateElt *p) = 0;
  virtual void visitUpdateEltWith(UpdateEltWith *p) = 0;
  virtual void visitFieldElt(FieldElt *p) = 0;
  virtual void visitArrayElt(ArrayElt *p) = 0;
  virtual void visitArrayRangeElt(ArrayRangeElt *p) = 0;
  virtual void visitTheBinders(TheBinders *p) = 0;
  virtual void visitBindersReentranceDeclSpec(BindersReentranceDeclSpec *p) = 0;
  virtual void visitBindersReentranceVarSpec(BindersReentranceVarSpec *p) = 0;
  virtual void visitStartVarSpec(StartVarSpec *p) = 0;
  virtual void visitIntConstArraySize(IntConstArraySize *p) = 0;
  virtual void visitSomeArraySize(SomeArraySize *p) = 0;
  virtual void visitNoSize(NoSize *p) = 0;
  virtual void visitSimpleSpec(SimpleSpec *p) = 0;
  virtual void visitArraySpec(ArraySpec *p) = 0;
  virtual void visitFunctionSpec(FunctionSpec *p) = 0;
  virtual void visitEmptyTypeParam(EmptyTypeParam *p) = 0;
  virtual void visitSomeTypeParam(SomeTypeParam *p) = 0;
  virtual void visitInfTypeParam(InfTypeParam *p) = 0;
  virtual void visitAbsParamsElement(AbsParamsElement *p) = 0;
  virtual void visitPrartemer(Prartemer *p) = 0;
  virtual void visitLogicTypeGenTypemane(LogicTypeGenTypemane *p) = 0;
  virtual void visitLogicTypeGenIdOrTypename(LogicTypeGenIdOrTypename *p) = 0;
  virtual void visitConstCV(ConstCV *p) = 0;
  virtual void visitVolatileCV(VolatileCV *p) = 0;
  virtual void visitGhostCV(GhostCV *p) = 0;
  virtual void visitTypeSpecCVTypename(TypeSpecCVTypename *p) = 0;
  virtual void visitAnCastLogicType(AnCastLogicType *p) = 0;
  virtual void visitLogicRTType(LogicRTType *p) = 0;
  virtual void visitNoAbsSpec(NoAbsSpec *p) = 0;
  virtual void visitSomeAbsSpec(SomeAbsSpec *p) = 0;
  virtual void visitNoAbsSpecCV(NoAbsSpecCV *p) = 0;
  virtual void visitSomeAbsSpecCV(SomeAbsSpecCV *p) = 0;
  virtual void visitAbsSpecTabs(AbsSpecTabs *p) = 0;
  virtual void visitAbsSpecStars(AbsSpecStars *p) = 0;
  virtual void visitAbsSpecStarsTabs(AbsSpecStarsTabs *p) = 0;
  virtual void visitAbsSpecBitsStars(AbsSpecBitsStars *p) = 0;
  virtual void visitAbsSpecBitsStarsTabs(AbsSpecBitsStarsTabs *p) = 0;
  virtual void visitAbsSpecBitsTabs(AbsSpecBitsTabs *p) = 0;
  virtual void visitAbsSpecBits(AbsSpecBits *p) = 0;
  virtual void visitAbsSpecCVTabs(AbsSpecCVTabs *p) = 0;
  virtual void visitAbsSpecCVStars(AbsSpecCVStars *p) = 0;
  virtual void visitAbsSpecCVStarsTabs(AbsSpecCVStarsTabs *p) = 0;
  virtual void visitAbsSpecCVBitsStars(AbsSpecCVBitsStars *p) = 0;
  virtual void visitAbsSpecCVBitsStarsTabs(AbsSpecCVBitsStarsTabs *p) = 0;
  virtual void visitAbsSpecCVBitsTabs(AbsSpecCVBitsTabs *p) = 0;
  virtual void visitAbsSpecCVBits(AbsSpecCVBits *p) = 0;
  virtual void visitAbsSpecBitsParams(AbsSpecBitsParams *p) = 0;
  virtual void visitAbsSpecBitsCVParams(AbsSpecBitsCVParams *p) = 0;
  virtual void visitStar(Star *p) = 0;
  virtual void visitStarCV(StarCV *p) = 0;
  virtual void visitStarCVWithCV(StarCVWithCV *p) = 0;
  virtual void visitTab(Tab *p) = 0;
  virtual void visitTypeSpecIntegerKeyWord(TypeSpecIntegerKeyWord *p) = 0;
  virtual void visitTypeSpecRealKeyWord(TypeSpecRealKeyWord *p) = 0;
  virtual void visitTypeSpecBooleanKeyWord(TypeSpecBooleanKeyWord *p) = 0;
  virtual void visitTypeSpecVoidKeyWord(TypeSpecVoidKeyWord *p) = 0;
  virtual void visitTypeSpecBoolKeyWord(TypeSpecBoolKeyWord *p) = 0;
  virtual void visitTypeSpecCharKeyWord(TypeSpecCharKeyWord *p) = 0;
  virtual void visitTypeSpecSignedCharKeyWord(TypeSpecSignedCharKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedCharKeyWord(TypeSpecUnsignedCharKeyWord *p) = 0;
  virtual void visitTypeSpecIntKeyWord(TypeSpecIntKeyWord *p) = 0;
  virtual void visitTypeSpecSignedIntKeyWord(TypeSpecSignedIntKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedIntKeyWord(TypeSpecUnsignedIntKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedKeyWord(TypeSpecUnsignedKeyWord *p) = 0;
  virtual void visitTypeSpecShortKeyWord(TypeSpecShortKeyWord *p) = 0;
  virtual void visitTypeSpecSignedShortKeyWord(TypeSpecSignedShortKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedShortKeyWord(TypeSpecUnsignedShortKeyWord *p) = 0;
  virtual void visitTypeSpecShortIntKeyWord(TypeSpecShortIntKeyWord *p) = 0;
  virtual void visitTypeSpecSignedShortIntKeyWord(TypeSpecSignedShortIntKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedShortIntKeyWord(TypeSpecUnsignedShortIntKeyWord *p) = 0;
  virtual void visitTypeSpecLongKeyWord(TypeSpecLongKeyWord *p) = 0;
  virtual void visitTypeSpecSignedLongKeyWord(TypeSpecSignedLongKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedLongKeyWord(TypeSpecUnsignedLongKeyWord *p) = 0;
  virtual void visitTypeSpecSignedLongIntKeyWord(TypeSpecSignedLongIntKeyWord *p) = 0;
  virtual void visitTypeSpecLongIntKeyWord(TypeSpecLongIntKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedLongIntKeyWord(TypeSpecUnsignedLongIntKeyWord *p) = 0;
  virtual void visitTypeSpecLongLongKeyWord(TypeSpecLongLongKeyWord *p) = 0;
  virtual void visitTypeSpecSignedLongLongKeyWord(TypeSpecSignedLongLongKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedLongLongKeyWord(TypeSpecUnsignedLongLongKeyWord *p) = 0;
  virtual void visitTypeSpecLongLongIntKeyWord(TypeSpecLongLongIntKeyWord *p) = 0;
  virtual void visitTypeSpecSignedLongLongIntKeyWord(TypeSpecSignedLongLongIntKeyWord *p) = 0;
  virtual void visitTypeSpecUnsignedLongLongIntKeyWord(TypeSpecUnsignedLongLongIntKeyWord *p) = 0;
  virtual void visitTypeSpecFloatKeyWord(TypeSpecFloatKeyWord *p) = 0;
  virtual void visitTypeSpecDoubleKeyWord(TypeSpecDoubleKeyWord *p) = 0;
  virtual void visitTypeSpecLongDoubleKeyWord(TypeSpecLongDoubleKeyWord *p) = 0;
  virtual void visitTypeSpecStruct(TypeSpecStruct *p) = 0;
  virtual void visitTypeSpecEnum(TypeSpecEnum *p) = 0;
  virtual void visitTypeSpecUnion(TypeSpecUnion *p) = 0;
  virtual void visitTYPENAME(TYPENAME *p) = 0;
  virtual void visitTypeSpecTYPENAME(TypeSpecTYPENAME *p) = 0;
  virtual void visitTypeSpecSimpleFromTypenameTypeSpec(TypeSpecSimpleFromTypenameTypeSpec *p) = 0;
  virtual void visitTypeSpecIdentifierOrTypename(TypeSpecIdentifierOrTypename *p) = 0;
  virtual void visitTypeSpecIdentifierOrTypenameAngles(TypeSpecIdentifierOrTypenameAngles *p) = 0;
  virtual void visitTypeSpecSimpleFromIdTypenameTypeSpec(TypeSpecSimpleFromIdTypenameTypeSpec *p) = 0;
  virtual void visitSimpleIdentifierFull(SimpleIdentifierFull *p) = 0;
  virtual void visitAdmitKeyWordFullIdent(AdmitKeyWordFullIdent *p) = 0;
  virtual void visitAllocatesKeyWordFullIdent(AllocatesKeyWordFullIdent *p) = 0;
  virtual void visitAssertKeyWordFullIdent(AssertKeyWordFullIdent *p) = 0;
  virtual void visitAssignsKeyWordFullIdent(AssignsKeyWordFullIdent *p) = 0;
  virtual void visitAssumesKeyWordFullIdent(AssumesKeyWordFullIdent *p) = 0;
  virtual void visitAtKeyWordFullIdent(AtKeyWordFullIdent *p) = 0;
  virtual void visitAxiomKeyWordFullIdent(AxiomKeyWordFullIdent *p) = 0;
  virtual void visitAxiomaticKeyWordFullIdent(AxiomaticKeyWordFullIdent *p) = 0;
  virtual void visitBehaviorKeyWordFullIdent(BehaviorKeyWordFullIdent *p) = 0;
  virtual void visitBreaksKeyWordFullIdent(BreaksKeyWordFullIdent *p) = 0;
  virtual void visitCheckKeyWordFullIdent(CheckKeyWordFullIdent *p) = 0;
  virtual void visitCompleteKeyWordFullIdent(CompleteKeyWordFullIdent *p) = 0;
  virtual void visitContinuesKeyWordFullIdent(ContinuesKeyWordFullIdent *p) = 0;
  virtual void visitContractKeyWordFullIdent(ContractKeyWordFullIdent *p) = 0;
  virtual void visitDecreasesKeyWordFullIdent(DecreasesKeyWordFullIdent *p) = 0;
  virtual void visitDisjointKeyWordFullIdent(DisjointKeyWordFullIdent *p) = 0;
  virtual void visitEnsuresKeyWordFullIdent(EnsuresKeyWordFullIdent *p) = 0;
  virtual void visitExitsKeyWordFullIdent(ExitsKeyWordFullIdent *p) = 0;
  virtual void visitFreesKeyWordFullIdent(FreesKeyWordFullIdent *p) = 0;
  virtual void visitFunctionKeyWordFullIdent(FunctionKeyWordFullIdent *p) = 0;
  virtual void visitGlobalKeyWordFullIdent(GlobalKeyWordFullIdent *p) = 0;
  virtual void visitImpactKeyWordFullIdent(ImpactKeyWordFullIdent *p) = 0;
  virtual void visitInductiveKeyWordFullIdent(InductiveKeyWordFullIdent *p) = 0;
  virtual void visitIncludeKeyWordFullIdent(IncludeKeyWordFullIdent *p) = 0;
  virtual void visitInvariantKeyWordFullIdent(InvariantKeyWordFullIdent *p) = 0;
  virtual void visitLemmaKeyWordFullIdent(LemmaKeyWordFullIdent *p) = 0;
  virtual void visitLetKeyWordFullIdent(LetKeyWordFullIdent *p) = 0;
  virtual void visitLogicKeyWordFullIdent(LogicKeyWordFullIdent *p) = 0;
  virtual void visitLoopKeyWordFullIdent(LoopKeyWordFullIdent *p) = 0;
  virtual void visitModelKeyWordFullIdent(ModelKeyWordFullIdent *p) = 0;
  virtual void visitModuleKeyWordFullIdent(ModuleKeyWordFullIdent *p) = 0;
  virtual void visitPragmaKeyWordFullIdent(PragmaKeyWordFullIdent *p) = 0;
  virtual void visitPredicateKeyWordFullIdent(PredicateKeyWordFullIdent *p) = 0;
  virtual void visitRequiresKeyWordFullIdent(RequiresKeyWordFullIdent *p) = 0;
  virtual void visitReturnsKeyWordFullIdent(ReturnsKeyWordFullIdent *p) = 0;
  virtual void visitSliceKeyWordFullIdent(SliceKeyWordFullIdent *p) = 0;
  virtual void visitTerminatesKeyWordFullIdent(TerminatesKeyWordFullIdent *p) = 0;
  virtual void visitTypeKeyWordFullIdent(TypeKeyWordFullIdent *p) = 0;
  virtual void visitVariantKeyWordFullIdent(VariantKeyWordFullIdent *p) = 0;
  virtual void visitIdentExtCodeAnnotFullIdent(IdentExtCodeAnnotFullIdent *p) = 0;
  virtual void visitIdentExtContractFullIdent(IdentExtContractFullIdent *p) = 0;
  virtual void visitIdentExtGlobalFullIdent(IdentExtGlobalFullIdent *p) = 0;
  virtual void visitIdentExtGlobalBlockFullIdent(IdentExtGlobalBlockFullIdent *p) = 0;
  virtual void visitExrSpec(ExrSpec *p) = 0;
  virtual void visitEmptyExtGlobalClauses(EmptyExtGlobalClauses *p) = 0;
  virtual void visitSomeExtGlobalClauses(SomeExtGlobalClauses *p) = 0;
  virtual void visitDeclClause(DeclClause *p) = 0;
  virtual void visitLetClause(LetClause *p) = 0;
  virtual void visitGlobalLetClause(GlobalLetClause *p) = 0;
  virtual void visitIncludeClause(IncludeClause *p) = 0;
  virtual void visitEmptyExtGlobalSpecs(EmptyExtGlobalSpecs *p) = 0;
  virtual void visitSomeExtGlobalSpecs(SomeExtGlobalSpecs *p) = 0;
  virtual void visitExtGlobalSpecClauseModule(ExtGlobalSpecClauseModule *p) = 0;
  virtual void visitExtGlobalSpecModule(ExtGlobalSpecModule *p) = 0;
  virtual void visitExtGlobalSpecClause(ExtGlobalSpecClause *p) = 0;
  virtual void visitExtGlobalSpecSimple(ExtGlobalSpecSimple *p) = 0;
  virtual void visitEmptyExtModuleSpecs(EmptyExtModuleSpecs *p) = 0;
  virtual void visitListExtModuleSpecs(ListExtModuleSpecs *p) = 0;
  virtual void visitFunSpecExtModuleSpecs(FunSpecExtModuleSpecs *p) = 0;
  virtual void visitFunSpecWithListModules(FunSpecWithListModules *p) = 0;
  virtual void visitAnExtModuleSpec(AnExtModuleSpec *p) = 0;
  virtual void visitNoExtFunctionSpecs(NoExtFunctionSpecs *p) = 0;
  virtual void visitSomeExtFunctionSpecs(SomeExtFunctionSpecs *p) = 0;
  virtual void visitAtMarkup(AtMarkup *p) = 0;
  virtual void visitListFunctionSpecs(ListFunctionSpecs *p) = 0;
  virtual void visitListFunctionSpecsAtMarkup(ListFunctionSpecsAtMarkup *p) = 0;
  virtual void visitAnExtGlobalClause(AnExtGlobalClause *p) = 0;
  virtual void visitAnExtFunSpec(AnExtFunSpec *p) = 0;
  virtual void visitFunSpecAtAnnotation(FunSpecAtAnnotation *p) = 0;
  virtual void visitFunSpecAtContract(FunSpecAtContract *p) = 0;
  virtual void visitFunSpecContract(FunSpecContract *p) = 0;
  virtual void visitExtIdentifierEmpty(ExtIdentifierEmpty *p) = 0;
  virtual void visitExtIdentifierSome(ExtIdentifierSome *p) = 0;
  virtual void visitMarkupStmtIdentifier(MarkupStmtIdentifier *p) = 0;
  virtual void visitMarkupIntConstant(MarkupIntConstant *p) = 0;
  virtual void visitSpecConstract(SpecConstract *p) = 0;
  virtual void visitSimpleContract(SimpleContract *p) = 0;
  virtual void visitTerminatesRequiresContract(TerminatesRequiresContract *p) = 0;
  virtual void visitDecreasesRequiresContract(DecreasesRequiresContract *p) = 0;
  virtual void visitDecreasesTerminatesContract(DecreasesTerminatesContract *p) = 0;
  virtual void visitClausesRequiresContract(ClausesRequiresContract *p) = 0;
  virtual void visitClausesTerminatesContract(ClausesTerminatesContract *p) = 0;
  virtual void visitClausesDecreasesContract(ClausesDecreasesContract *p) = 0;
  virtual void visitBehaviorsTerminatesContract(BehaviorsTerminatesContract *p) = 0;
  virtual void visitBehaviorsDecreasesContract(BehaviorsDecreasesContract *p) = 0;
  virtual void visitComplDisjRequiresContract(ComplDisjRequiresContract *p) = 0;
  virtual void visitComplDisjTerminatesContract(ComplDisjTerminatesContract *p) = 0;
  virtual void visitComplDisjDecreasesContract(ComplDisjDecreasesContract *p) = 0;
  virtual void visitComplDisjBehaviorContract(ComplDisjBehaviorContract *p) = 0;
  virtual void visitComplDisjAssignsContract(ComplDisjAssignsContract *p) = 0;
  virtual void visitComplDisjAllocatesContract(ComplDisjAllocatesContract *p) = 0;
  virtual void visitComplDisjFreesContract(ComplDisjFreesContract *p) = 0;
  virtual void visitComplDisjPostCondContract(ComplDisjPostCondContract *p) = 0;
  virtual void visitAdmitRequiresClause(AdmitRequiresClause *p) = 0;
  virtual void visitAdmitInvariantClause(AdmitInvariantClause *p) = 0;
  virtual void visitAdmitLemmaClause(AdmitLemmaClause *p) = 0;
  virtual void visitAdmitLoopClause(AdmitLoopClause *p) = 0;
  virtual void visitCheckRequiresClause(CheckRequiresClause *p) = 0;
  virtual void visitCheckInvariantClause(CheckInvariantClause *p) = 0;
  virtual void visitCheckLemmaClause(CheckLemmaClause *p) = 0;
  virtual void visitCheckLoopClause(CheckLoopClause *p) = 0;
  virtual void visitRequiresClause(RequiresClause *p) = 0;
  virtual void visitAssumesClause(AssumesClause *p) = 0;
  virtual void visitAssignsClause(AssignsClause *p) = 0;
  virtual void visitPostCondClause(PostCondClause *p) = 0;
  virtual void visitDecreasesClause(DecreasesClause *p) = 0;
  virtual void visitBehaviorClause(BehaviorClause *p) = 0;
  virtual void visitAllocatesClause(AllocatesClause *p) = 0;
  virtual void visitFreesClause(FreesClause *p) = 0;
  virtual void visitCompleteClause(CompleteClause *p) = 0;
  virtual void visitDisjointClause(DisjointClause *p) = 0;
  virtual void visitClauseExtConstract(ClauseExtConstract *p) = 0;
  virtual void visitEmptyClauseKW(EmptyClauseKW *p) = 0;
  virtual void visitNoRequires(NoRequires *p) = 0;
  virtual void visitSomeRequires(SomeRequires *p) = 0;
  virtual void visitSimpleRequires(SimpleRequires *p) = 0;
  virtual void visitCheckRequires(CheckRequires *p) = 0;
  virtual void visitAdimtRequires(AdimtRequires *p) = 0;
  virtual void visitClauseSimpleRequires(ClauseSimpleRequires *p) = 0;
  virtual void visitClauseCheckRequires(ClauseCheckRequires *p) = 0;
  virtual void visitClauseAdimtRequires(ClauseAdimtRequires *p) = 0;
  virtual void visitNoTerminate(NoTerminate *p) = 0;
  virtual void visitSomeTerminate(SomeTerminate *p) = 0;
  virtual void visitSimpleTerminates(SimpleTerminates *p) = 0;
  virtual void visitClauseTerminates(ClauseTerminates *p) = 0;
  virtual void visitNoDecreases(NoDecreases *p) = 0;
  virtual void visitSomeDecreases(SomeDecreases *p) = 0;
  virtual void visitSimpleDecreases(SimpleDecreases *p) = 0;
  virtual void visitClauseDecreases(ClauseDecreases *p) = 0;
  virtual void visitForVariant(ForVariant *p) = 0;
  virtual void visitLexprVariant(LexprVariant *p) = 0;
  virtual void visitNoSimpleClauses(NoSimpleClauses *p) = 0;
  virtual void visitSomeSimpleClauses(SomeSimpleClauses *p) = 0;
  virtual void visitAllocatesZones(AllocatesZones *p) = 0;
  virtual void visitFreesZones(FreesZones *p) = 0;
  virtual void visitPostCondSimpleClauses(PostCondSimpleClauses *p) = 0;
  virtual void visitAllocationSimpleClauses(AllocationSimpleClauses *p) = 0;
  virtual void visitAssignsSimpleClauses(AssignsSimpleClauses *p) = 0;
  virtual void visitExtContractSimpleClauses(ExtContractSimpleClauses *p) = 0;
  virtual void visitClausesPostCondSimpleClauses(ClausesPostCondSimpleClauses *p) = 0;
  virtual void visitClausesAllocationSimpleClauses(ClausesAllocationSimpleClauses *p) = 0;
  virtual void visitClausesAssignsSimpleClauses(ClausesAssignsSimpleClauses *p) = 0;
  virtual void visitExtConClausestractSimpleClauses(ExtConClausestractSimpleClauses *p) = 0;
  virtual void visitNoExtensionContent(NoExtensionContent *p) = 0;
  virtual void visitSomeExtensionContent(SomeExtensionContent *p) = 0;
  virtual void visitNoBehaviors(NoBehaviors *p) = 0;
  virtual void visitSomeBehaviors(SomeBehaviors *p) = 0;
  virtual void visitTheBehaviors(TheBehaviors *p) = 0;
  virtual void visitSimpleClausesBehavior(SimpleClausesBehavior *p) = 0;
  virtual void visitRequiresAssumes(RequiresAssumes *p) = 0;
  virtual void visitSimpleClausesAssumes(SimpleClausesAssumes *p) = 0;
  virtual void visitRequiresRequires(RequiresRequires *p) = 0;
  virtual void visitNoAssumes(NoAssumes *p) = 0;
  virtual void visitSimpleAssumes(SimpleAssumes *p) = 0;
  virtual void visitClauseAssumes(ClauseAssumes *p) = 0;
  virtual void visitNoComplDisj(NoComplDisj *p) = 0;
  virtual void visitSomeComplDisj(SomeComplDisj *p) = 0;
  virtual void visitCompleteBehavior(CompleteBehavior *p) = 0;
  virtual void visitDisjointBehavior(DisjointBehavior *p) = 0;
  virtual void visitCompleteBehaviorClause(CompleteBehaviorClause *p) = 0;
  virtual void visitDisjointBehaviorClause(DisjointBehaviorClause *p) = 0;
  virtual void visitAssignZone(AssignZone *p) = 0;
  virtual void visitAssignZoneFromZone(AssignZoneFromZone *p) = 0;
  virtual void visitSomeZone(SomeZone *p) = 0;
  virtual void visitNoZone(NoZone *p) = 0;
  virtual void visitAnAnnotation(AnAnnotation *p) = 0;
  virtual void visitACSLSpec(ACSLSpec *p) = 0;
  virtual void visitAnnotDecl(AnnotDecl *p) = 0;
  virtual void visitLoopAnnotation(LoopAnnotation *p) = 0;
  virtual void visitForContractAnnotation(ForContractAnnotation *p) = 0;
  virtual void visitForCodeAnnotation(ForCodeAnnotation *p) = 0;
  virtual void visitSimplePragmaOrCodeAnnotation(SimplePragmaOrCodeAnnotation *p) = 0;
  virtual void visitPragmaOrCodeAnnotationBeg(PragmaOrCodeAnnotationBeg *p) = 0;
  virtual void visitIdentifierAnnotation(IdentifierAnnotation *p) = 0;
  virtual void visitGhostAnnotation(GhostAnnotation *p) = 0;
  virtual void visitLoopAnnotStackInvariant(LoopAnnotStackInvariant *p) = 0;
  virtual void visitLoopAnnotStackEffects(LoopAnnotStackEffects *p) = 0;
  virtual void visitLoopAnnotStackAllocation(LoopAnnotStackAllocation *p) = 0;
  virtual void visitLoopAnnotStackForBehavior(LoopAnnotStackForBehavior *p) = 0;
  virtual void visitLoopAnnotStackVariant(LoopAnnotStackVariant *p) = 0;
  virtual void visitLoopAnnotStackPragma(LoopAnnotStackPragma *p) = 0;
  virtual void visitLoopAnnotStackGrammarExten(LoopAnnotStackGrammarExten *p) = 0;
  virtual void visitNoLoopAnnot(NoLoopAnnot *p) = 0;
  virtual void visitSomeLoopAnnot(SomeLoopAnnot *p) = 0;
  virtual void visitLoopAssigns(LoopAssigns *p) = 0;
  virtual void visitSimpleLoopAllocation(SimpleLoopAllocation *p) = 0;
  virtual void visitSimpleLoopInvariant(SimpleLoopInvariant *p) = 0;
  virtual void visitCheckLoopInvariant(CheckLoopInvariant *p) = 0;
  virtual void visitAdmitLoopInvariant(AdmitLoopInvariant *p) = 0;
  virtual void visitSimpleLoopVariant(SimpleLoopVariant *p) = 0;
  virtual void visitSimpleLoopGrammarExten(SimpleLoopGrammarExten *p) = 0;
  virtual void visitPragmaLoop(PragmaLoop *p) = 0;
  virtual void visitImpactKeyWordBegPragma(ImpactKeyWordBegPragma *p) = 0;
  virtual void visitSliceKeyWordBegPragma(SliceKeyWordBegPragma *p) = 0;
  virtual void visitForKeyWordBegPragma(ForKeyWordBegPragma *p) = 0;
  virtual void visitAssertKeyWordBegPragma(AssertKeyWordBegPragma *p) = 0;
  virtual void visitCheckKeyWordBegPragma(CheckKeyWordBegPragma *p) = 0;
  virtual void visitAdmitKeyWordBegPragma(AdmitKeyWordBegPragma *p) = 0;
  virtual void visitInvariantKeyWordBegPragma(InvariantKeyWordBegPragma *p) = 0;
  virtual void visitCheckInvariantKeyWordBegPragma(CheckInvariantKeyWordBegPragma *p) = 0;
  virtual void visitAdmitInvariantKeyWordBegPragma(AdmitInvariantKeyWordBegPragma *p) = 0;
  virtual void visitCheckLoopKeyWordBegPragma(CheckLoopKeyWordBegPragma *p) = 0;
  virtual void visitAdmitLoopKeyWordBegPragma(AdmitLoopKeyWordBegPragma *p) = 0;
  virtual void visitBegExtCodeAnnotBegPragma(BegExtCodeAnnotBegPragma *p) = 0;
  virtual void visitPragmaCodeAnnotSlice(PragmaCodeAnnotSlice *p) = 0;
  virtual void visitPragmaCodeAnnotImpact(PragmaCodeAnnotImpact *p) = 0;
  virtual void visitCodeAnnot(CodeAnnot *p) = 0;
  virtual void visitAssertCodeAnnot(AssertCodeAnnot *p) = 0;
  virtual void visitCheckCodeAnnot(CheckCodeAnnot *p) = 0;
  virtual void visitAdmitCodeAnnot(AdmitCodeAnnot *p) = 0;
  virtual void visitInvariantCodeAnnot(InvariantCodeAnnot *p) = 0;
  virtual void visitCheckInvariantCodeAnnot(CheckInvariantCodeAnnot *p) = 0;
  virtual void visitAdmitInvariantCodeAnnot(AdmitInvariantCodeAnnot *p) = 0;
  virtual void visitExtCodeAnnotCodeAnnot(ExtCodeAnnotCodeAnnot *p) = 0;
  virtual void visitPragmaSliceLexpr(PragmaSliceLexpr *p) = 0;
  virtual void visitPragmaSlice(PragmaSlice *p) = 0;
  virtual void visitImpactPragmaLexpr(ImpactPragmaLexpr *p) = 0;
  virtual void visitAnImpactPragma(AnImpactPragma *p) = 0;
  virtual void visitDeclGlobalInvariant(DeclGlobalInvariant *p) = 0;
  virtual void visitDeclVolatile(DeclVolatile *p) = 0;
  virtual void visitDeclTypeAnnot(DeclTypeAnnot *p) = 0;
  virtual void visitDeclModelAnnot(DeclModelAnnot *p) = 0;
  virtual void visitDeclLogicDef(DeclLogicDef *p) = 0;
  virtual void visitDeclExt(DeclExt *p) = 0;
  virtual void visitDeclDeprecatedLogic(DeclDeprecatedLogic *p) = 0;
  virtual void visitExtGlobalDecl(ExtGlobalDecl *p) = 0;
  virtual void visitExtGlobalBlockDecl(ExtGlobalBlockDecl *p) = 0;
  virtual void visitReadVolotile(ReadVolotile *p) = 0;
  virtual void visitWriteVolotile(WriteVolotile *p) = 0;
  virtual void visitTypeInvariant(TypeInvariant *p) = 0;
  virtual void visitNoSemicolon(NoSemicolon *p) = 0;
  virtual void visitSemicolon(Semicolon *p) = 0;
  virtual void visitModelAnnotation(ModelAnnotation *p) = 0;
  virtual void visitSimplePolyIdType(SimplePolyIdType *p) = 0;
  virtual void visitPolyIdTypeAngles(PolyIdTypeAngles *p) = 0;
  virtual void visitPolyTypeId(PolyTypeId *p) = 0;
  virtual void visitPolyIdTypeSquares(PolyIdTypeSquares *p) = 0;
  virtual void visitPolyIdTypeSquaresAngles(PolyIdTypeSquaresAngles *p) = 0;
  virtual void visitNoParameters(NoParameters *p) = 0;
  virtual void visitSomeParameters(SomeParameters *p) = 0;
  virtual void visitAParameters(AParameters *p) = 0;
  virtual void visitSimpleLogicDef(SimpleLogicDef *p) = 0;
  virtual void visitPredicateLogicDef(PredicateLogicDef *p) = 0;
  virtual void visitInductiveLogicDef(InductiveLogicDef *p) = 0;
  virtual void visitLemmaLogicDef(LemmaLogicDef *p) = 0;
  virtual void visitCheckLemmaLogicDef(CheckLemmaLogicDef *p) = 0;
  virtual void visitAdmitLemmaLogicDef(AdmitLemmaLogicDef *p) = 0;
  virtual void visitAxiomaticLogicDef(AxiomaticLogicDef *p) = 0;
  virtual void visitTypeLogicDef(TypeLogicDef *p) = 0;
  virtual void visitSimpleDeprecatedLogicDecl(SimpleDeprecatedLogicDecl *p) = 0;
  virtual void visitPredicateDeprecatedLogicDecl(PredicateDeprecatedLogicDecl *p) = 0;
  virtual void visitTypeDeprecatedLogicDecl(TypeDeprecatedLogicDecl *p) = 0;
  virtual void visitAxiomDeprecatedLogicDecl(AxiomDeprecatedLogicDecl *p) = 0;
  virtual void visitLocidDeclDef(LocidDeclDef *p) = 0;
  virtual void visitSimpleLogicDecl(SimpleLogicDecl *p) = 0;
  virtual void visitPredicateLogicDecl(PredicateLogicDecl *p) = 0;
  virtual void visitTypeLogicDecl(TypeLogicDecl *p) = 0;
  virtual void visitAxiomLogicDecl(AxiomLogicDecl *p) = 0;
  virtual void visitNoReadsClause(NoReadsClause *p) = 0;
  virtual void visitSomeReadsClause(SomeReadsClause *p) = 0;
  virtual void visitListOfDatacons(ListOfDatacons *p) = 0;
  virtual void visitTypedefLogicTypeGen(TypedefLogicTypeGen *p) = 0;
  virtual void visitSimpleDataCons(SimpleDataCons *p) = 0;
  virtual void visitDataConsWithPipe(DataConsWithPipe *p) = 0;
  virtual void visitDataConsFullIdentifier(DataConsFullIdentifier *p) = 0;
  virtual void visitDataConsFullIdentifierFun(DataConsFullIdentifierFun *p) = 0;
  virtual void visitIndCase(IndCase *p) = 0;
  virtual void visitOptLabelOne(OptLabelOne *p) = 0;
  virtual void visitOptLabelTwo(OptLabelTwo *p) = 0;
  virtual void visitNoLableList(NoLableList *p) = 0;
  virtual void visitLableList(LableList *p) = 0;
  virtual void visitLableName(LableName *p) = 0;
  virtual void visitEmptyBehaviorNameList(EmptyBehaviorNameList *p) = 0;
  virtual void visitAnBehaviorNameList(AnBehaviorNameList *p) = 0;
  virtual void visitBehaviorNameAnyIdent(BehaviorNameAnyIdent *p) = 0;
  virtual void visitSimpleIdentifierAny(SimpleIdentifierAny *p) = 0;
  virtual void visitACSLTypenameIdentifier(ACSLTypenameIdentifier *p) = 0;
  virtual void visitTypenameIdentifier(TypenameIdentifier *p) = 0;
  virtual void visitKeywordIdentifier(KeywordIdentifier *p) = 0;
  virtual void visitTypename(Typename *p) = 0;
  virtual void visitAnFullIdentifier(AnFullIdentifier *p) = 0;
  virtual void visitACSLTypename(ACSLTypename *p) = 0;
  virtual void visitAnIdentifierOrTypename(AnIdentifierOrTypename *p) = 0;
  virtual void visitIdentifierIdent(IdentifierIdent *p) = 0;
  virtual void visitBehaviorsKeyWord(BehaviorsKeyWord *p) = 0;
  virtual void visitLabelKeyWord(LabelKeyWord *p) = 0;
  virtual void visitReadsKeyWord(ReadsKeyWord *p) = 0;
  virtual void visitWritesKeyWord(WritesKeyWord *p) = 0;
  virtual void visitBoendedVarFullIdentifier(BoendedVarFullIdentifier *p) = 0;
  virtual void visitBoendedVarACSLTypename(BoendedVarACSLTypename *p) = 0;
  virtual void visitBoendedVarTypename(BoendedVarTypename *p) = 0;
  virtual void visitCharKeyWord(CharKeyWord *p) = 0;
  virtual void visitBooleanKeyWord(BooleanKeyWord *p) = 0;
  virtual void visitBoolKeyWord(BoolKeyWord *p) = 0;
  virtual void visitConstKeyWord(ConstKeyWord *p) = 0;
  virtual void visitDoubleKeyWord(DoubleKeyWord *p) = 0;
  virtual void visitEnumKeyWord(EnumKeyWord *p) = 0;
  virtual void visitElseKeyWord(ElseKeyWord *p) = 0;
  virtual void visitFloatKeyWord(FloatKeyWord *p) = 0;
  virtual void visitIfKeyWord(IfKeyWord *p) = 0;
  virtual void visitIntKeyWord(IntKeyWord *p) = 0;
  virtual void visitLongKeyWord(LongKeyWord *p) = 0;
  virtual void visitShortKeyWord(ShortKeyWord *p) = 0;
  virtual void visitSignedKeyWord(SignedKeyWord *p) = 0;
  virtual void visitSizeofKeyWord(SizeofKeyWord *p) = 0;
  virtual void visitStaticKeyWord(StaticKeyWord *p) = 0;
  virtual void visitStructKeyWord(StructKeyWord *p) = 0;
  virtual void visitUnionKeyWord(UnionKeyWord *p) = 0;
  virtual void visitUnsignedKeyWord(UnsignedKeyWord *p) = 0;
  virtual void visitVoidKeyWord(VoidKeyWord *p) = 0;
  virtual void visitCaseKeyWord(CaseKeyWord *p) = 0;
  virtual void visitForKeyWord(ForKeyWord *p) = 0;
  virtual void visitVolatileKeyWord(VolatileKeyWord *p) = 0;
  virtual void visitEnsuresKeyWord(EnsuresKeyWord *p) = 0;
  virtual void visitExitsKeyWord(ExitsKeyWord *p) = 0;
  virtual void visitBreaksKeyWord(BreaksKeyWord *p) = 0;
  virtual void visitContinuesKeyWord(ContinuesKeyWord *p) = 0;
  virtual void visitReturnsKeyWord(ReturnsKeyWord *p) = 0;
  virtual void visitCheckEnsuresKeyWord(CheckEnsuresKeyWord *p) = 0;
  virtual void visitCheckExitsKeyWord(CheckExitsKeyWord *p) = 0;
  virtual void visitCheckBreaksKeyWord(CheckBreaksKeyWord *p) = 0;
  virtual void visitCheckContinuesKeyWord(CheckContinuesKeyWord *p) = 0;
  virtual void visitCheckReturnsKeyWord(CheckReturnsKeyWord *p) = 0;
  virtual void visitAdmitEnsuresKeyWord(AdmitEnsuresKeyWord *p) = 0;
  virtual void visitAdmitExitsKeyWord(AdmitExitsKeyWord *p) = 0;
  virtual void visitAdmitBreaksKeyWord(AdmitBreaksKeyWord *p) = 0;
  virtual void visitAdmitContinuesKeyWord(AdmitContinuesKeyWord *p) = 0;
  virtual void visitAdmitReturnsKeyWord(AdmitReturnsKeyWord *p) = 0;
  virtual void visitPostCondKeyWord(PostCondKeyWord *p) = 0;
  virtual void visitExtContractKeyWord(ExtContractKeyWord *p) = 0;
  virtual void visitAssignsKeyWord(AssignsKeyWord *p) = 0;
  virtual void visitAllocatesKeyWord(AllocatesKeyWord *p) = 0;
  virtual void visitFreesKeyWord(FreesKeyWord *p) = 0;
  virtual void visitBehaviorKeyWord(BehaviorKeyWord *p) = 0;
  virtual void visitRequiresKeyWord(RequiresKeyWord *p) = 0;
  virtual void visitCheckRequiresKeyWord(CheckRequiresKeyWord *p) = 0;
  virtual void visitAdmitRequiresKeyWord(AdmitRequiresKeyWord *p) = 0;
  virtual void visitTerminatesKeyWord(TerminatesKeyWord *p) = 0;
  virtual void visitCompleteKeyWord(CompleteKeyWord *p) = 0;
  virtual void visitDecreasesKeyWord(DecreasesKeyWord *p) = 0;
  virtual void visitDisjointKeyWord(DisjointKeyWord *p) = 0;
  virtual void visitExtCodeAnnotKeyWord(ExtCodeAnnotKeyWord *p) = 0;
  virtual void visitExtGlobalKeyWord(ExtGlobalKeyWord *p) = 0;
  virtual void visitExtGlobalBlockKeyWord(ExtGlobalBlockKeyWord *p) = 0;
  virtual void visitAssumesKeyWord(AssumesKeyWord *p) = 0;
  virtual void visitAssertKeyWord(AssertKeyWord *p) = 0;
  virtual void visitCheckKeyWord(CheckKeyWord *p) = 0;
  virtual void visitAdmitKeyWord(AdmitKeyWord *p) = 0;
  virtual void visitGlobalKeyWord(GlobalKeyWord *p) = 0;
  virtual void visitImpactKeyWord(ImpactKeyWord *p) = 0;
  virtual void visitInductiveKeyWord(InductiveKeyWord *p) = 0;
  virtual void visitInvariantKeyWord(InvariantKeyWord *p) = 0;
  virtual void visitAdmitInvariantKeyWord(AdmitInvariantKeyWord *p) = 0;
  virtual void visitCheckInvariantKeyWord(CheckInvariantKeyWord *p) = 0;
  virtual void visitLemmaKeyWord(LemmaKeyWord *p) = 0;
  virtual void visitAdmitLemmaKeyWord(AdmitLemmaKeyWord *p) = 0;
  virtual void visitCheckLemmaKeyWord(CheckLemmaKeyWord *p) = 0;
  virtual void visitLoopKeyWord(LoopKeyWord *p) = 0;
  virtual void visitAdmitLoopKeyWord(AdmitLoopKeyWord *p) = 0;
  virtual void visitCheckLoopKeyWord(CheckLoopKeyWord *p) = 0;
  virtual void visitPragmaKeyWord(PragmaKeyWord *p) = 0;
  virtual void visitPredicateKeyWord(PredicateKeyWord *p) = 0;
  virtual void visitSliceKeyWord(SliceKeyWord *p) = 0;
  virtual void visitTypeKeyWord(TypeKeyWord *p) = 0;
  virtual void visitModelKeyWord(ModelKeyWord *p) = 0;
  virtual void visitAxiomKeyWord(AxiomKeyWord *p) = 0;
  virtual void visitVariantKeyWord(VariantKeyWord *p) = 0;
  virtual void visitAxiomaticKeyWord(AxiomaticKeyWord *p) = 0;
  virtual void visitInteger(Integer *p) = 0;
  virtual void visitReal(Real *p) = 0;
  virtual void visitContractKeyWord(ContractKeyWord *p) = 0;
  virtual void visitFunctionKeyWord(FunctionKeyWord *p) = 0;
  virtual void visitModuleKeyWord(ModuleKeyWord *p) = 0;
  virtual void visitIncludeKeyWord(IncludeKeyWord *p) = 0;
  virtual void visitAtKeyWord(AtKeyWord *p) = 0;
  virtual void visitLetKeyWord(LetKeyWord *p) = 0;
  virtual void visitLogicKeyWord(LogicKeyWord *p) = 0;
  virtual void visitCKeyWord(CKeyWord *p) = 0;
  virtual void visitACSLCKeyWord(ACSLCKeyWord *p) = 0;
  virtual void visitExtSpecKeyWord(ExtSpecKeyWord *p) = 0;
  virtual void visitACSLSpecKeyWord(ACSLSpecKeyWord *p) = 0;
  virtual void visitACSLDeclCodeAnnotKeyWord(ACSLDeclCodeAnnotKeyWord *p) = 0;
  virtual void visitSlashAllocableKeyWord(SlashAllocableKeyWord *p) = 0;
  virtual void visitSlashAllocationKeyWord(SlashAllocationKeyWord *p) = 0;
  virtual void visitSlashAutomaticKeyWord(SlashAutomaticKeyWord *p) = 0;
  virtual void visitSlashAtKeyWord(SlashAtKeyWord *p) = 0;
  virtual void visitSlashBaseAddrKeyWord(SlashBaseAddrKeyWord *p) = 0;
  virtual void visitSlashBlockLengthKeyWord(SlashBlockLengthKeyWord *p) = 0;
  virtual void visitSlashGhostKeyWord(SlashGhostKeyWord *p) = 0;
  virtual void visitSlashDynamicKeyWord(SlashDynamicKeyWord *p) = 0;
  virtual void visitSlashEmptyKeyWord(SlashEmptyKeyWord *p) = 0;
  virtual void visitSlashFalseKeyWord(SlashFalseKeyWord *p) = 0;
  virtual void visitSlashForallKeyWord(SlashForallKeyWord *p) = 0;
  virtual void visitSlashFreeableKeyWord(SlashFreeableKeyWord *p) = 0;
  virtual void visitSlashFreshKeyWord(SlashFreshKeyWord *p) = 0;
  virtual void visitSlashFromKeyWord(SlashFromKeyWord *p) = 0;
  virtual void visitSlashInterKeyWord(SlashInterKeyWord *p) = 0;
  virtual void visitSlashLambdaKeyWord(SlashLambdaKeyWord *p) = 0;
  virtual void visitSlashLetKeyWord(SlashLetKeyWord *p) = 0;
  virtual void visitSlashNothingKeyWord(SlashNothingKeyWord *p) = 0;
  virtual void visitSlashNullKeyWord(SlashNullKeyWord *p) = 0;
  virtual void visitSlashOldKeyWord(SlashOldKeyWord *p) = 0;
  virtual void visitSlashOffsetKeyWord(SlashOffsetKeyWord *p) = 0;
  virtual void visitSlashRegisterKeyWord(SlashRegisterKeyWord *p) = 0;
  virtual void visitSlashResultKeyWord(SlashResultKeyWord *p) = 0;
  virtual void visitSlashSeparatedKeyWord(SlashSeparatedKeyWord *p) = 0;
  virtual void visitSlashTrueKeyWord(SlashTrueKeyWord *p) = 0;
  virtual void visitSlashTypeKeyWord(SlashTypeKeyWord *p) = 0;
  virtual void visitSlashTypeofKeyWord(SlashTypeofKeyWord *p) = 0;
  virtual void visitSlashUnionKeyWord(SlashUnionKeyWord *p) = 0;
  virtual void visitSlashUnallocatedKeyWord(SlashUnallocatedKeyWord *p) = 0;
  virtual void visitSlashObjectPointerKeyWord(SlashObjectPointerKeyWord *p) = 0;
  virtual void visitSlashValidKeyWord(SlashValidKeyWord *p) = 0;
  virtual void visitSlashValidIndexKeyWord(SlashValidIndexKeyWord *p) = 0;
  virtual void visitSlashValidRangeKeyWord(SlashValidRangeKeyWord *p) = 0;
  virtual void visitSlashValidReadKeyWord(SlashValidReadKeyWord *p) = 0;
  virtual void visitSlashValidFunctionKeyWord(SlashValidFunctionKeyWord *p) = 0;
  virtual void visitSlashInitializedKeyWord(SlashInitializedKeyWord *p) = 0;
  virtual void visitSlashDanglingKeyWord(SlashDanglingKeyWord *p) = 0;
  virtual void visitSlashWithKeyWord(SlashWithKeyWord *p) = 0;
  virtual void visitWildCardAnyIdent(WildCardAnyIdent *p) = 0;
  virtual void visitWildCardBSKeyWord(WildCardBSKeyWord *p) = 0;
  virtual void visitAmp(Amp *p) = 0;
  virtual void visitAnd(And *p) = 0;
  virtual void visitArrow(Arrow *p) = 0;
  virtual void visitBIff(BIff *p) = 0;
  virtual void visitBImplicate(BImplicate *p) = 0;
  virtual void visitColon(Colon *p) = 0;
  virtual void visitColonColon(ColonColon *p) = 0;
  virtual void visitComma(Comma *p) = 0;
  virtual void visitIntConstant(IntConstant *p) = 0;
  virtual void visitFloatConstant(FloatConstant *p) = 0;
  virtual void visitStringConstant(StringConstant *p) = 0;
  virtual void visitWstringConstant(WstringConstant *p) = 0;
  virtual void visitDollar(Dollar *p) = 0;
  virtual void visitDot(Dot *p) = 0;
  virtual void visitDotDot(DotDot *p) = 0;
  virtual void visitDotDotDot(DotDotDot *p) = 0;
  virtual void visitEQ(EQ *p) = 0;
  virtual void visitEqual(Equal *p) = 0;
  virtual void visitExistsKeyWord(ExistsKeyWord *p) = 0;
  virtual void visitGreaterEq(GreaterEq *p) = 0;
  virtual void visitGhostKeyWord(GhostKeyWord *p) = 0;
  virtual void visitGreater(Greater *p) = 0;
  virtual void visitGreaterGreater(GreaterGreater *p) = 0;
  virtual void visitHat(Hat *p) = 0;
  virtual void visitHatHat(HatHat *p) = 0;
  virtual void visitIff(Iff *p) = 0;
  virtual void visitImplicate(Implicate *p) = 0;
  virtual void visitLeftBrace(LeftBrace *p) = 0;
  virtual void visitLessEq(LessEq *p) = 0;
  virtual void visitLeftPar(LeftPar *p) = 0;
  virtual void visitLeftSquare(LeftSquare *p) = 0;
  virtual void visitLeftSquarePipe(LeftSquarePipe *p) = 0;
  virtual void visitLess(Less *p) = 0;
  virtual void visitLessLess(LessLess *p) = 0;
  virtual void visitMinus(Minus *p) = 0;
  virtual void visitNotEq(NotEq *p) = 0;
  virtual void visitNot(Not *p) = 0;
  virtual void visitPipePipe(PipePipe *p) = 0;
  virtual void visitMod(Mod *p) = 0;
  virtual void visitPiKeyWord(PiKeyWord *p) = 0;
  virtual void visitPipe(Pipe *p) = 0;
  virtual void visitPlus(Plus *p) = 0;
  virtual void visitQuestion(Question *p) = 0;
  virtual void visitRightBrace(RightBrace *p) = 0;
  virtual void visitRightPar(RightPar *p) = 0;
  virtual void visitRightSquare(RightSquare *p) = 0;
  virtual void visitRightSquarePipe(RightSquarePipe *p) = 0;
  virtual void visitSemiColon(SemiColon *p) = 0;
  virtual void visitDivide(Divide *p) = 0;
  virtual void visitMult(Mult *p) = 0;
  virtual void visitMultHat(MultHat *p) = 0;
  virtual void visitStringLiteral(StringLiteral *p) = 0;
  virtual void visitTildeKeyWord(TildeKeyWord *p) = 0;
  virtual void visitInKeyWord(InKeyWord *p) = 0;
  virtual void visitListLexpr(ListLexpr *p) = 0;
  virtual void visitListLexprRelInner(ListLexprRelInner *p) = 0;
  virtual void visitListSTRING_LITERAL(ListSTRING_LITERAL *p) = 0;
  virtual void visitListFieldInitElt(ListFieldInitElt *p) = 0;
  virtual void visitListArrayInitElt(ListArrayInitElt *p) = 0;
  virtual void visitListUpdateElt(ListUpdateElt *p) = 0;
  virtual void visitListPathElt(ListPathElt *p) = 0;
  virtual void visitListBindersReentrance(ListBindersReentrance *p) = 0;
  virtual void visitListAbsParam(ListAbsParam *p) = 0;
  virtual void visitListParameter(ListParameter *p) = 0;
  virtual void visitListLogicTypeGenOFTYPENAME(ListLogicTypeGenOFTYPENAME *p) = 0;
  virtual void visitListLogicTypeGenOFIdentifierOrTypename(ListLogicTypeGenOFIdentifierOrTypename *p) = 0;
  virtual void visitListCV(ListCV *p) = 0;
  virtual void visitListStars(ListStars *p) = 0;
  virtual void visitListStarsCV(ListStarsCV *p) = 0;
  virtual void visitListTabs(ListTabs *p) = 0;
  virtual void visitListFullIdentifier(ListFullIdentifier *p) = 0;
  virtual void visitListExtGlobalClause(ListExtGlobalClause *p) = 0;
  virtual void visitListExtGlobalSpec(ListExtGlobalSpec *p) = 0;
  virtual void visitListExtModuleSpec(ListExtModuleSpec *p) = 0;
  virtual void visitListExtFunctionSpec(ListExtFunctionSpec *p) = 0;
  virtual void visitListExtFunSpec(ListExtFunSpec *p) = 0;
  virtual void visitListStmtMarkup(ListStmtMarkup *p) = 0;
  virtual void visitListDecl(ListDecl *p) = 0;
  virtual void visitListExtDecl(ListExtDecl *p) = 0;
  virtual void visitListVolatileOpt(ListVolatileOpt *p) = 0;
  virtual void visitListLogicDecl(ListLogicDecl *p) = 0;
  virtual void visitListDataconsWithSeparator(ListDataconsWithSeparator *p) = 0;
  virtual void visitListIndcase(ListIndcase *p) = 0;
  virtual void visitListLabelName(ListLabelName *p) = 0;
  virtual void visitListBehaviorName(ListBehaviorName *p) = 0;
  virtual void visitListIdentifierOrTypenameFull(ListIdentifierOrTypenameFull *p) = 0;
  virtual void visitListWildcard(ListWildcard *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitEXT_GLOBAL(EXT_GLOBAL x) = 0;
  virtual void visitEXT_GLOBAL_BLOCK(EXT_GLOBAL_BLOCK x) = 0;
  virtual void visitEXT_CODE_ANNOT(EXT_CODE_ANNOT x) = 0;
  virtual void visitEXT_CONTRACT(EXT_CONTRACT x) = 0;
  virtual void visitSTRING_LITERAL(STRING_LITERAL x) = 0;
  virtual void visitWSTRING_CONSTANT(WSTRING_CONSTANT x) = 0;
  virtual void visitTYPENAME(TYPENAME x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class LexprEOF : public Visitable
{
public:
  virtual LexprEOF *clone() const = 0;
  int line_number, char_number;
};

class LexprList : public Visitable
{
public:
  virtual LexprList *clone() const = 0;
  int line_number, char_number;
};

class LexprOption : public Visitable
{
public:
  virtual LexprOption *clone() const = 0;
  int line_number, char_number;
};

class Lexpr : public Visitable
{
public:
  virtual Lexpr *clone() const = 0;
  int line_number, char_number;
};

class LexprBinder : public Visitable
{
public:
  virtual LexprBinder *clone() const = 0;
  int line_number, char_number;
};

class LexprRelInner : public Visitable
{
public:
  virtual LexprRelInner *clone() const = 0;
  int line_number, char_number;
};

class Relation : public Visitable
{
public:
  virtual Relation *clone() const = 0;
  int line_number, char_number;
};

class Range : public Visitable
{
public:
  virtual Range *clone() const = 0;
  int line_number, char_number;
};

class FieldInitElt : public Visitable
{
public:
  virtual FieldInitElt *clone() const = 0;
  int line_number, char_number;
};

class ArrayInitElt : public Visitable
{
public:
  virtual ArrayInitElt *clone() const = 0;
  int line_number, char_number;
};

class UpdateElt : public Visitable
{
public:
  virtual UpdateElt *clone() const = 0;
  int line_number, char_number;
};

class PathElt : public Visitable
{
public:
  virtual PathElt *clone() const = 0;
  int line_number, char_number;
};

class Binders : public Visitable
{
public:
  virtual Binders *clone() const = 0;
  int line_number, char_number;
};

class BindersReentrance : public Visitable
{
public:
  virtual BindersReentrance *clone() const = 0;
  int line_number, char_number;
};

class VarSpec : public Visitable
{
public:
  virtual VarSpec *clone() const = 0;
  int line_number, char_number;
};

class ArraySize : public Visitable
{
public:
  virtual ArraySize *clone() const = 0;
  int line_number, char_number;
};

class AbsParamTypeList : public Visitable
{
public:
  virtual AbsParamTypeList *clone() const = 0;
  int line_number, char_number;
};

class AbsParam : public Visitable
{
public:
  virtual AbsParam *clone() const = 0;
  int line_number, char_number;
};

class Parameter : public Visitable
{
public:
  virtual Parameter *clone() const = 0;
  int line_number, char_number;
};

class LogicTypeGenOFTYPENAME : public Visitable
{
public:
  virtual LogicTypeGenOFTYPENAME *clone() const = 0;
  int line_number, char_number;
};

class LogicTypeGenOFIdentifierOrTypename : public Visitable
{
public:
  virtual LogicTypeGenOFIdentifierOrTypename *clone() const = 0;
  int line_number, char_number;
};

class CV : public Visitable
{
public:
  virtual CV *clone() const = 0;
  int line_number, char_number;
};

class TypeSpecCVOFTYPENAME : public Visitable
{
public:
  virtual TypeSpecCVOFTYPENAME *clone() const = 0;
  int line_number, char_number;
};

class CastLogicType : public Visitable
{
public:
  virtual CastLogicType *clone() const = 0;
  int line_number, char_number;
};

class LogicRtType : public Visitable
{
public:
  virtual LogicRtType *clone() const = 0;
  int line_number, char_number;
};

class AbsSpecOption : public Visitable
{
public:
  virtual AbsSpecOption *clone() const = 0;
  int line_number, char_number;
};

class AbsSpecCVOption : public Visitable
{
public:
  virtual AbsSpecCVOption *clone() const = 0;
  int line_number, char_number;
};

class AbsSpec : public Visitable
{
public:
  virtual AbsSpec *clone() const = 0;
  int line_number, char_number;
};

class AbsSpecCV : public Visitable
{
public:
  virtual AbsSpecCV *clone() const = 0;
  int line_number, char_number;
};

class Stars : public Visitable
{
public:
  virtual Stars *clone() const = 0;
  int line_number, char_number;
};

class StarsCV : public Visitable
{
public:
  virtual StarsCV *clone() const = 0;
  int line_number, char_number;
};

class Tabs : public Visitable
{
public:
  virtual Tabs *clone() const = 0;
  int line_number, char_number;
};

class TypeSpecSimple : public Visitable
{
public:
  virtual TypeSpecSimple *clone() const = 0;
  int line_number, char_number;
};

class TypeSpecOFTYPENAME : public Visitable
{
public:
  virtual TypeSpecOFTYPENAME *clone() const = 0;
  int line_number, char_number;
};

class TypeSpecOFIdentifierOrTypename : public Visitable
{
public:
  virtual TypeSpecOFIdentifierOrTypename *clone() const = 0;
  int line_number, char_number;
};

class FullIdentifier : public Visitable
{
public:
  virtual FullIdentifier *clone() const = 0;
  int line_number, char_number;
};

class ExtSpec : public Visitable
{
public:
  virtual ExtSpec *clone() const = 0;
  int line_number, char_number;
};

class ExtGlobalClausesOpt : public Visitable
{
public:
  virtual ExtGlobalClausesOpt *clone() const = 0;
  int line_number, char_number;
};

class ExtGlobalClause : public Visitable
{
public:
  virtual ExtGlobalClause *clone() const = 0;
  int line_number, char_number;
};

class ExtGlobalSpecsOpt : public Visitable
{
public:
  virtual ExtGlobalSpecsOpt *clone() const = 0;
  int line_number, char_number;
};

class ExtGlobalSpec : public Visitable
{
public:
  virtual ExtGlobalSpec *clone() const = 0;
  int line_number, char_number;
};

class ExtModuleSpecsOpt : public Visitable
{
public:
  virtual ExtModuleSpecsOpt *clone() const = 0;
  int line_number, char_number;
};

class ExtModuleSpec : public Visitable
{
public:
  virtual ExtModuleSpec *clone() const = 0;
  int line_number, char_number;
};

class ExtFunctionSpecsOpt : public Visitable
{
public:
  virtual ExtFunctionSpecsOpt *clone() const = 0;
  int line_number, char_number;
};

class ExtFunctionSpecs : public Visitable
{
public:
  virtual ExtFunctionSpecs *clone() const = 0;
  int line_number, char_number;
};

class ExtFunctionSpec : public Visitable
{
public:
  virtual ExtFunctionSpec *clone() const = 0;
  int line_number, char_number;
};

class ExtFunSpec : public Visitable
{
public:
  virtual ExtFunSpec *clone() const = 0;
  int line_number, char_number;
};

class ExtIdentifierOpt : public Visitable
{
public:
  virtual ExtIdentifierOpt *clone() const = 0;
  int line_number, char_number;
};

class StmtMarkup : public Visitable
{
public:
  virtual StmtMarkup *clone() const = 0;
  int line_number, char_number;
};

class Spec : public Visitable
{
public:
  virtual Spec *clone() const = 0;
  int line_number, char_number;
};

class Contract : public Visitable
{
public:
  virtual Contract *clone() const = 0;
  int line_number, char_number;
};

class ClauseKW : public Visitable
{
public:
  virtual ClauseKW *clone() const = 0;
  int line_number, char_number;
};

class Requires : public Visitable
{
public:
  virtual Requires *clone() const = 0;
  int line_number, char_number;
};

class NERequires : public Visitable
{
public:
  virtual NERequires *clone() const = 0;
  int line_number, char_number;
};

class Terminates : public Visitable
{
public:
  virtual Terminates *clone() const = 0;
  int line_number, char_number;
};

class NETerminates : public Visitable
{
public:
  virtual NETerminates *clone() const = 0;
  int line_number, char_number;
};

class Decreases : public Visitable
{
public:
  virtual Decreases *clone() const = 0;
  int line_number, char_number;
};

class NEDecreases : public Visitable
{
public:
  virtual NEDecreases *clone() const = 0;
  int line_number, char_number;
};

class Variant : public Visitable
{
public:
  virtual Variant *clone() const = 0;
  int line_number, char_number;
};

class SimpleClauses : public Visitable
{
public:
  virtual SimpleClauses *clone() const = 0;
  int line_number, char_number;
};

class Allocation : public Visitable
{
public:
  virtual Allocation *clone() const = 0;
  int line_number, char_number;
};

class NESimpleClauses : public Visitable
{
public:
  virtual NESimpleClauses *clone() const = 0;
  int line_number, char_number;
};

class ExtensionContent : public Visitable
{
public:
  virtual ExtensionContent *clone() const = 0;
  int line_number, char_number;
};

class Behaviors : public Visitable
{
public:
  virtual Behaviors *clone() const = 0;
  int line_number, char_number;
};

class NEBehaviors : public Visitable
{
public:
  virtual NEBehaviors *clone() const = 0;
  int line_number, char_number;
};

class BehaviorBody : public Visitable
{
public:
  virtual BehaviorBody *clone() const = 0;
  int line_number, char_number;
};

class Assumes : public Visitable
{
public:
  virtual Assumes *clone() const = 0;
  int line_number, char_number;
};

class CompleteOrDisjoint : public Visitable
{
public:
  virtual CompleteOrDisjoint *clone() const = 0;
  int line_number, char_number;
};

class NECompleteOrDisjoint : public Visitable
{
public:
  virtual NECompleteOrDisjoint *clone() const = 0;
  int line_number, char_number;
};

class Assigns : public Visitable
{
public:
  virtual Assigns *clone() const = 0;
  int line_number, char_number;
};

class Zones : public Visitable
{
public:
  virtual Zones *clone() const = 0;
  int line_number, char_number;
};

class Annot : public Visitable
{
public:
  virtual Annot *clone() const = 0;
  int line_number, char_number;
};

class Annotation : public Visitable
{
public:
  virtual Annotation *clone() const = 0;
  int line_number, char_number;
};

class LoopAnnotStack : public Visitable
{
public:
  virtual LoopAnnotStack *clone() const = 0;
  int line_number, char_number;
};

class LoopAnnotOpt : public Visitable
{
public:
  virtual LoopAnnotOpt *clone() const = 0;
  int line_number, char_number;
};

class LoopEffects : public Visitable
{
public:
  virtual LoopEffects *clone() const = 0;
  int line_number, char_number;
};

class LoopAllocation : public Visitable
{
public:
  virtual LoopAllocation *clone() const = 0;
  int line_number, char_number;
};

class LoopInvariant : public Visitable
{
public:
  virtual LoopInvariant *clone() const = 0;
  int line_number, char_number;
};

class LoopVariant : public Visitable
{
public:
  virtual LoopVariant *clone() const = 0;
  int line_number, char_number;
};

class LoopGrammarExtension : public Visitable
{
public:
  virtual LoopGrammarExtension *clone() const = 0;
  int line_number, char_number;
};

class LoopPragma : public Visitable
{
public:
  virtual LoopPragma *clone() const = 0;
  int line_number, char_number;
};

class BegPragmaOrCodeAnnotation : public Visitable
{
public:
  virtual BegPragmaOrCodeAnnotation *clone() const = 0;
  int line_number, char_number;
};

class PragmaOrCodeAnnotation : public Visitable
{
public:
  virtual PragmaOrCodeAnnotation *clone() const = 0;
  int line_number, char_number;
};

class CodeAnnotation : public Visitable
{
public:
  virtual CodeAnnotation *clone() const = 0;
  int line_number, char_number;
};

class SlicePragma : public Visitable
{
public:
  virtual SlicePragma *clone() const = 0;
  int line_number, char_number;
};

class ImpactPragma : public Visitable
{
public:
  virtual ImpactPragma *clone() const = 0;
  int line_number, char_number;
};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;
  int line_number, char_number;
};

class ExtDecl : public Visitable
{
public:
  virtual ExtDecl *clone() const = 0;
  int line_number, char_number;
};

class VolatileOpt : public Visitable
{
public:
  virtual VolatileOpt *clone() const = 0;
  int line_number, char_number;
};

class TypeAnnot : public Visitable
{
public:
  virtual TypeAnnot *clone() const = 0;
  int line_number, char_number;
};

class OptSemicolon : public Visitable
{
public:
  virtual OptSemicolon *clone() const = 0;
  int line_number, char_number;
};

class ModelAnnot : public Visitable
{
public:
  virtual ModelAnnot *clone() const = 0;
  int line_number, char_number;
};

class PolyIdType : public Visitable
{
public:
  virtual PolyIdType *clone() const = 0;
  int line_number, char_number;
};

class PolyId : public Visitable
{
public:
  virtual PolyId *clone() const = 0;
  int line_number, char_number;
};

class OptParameters : public Visitable
{
public:
  virtual OptParameters *clone() const = 0;
  int line_number, char_number;
};

class Parameters : public Visitable
{
public:
  virtual Parameters *clone() const = 0;
  int line_number, char_number;
};

class LogicDef : public Visitable
{
public:
  virtual LogicDef *clone() const = 0;
  int line_number, char_number;
};

class DeprecatedLogicDecl : public Visitable
{
public:
  virtual DeprecatedLogicDecl *clone() const = 0;
  int line_number, char_number;
};

class LogicDecl : public Visitable
{
public:
  virtual LogicDecl *clone() const = 0;
  int line_number, char_number;
};

class ReadsClause : public Visitable
{
public:
  virtual ReadsClause *clone() const = 0;
  int line_number, char_number;
};

class Typedef : public Visitable
{
public:
  virtual Typedef *clone() const = 0;
  int line_number, char_number;
};

class DataconsWithSeparator : public Visitable
{
public:
  virtual DataconsWithSeparator *clone() const = 0;
  int line_number, char_number;
};

class Datacons : public Visitable
{
public:
  virtual Datacons *clone() const = 0;
  int line_number, char_number;
};

class Indcase : public Visitable
{
public:
  virtual Indcase *clone() const = 0;
  int line_number, char_number;
};

class OptLabel : public Visitable
{
public:
  virtual OptLabel *clone() const = 0;
  int line_number, char_number;
};

class OptLabelList : public Visitable
{
public:
  virtual OptLabelList *clone() const = 0;
  int line_number, char_number;
};

class LabelName : public Visitable
{
public:
  virtual LabelName *clone() const = 0;
  int line_number, char_number;
};

class BehaviorNameList : public Visitable
{
public:
  virtual BehaviorNameList *clone() const = 0;
  int line_number, char_number;
};

class BehaviorName : public Visitable
{
public:
  virtual BehaviorName *clone() const = 0;
  int line_number, char_number;
};

class AnyIdentifier : public Visitable
{
public:
  virtual AnyIdentifier *clone() const = 0;
  int line_number, char_number;
};

class IdentifierOrTypename : public Visitable
{
public:
  virtual IdentifierOrTypename *clone() const = 0;
  int line_number, char_number;
};

class IdentifierOrTypenameFull : public Visitable
{
public:
  virtual IdentifierOrTypenameFull *clone() const = 0;
  int line_number, char_number;
};

class Identifier : public Visitable
{
public:
  virtual Identifier *clone() const = 0;
  int line_number, char_number;
};

class BoundedVar : public Visitable
{
public:
  virtual BoundedVar *clone() const = 0;
  int line_number, char_number;
};

class CKeyword : public Visitable
{
public:
  virtual CKeyword *clone() const = 0;
  int line_number, char_number;
};

class ACSLCKeyword : public Visitable
{
public:
  virtual ACSLCKeyword *clone() const = 0;
  int line_number, char_number;
};

class PostCond : public Visitable
{
public:
  virtual PostCond *clone() const = 0;
  int line_number, char_number;
};

class IsACSLSpec : public Visitable
{
public:
  virtual IsACSLSpec *clone() const = 0;
  int line_number, char_number;
};

class IsACSLDeclOrCodeAnnot : public Visitable
{
public:
  virtual IsACSLDeclOrCodeAnnot *clone() const = 0;
  int line_number, char_number;
};

class IsACSLTypename : public Visitable
{
public:
  virtual IsACSLTypename *clone() const = 0;
  int line_number, char_number;
};

class IsExtSpec : public Visitable
{
public:
  virtual IsExtSpec *clone() const = 0;
  int line_number, char_number;
};

class Keyword : public Visitable
{
public:
  virtual Keyword *clone() const = 0;
  int line_number, char_number;
};

class BSKeyword : public Visitable
{
public:
  virtual BSKeyword *clone() const = 0;
  int line_number, char_number;
};

class Wildcard : public Visitable
{
public:
  virtual Wildcard *clone() const = 0;
  int line_number, char_number;
};



class LexprEof : public LexprEOF
{
public:
  Lexpr *lexpr_;

  LexprEof(const LexprEof &);
  LexprEof &operator=(const LexprEof &);
  LexprEof(Lexpr *p1);
  ~LexprEof();
  virtual void accept(Visitor *v);
  virtual LexprEof *clone() const;
  void swap(LexprEof &);
};

class EmptyLexprList : public LexprList
{
public:

  EmptyLexprList(const EmptyLexprList &);
  EmptyLexprList &operator=(const EmptyLexprList &);
  EmptyLexprList();
  ~EmptyLexprList();
  virtual void accept(Visitor *v);
  virtual EmptyLexprList *clone() const;
  void swap(EmptyLexprList &);
};

class NonEmptyLexprList : public LexprList
{
public:
  ListLexpr *listlexpr_;

  NonEmptyLexprList(const NonEmptyLexprList &);
  NonEmptyLexprList &operator=(const NonEmptyLexprList &);
  NonEmptyLexprList(ListLexpr *p1);
  ~NonEmptyLexprList();
  virtual void accept(Visitor *v);
  virtual NonEmptyLexprList *clone() const;
  void swap(NonEmptyLexprList &);
};

class NoLexprOption : public LexprOption
{
public:

  NoLexprOption(const NoLexprOption &);
  NoLexprOption &operator=(const NoLexprOption &);
  NoLexprOption();
  ~NoLexprOption();
  virtual void accept(Visitor *v);
  virtual NoLexprOption *clone() const;
  void swap(NoLexprOption &);
};

class SomeLexprOption : public LexprOption
{
public:
  Lexpr *lexpr_;

  SomeLexprOption(const SomeLexprOption &);
  SomeLexprOption &operator=(const SomeLexprOption &);
  SomeLexprOption(Lexpr *p1);
  ~SomeLexprOption();
  virtual void accept(Visitor *v);
  virtual SomeLexprOption *clone() const;
  void swap(SomeLexprOption &);
};

class NoLexpr : public Lexpr
{
public:

  NoLexpr(const NoLexpr &);
  NoLexpr &operator=(const NoLexpr &);
  NoLexpr();
  ~NoLexpr();
  virtual void accept(Visitor *v);
  virtual NoLexpr *clone() const;
  void swap(NoLexpr &);
};

class ImplLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  ImplLexpr(const ImplLexpr &);
  ImplLexpr &operator=(const ImplLexpr &);
  ImplLexpr(Lexpr *p1, Lexpr *p2);
  ~ImplLexpr();
  virtual void accept(Visitor *v);
  virtual ImplLexpr *clone() const;
  void swap(ImplLexpr &);
};

class IffLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  IffLexpr(const IffLexpr &);
  IffLexpr &operator=(const IffLexpr &);
  IffLexpr(Lexpr *p1, Lexpr *p2);
  ~IffLexpr();
  virtual void accept(Visitor *v);
  virtual IffLexpr *clone() const;
  void swap(IffLexpr &);
};

class OrLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  OrLexpr(const OrLexpr &);
  OrLexpr &operator=(const OrLexpr &);
  OrLexpr(Lexpr *p1, Lexpr *p2);
  ~OrLexpr();
  virtual void accept(Visitor *v);
  virtual OrLexpr *clone() const;
  void swap(OrLexpr &);
};

class AndLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AndLexpr(const AndLexpr &);
  AndLexpr &operator=(const AndLexpr &);
  AndLexpr(Lexpr *p1, Lexpr *p2);
  ~AndLexpr();
  virtual void accept(Visitor *v);
  virtual AndLexpr *clone() const;
  void swap(AndLexpr &);
};

class HatHatLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  HatHatLexpr(const HatHatLexpr &);
  HatHatLexpr &operator=(const HatHatLexpr &);
  HatHatLexpr(Lexpr *p1, Lexpr *p2);
  ~HatHatLexpr();
  virtual void accept(Visitor *v);
  virtual HatHatLexpr *clone() const;
  void swap(HatHatLexpr &);
};

class AmpLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AmpLexpr(const AmpLexpr &);
  AmpLexpr &operator=(const AmpLexpr &);
  AmpLexpr(Lexpr *p1, Lexpr *p2);
  ~AmpLexpr();
  virtual void accept(Visitor *v);
  virtual AmpLexpr *clone() const;
  void swap(AmpLexpr &);
};

class PipeLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  PipeLexpr(const PipeLexpr &);
  PipeLexpr &operator=(const PipeLexpr &);
  PipeLexpr(Lexpr *p1, Lexpr *p2);
  ~PipeLexpr();
  virtual void accept(Visitor *v);
  virtual PipeLexpr *clone() const;
  void swap(PipeLexpr &);
};

class HatLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  HatLexpr(const HatLexpr &);
  HatLexpr &operator=(const HatLexpr &);
  HatLexpr(Lexpr *p1, Lexpr *p2);
  ~HatLexpr();
  virtual void accept(Visitor *v);
  virtual HatLexpr *clone() const;
  void swap(HatLexpr &);
};

class BimpliesLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  BimpliesLexpr(const BimpliesLexpr &);
  BimpliesLexpr &operator=(const BimpliesLexpr &);
  BimpliesLexpr(Lexpr *p1, Lexpr *p2);
  ~BimpliesLexpr();
  virtual void accept(Visitor *v);
  virtual BimpliesLexpr *clone() const;
  void swap(BimpliesLexpr &);
};

class BiffLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  BiffLexpr(const BiffLexpr &);
  BiffLexpr &operator=(const BiffLexpr &);
  BiffLexpr(Lexpr *p1, Lexpr *p2);
  ~BiffLexpr();
  virtual void accept(Visitor *v);
  virtual BiffLexpr *clone() const;
  void swap(BiffLexpr &);
};

class InLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  InLexpr(const InLexpr &);
  InLexpr &operator=(const InLexpr &);
  InLexpr(Lexpr *p1, Lexpr *p2);
  ~InLexpr();
  virtual void accept(Visitor *v);
  virtual InLexpr *clone() const;
  void swap(InLexpr &);
};

class TernaryLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;
  Lexpr *lexpr_3;

  TernaryLexpr(const TernaryLexpr &);
  TernaryLexpr &operator=(const TernaryLexpr &);
  TernaryLexpr(Lexpr *p1, Lexpr *p2, Lexpr *p3);
  ~TernaryLexpr();
  virtual void accept(Visitor *v);
  virtual TernaryLexpr *clone() const;
  void swap(TernaryLexpr &);
};

class IdAssignLexpr : public Lexpr
{
public:
  AnyIdentifier *anyidentifier_;
  Lexpr *lexpr_;

  IdAssignLexpr(const IdAssignLexpr &);
  IdAssignLexpr &operator=(const IdAssignLexpr &);
  IdAssignLexpr(AnyIdentifier *p1, Lexpr *p2);
  ~IdAssignLexpr();
  virtual void accept(Visitor *v);
  virtual IdAssignLexpr *clone() const;
  void swap(IdAssignLexpr &);
};

class StrAssignLexpr : public Lexpr
{
public:
  ListSTRING_LITERAL *liststring_literal_;
  Lexpr *lexpr_;

  StrAssignLexpr(const StrAssignLexpr &);
  StrAssignLexpr &operator=(const StrAssignLexpr &);
  StrAssignLexpr(ListSTRING_LITERAL *p1, Lexpr *p2);
  ~StrAssignLexpr();
  virtual void accept(Visitor *v);
  virtual StrAssignLexpr *clone() const;
  void swap(StrAssignLexpr &);
};

class RelationLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  ListLexprRelInner *listlexprrelinner_;
  Relation *relation_;
  Lexpr *lexpr_2;

  RelationLexpr(const RelationLexpr &);
  RelationLexpr &operator=(const RelationLexpr &);
  RelationLexpr(Lexpr *p1, ListLexprRelInner *p2, Relation *p3, Lexpr *p4);
  ~RelationLexpr();
  virtual void accept(Visitor *v);
  virtual RelationLexpr *clone() const;
  void swap(RelationLexpr &);
};

class BinderLexpr : public Lexpr
{
public:
  LexprBinder *lexprbinder_;

  BinderLexpr(const BinderLexpr &);
  BinderLexpr &operator=(const BinderLexpr &);
  BinderLexpr(LexprBinder *p1);
  ~BinderLexpr();
  virtual void accept(Visitor *v);
  virtual BinderLexpr *clone() const;
  void swap(BinderLexpr &);
};

class NotBinderLexpr : public Lexpr
{
public:
  LexprBinder *lexprbinder_;

  NotBinderLexpr(const NotBinderLexpr &);
  NotBinderLexpr &operator=(const NotBinderLexpr &);
  NotBinderLexpr(LexprBinder *p1);
  ~NotBinderLexpr();
  virtual void accept(Visitor *v);
  virtual NotBinderLexpr *clone() const;
  void swap(NotBinderLexpr &);
};

class StringLexpr : public Lexpr
{
public:
  ListSTRING_LITERAL *liststring_literal_;

  StringLexpr(const StringLexpr &);
  StringLexpr &operator=(const StringLexpr &);
  StringLexpr(ListSTRING_LITERAL *p1);
  ~StringLexpr();
  virtual void accept(Visitor *v);
  virtual StringLexpr *clone() const;
  void swap(StringLexpr &);
};

class NotLexprInner : public Lexpr
{
public:
  Lexpr *lexpr_;

  NotLexprInner(const NotLexprInner &);
  NotLexprInner &operator=(const NotLexprInner &);
  NotLexprInner(Lexpr *p1);
  ~NotLexprInner();
  virtual void accept(Visitor *v);
  virtual NotLexprInner *clone() const;
  void swap(NotLexprInner &);
};

class TrueLexpr : public Lexpr
{
public:

  TrueLexpr(const TrueLexpr &);
  TrueLexpr &operator=(const TrueLexpr &);
  TrueLexpr();
  ~TrueLexpr();
  virtual void accept(Visitor *v);
  virtual TrueLexpr *clone() const;
  void swap(TrueLexpr &);
};

class FalseLexpr : public Lexpr
{
public:

  FalseLexpr(const FalseLexpr &);
  FalseLexpr &operator=(const FalseLexpr &);
  FalseLexpr();
  ~FalseLexpr();
  virtual void accept(Visitor *v);
  virtual FalseLexpr *clone() const;
  void swap(FalseLexpr &);
};

class PointerLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  PointerLexpr(const PointerLexpr &);
  PointerLexpr &operator=(const PointerLexpr &);
  PointerLexpr(OptLabel *p1, Lexpr *p2);
  ~PointerLexpr();
  virtual void accept(Visitor *v);
  virtual PointerLexpr *clone() const;
  void swap(PointerLexpr &);
};

class ValidLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  ValidLexpr(const ValidLexpr &);
  ValidLexpr &operator=(const ValidLexpr &);
  ValidLexpr(OptLabel *p1, Lexpr *p2);
  ~ValidLexpr();
  virtual void accept(Visitor *v);
  virtual ValidLexpr *clone() const;
  void swap(ValidLexpr &);
};

class ValidReadLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  ValidReadLexpr(const ValidReadLexpr &);
  ValidReadLexpr &operator=(const ValidReadLexpr &);
  ValidReadLexpr(OptLabel *p1, Lexpr *p2);
  ~ValidReadLexpr();
  virtual void accept(Visitor *v);
  virtual ValidReadLexpr *clone() const;
  void swap(ValidReadLexpr &);
};

class ValidFuncLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  ValidFuncLexpr(const ValidFuncLexpr &);
  ValidFuncLexpr &operator=(const ValidFuncLexpr &);
  ValidFuncLexpr(Lexpr *p1);
  ~ValidFuncLexpr();
  virtual void accept(Visitor *v);
  virtual ValidFuncLexpr *clone() const;
  void swap(ValidFuncLexpr &);
};

class ValidIndxLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  ValidIndxLexpr(const ValidIndxLexpr &);
  ValidIndxLexpr &operator=(const ValidIndxLexpr &);
  ValidIndxLexpr(OptLabel *p1, Lexpr *p2, Lexpr *p3);
  ~ValidIndxLexpr();
  virtual void accept(Visitor *v);
  virtual ValidIndxLexpr *clone() const;
  void swap(ValidIndxLexpr &);
};

class ValidRangeLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;
  Lexpr *lexpr_3;

  ValidRangeLexpr(const ValidRangeLexpr &);
  ValidRangeLexpr &operator=(const ValidRangeLexpr &);
  ValidRangeLexpr(OptLabel *p1, Lexpr *p2, Lexpr *p3, Lexpr *p4);
  ~ValidRangeLexpr();
  virtual void accept(Visitor *v);
  virtual ValidRangeLexpr *clone() const;
  void swap(ValidRangeLexpr &);
};

class InitializedLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  InitializedLexpr(const InitializedLexpr &);
  InitializedLexpr &operator=(const InitializedLexpr &);
  InitializedLexpr(OptLabel *p1, Lexpr *p2);
  ~InitializedLexpr();
  virtual void accept(Visitor *v);
  virtual InitializedLexpr *clone() const;
  void swap(InitializedLexpr &);
};

class DanglingLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  DanglingLexpr(const DanglingLexpr &);
  DanglingLexpr &operator=(const DanglingLexpr &);
  DanglingLexpr(OptLabel *p1, Lexpr *p2);
  ~DanglingLexpr();
  virtual void accept(Visitor *v);
  virtual DanglingLexpr *clone() const;
  void swap(DanglingLexpr &);
};

class FreshLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  FreshLexpr(const FreshLexpr &);
  FreshLexpr &operator=(const FreshLexpr &);
  FreshLexpr(OptLabel *p1, Lexpr *p2, Lexpr *p3);
  ~FreshLexpr();
  virtual void accept(Visitor *v);
  virtual FreshLexpr *clone() const;
  void swap(FreshLexpr &);
};

class BaseAddrLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  BaseAddrLexpr(const BaseAddrLexpr &);
  BaseAddrLexpr &operator=(const BaseAddrLexpr &);
  BaseAddrLexpr(OptLabel *p1, Lexpr *p2);
  ~BaseAddrLexpr();
  virtual void accept(Visitor *v);
  virtual BaseAddrLexpr *clone() const;
  void swap(BaseAddrLexpr &);
};

class BlockLengthLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  BlockLengthLexpr(const BlockLengthLexpr &);
  BlockLengthLexpr &operator=(const BlockLengthLexpr &);
  BlockLengthLexpr(OptLabel *p1, Lexpr *p2);
  ~BlockLengthLexpr();
  virtual void accept(Visitor *v);
  virtual BlockLengthLexpr *clone() const;
  void swap(BlockLengthLexpr &);
};

class OffsetLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  OffsetLexpr(const OffsetLexpr &);
  OffsetLexpr &operator=(const OffsetLexpr &);
  OffsetLexpr(OptLabel *p1, Lexpr *p2);
  ~OffsetLexpr();
  virtual void accept(Visitor *v);
  virtual OffsetLexpr *clone() const;
  void swap(OffsetLexpr &);
};

class AllocableLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  AllocableLexpr(const AllocableLexpr &);
  AllocableLexpr &operator=(const AllocableLexpr &);
  AllocableLexpr(OptLabel *p1, Lexpr *p2);
  ~AllocableLexpr();
  virtual void accept(Visitor *v);
  virtual AllocableLexpr *clone() const;
  void swap(AllocableLexpr &);
};

class FreeableLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  FreeableLexpr(const FreeableLexpr &);
  FreeableLexpr &operator=(const FreeableLexpr &);
  FreeableLexpr(OptLabel *p1, Lexpr *p2);
  ~FreeableLexpr();
  virtual void accept(Visitor *v);
  virtual FreeableLexpr *clone() const;
  void swap(FreeableLexpr &);
};

class AllocationLexpr : public Lexpr
{
public:
  OptLabel *optlabel_;
  Lexpr *lexpr_;

  AllocationLexpr(const AllocationLexpr &);
  AllocationLexpr &operator=(const AllocationLexpr &);
  AllocationLexpr(OptLabel *p1, Lexpr *p2);
  ~AllocationLexpr();
  virtual void accept(Visitor *v);
  virtual AllocationLexpr *clone() const;
  void swap(AllocationLexpr &);
};

class AutomaticLexpr : public Lexpr
{
public:

  AutomaticLexpr(const AutomaticLexpr &);
  AutomaticLexpr &operator=(const AutomaticLexpr &);
  AutomaticLexpr();
  ~AutomaticLexpr();
  virtual void accept(Visitor *v);
  virtual AutomaticLexpr *clone() const;
  void swap(AutomaticLexpr &);
};

class DynamicLexpr : public Lexpr
{
public:

  DynamicLexpr(const DynamicLexpr &);
  DynamicLexpr &operator=(const DynamicLexpr &);
  DynamicLexpr();
  ~DynamicLexpr();
  virtual void accept(Visitor *v);
  virtual DynamicLexpr *clone() const;
  void swap(DynamicLexpr &);
};

class RegisterLexpr : public Lexpr
{
public:

  RegisterLexpr(const RegisterLexpr &);
  RegisterLexpr &operator=(const RegisterLexpr &);
  RegisterLexpr();
  ~RegisterLexpr();
  virtual void accept(Visitor *v);
  virtual RegisterLexpr *clone() const;
  void swap(RegisterLexpr &);
};

class StaticLexpr : public Lexpr
{
public:

  StaticLexpr(const StaticLexpr &);
  StaticLexpr &operator=(const StaticLexpr &);
  StaticLexpr();
  ~StaticLexpr();
  virtual void accept(Visitor *v);
  virtual StaticLexpr *clone() const;
  void swap(StaticLexpr &);
};

class UnallocatedLexpr : public Lexpr
{
public:

  UnallocatedLexpr(const UnallocatedLexpr &);
  UnallocatedLexpr &operator=(const UnallocatedLexpr &);
  UnallocatedLexpr();
  ~UnallocatedLexpr();
  virtual void accept(Visitor *v);
  virtual UnallocatedLexpr *clone() const;
  void swap(UnallocatedLexpr &);
};

class NullLexpr : public Lexpr
{
public:

  NullLexpr(const NullLexpr &);
  NullLexpr &operator=(const NullLexpr &);
  NullLexpr();
  ~NullLexpr();
  virtual void accept(Visitor *v);
  virtual NullLexpr *clone() const;
  void swap(NullLexpr &);
};

class IntConst : public Lexpr
{
public:
  Integer integer_;

  IntConst(const IntConst &);
  IntConst &operator=(const IntConst &);
  IntConst(Integer p1);
  ~IntConst();
  virtual void accept(Visitor *v);
  virtual IntConst *clone() const;
  void swap(IntConst &);
};

class FloatConst : public Lexpr
{
public:
  Double double_;

  FloatConst(const FloatConst &);
  FloatConst &operator=(const FloatConst &);
  FloatConst(Double p1);
  ~FloatConst();
  virtual void accept(Visitor *v);
  virtual FloatConst *clone() const;
  void swap(FloatConst &);
};

class StringConst : public Lexpr
{
public:
  String string_;

  StringConst(const StringConst &);
  StringConst &operator=(const StringConst &);
  StringConst(String p1);
  ~StringConst();
  virtual void accept(Visitor *v);
  virtual StringConst *clone() const;
  void swap(StringConst &);
};

class WStringConst : public Lexpr
{
public:
  WSTRING_CONSTANT wstring_constant_;

  WStringConst(const WStringConst &);
  WStringConst &operator=(const WStringConst &);
  WStringConst(WSTRING_CONSTANT p1);
  ~WStringConst();
  virtual void accept(Visitor *v);
  virtual WStringConst *clone() const;
  void swap(WStringConst &);
};

class AddLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AddLexpr(const AddLexpr &);
  AddLexpr &operator=(const AddLexpr &);
  AddLexpr(Lexpr *p1, Lexpr *p2);
  ~AddLexpr();
  virtual void accept(Visitor *v);
  virtual AddLexpr *clone() const;
  void swap(AddLexpr &);
};

class SubtrLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  SubtrLexpr(const SubtrLexpr &);
  SubtrLexpr &operator=(const SubtrLexpr &);
  SubtrLexpr(Lexpr *p1, Lexpr *p2);
  ~SubtrLexpr();
  virtual void accept(Visitor *v);
  virtual SubtrLexpr *clone() const;
  void swap(SubtrLexpr &);
};

class MultLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  MultLexpr(const MultLexpr &);
  MultLexpr &operator=(const MultLexpr &);
  MultLexpr(Lexpr *p1, Lexpr *p2);
  ~MultLexpr();
  virtual void accept(Visitor *v);
  virtual MultLexpr *clone() const;
  void swap(MultLexpr &);
};

class DivLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  DivLexpr(const DivLexpr &);
  DivLexpr &operator=(const DivLexpr &);
  DivLexpr(Lexpr *p1, Lexpr *p2);
  ~DivLexpr();
  virtual void accept(Visitor *v);
  virtual DivLexpr *clone() const;
  void swap(DivLexpr &);
};

class ModLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  ModLexpr(const ModLexpr &);
  ModLexpr &operator=(const ModLexpr &);
  ModLexpr(Lexpr *p1, Lexpr *p2);
  ~ModLexpr();
  virtual void accept(Visitor *v);
  virtual ModLexpr *clone() const;
  void swap(ModLexpr &);
};

class StarHatLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  StarHatLexpr(const StarHatLexpr &);
  StarHatLexpr &operator=(const StarHatLexpr &);
  StarHatLexpr(Lexpr *p1, Lexpr *p2);
  ~StarHatLexpr();
  virtual void accept(Visitor *v);
  virtual StarHatLexpr *clone() const;
  void swap(StarHatLexpr &);
};

class ArrowLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;
  IdentifierOrTypenameFull *identifierortypenamefull_;

  ArrowLexpr(const ArrowLexpr &);
  ArrowLexpr &operator=(const ArrowLexpr &);
  ArrowLexpr(Lexpr *p1, IdentifierOrTypenameFull *p2);
  ~ArrowLexpr();
  virtual void accept(Visitor *v);
  virtual ArrowLexpr *clone() const;
  void swap(ArrowLexpr &);
};

class DotLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;
  IdentifierOrTypenameFull *identifierortypenamefull_;

  DotLexpr(const DotLexpr &);
  DotLexpr &operator=(const DotLexpr &);
  DotLexpr(Lexpr *p1, IdentifierOrTypenameFull *p2);
  ~DotLexpr();
  virtual void accept(Visitor *v);
  virtual DotLexpr *clone() const;
  void swap(DotLexpr &);
};

class SquaresRangeLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;
  Range *range_;

  SquaresRangeLexpr(const SquaresRangeLexpr &);
  SquaresRangeLexpr &operator=(const SquaresRangeLexpr &);
  SquaresRangeLexpr(Lexpr *p1, Range *p2);
  ~SquaresRangeLexpr();
  virtual void accept(Visitor *v);
  virtual SquaresRangeLexpr *clone() const;
  void swap(SquaresRangeLexpr &);
};

class SquaresLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  SquaresLexpr(const SquaresLexpr &);
  SquaresLexpr &operator=(const SquaresLexpr &);
  SquaresLexpr(Lexpr *p1, Lexpr *p2);
  ~SquaresLexpr();
  virtual void accept(Visitor *v);
  virtual SquaresLexpr *clone() const;
  void swap(SquaresLexpr &);
};

class SquaresPipeLexpr : public Lexpr
{
public:
  LexprList *lexprlist_;

  SquaresPipeLexpr(const SquaresPipeLexpr &);
  SquaresPipeLexpr &operator=(const SquaresPipeLexpr &);
  SquaresPipeLexpr(LexprList *p1);
  ~SquaresPipeLexpr();
  virtual void accept(Visitor *v);
  virtual SquaresPipeLexpr *clone() const;
  void swap(SquaresPipeLexpr &);
};

class MinusLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  MinusLexpr(const MinusLexpr &);
  MinusLexpr &operator=(const MinusLexpr &);
  MinusLexpr(Lexpr *p1);
  ~MinusLexpr();
  virtual void accept(Visitor *v);
  virtual MinusLexpr *clone() const;
  void swap(MinusLexpr &);
};

class PlusLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  PlusLexpr(const PlusLexpr &);
  PlusLexpr &operator=(const PlusLexpr &);
  PlusLexpr(Lexpr *p1);
  ~PlusLexpr();
  virtual void accept(Visitor *v);
  virtual PlusLexpr *clone() const;
  void swap(PlusLexpr &);
};

class TildeLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  TildeLexpr(const TildeLexpr &);
  TildeLexpr &operator=(const TildeLexpr &);
  TildeLexpr(Lexpr *p1);
  ~TildeLexpr();
  virtual void accept(Visitor *v);
  virtual TildeLexpr *clone() const;
  void swap(TildeLexpr &);
};

class StarLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  StarLexpr(const StarLexpr &);
  StarLexpr &operator=(const StarLexpr &);
  StarLexpr(Lexpr *p1);
  ~StarLexpr();
  virtual void accept(Visitor *v);
  virtual StarLexpr *clone() const;
  void swap(StarLexpr &);
};

class AmpUnaryLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  AmpUnaryLexpr(const AmpUnaryLexpr &);
  AmpUnaryLexpr &operator=(const AmpUnaryLexpr &);
  AmpUnaryLexpr(Lexpr *p1);
  ~AmpUnaryLexpr();
  virtual void accept(Visitor *v);
  virtual AmpUnaryLexpr *clone() const;
  void swap(AmpUnaryLexpr &);
};

class SizeOfLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  SizeOfLexpr(const SizeOfLexpr &);
  SizeOfLexpr &operator=(const SizeOfLexpr &);
  SizeOfLexpr(Lexpr *p1);
  ~SizeOfLexpr();
  virtual void accept(Visitor *v);
  virtual SizeOfLexpr *clone() const;
  void swap(SizeOfLexpr &);
};

class SizeOfLogicTypeLexpr : public Lexpr
{
public:
  CastLogicType *castlogictype_;

  SizeOfLogicTypeLexpr(const SizeOfLogicTypeLexpr &);
  SizeOfLogicTypeLexpr &operator=(const SizeOfLogicTypeLexpr &);
  SizeOfLogicTypeLexpr(CastLogicType *p1);
  ~SizeOfLogicTypeLexpr();
  virtual void accept(Visitor *v);
  virtual SizeOfLogicTypeLexpr *clone() const;
  void swap(SizeOfLogicTypeLexpr &);
};

class OldLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  OldLexpr(const OldLexpr &);
  OldLexpr &operator=(const OldLexpr &);
  OldLexpr(Lexpr *p1);
  ~OldLexpr();
  virtual void accept(Visitor *v);
  virtual OldLexpr *clone() const;
  void swap(OldLexpr &);
};

class AtLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;
  LabelName *labelname_;

  AtLexpr(const AtLexpr &);
  AtLexpr &operator=(const AtLexpr &);
  AtLexpr(Lexpr *p1, LabelName *p2);
  ~AtLexpr();
  virtual void accept(Visitor *v);
  virtual AtLexpr *clone() const;
  void swap(AtLexpr &);
};

class ResultLexpr : public Lexpr
{
public:

  ResultLexpr(const ResultLexpr &);
  ResultLexpr &operator=(const ResultLexpr &);
  ResultLexpr();
  ~ResultLexpr();
  virtual void accept(Visitor *v);
  virtual ResultLexpr *clone() const;
  void swap(ResultLexpr &);
};

class SeparatedLexpr : public Lexpr
{
public:
  ListLexpr *listlexpr_;

  SeparatedLexpr(const SeparatedLexpr &);
  SeparatedLexpr &operator=(const SeparatedLexpr &);
  SeparatedLexpr(ListLexpr *p1);
  ~SeparatedLexpr();
  virtual void accept(Visitor *v);
  virtual SeparatedLexpr *clone() const;
  void swap(SeparatedLexpr &);
};

class FullIdParenLexpr : public Lexpr
{
public:
  FullIdentifier *fullidentifier_;
  ListLexpr *listlexpr_;

  FullIdParenLexpr(const FullIdParenLexpr &);
  FullIdParenLexpr &operator=(const FullIdParenLexpr &);
  FullIdParenLexpr(FullIdentifier *p1, ListLexpr *p2);
  ~FullIdParenLexpr();
  virtual void accept(Visitor *v);
  virtual FullIdParenLexpr *clone() const;
  void swap(FullIdParenLexpr &);
};

class FullIdBraceParenLexpr : public Lexpr
{
public:
  FullIdentifier *fullidentifier_;
  ListIdentifierOrTypenameFull *listidentifierortypenamefull_;
  ListLexpr *listlexpr_;

  FullIdBraceParenLexpr(const FullIdBraceParenLexpr &);
  FullIdBraceParenLexpr &operator=(const FullIdBraceParenLexpr &);
  FullIdBraceParenLexpr(FullIdentifier *p1, ListIdentifierOrTypenameFull *p2, ListLexpr *p3);
  ~FullIdBraceParenLexpr();
  virtual void accept(Visitor *v);
  virtual FullIdBraceParenLexpr *clone() const;
  void swap(FullIdBraceParenLexpr &);
};

class FullIdBracesLexpr : public Lexpr
{
public:
  FullIdentifier *fullidentifier_;
  ListIdentifierOrTypenameFull *listidentifierortypenamefull_;

  FullIdBracesLexpr(const FullIdBracesLexpr &);
  FullIdBracesLexpr &operator=(const FullIdBracesLexpr &);
  FullIdBracesLexpr(FullIdentifier *p1, ListIdentifierOrTypenameFull *p2);
  ~FullIdBracesLexpr();
  virtual void accept(Visitor *v);
  virtual FullIdBracesLexpr *clone() const;
  void swap(FullIdBracesLexpr &);
};

class FullId : public Lexpr
{
public:
  FullIdentifier *fullidentifier_;

  FullId(const FullId &);
  FullId &operator=(const FullId &);
  FullId(FullIdentifier *p1);
  ~FullId();
  virtual void accept(Visitor *v);
  virtual FullId *clone() const;
  void swap(FullId &);
};

class PiLexpr : public Lexpr
{
public:

  PiLexpr(const PiLexpr &);
  PiLexpr &operator=(const PiLexpr &);
  PiLexpr();
  ~PiLexpr();
  virtual void accept(Visitor *v);
  virtual PiLexpr *clone() const;
  void swap(PiLexpr &);
};

class LessLessLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  LessLessLexpr(const LessLessLexpr &);
  LessLessLexpr &operator=(const LessLessLexpr &);
  LessLessLexpr(Lexpr *p1, Lexpr *p2);
  ~LessLessLexpr();
  virtual void accept(Visitor *v);
  virtual LessLessLexpr *clone() const;
  void swap(LessLessLexpr &);
};

class GreaterGreaterLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  GreaterGreaterLexpr(const GreaterGreaterLexpr &);
  GreaterGreaterLexpr &operator=(const GreaterGreaterLexpr &);
  GreaterGreaterLexpr(Lexpr *p1, Lexpr *p2);
  ~GreaterGreaterLexpr();
  virtual void accept(Visitor *v);
  virtual GreaterGreaterLexpr *clone() const;
  void swap(GreaterGreaterLexpr &);
};

class ParenRangeLexpr : public Lexpr
{
public:
  Range *range_;

  ParenRangeLexpr(const ParenRangeLexpr &);
  ParenRangeLexpr &operator=(const ParenRangeLexpr &);
  ParenRangeLexpr(Range *p1);
  ~ParenRangeLexpr();
  virtual void accept(Visitor *v);
  virtual ParenRangeLexpr *clone() const;
  void swap(ParenRangeLexpr &);
};

class CastLexpr : public Lexpr
{
public:
  CastLogicType *castlogictype_;
  Lexpr *lexpr_;

  CastLexpr(const CastLexpr &);
  CastLexpr &operator=(const CastLexpr &);
  CastLexpr(CastLogicType *p1, Lexpr *p2);
  ~CastLexpr();
  virtual void accept(Visitor *v);
  virtual CastLexpr *clone() const;
  void swap(CastLexpr &);
};

class TypeOfLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  TypeOfLexpr(const TypeOfLexpr &);
  TypeOfLexpr &operator=(const TypeOfLexpr &);
  TypeOfLexpr(Lexpr *p1);
  ~TypeOfLexpr();
  virtual void accept(Visitor *v);
  virtual TypeOfLexpr *clone() const;
  void swap(TypeOfLexpr &);
};

class TypeLexpr : public Lexpr
{
public:
  TypeSpecOFTYPENAME *typespecoftypename_;

  TypeLexpr(const TypeLexpr &);
  TypeLexpr &operator=(const TypeLexpr &);
  TypeLexpr(TypeSpecOFTYPENAME *p1);
  ~TypeLexpr();
  virtual void accept(Visitor *v);
  virtual TypeLexpr *clone() const;
  void swap(TypeLexpr &);
};

class TypeWithStarsLexpr : public Lexpr
{
public:
  TypeSpecOFTYPENAME *typespecoftypename_;
  ListStars *liststars_;

  TypeWithStarsLexpr(const TypeWithStarsLexpr &);
  TypeWithStarsLexpr &operator=(const TypeWithStarsLexpr &);
  TypeWithStarsLexpr(TypeSpecOFTYPENAME *p1, ListStars *p2);
  ~TypeWithStarsLexpr();
  virtual void accept(Visitor *v);
  virtual TypeWithStarsLexpr *clone() const;
  void swap(TypeWithStarsLexpr &);
};

class EmptyLexpr : public Lexpr
{
public:

  EmptyLexpr(const EmptyLexpr &);
  EmptyLexpr &operator=(const EmptyLexpr &);
  EmptyLexpr();
  ~EmptyLexpr();
  virtual void accept(Visitor *v);
  virtual EmptyLexpr *clone() const;
  void swap(EmptyLexpr &);
};

class UnionLexpr : public Lexpr
{
public:
  LexprList *lexprlist_;

  UnionLexpr(const UnionLexpr &);
  UnionLexpr &operator=(const UnionLexpr &);
  UnionLexpr(LexprList *p1);
  ~UnionLexpr();
  virtual void accept(Visitor *v);
  virtual UnionLexpr *clone() const;
  void swap(UnionLexpr &);
};

class InterLexpr : public Lexpr
{
public:
  LexprList *lexprlist_;

  InterLexpr(const InterLexpr &);
  InterLexpr &operator=(const InterLexpr &);
  InterLexpr(LexprList *p1);
  ~InterLexpr();
  virtual void accept(Visitor *v);
  virtual InterLexpr *clone() const;
  void swap(InterLexpr &);
};

class BraceLexprList : public Lexpr
{
public:
  LexprList *lexprlist_;

  BraceLexprList(const BraceLexprList &);
  BraceLexprList &operator=(const BraceLexprList &);
  BraceLexprList(LexprList *p1);
  ~BraceLexprList();
  virtual void accept(Visitor *v);
  virtual BraceLexprList *clone() const;
  void swap(BraceLexprList &);
};

class BraceBinderLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;
  Binders *binders_;

  BraceBinderLexpr(const BraceBinderLexpr &);
  BraceBinderLexpr &operator=(const BraceBinderLexpr &);
  BraceBinderLexpr(Lexpr *p1, Binders *p2);
  ~BraceBinderLexpr();
  virtual void accept(Visitor *v);
  virtual BraceBinderLexpr *clone() const;
  void swap(BraceBinderLexpr &);
};

class BraceBinderLexprLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Binders *binders_;
  Lexpr *lexpr_2;

  BraceBinderLexprLexpr(const BraceBinderLexprLexpr &);
  BraceBinderLexprLexpr &operator=(const BraceBinderLexprLexpr &);
  BraceBinderLexprLexpr(Lexpr *p1, Binders *p2, Lexpr *p3);
  ~BraceBinderLexprLexpr();
  virtual void accept(Visitor *v);
  virtual BraceBinderLexprLexpr *clone() const;
  void swap(BraceBinderLexprLexpr &);
};

class FieldInitLexpr : public Lexpr
{
public:
  ListFieldInitElt *listfieldinitelt_;

  FieldInitLexpr(const FieldInitLexpr &);
  FieldInitLexpr &operator=(const FieldInitLexpr &);
  FieldInitLexpr(ListFieldInitElt *p1);
  ~FieldInitLexpr();
  virtual void accept(Visitor *v);
  virtual FieldInitLexpr *clone() const;
  void swap(FieldInitLexpr &);
};

class ArrayInitLexpr : public Lexpr
{
public:
  ListArrayInitElt *listarrayinitelt_;

  ArrayInitLexpr(const ArrayInitLexpr &);
  ArrayInitLexpr &operator=(const ArrayInitLexpr &);
  ArrayInitLexpr(ListArrayInitElt *p1);
  ~ArrayInitLexpr();
  virtual void accept(Visitor *v);
  virtual ArrayInitLexpr *clone() const;
  void swap(ArrayInitLexpr &);
};

class UpdateBraceLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;
  ListUpdateElt *listupdateelt_;

  UpdateBraceLexpr(const UpdateBraceLexpr &);
  UpdateBraceLexpr &operator=(const UpdateBraceLexpr &);
  UpdateBraceLexpr(Lexpr *p1, ListUpdateElt *p2);
  ~UpdateBraceLexpr();
  virtual void accept(Visitor *v);
  virtual UpdateBraceLexpr *clone() const;
  void swap(UpdateBraceLexpr &);
};

class LetBinderLexpr : public LexprBinder
{
public:
  BoundedVar *boundedvar_;
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  LetBinderLexpr(const LetBinderLexpr &);
  LetBinderLexpr &operator=(const LetBinderLexpr &);
  LetBinderLexpr(BoundedVar *p1, Lexpr *p2, Lexpr *p3);
  ~LetBinderLexpr();
  virtual void accept(Visitor *v);
  virtual LetBinderLexpr *clone() const;
  void swap(LetBinderLexpr &);
};

class ForallBinderLexpr : public LexprBinder
{
public:
  Binders *binders_;
  Lexpr *lexpr_;

  ForallBinderLexpr(const ForallBinderLexpr &);
  ForallBinderLexpr &operator=(const ForallBinderLexpr &);
  ForallBinderLexpr(Binders *p1, Lexpr *p2);
  ~ForallBinderLexpr();
  virtual void accept(Visitor *v);
  virtual ForallBinderLexpr *clone() const;
  void swap(ForallBinderLexpr &);
};

class ExistBinderLexpr : public LexprBinder
{
public:
  Binders *binders_;
  Lexpr *lexpr_;

  ExistBinderLexpr(const ExistBinderLexpr &);
  ExistBinderLexpr &operator=(const ExistBinderLexpr &);
  ExistBinderLexpr(Binders *p1, Lexpr *p2);
  ~ExistBinderLexpr();
  virtual void accept(Visitor *v);
  virtual ExistBinderLexpr *clone() const;
  void swap(ExistBinderLexpr &);
};

class LambdaBinderLexpr : public LexprBinder
{
public:
  Binders *binders_;
  Lexpr *lexpr_;

  LambdaBinderLexpr(const LambdaBinderLexpr &);
  LambdaBinderLexpr &operator=(const LambdaBinderLexpr &);
  LambdaBinderLexpr(Binders *p1, Lexpr *p2);
  ~LambdaBinderLexpr();
  virtual void accept(Visitor *v);
  virtual LambdaBinderLexpr *clone() const;
  void swap(LambdaBinderLexpr &);
};

class RelInnerLexpr : public LexprRelInner
{
public:
  Relation *relation_;
  Lexpr *lexpr_;

  RelInnerLexpr(const RelInnerLexpr &);
  RelInnerLexpr &operator=(const RelInnerLexpr &);
  RelInnerLexpr(Relation *p1, Lexpr *p2);
  ~RelInnerLexpr();
  virtual void accept(Visitor *v);
  virtual RelInnerLexpr *clone() const;
  void swap(RelInnerLexpr &);
};

class LessRel : public Relation
{
public:

  LessRel(const LessRel &);
  LessRel &operator=(const LessRel &);
  LessRel();
  ~LessRel();
  virtual void accept(Visitor *v);
  virtual LessRel *clone() const;
  void swap(LessRel &);
};

class GreaterRel : public Relation
{
public:

  GreaterRel(const GreaterRel &);
  GreaterRel &operator=(const GreaterRel &);
  GreaterRel();
  ~GreaterRel();
  virtual void accept(Visitor *v);
  virtual GreaterRel *clone() const;
  void swap(GreaterRel &);
};

class LessEqRel : public Relation
{
public:

  LessEqRel(const LessEqRel &);
  LessEqRel &operator=(const LessEqRel &);
  LessEqRel();
  ~LessEqRel();
  virtual void accept(Visitor *v);
  virtual LessEqRel *clone() const;
  void swap(LessEqRel &);
};

class GreaterEqRel : public Relation
{
public:

  GreaterEqRel(const GreaterEqRel &);
  GreaterEqRel &operator=(const GreaterEqRel &);
  GreaterEqRel();
  ~GreaterEqRel();
  virtual void accept(Visitor *v);
  virtual GreaterEqRel *clone() const;
  void swap(GreaterEqRel &);
};

class EqRel : public Relation
{
public:

  EqRel(const EqRel &);
  EqRel &operator=(const EqRel &);
  EqRel();
  ~EqRel();
  virtual void accept(Visitor *v);
  virtual EqRel *clone() const;
  void swap(EqRel &);
};

class NotEqRel : public Relation
{
public:

  NotEqRel(const NotEqRel &);
  NotEqRel &operator=(const NotEqRel &);
  NotEqRel();
  ~NotEqRel();
  virtual void accept(Visitor *v);
  virtual NotEqRel *clone() const;
  void swap(NotEqRel &);
};

class EQUALRel : public Relation
{
public:

  EQUALRel(const EQUALRel &);
  EQUALRel &operator=(const EQUALRel &);
  EQUALRel();
  ~EQUALRel();
  virtual void accept(Visitor *v);
  virtual EQUALRel *clone() const;
  void swap(EQUALRel &);
};

class LexprRange : public Range
{
public:
  LexprOption *lexproption_1;
  LexprOption *lexproption_2;

  LexprRange(const LexprRange &);
  LexprRange &operator=(const LexprRange &);
  LexprRange(LexprOption *p1, LexprOption *p2);
  ~LexprRange();
  virtual void accept(Visitor *v);
  virtual LexprRange *clone() const;
  void swap(LexprRange &);
};

class AFieldInitElt : public FieldInitElt
{
public:
  IdentifierOrTypenameFull *identifierortypenamefull_;
  Lexpr *lexpr_;

  AFieldInitElt(const AFieldInitElt &);
  AFieldInitElt &operator=(const AFieldInitElt &);
  AFieldInitElt(IdentifierOrTypenameFull *p1, Lexpr *p2);
  ~AFieldInitElt();
  virtual void accept(Visitor *v);
  virtual AFieldInitElt *clone() const;
  void swap(AFieldInitElt &);
};

class AnArrayInitElt : public ArrayInitElt
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AnArrayInitElt(const AnArrayInitElt &);
  AnArrayInitElt &operator=(const AnArrayInitElt &);
  AnArrayInitElt(Lexpr *p1, Lexpr *p2);
  ~AnArrayInitElt();
  virtual void accept(Visitor *v);
  virtual AnArrayInitElt *clone() const;
  void swap(AnArrayInitElt &);
};

class ArrayInitRangeElt : public ArrayInitElt
{
public:
  Range *range_;
  Lexpr *lexpr_;

  ArrayInitRangeElt(const ArrayInitRangeElt &);
  ArrayInitRangeElt &operator=(const ArrayInitRangeElt &);
  ArrayInitRangeElt(Range *p1, Lexpr *p2);
  ~ArrayInitRangeElt();
  virtual void accept(Visitor *v);
  virtual ArrayInitRangeElt *clone() const;
  void swap(ArrayInitRangeElt &);
};

class AnUpdateElt : public UpdateElt
{
public:
  ListPathElt *listpathelt_;
  Lexpr *lexpr_;

  AnUpdateElt(const AnUpdateElt &);
  AnUpdateElt &operator=(const AnUpdateElt &);
  AnUpdateElt(ListPathElt *p1, Lexpr *p2);
  ~AnUpdateElt();
  virtual void accept(Visitor *v);
  virtual AnUpdateElt *clone() const;
  void swap(AnUpdateElt &);
};

class UpdateEltWith : public UpdateElt
{
public:
  ListPathElt *listpathelt_;
  ListUpdateElt *listupdateelt_;

  UpdateEltWith(const UpdateEltWith &);
  UpdateEltWith &operator=(const UpdateEltWith &);
  UpdateEltWith(ListPathElt *p1, ListUpdateElt *p2);
  ~UpdateEltWith();
  virtual void accept(Visitor *v);
  virtual UpdateEltWith *clone() const;
  void swap(UpdateEltWith &);
};

class FieldElt : public PathElt
{
public:
  IdentifierOrTypenameFull *identifierortypenamefull_;

  FieldElt(const FieldElt &);
  FieldElt &operator=(const FieldElt &);
  FieldElt(IdentifierOrTypenameFull *p1);
  ~FieldElt();
  virtual void accept(Visitor *v);
  virtual FieldElt *clone() const;
  void swap(FieldElt &);
};

class ArrayElt : public PathElt
{
public:
  Lexpr *lexpr_;

  ArrayElt(const ArrayElt &);
  ArrayElt &operator=(const ArrayElt &);
  ArrayElt(Lexpr *p1);
  ~ArrayElt();
  virtual void accept(Visitor *v);
  virtual ArrayElt *clone() const;
  void swap(ArrayElt &);
};

class ArrayRangeElt : public PathElt
{
public:
  Range *range_;

  ArrayRangeElt(const ArrayRangeElt &);
  ArrayRangeElt &operator=(const ArrayRangeElt &);
  ArrayRangeElt(Range *p1);
  ~ArrayRangeElt();
  virtual void accept(Visitor *v);
  virtual ArrayRangeElt *clone() const;
  void swap(ArrayRangeElt &);
};

class TheBinders : public Binders
{
public:
  TypeSpecOFTYPENAME *typespecoftypename_;
  VarSpec *varspec_;
  ListBindersReentrance *listbindersreentrance_;

  TheBinders(const TheBinders &);
  TheBinders &operator=(const TheBinders &);
  TheBinders(TypeSpecOFTYPENAME *p1, VarSpec *p2, ListBindersReentrance *p3);
  ~TheBinders();
  virtual void accept(Visitor *v);
  virtual TheBinders *clone() const;
  void swap(TheBinders &);
};

class BindersReentranceDeclSpec : public BindersReentrance
{
public:
  TypeSpecOFTYPENAME *typespecoftypename_;
  VarSpec *varspec_;

  BindersReentranceDeclSpec(const BindersReentranceDeclSpec &);
  BindersReentranceDeclSpec &operator=(const BindersReentranceDeclSpec &);
  BindersReentranceDeclSpec(TypeSpecOFTYPENAME *p1, VarSpec *p2);
  ~BindersReentranceDeclSpec();
  virtual void accept(Visitor *v);
  virtual BindersReentranceDeclSpec *clone() const;
  void swap(BindersReentranceDeclSpec &);
};

class BindersReentranceVarSpec : public BindersReentrance
{
public:
  VarSpec *varspec_;

  BindersReentranceVarSpec(const BindersReentranceVarSpec &);
  BindersReentranceVarSpec &operator=(const BindersReentranceVarSpec &);
  BindersReentranceVarSpec(VarSpec *p1);
  ~BindersReentranceVarSpec();
  virtual void accept(Visitor *v);
  virtual BindersReentranceVarSpec *clone() const;
  void swap(BindersReentranceVarSpec &);
};

class StartVarSpec : public VarSpec
{
public:
  ListStars *liststars_;
  VarSpec *varspec_;

  StartVarSpec(const StartVarSpec &);
  StartVarSpec &operator=(const StartVarSpec &);
  StartVarSpec(ListStars *p1, VarSpec *p2);
  ~StartVarSpec();
  virtual void accept(Visitor *v);
  virtual StartVarSpec *clone() const;
  void swap(StartVarSpec &);
};

class SimpleSpec : public VarSpec
{
public:
  FullIdentifier *fullidentifier_;

  SimpleSpec(const SimpleSpec &);
  SimpleSpec &operator=(const SimpleSpec &);
  SimpleSpec(FullIdentifier *p1);
  ~SimpleSpec();
  virtual void accept(Visitor *v);
  virtual SimpleSpec *clone() const;
  void swap(SimpleSpec &);
};

class ArraySpec : public VarSpec
{
public:
  VarSpec *varspec_;
  ArraySize *arraysize_;

  ArraySpec(const ArraySpec &);
  ArraySpec &operator=(const ArraySpec &);
  ArraySpec(VarSpec *p1, ArraySize *p2);
  ~ArraySpec();
  virtual void accept(Visitor *v);
  virtual ArraySpec *clone() const;
  void swap(ArraySpec &);
};

class FunctionSpec : public VarSpec
{
public:
  VarSpec *varspec_;
  AbsParamTypeList *absparamtypelist_;

  FunctionSpec(const FunctionSpec &);
  FunctionSpec &operator=(const FunctionSpec &);
  FunctionSpec(VarSpec *p1, AbsParamTypeList *p2);
  ~FunctionSpec();
  virtual void accept(Visitor *v);
  virtual FunctionSpec *clone() const;
  void swap(FunctionSpec &);
};

class IntConstArraySize : public ArraySize
{
public:
  Integer integer_;

  IntConstArraySize(const IntConstArraySize &);
  IntConstArraySize &operator=(const IntConstArraySize &);
  IntConstArraySize(Integer p1);
  ~IntConstArraySize();
  virtual void accept(Visitor *v);
  virtual IntConstArraySize *clone() const;
  void swap(IntConstArraySize &);
};

class SomeArraySize : public ArraySize
{
public:
  FullIdentifier *fullidentifier_;

  SomeArraySize(const SomeArraySize &);
  SomeArraySize &operator=(const SomeArraySize &);
  SomeArraySize(FullIdentifier *p1);
  ~SomeArraySize();
  virtual void accept(Visitor *v);
  virtual SomeArraySize *clone() const;
  void swap(SomeArraySize &);
};

class NoSize : public ArraySize
{
public:

  NoSize(const NoSize &);
  NoSize &operator=(const NoSize &);
  NoSize();
  ~NoSize();
  virtual void accept(Visitor *v);
  virtual NoSize *clone() const;
  void swap(NoSize &);
};

class EmptyTypeParam : public AbsParamTypeList
{
public:

  EmptyTypeParam(const EmptyTypeParam &);
  EmptyTypeParam &operator=(const EmptyTypeParam &);
  EmptyTypeParam();
  ~EmptyTypeParam();
  virtual void accept(Visitor *v);
  virtual EmptyTypeParam *clone() const;
  void swap(EmptyTypeParam &);
};

class SomeTypeParam : public AbsParamTypeList
{
public:
  ListAbsParam *listabsparam_;

  SomeTypeParam(const SomeTypeParam &);
  SomeTypeParam &operator=(const SomeTypeParam &);
  SomeTypeParam(ListAbsParam *p1);
  ~SomeTypeParam();
  virtual void accept(Visitor *v);
  virtual SomeTypeParam *clone() const;
  void swap(SomeTypeParam &);
};

class InfTypeParam : public AbsParamTypeList
{
public:
  ListAbsParam *listabsparam_;

  InfTypeParam(const InfTypeParam &);
  InfTypeParam &operator=(const InfTypeParam &);
  InfTypeParam(ListAbsParam *p1);
  ~InfTypeParam();
  virtual void accept(Visitor *v);
  virtual InfTypeParam *clone() const;
  void swap(InfTypeParam &);
};

class AbsParamsElement : public AbsParam
{
public:
  LogicTypeGenOFTYPENAME *logictypegenoftypename_;

  AbsParamsElement(const AbsParamsElement &);
  AbsParamsElement &operator=(const AbsParamsElement &);
  AbsParamsElement(LogicTypeGenOFTYPENAME *p1);
  ~AbsParamsElement();
  virtual void accept(Visitor *v);
  virtual AbsParamsElement *clone() const;
  void swap(AbsParamsElement &);
};

class Prartemer : public Parameter
{
public:
  TypeSpecOFIdentifierOrTypename *typespecofidentifierortypename_;
  VarSpec *varspec_;

  Prartemer(const Prartemer &);
  Prartemer &operator=(const Prartemer &);
  Prartemer(TypeSpecOFIdentifierOrTypename *p1, VarSpec *p2);
  ~Prartemer();
  virtual void accept(Visitor *v);
  virtual Prartemer *clone() const;
  void swap(Prartemer &);
};

class LogicTypeGenTypemane : public LogicTypeGenOFTYPENAME
{
public:
  TypeSpecOFTYPENAME *typespecoftypename_;
  AbsSpecOption *absspecoption_;

  LogicTypeGenTypemane(const LogicTypeGenTypemane &);
  LogicTypeGenTypemane &operator=(const LogicTypeGenTypemane &);
  LogicTypeGenTypemane(TypeSpecOFTYPENAME *p1, AbsSpecOption *p2);
  ~LogicTypeGenTypemane();
  virtual void accept(Visitor *v);
  virtual LogicTypeGenTypemane *clone() const;
  void swap(LogicTypeGenTypemane &);
};

class LogicTypeGenIdOrTypename : public LogicTypeGenOFIdentifierOrTypename
{
public:
  TypeSpecOFIdentifierOrTypename *typespecofidentifierortypename_;
  AbsSpecOption *absspecoption_;

  LogicTypeGenIdOrTypename(const LogicTypeGenIdOrTypename &);
  LogicTypeGenIdOrTypename &operator=(const LogicTypeGenIdOrTypename &);
  LogicTypeGenIdOrTypename(TypeSpecOFIdentifierOrTypename *p1, AbsSpecOption *p2);
  ~LogicTypeGenIdOrTypename();
  virtual void accept(Visitor *v);
  virtual LogicTypeGenIdOrTypename *clone() const;
  void swap(LogicTypeGenIdOrTypename &);
};

class ConstCV : public CV
{
public:

  ConstCV(const ConstCV &);
  ConstCV &operator=(const ConstCV &);
  ConstCV();
  ~ConstCV();
  virtual void accept(Visitor *v);
  virtual ConstCV *clone() const;
  void swap(ConstCV &);
};

class VolatileCV : public CV
{
public:

  VolatileCV(const VolatileCV &);
  VolatileCV &operator=(const VolatileCV &);
  VolatileCV();
  ~VolatileCV();
  virtual void accept(Visitor *v);
  virtual VolatileCV *clone() const;
  void swap(VolatileCV &);
};

class GhostCV : public CV
{
public:

  GhostCV(const GhostCV &);
  GhostCV &operator=(const GhostCV &);
  GhostCV();
  ~GhostCV();
  virtual void accept(Visitor *v);
  virtual GhostCV *clone() const;
  void swap(GhostCV &);
};

class TypeSpecCVTypename : public TypeSpecCVOFTYPENAME
{
public:
  ListCV *listcv_1;
  TypeSpecOFTYPENAME *typespecoftypename_;
  ListCV *listcv_2;

  TypeSpecCVTypename(const TypeSpecCVTypename &);
  TypeSpecCVTypename &operator=(const TypeSpecCVTypename &);
  TypeSpecCVTypename(ListCV *p1, TypeSpecOFTYPENAME *p2, ListCV *p3);
  ~TypeSpecCVTypename();
  virtual void accept(Visitor *v);
  virtual TypeSpecCVTypename *clone() const;
  void swap(TypeSpecCVTypename &);
};

class AnCastLogicType : public CastLogicType
{
public:
  TypeSpecCVOFTYPENAME *typespeccvoftypename_;
  AbsSpecCVOption *absspeccvoption_;

  AnCastLogicType(const AnCastLogicType &);
  AnCastLogicType &operator=(const AnCastLogicType &);
  AnCastLogicType(TypeSpecCVOFTYPENAME *p1, AbsSpecCVOption *p2);
  ~AnCastLogicType();
  virtual void accept(Visitor *v);
  virtual AnCastLogicType *clone() const;
  void swap(AnCastLogicType &);
};

class LogicRTType : public LogicRtType
{
public:
  LogicTypeGenOFIdentifierOrTypename *logictypegenofidentifierortypename_;

  LogicRTType(const LogicRTType &);
  LogicRTType &operator=(const LogicRTType &);
  LogicRTType(LogicTypeGenOFIdentifierOrTypename *p1);
  ~LogicRTType();
  virtual void accept(Visitor *v);
  virtual LogicRTType *clone() const;
  void swap(LogicRTType &);
};

class NoAbsSpec : public AbsSpecOption
{
public:

  NoAbsSpec(const NoAbsSpec &);
  NoAbsSpec &operator=(const NoAbsSpec &);
  NoAbsSpec();
  ~NoAbsSpec();
  virtual void accept(Visitor *v);
  virtual NoAbsSpec *clone() const;
  void swap(NoAbsSpec &);
};

class SomeAbsSpec : public AbsSpecOption
{
public:
  AbsSpec *absspec_;

  SomeAbsSpec(const SomeAbsSpec &);
  SomeAbsSpec &operator=(const SomeAbsSpec &);
  SomeAbsSpec(AbsSpec *p1);
  ~SomeAbsSpec();
  virtual void accept(Visitor *v);
  virtual SomeAbsSpec *clone() const;
  void swap(SomeAbsSpec &);
};

class NoAbsSpecCV : public AbsSpecCVOption
{
public:

  NoAbsSpecCV(const NoAbsSpecCV &);
  NoAbsSpecCV &operator=(const NoAbsSpecCV &);
  NoAbsSpecCV();
  ~NoAbsSpecCV();
  virtual void accept(Visitor *v);
  virtual NoAbsSpecCV *clone() const;
  void swap(NoAbsSpecCV &);
};

class SomeAbsSpecCV : public AbsSpecCVOption
{
public:
  AbsSpecCV *absspeccv_;

  SomeAbsSpecCV(const SomeAbsSpecCV &);
  SomeAbsSpecCV &operator=(const SomeAbsSpecCV &);
  SomeAbsSpecCV(AbsSpecCV *p1);
  ~SomeAbsSpecCV();
  virtual void accept(Visitor *v);
  virtual SomeAbsSpecCV *clone() const;
  void swap(SomeAbsSpecCV &);
};

class AbsSpecTabs : public AbsSpec
{
public:
  ListTabs *listtabs_;

  AbsSpecTabs(const AbsSpecTabs &);
  AbsSpecTabs &operator=(const AbsSpecTabs &);
  AbsSpecTabs(ListTabs *p1);
  ~AbsSpecTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecTabs *clone() const;
  void swap(AbsSpecTabs &);
};

class AbsSpecStars : public AbsSpec
{
public:
  ListStars *liststars_;

  AbsSpecStars(const AbsSpecStars &);
  AbsSpecStars &operator=(const AbsSpecStars &);
  AbsSpecStars(ListStars *p1);
  ~AbsSpecStars();
  virtual void accept(Visitor *v);
  virtual AbsSpecStars *clone() const;
  void swap(AbsSpecStars &);
};

class AbsSpecStarsTabs : public AbsSpec
{
public:
  ListStars *liststars_;
  ListTabs *listtabs_;

  AbsSpecStarsTabs(const AbsSpecStarsTabs &);
  AbsSpecStarsTabs &operator=(const AbsSpecStarsTabs &);
  AbsSpecStarsTabs(ListStars *p1, ListTabs *p2);
  ~AbsSpecStarsTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecStarsTabs *clone() const;
  void swap(AbsSpecStarsTabs &);
};

class AbsSpecBitsStars : public AbsSpec
{
public:
  ListStars *liststars_;
  AbsSpec *absspec_;

  AbsSpecBitsStars(const AbsSpecBitsStars &);
  AbsSpecBitsStars &operator=(const AbsSpecBitsStars &);
  AbsSpecBitsStars(ListStars *p1, AbsSpec *p2);
  ~AbsSpecBitsStars();
  virtual void accept(Visitor *v);
  virtual AbsSpecBitsStars *clone() const;
  void swap(AbsSpecBitsStars &);
};

class AbsSpecBitsStarsTabs : public AbsSpec
{
public:
  ListStars *liststars_;
  AbsSpec *absspec_;
  ListTabs *listtabs_;

  AbsSpecBitsStarsTabs(const AbsSpecBitsStarsTabs &);
  AbsSpecBitsStarsTabs &operator=(const AbsSpecBitsStarsTabs &);
  AbsSpecBitsStarsTabs(ListStars *p1, AbsSpec *p2, ListTabs *p3);
  ~AbsSpecBitsStarsTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecBitsStarsTabs *clone() const;
  void swap(AbsSpecBitsStarsTabs &);
};

class AbsSpecBitsTabs : public AbsSpec
{
public:
  AbsSpec *absspec_;
  ListTabs *listtabs_;

  AbsSpecBitsTabs(const AbsSpecBitsTabs &);
  AbsSpecBitsTabs &operator=(const AbsSpecBitsTabs &);
  AbsSpecBitsTabs(AbsSpec *p1, ListTabs *p2);
  ~AbsSpecBitsTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecBitsTabs *clone() const;
  void swap(AbsSpecBitsTabs &);
};

class AbsSpecBits : public AbsSpec
{
public:
  AbsSpec *absspec_;

  AbsSpecBits(const AbsSpecBits &);
  AbsSpecBits &operator=(const AbsSpecBits &);
  AbsSpecBits(AbsSpec *p1);
  ~AbsSpecBits();
  virtual void accept(Visitor *v);
  virtual AbsSpecBits *clone() const;
  void swap(AbsSpecBits &);
};

class AbsSpecBitsParams : public AbsSpec
{
public:
  AbsSpec *absspec_;
  AbsParamTypeList *absparamtypelist_;

  AbsSpecBitsParams(const AbsSpecBitsParams &);
  AbsSpecBitsParams &operator=(const AbsSpecBitsParams &);
  AbsSpecBitsParams(AbsSpec *p1, AbsParamTypeList *p2);
  ~AbsSpecBitsParams();
  virtual void accept(Visitor *v);
  virtual AbsSpecBitsParams *clone() const;
  void swap(AbsSpecBitsParams &);
};

class AbsSpecCVTabs : public AbsSpecCV
{
public:
  ListTabs *listtabs_;

  AbsSpecCVTabs(const AbsSpecCVTabs &);
  AbsSpecCVTabs &operator=(const AbsSpecCVTabs &);
  AbsSpecCVTabs(ListTabs *p1);
  ~AbsSpecCVTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVTabs *clone() const;
  void swap(AbsSpecCVTabs &);
};

class AbsSpecCVStars : public AbsSpecCV
{
public:
  ListStarsCV *liststarscv_;

  AbsSpecCVStars(const AbsSpecCVStars &);
  AbsSpecCVStars &operator=(const AbsSpecCVStars &);
  AbsSpecCVStars(ListStarsCV *p1);
  ~AbsSpecCVStars();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVStars *clone() const;
  void swap(AbsSpecCVStars &);
};

class AbsSpecCVStarsTabs : public AbsSpecCV
{
public:
  ListStarsCV *liststarscv_;
  ListTabs *listtabs_;

  AbsSpecCVStarsTabs(const AbsSpecCVStarsTabs &);
  AbsSpecCVStarsTabs &operator=(const AbsSpecCVStarsTabs &);
  AbsSpecCVStarsTabs(ListStarsCV *p1, ListTabs *p2);
  ~AbsSpecCVStarsTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVStarsTabs *clone() const;
  void swap(AbsSpecCVStarsTabs &);
};

class AbsSpecCVBitsStars : public AbsSpecCV
{
public:
  ListStarsCV *liststarscv_;
  AbsSpecCV *absspeccv_;

  AbsSpecCVBitsStars(const AbsSpecCVBitsStars &);
  AbsSpecCVBitsStars &operator=(const AbsSpecCVBitsStars &);
  AbsSpecCVBitsStars(ListStarsCV *p1, AbsSpecCV *p2);
  ~AbsSpecCVBitsStars();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVBitsStars *clone() const;
  void swap(AbsSpecCVBitsStars &);
};

class AbsSpecCVBitsStarsTabs : public AbsSpecCV
{
public:
  ListStarsCV *liststarscv_;
  AbsSpecCV *absspeccv_;
  ListTabs *listtabs_;

  AbsSpecCVBitsStarsTabs(const AbsSpecCVBitsStarsTabs &);
  AbsSpecCVBitsStarsTabs &operator=(const AbsSpecCVBitsStarsTabs &);
  AbsSpecCVBitsStarsTabs(ListStarsCV *p1, AbsSpecCV *p2, ListTabs *p3);
  ~AbsSpecCVBitsStarsTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVBitsStarsTabs *clone() const;
  void swap(AbsSpecCVBitsStarsTabs &);
};

class AbsSpecCVBitsTabs : public AbsSpecCV
{
public:
  AbsSpecCV *absspeccv_;
  ListTabs *listtabs_;

  AbsSpecCVBitsTabs(const AbsSpecCVBitsTabs &);
  AbsSpecCVBitsTabs &operator=(const AbsSpecCVBitsTabs &);
  AbsSpecCVBitsTabs(AbsSpecCV *p1, ListTabs *p2);
  ~AbsSpecCVBitsTabs();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVBitsTabs *clone() const;
  void swap(AbsSpecCVBitsTabs &);
};

class AbsSpecCVBits : public AbsSpecCV
{
public:
  AbsSpecCV *absspeccv_;

  AbsSpecCVBits(const AbsSpecCVBits &);
  AbsSpecCVBits &operator=(const AbsSpecCVBits &);
  AbsSpecCVBits(AbsSpecCV *p1);
  ~AbsSpecCVBits();
  virtual void accept(Visitor *v);
  virtual AbsSpecCVBits *clone() const;
  void swap(AbsSpecCVBits &);
};

class AbsSpecBitsCVParams : public AbsSpecCV
{
public:
  AbsSpecCV *absspeccv_;
  AbsParamTypeList *absparamtypelist_;

  AbsSpecBitsCVParams(const AbsSpecBitsCVParams &);
  AbsSpecBitsCVParams &operator=(const AbsSpecBitsCVParams &);
  AbsSpecBitsCVParams(AbsSpecCV *p1, AbsParamTypeList *p2);
  ~AbsSpecBitsCVParams();
  virtual void accept(Visitor *v);
  virtual AbsSpecBitsCVParams *clone() const;
  void swap(AbsSpecBitsCVParams &);
};

class Star : public Stars
{
public:

  Star(const Star &);
  Star &operator=(const Star &);
  Star();
  ~Star();
  virtual void accept(Visitor *v);
  virtual Star *clone() const;
  void swap(Star &);
};

class StarCV : public StarsCV
{
public:

  StarCV(const StarCV &);
  StarCV &operator=(const StarCV &);
  StarCV();
  ~StarCV();
  virtual void accept(Visitor *v);
  virtual StarCV *clone() const;
  void swap(StarCV &);
};

class StarCVWithCV : public StarsCV
{
public:
  CV *cv_;

  StarCVWithCV(const StarCVWithCV &);
  StarCVWithCV &operator=(const StarCVWithCV &);
  StarCVWithCV(CV *p1);
  ~StarCVWithCV();
  virtual void accept(Visitor *v);
  virtual StarCVWithCV *clone() const;
  void swap(StarCVWithCV &);
};

class Tab : public Tabs
{
public:
  ArraySize *arraysize_;

  Tab(const Tab &);
  Tab &operator=(const Tab &);
  Tab(ArraySize *p1);
  ~Tab();
  virtual void accept(Visitor *v);
  virtual Tab *clone() const;
  void swap(Tab &);
};

class TypeSpecIntegerKeyWord : public TypeSpecSimple
{
public:

  TypeSpecIntegerKeyWord(const TypeSpecIntegerKeyWord &);
  TypeSpecIntegerKeyWord &operator=(const TypeSpecIntegerKeyWord &);
  TypeSpecIntegerKeyWord();
  ~TypeSpecIntegerKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecIntegerKeyWord *clone() const;
  void swap(TypeSpecIntegerKeyWord &);
};

class TypeSpecRealKeyWord : public TypeSpecSimple
{
public:

  TypeSpecRealKeyWord(const TypeSpecRealKeyWord &);
  TypeSpecRealKeyWord &operator=(const TypeSpecRealKeyWord &);
  TypeSpecRealKeyWord();
  ~TypeSpecRealKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecRealKeyWord *clone() const;
  void swap(TypeSpecRealKeyWord &);
};

class TypeSpecBooleanKeyWord : public TypeSpecSimple
{
public:

  TypeSpecBooleanKeyWord(const TypeSpecBooleanKeyWord &);
  TypeSpecBooleanKeyWord &operator=(const TypeSpecBooleanKeyWord &);
  TypeSpecBooleanKeyWord();
  ~TypeSpecBooleanKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecBooleanKeyWord *clone() const;
  void swap(TypeSpecBooleanKeyWord &);
};

class TypeSpecVoidKeyWord : public TypeSpecSimple
{
public:

  TypeSpecVoidKeyWord(const TypeSpecVoidKeyWord &);
  TypeSpecVoidKeyWord &operator=(const TypeSpecVoidKeyWord &);
  TypeSpecVoidKeyWord();
  ~TypeSpecVoidKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecVoidKeyWord *clone() const;
  void swap(TypeSpecVoidKeyWord &);
};

class TypeSpecBoolKeyWord : public TypeSpecSimple
{
public:

  TypeSpecBoolKeyWord(const TypeSpecBoolKeyWord &);
  TypeSpecBoolKeyWord &operator=(const TypeSpecBoolKeyWord &);
  TypeSpecBoolKeyWord();
  ~TypeSpecBoolKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecBoolKeyWord *clone() const;
  void swap(TypeSpecBoolKeyWord &);
};

class TypeSpecCharKeyWord : public TypeSpecSimple
{
public:

  TypeSpecCharKeyWord(const TypeSpecCharKeyWord &);
  TypeSpecCharKeyWord &operator=(const TypeSpecCharKeyWord &);
  TypeSpecCharKeyWord();
  ~TypeSpecCharKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecCharKeyWord *clone() const;
  void swap(TypeSpecCharKeyWord &);
};

class TypeSpecSignedCharKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedCharKeyWord(const TypeSpecSignedCharKeyWord &);
  TypeSpecSignedCharKeyWord &operator=(const TypeSpecSignedCharKeyWord &);
  TypeSpecSignedCharKeyWord();
  ~TypeSpecSignedCharKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedCharKeyWord *clone() const;
  void swap(TypeSpecSignedCharKeyWord &);
};

class TypeSpecUnsignedCharKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedCharKeyWord(const TypeSpecUnsignedCharKeyWord &);
  TypeSpecUnsignedCharKeyWord &operator=(const TypeSpecUnsignedCharKeyWord &);
  TypeSpecUnsignedCharKeyWord();
  ~TypeSpecUnsignedCharKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedCharKeyWord *clone() const;
  void swap(TypeSpecUnsignedCharKeyWord &);
};

class TypeSpecIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecIntKeyWord(const TypeSpecIntKeyWord &);
  TypeSpecIntKeyWord &operator=(const TypeSpecIntKeyWord &);
  TypeSpecIntKeyWord();
  ~TypeSpecIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecIntKeyWord *clone() const;
  void swap(TypeSpecIntKeyWord &);
};

class TypeSpecSignedIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedIntKeyWord(const TypeSpecSignedIntKeyWord &);
  TypeSpecSignedIntKeyWord &operator=(const TypeSpecSignedIntKeyWord &);
  TypeSpecSignedIntKeyWord();
  ~TypeSpecSignedIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedIntKeyWord *clone() const;
  void swap(TypeSpecSignedIntKeyWord &);
};

class TypeSpecUnsignedIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedIntKeyWord(const TypeSpecUnsignedIntKeyWord &);
  TypeSpecUnsignedIntKeyWord &operator=(const TypeSpecUnsignedIntKeyWord &);
  TypeSpecUnsignedIntKeyWord();
  ~TypeSpecUnsignedIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedIntKeyWord *clone() const;
  void swap(TypeSpecUnsignedIntKeyWord &);
};

class TypeSpecUnsignedKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedKeyWord(const TypeSpecUnsignedKeyWord &);
  TypeSpecUnsignedKeyWord &operator=(const TypeSpecUnsignedKeyWord &);
  TypeSpecUnsignedKeyWord();
  ~TypeSpecUnsignedKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedKeyWord *clone() const;
  void swap(TypeSpecUnsignedKeyWord &);
};

class TypeSpecShortKeyWord : public TypeSpecSimple
{
public:

  TypeSpecShortKeyWord(const TypeSpecShortKeyWord &);
  TypeSpecShortKeyWord &operator=(const TypeSpecShortKeyWord &);
  TypeSpecShortKeyWord();
  ~TypeSpecShortKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecShortKeyWord *clone() const;
  void swap(TypeSpecShortKeyWord &);
};

class TypeSpecSignedShortKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedShortKeyWord(const TypeSpecSignedShortKeyWord &);
  TypeSpecSignedShortKeyWord &operator=(const TypeSpecSignedShortKeyWord &);
  TypeSpecSignedShortKeyWord();
  ~TypeSpecSignedShortKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedShortKeyWord *clone() const;
  void swap(TypeSpecSignedShortKeyWord &);
};

class TypeSpecUnsignedShortKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedShortKeyWord(const TypeSpecUnsignedShortKeyWord &);
  TypeSpecUnsignedShortKeyWord &operator=(const TypeSpecUnsignedShortKeyWord &);
  TypeSpecUnsignedShortKeyWord();
  ~TypeSpecUnsignedShortKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedShortKeyWord *clone() const;
  void swap(TypeSpecUnsignedShortKeyWord &);
};

class TypeSpecShortIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecShortIntKeyWord(const TypeSpecShortIntKeyWord &);
  TypeSpecShortIntKeyWord &operator=(const TypeSpecShortIntKeyWord &);
  TypeSpecShortIntKeyWord();
  ~TypeSpecShortIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecShortIntKeyWord *clone() const;
  void swap(TypeSpecShortIntKeyWord &);
};

class TypeSpecSignedShortIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedShortIntKeyWord(const TypeSpecSignedShortIntKeyWord &);
  TypeSpecSignedShortIntKeyWord &operator=(const TypeSpecSignedShortIntKeyWord &);
  TypeSpecSignedShortIntKeyWord();
  ~TypeSpecSignedShortIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedShortIntKeyWord *clone() const;
  void swap(TypeSpecSignedShortIntKeyWord &);
};

class TypeSpecUnsignedShortIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedShortIntKeyWord(const TypeSpecUnsignedShortIntKeyWord &);
  TypeSpecUnsignedShortIntKeyWord &operator=(const TypeSpecUnsignedShortIntKeyWord &);
  TypeSpecUnsignedShortIntKeyWord();
  ~TypeSpecUnsignedShortIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedShortIntKeyWord *clone() const;
  void swap(TypeSpecUnsignedShortIntKeyWord &);
};

class TypeSpecLongKeyWord : public TypeSpecSimple
{
public:

  TypeSpecLongKeyWord(const TypeSpecLongKeyWord &);
  TypeSpecLongKeyWord &operator=(const TypeSpecLongKeyWord &);
  TypeSpecLongKeyWord();
  ~TypeSpecLongKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecLongKeyWord *clone() const;
  void swap(TypeSpecLongKeyWord &);
};

class TypeSpecSignedLongKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedLongKeyWord(const TypeSpecSignedLongKeyWord &);
  TypeSpecSignedLongKeyWord &operator=(const TypeSpecSignedLongKeyWord &);
  TypeSpecSignedLongKeyWord();
  ~TypeSpecSignedLongKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedLongKeyWord *clone() const;
  void swap(TypeSpecSignedLongKeyWord &);
};

class TypeSpecUnsignedLongKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedLongKeyWord(const TypeSpecUnsignedLongKeyWord &);
  TypeSpecUnsignedLongKeyWord &operator=(const TypeSpecUnsignedLongKeyWord &);
  TypeSpecUnsignedLongKeyWord();
  ~TypeSpecUnsignedLongKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedLongKeyWord *clone() const;
  void swap(TypeSpecUnsignedLongKeyWord &);
};

class TypeSpecSignedLongIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedLongIntKeyWord(const TypeSpecSignedLongIntKeyWord &);
  TypeSpecSignedLongIntKeyWord &operator=(const TypeSpecSignedLongIntKeyWord &);
  TypeSpecSignedLongIntKeyWord();
  ~TypeSpecSignedLongIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedLongIntKeyWord *clone() const;
  void swap(TypeSpecSignedLongIntKeyWord &);
};

class TypeSpecLongIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecLongIntKeyWord(const TypeSpecLongIntKeyWord &);
  TypeSpecLongIntKeyWord &operator=(const TypeSpecLongIntKeyWord &);
  TypeSpecLongIntKeyWord();
  ~TypeSpecLongIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecLongIntKeyWord *clone() const;
  void swap(TypeSpecLongIntKeyWord &);
};

class TypeSpecUnsignedLongIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedLongIntKeyWord(const TypeSpecUnsignedLongIntKeyWord &);
  TypeSpecUnsignedLongIntKeyWord &operator=(const TypeSpecUnsignedLongIntKeyWord &);
  TypeSpecUnsignedLongIntKeyWord();
  ~TypeSpecUnsignedLongIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedLongIntKeyWord *clone() const;
  void swap(TypeSpecUnsignedLongIntKeyWord &);
};

class TypeSpecLongLongKeyWord : public TypeSpecSimple
{
public:

  TypeSpecLongLongKeyWord(const TypeSpecLongLongKeyWord &);
  TypeSpecLongLongKeyWord &operator=(const TypeSpecLongLongKeyWord &);
  TypeSpecLongLongKeyWord();
  ~TypeSpecLongLongKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecLongLongKeyWord *clone() const;
  void swap(TypeSpecLongLongKeyWord &);
};

class TypeSpecSignedLongLongKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedLongLongKeyWord(const TypeSpecSignedLongLongKeyWord &);
  TypeSpecSignedLongLongKeyWord &operator=(const TypeSpecSignedLongLongKeyWord &);
  TypeSpecSignedLongLongKeyWord();
  ~TypeSpecSignedLongLongKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedLongLongKeyWord *clone() const;
  void swap(TypeSpecSignedLongLongKeyWord &);
};

class TypeSpecUnsignedLongLongKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedLongLongKeyWord(const TypeSpecUnsignedLongLongKeyWord &);
  TypeSpecUnsignedLongLongKeyWord &operator=(const TypeSpecUnsignedLongLongKeyWord &);
  TypeSpecUnsignedLongLongKeyWord();
  ~TypeSpecUnsignedLongLongKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedLongLongKeyWord *clone() const;
  void swap(TypeSpecUnsignedLongLongKeyWord &);
};

class TypeSpecLongLongIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecLongLongIntKeyWord(const TypeSpecLongLongIntKeyWord &);
  TypeSpecLongLongIntKeyWord &operator=(const TypeSpecLongLongIntKeyWord &);
  TypeSpecLongLongIntKeyWord();
  ~TypeSpecLongLongIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecLongLongIntKeyWord *clone() const;
  void swap(TypeSpecLongLongIntKeyWord &);
};

class TypeSpecSignedLongLongIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecSignedLongLongIntKeyWord(const TypeSpecSignedLongLongIntKeyWord &);
  TypeSpecSignedLongLongIntKeyWord &operator=(const TypeSpecSignedLongLongIntKeyWord &);
  TypeSpecSignedLongLongIntKeyWord();
  ~TypeSpecSignedLongLongIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecSignedLongLongIntKeyWord *clone() const;
  void swap(TypeSpecSignedLongLongIntKeyWord &);
};

class TypeSpecUnsignedLongLongIntKeyWord : public TypeSpecSimple
{
public:

  TypeSpecUnsignedLongLongIntKeyWord(const TypeSpecUnsignedLongLongIntKeyWord &);
  TypeSpecUnsignedLongLongIntKeyWord &operator=(const TypeSpecUnsignedLongLongIntKeyWord &);
  TypeSpecUnsignedLongLongIntKeyWord();
  ~TypeSpecUnsignedLongLongIntKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnsignedLongLongIntKeyWord *clone() const;
  void swap(TypeSpecUnsignedLongLongIntKeyWord &);
};

class TypeSpecFloatKeyWord : public TypeSpecSimple
{
public:

  TypeSpecFloatKeyWord(const TypeSpecFloatKeyWord &);
  TypeSpecFloatKeyWord &operator=(const TypeSpecFloatKeyWord &);
  TypeSpecFloatKeyWord();
  ~TypeSpecFloatKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecFloatKeyWord *clone() const;
  void swap(TypeSpecFloatKeyWord &);
};

class TypeSpecDoubleKeyWord : public TypeSpecSimple
{
public:

  TypeSpecDoubleKeyWord(const TypeSpecDoubleKeyWord &);
  TypeSpecDoubleKeyWord &operator=(const TypeSpecDoubleKeyWord &);
  TypeSpecDoubleKeyWord();
  ~TypeSpecDoubleKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecDoubleKeyWord *clone() const;
  void swap(TypeSpecDoubleKeyWord &);
};

class TypeSpecLongDoubleKeyWord : public TypeSpecSimple
{
public:

  TypeSpecLongDoubleKeyWord(const TypeSpecLongDoubleKeyWord &);
  TypeSpecLongDoubleKeyWord &operator=(const TypeSpecLongDoubleKeyWord &);
  TypeSpecLongDoubleKeyWord();
  ~TypeSpecLongDoubleKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeSpecLongDoubleKeyWord *clone() const;
  void swap(TypeSpecLongDoubleKeyWord &);
};

class TypeSpecStruct : public TypeSpecSimple
{
public:
  IdentifierOrTypenameFull *identifierortypenamefull_;

  TypeSpecStruct(const TypeSpecStruct &);
  TypeSpecStruct &operator=(const TypeSpecStruct &);
  TypeSpecStruct(IdentifierOrTypenameFull *p1);
  ~TypeSpecStruct();
  virtual void accept(Visitor *v);
  virtual TypeSpecStruct *clone() const;
  void swap(TypeSpecStruct &);
};

class TypeSpecEnum : public TypeSpecSimple
{
public:
  IdentifierOrTypenameFull *identifierortypenamefull_;

  TypeSpecEnum(const TypeSpecEnum &);
  TypeSpecEnum &operator=(const TypeSpecEnum &);
  TypeSpecEnum(IdentifierOrTypenameFull *p1);
  ~TypeSpecEnum();
  virtual void accept(Visitor *v);
  virtual TypeSpecEnum *clone() const;
  void swap(TypeSpecEnum &);
};

class TypeSpecUnion : public TypeSpecSimple
{
public:
  IdentifierOrTypenameFull *identifierortypenamefull_;

  TypeSpecUnion(const TypeSpecUnion &);
  TypeSpecUnion &operator=(const TypeSpecUnion &);
  TypeSpecUnion(IdentifierOrTypenameFull *p1);
  ~TypeSpecUnion();
  virtual void accept(Visitor *v);
  virtual TypeSpecUnion *clone() const;
  void swap(TypeSpecUnion &);
};

class TYPENAME : public TypeSpecOFTYPENAME
{
public:
  TYPENAME typename_;

  TYPENAME(const TYPENAME &);
  TYPENAME &operator=(const TYPENAME &);
  TYPENAME(TYPENAME p1);
  ~TYPENAME();
  virtual void accept(Visitor *v);
  virtual TYPENAME *clone() const;
  void swap(TYPENAME &);
};

class TypeSpecTYPENAME : public TypeSpecOFTYPENAME
{
public:
  TYPENAME typename_;
  ListLogicTypeGenOFTYPENAME *listlogictypegenoftypename_;

  TypeSpecTYPENAME(const TypeSpecTYPENAME &);
  TypeSpecTYPENAME &operator=(const TypeSpecTYPENAME &);
  TypeSpecTYPENAME(TYPENAME p1, ListLogicTypeGenOFTYPENAME *p2);
  ~TypeSpecTYPENAME();
  virtual void accept(Visitor *v);
  virtual TypeSpecTYPENAME *clone() const;
  void swap(TypeSpecTYPENAME &);
};

class TypeSpecSimpleFromTypenameTypeSpec : public TypeSpecOFTYPENAME
{
public:
  TypeSpecSimple *typespecsimple_;

  TypeSpecSimpleFromTypenameTypeSpec(const TypeSpecSimpleFromTypenameTypeSpec &);
  TypeSpecSimpleFromTypenameTypeSpec &operator=(const TypeSpecSimpleFromTypenameTypeSpec &);
  TypeSpecSimpleFromTypenameTypeSpec(TypeSpecSimple *p1);
  ~TypeSpecSimpleFromTypenameTypeSpec();
  virtual void accept(Visitor *v);
  virtual TypeSpecSimpleFromTypenameTypeSpec *clone() const;
  void swap(TypeSpecSimpleFromTypenameTypeSpec &);
};

class TypeSpecIdentifierOrTypename : public TypeSpecOFIdentifierOrTypename
{
public:
  IdentifierOrTypename *identifierortypename_;

  TypeSpecIdentifierOrTypename(const TypeSpecIdentifierOrTypename &);
  TypeSpecIdentifierOrTypename &operator=(const TypeSpecIdentifierOrTypename &);
  TypeSpecIdentifierOrTypename(IdentifierOrTypename *p1);
  ~TypeSpecIdentifierOrTypename();
  virtual void accept(Visitor *v);
  virtual TypeSpecIdentifierOrTypename *clone() const;
  void swap(TypeSpecIdentifierOrTypename &);
};

class TypeSpecIdentifierOrTypenameAngles : public TypeSpecOFIdentifierOrTypename
{
public:
  IdentifierOrTypename *identifierortypename_;
  ListLogicTypeGenOFIdentifierOrTypename *listlogictypegenofidentifierortypename_;

  TypeSpecIdentifierOrTypenameAngles(const TypeSpecIdentifierOrTypenameAngles &);
  TypeSpecIdentifierOrTypenameAngles &operator=(const TypeSpecIdentifierOrTypenameAngles &);
  TypeSpecIdentifierOrTypenameAngles(IdentifierOrTypename *p1, ListLogicTypeGenOFIdentifierOrTypename *p2);
  ~TypeSpecIdentifierOrTypenameAngles();
  virtual void accept(Visitor *v);
  virtual TypeSpecIdentifierOrTypenameAngles *clone() const;
  void swap(TypeSpecIdentifierOrTypenameAngles &);
};

class TypeSpecSimpleFromIdTypenameTypeSpec : public TypeSpecOFIdentifierOrTypename
{
public:
  TypeSpecSimple *typespecsimple_;

  TypeSpecSimpleFromIdTypenameTypeSpec(const TypeSpecSimpleFromIdTypenameTypeSpec &);
  TypeSpecSimpleFromIdTypenameTypeSpec &operator=(const TypeSpecSimpleFromIdTypenameTypeSpec &);
  TypeSpecSimpleFromIdTypenameTypeSpec(TypeSpecSimple *p1);
  ~TypeSpecSimpleFromIdTypenameTypeSpec();
  virtual void accept(Visitor *v);
  virtual TypeSpecSimpleFromIdTypenameTypeSpec *clone() const;
  void swap(TypeSpecSimpleFromIdTypenameTypeSpec &);
};

class SimpleIdentifierFull : public FullIdentifier
{
public:
  Identifier *identifier_;

  SimpleIdentifierFull(const SimpleIdentifierFull &);
  SimpleIdentifierFull &operator=(const SimpleIdentifierFull &);
  SimpleIdentifierFull(Identifier *p1);
  ~SimpleIdentifierFull();
  virtual void accept(Visitor *v);
  virtual SimpleIdentifierFull *clone() const;
  void swap(SimpleIdentifierFull &);
};

class AdmitKeyWordFullIdent : public FullIdentifier
{
public:

  AdmitKeyWordFullIdent(const AdmitKeyWordFullIdent &);
  AdmitKeyWordFullIdent &operator=(const AdmitKeyWordFullIdent &);
  AdmitKeyWordFullIdent();
  ~AdmitKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AdmitKeyWordFullIdent *clone() const;
  void swap(AdmitKeyWordFullIdent &);
};

class AllocatesKeyWordFullIdent : public FullIdentifier
{
public:

  AllocatesKeyWordFullIdent(const AllocatesKeyWordFullIdent &);
  AllocatesKeyWordFullIdent &operator=(const AllocatesKeyWordFullIdent &);
  AllocatesKeyWordFullIdent();
  ~AllocatesKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AllocatesKeyWordFullIdent *clone() const;
  void swap(AllocatesKeyWordFullIdent &);
};

class AssertKeyWordFullIdent : public FullIdentifier
{
public:

  AssertKeyWordFullIdent(const AssertKeyWordFullIdent &);
  AssertKeyWordFullIdent &operator=(const AssertKeyWordFullIdent &);
  AssertKeyWordFullIdent();
  ~AssertKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AssertKeyWordFullIdent *clone() const;
  void swap(AssertKeyWordFullIdent &);
};

class AssignsKeyWordFullIdent : public FullIdentifier
{
public:

  AssignsKeyWordFullIdent(const AssignsKeyWordFullIdent &);
  AssignsKeyWordFullIdent &operator=(const AssignsKeyWordFullIdent &);
  AssignsKeyWordFullIdent();
  ~AssignsKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AssignsKeyWordFullIdent *clone() const;
  void swap(AssignsKeyWordFullIdent &);
};

class AssumesKeyWordFullIdent : public FullIdentifier
{
public:

  AssumesKeyWordFullIdent(const AssumesKeyWordFullIdent &);
  AssumesKeyWordFullIdent &operator=(const AssumesKeyWordFullIdent &);
  AssumesKeyWordFullIdent();
  ~AssumesKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AssumesKeyWordFullIdent *clone() const;
  void swap(AssumesKeyWordFullIdent &);
};

class AtKeyWordFullIdent : public FullIdentifier
{
public:

  AtKeyWordFullIdent(const AtKeyWordFullIdent &);
  AtKeyWordFullIdent &operator=(const AtKeyWordFullIdent &);
  AtKeyWordFullIdent();
  ~AtKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AtKeyWordFullIdent *clone() const;
  void swap(AtKeyWordFullIdent &);
};

class AxiomKeyWordFullIdent : public FullIdentifier
{
public:

  AxiomKeyWordFullIdent(const AxiomKeyWordFullIdent &);
  AxiomKeyWordFullIdent &operator=(const AxiomKeyWordFullIdent &);
  AxiomKeyWordFullIdent();
  ~AxiomKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AxiomKeyWordFullIdent *clone() const;
  void swap(AxiomKeyWordFullIdent &);
};

class AxiomaticKeyWordFullIdent : public FullIdentifier
{
public:

  AxiomaticKeyWordFullIdent(const AxiomaticKeyWordFullIdent &);
  AxiomaticKeyWordFullIdent &operator=(const AxiomaticKeyWordFullIdent &);
  AxiomaticKeyWordFullIdent();
  ~AxiomaticKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual AxiomaticKeyWordFullIdent *clone() const;
  void swap(AxiomaticKeyWordFullIdent &);
};

class BehaviorKeyWordFullIdent : public FullIdentifier
{
public:

  BehaviorKeyWordFullIdent(const BehaviorKeyWordFullIdent &);
  BehaviorKeyWordFullIdent &operator=(const BehaviorKeyWordFullIdent &);
  BehaviorKeyWordFullIdent();
  ~BehaviorKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual BehaviorKeyWordFullIdent *clone() const;
  void swap(BehaviorKeyWordFullIdent &);
};

class BreaksKeyWordFullIdent : public FullIdentifier
{
public:

  BreaksKeyWordFullIdent(const BreaksKeyWordFullIdent &);
  BreaksKeyWordFullIdent &operator=(const BreaksKeyWordFullIdent &);
  BreaksKeyWordFullIdent();
  ~BreaksKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual BreaksKeyWordFullIdent *clone() const;
  void swap(BreaksKeyWordFullIdent &);
};

class CheckKeyWordFullIdent : public FullIdentifier
{
public:

  CheckKeyWordFullIdent(const CheckKeyWordFullIdent &);
  CheckKeyWordFullIdent &operator=(const CheckKeyWordFullIdent &);
  CheckKeyWordFullIdent();
  ~CheckKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual CheckKeyWordFullIdent *clone() const;
  void swap(CheckKeyWordFullIdent &);
};

class CompleteKeyWordFullIdent : public FullIdentifier
{
public:

  CompleteKeyWordFullIdent(const CompleteKeyWordFullIdent &);
  CompleteKeyWordFullIdent &operator=(const CompleteKeyWordFullIdent &);
  CompleteKeyWordFullIdent();
  ~CompleteKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual CompleteKeyWordFullIdent *clone() const;
  void swap(CompleteKeyWordFullIdent &);
};

class ContinuesKeyWordFullIdent : public FullIdentifier
{
public:

  ContinuesKeyWordFullIdent(const ContinuesKeyWordFullIdent &);
  ContinuesKeyWordFullIdent &operator=(const ContinuesKeyWordFullIdent &);
  ContinuesKeyWordFullIdent();
  ~ContinuesKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ContinuesKeyWordFullIdent *clone() const;
  void swap(ContinuesKeyWordFullIdent &);
};

class ContractKeyWordFullIdent : public FullIdentifier
{
public:

  ContractKeyWordFullIdent(const ContractKeyWordFullIdent &);
  ContractKeyWordFullIdent &operator=(const ContractKeyWordFullIdent &);
  ContractKeyWordFullIdent();
  ~ContractKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ContractKeyWordFullIdent *clone() const;
  void swap(ContractKeyWordFullIdent &);
};

class DecreasesKeyWordFullIdent : public FullIdentifier
{
public:

  DecreasesKeyWordFullIdent(const DecreasesKeyWordFullIdent &);
  DecreasesKeyWordFullIdent &operator=(const DecreasesKeyWordFullIdent &);
  DecreasesKeyWordFullIdent();
  ~DecreasesKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual DecreasesKeyWordFullIdent *clone() const;
  void swap(DecreasesKeyWordFullIdent &);
};

class DisjointKeyWordFullIdent : public FullIdentifier
{
public:

  DisjointKeyWordFullIdent(const DisjointKeyWordFullIdent &);
  DisjointKeyWordFullIdent &operator=(const DisjointKeyWordFullIdent &);
  DisjointKeyWordFullIdent();
  ~DisjointKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual DisjointKeyWordFullIdent *clone() const;
  void swap(DisjointKeyWordFullIdent &);
};

class EnsuresKeyWordFullIdent : public FullIdentifier
{
public:

  EnsuresKeyWordFullIdent(const EnsuresKeyWordFullIdent &);
  EnsuresKeyWordFullIdent &operator=(const EnsuresKeyWordFullIdent &);
  EnsuresKeyWordFullIdent();
  ~EnsuresKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual EnsuresKeyWordFullIdent *clone() const;
  void swap(EnsuresKeyWordFullIdent &);
};

class ExitsKeyWordFullIdent : public FullIdentifier
{
public:

  ExitsKeyWordFullIdent(const ExitsKeyWordFullIdent &);
  ExitsKeyWordFullIdent &operator=(const ExitsKeyWordFullIdent &);
  ExitsKeyWordFullIdent();
  ~ExitsKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ExitsKeyWordFullIdent *clone() const;
  void swap(ExitsKeyWordFullIdent &);
};

class FreesKeyWordFullIdent : public FullIdentifier
{
public:

  FreesKeyWordFullIdent(const FreesKeyWordFullIdent &);
  FreesKeyWordFullIdent &operator=(const FreesKeyWordFullIdent &);
  FreesKeyWordFullIdent();
  ~FreesKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual FreesKeyWordFullIdent *clone() const;
  void swap(FreesKeyWordFullIdent &);
};

class FunctionKeyWordFullIdent : public FullIdentifier
{
public:

  FunctionKeyWordFullIdent(const FunctionKeyWordFullIdent &);
  FunctionKeyWordFullIdent &operator=(const FunctionKeyWordFullIdent &);
  FunctionKeyWordFullIdent();
  ~FunctionKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual FunctionKeyWordFullIdent *clone() const;
  void swap(FunctionKeyWordFullIdent &);
};

class GlobalKeyWordFullIdent : public FullIdentifier
{
public:

  GlobalKeyWordFullIdent(const GlobalKeyWordFullIdent &);
  GlobalKeyWordFullIdent &operator=(const GlobalKeyWordFullIdent &);
  GlobalKeyWordFullIdent();
  ~GlobalKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual GlobalKeyWordFullIdent *clone() const;
  void swap(GlobalKeyWordFullIdent &);
};

class ImpactKeyWordFullIdent : public FullIdentifier
{
public:

  ImpactKeyWordFullIdent(const ImpactKeyWordFullIdent &);
  ImpactKeyWordFullIdent &operator=(const ImpactKeyWordFullIdent &);
  ImpactKeyWordFullIdent();
  ~ImpactKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ImpactKeyWordFullIdent *clone() const;
  void swap(ImpactKeyWordFullIdent &);
};

class InductiveKeyWordFullIdent : public FullIdentifier
{
public:

  InductiveKeyWordFullIdent(const InductiveKeyWordFullIdent &);
  InductiveKeyWordFullIdent &operator=(const InductiveKeyWordFullIdent &);
  InductiveKeyWordFullIdent();
  ~InductiveKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual InductiveKeyWordFullIdent *clone() const;
  void swap(InductiveKeyWordFullIdent &);
};

class IncludeKeyWordFullIdent : public FullIdentifier
{
public:

  IncludeKeyWordFullIdent(const IncludeKeyWordFullIdent &);
  IncludeKeyWordFullIdent &operator=(const IncludeKeyWordFullIdent &);
  IncludeKeyWordFullIdent();
  ~IncludeKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual IncludeKeyWordFullIdent *clone() const;
  void swap(IncludeKeyWordFullIdent &);
};

class InvariantKeyWordFullIdent : public FullIdentifier
{
public:

  InvariantKeyWordFullIdent(const InvariantKeyWordFullIdent &);
  InvariantKeyWordFullIdent &operator=(const InvariantKeyWordFullIdent &);
  InvariantKeyWordFullIdent();
  ~InvariantKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual InvariantKeyWordFullIdent *clone() const;
  void swap(InvariantKeyWordFullIdent &);
};

class LemmaKeyWordFullIdent : public FullIdentifier
{
public:

  LemmaKeyWordFullIdent(const LemmaKeyWordFullIdent &);
  LemmaKeyWordFullIdent &operator=(const LemmaKeyWordFullIdent &);
  LemmaKeyWordFullIdent();
  ~LemmaKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual LemmaKeyWordFullIdent *clone() const;
  void swap(LemmaKeyWordFullIdent &);
};

class LetKeyWordFullIdent : public FullIdentifier
{
public:

  LetKeyWordFullIdent(const LetKeyWordFullIdent &);
  LetKeyWordFullIdent &operator=(const LetKeyWordFullIdent &);
  LetKeyWordFullIdent();
  ~LetKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual LetKeyWordFullIdent *clone() const;
  void swap(LetKeyWordFullIdent &);
};

class LogicKeyWordFullIdent : public FullIdentifier
{
public:

  LogicKeyWordFullIdent(const LogicKeyWordFullIdent &);
  LogicKeyWordFullIdent &operator=(const LogicKeyWordFullIdent &);
  LogicKeyWordFullIdent();
  ~LogicKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual LogicKeyWordFullIdent *clone() const;
  void swap(LogicKeyWordFullIdent &);
};

class LoopKeyWordFullIdent : public FullIdentifier
{
public:

  LoopKeyWordFullIdent(const LoopKeyWordFullIdent &);
  LoopKeyWordFullIdent &operator=(const LoopKeyWordFullIdent &);
  LoopKeyWordFullIdent();
  ~LoopKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual LoopKeyWordFullIdent *clone() const;
  void swap(LoopKeyWordFullIdent &);
};

class ModelKeyWordFullIdent : public FullIdentifier
{
public:

  ModelKeyWordFullIdent(const ModelKeyWordFullIdent &);
  ModelKeyWordFullIdent &operator=(const ModelKeyWordFullIdent &);
  ModelKeyWordFullIdent();
  ~ModelKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ModelKeyWordFullIdent *clone() const;
  void swap(ModelKeyWordFullIdent &);
};

class ModuleKeyWordFullIdent : public FullIdentifier
{
public:

  ModuleKeyWordFullIdent(const ModuleKeyWordFullIdent &);
  ModuleKeyWordFullIdent &operator=(const ModuleKeyWordFullIdent &);
  ModuleKeyWordFullIdent();
  ~ModuleKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ModuleKeyWordFullIdent *clone() const;
  void swap(ModuleKeyWordFullIdent &);
};

class PragmaKeyWordFullIdent : public FullIdentifier
{
public:

  PragmaKeyWordFullIdent(const PragmaKeyWordFullIdent &);
  PragmaKeyWordFullIdent &operator=(const PragmaKeyWordFullIdent &);
  PragmaKeyWordFullIdent();
  ~PragmaKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual PragmaKeyWordFullIdent *clone() const;
  void swap(PragmaKeyWordFullIdent &);
};

class PredicateKeyWordFullIdent : public FullIdentifier
{
public:

  PredicateKeyWordFullIdent(const PredicateKeyWordFullIdent &);
  PredicateKeyWordFullIdent &operator=(const PredicateKeyWordFullIdent &);
  PredicateKeyWordFullIdent();
  ~PredicateKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual PredicateKeyWordFullIdent *clone() const;
  void swap(PredicateKeyWordFullIdent &);
};

class RequiresKeyWordFullIdent : public FullIdentifier
{
public:

  RequiresKeyWordFullIdent(const RequiresKeyWordFullIdent &);
  RequiresKeyWordFullIdent &operator=(const RequiresKeyWordFullIdent &);
  RequiresKeyWordFullIdent();
  ~RequiresKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual RequiresKeyWordFullIdent *clone() const;
  void swap(RequiresKeyWordFullIdent &);
};

class ReturnsKeyWordFullIdent : public FullIdentifier
{
public:

  ReturnsKeyWordFullIdent(const ReturnsKeyWordFullIdent &);
  ReturnsKeyWordFullIdent &operator=(const ReturnsKeyWordFullIdent &);
  ReturnsKeyWordFullIdent();
  ~ReturnsKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual ReturnsKeyWordFullIdent *clone() const;
  void swap(ReturnsKeyWordFullIdent &);
};

class SliceKeyWordFullIdent : public FullIdentifier
{
public:

  SliceKeyWordFullIdent(const SliceKeyWordFullIdent &);
  SliceKeyWordFullIdent &operator=(const SliceKeyWordFullIdent &);
  SliceKeyWordFullIdent();
  ~SliceKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual SliceKeyWordFullIdent *clone() const;
  void swap(SliceKeyWordFullIdent &);
};

class TerminatesKeyWordFullIdent : public FullIdentifier
{
public:

  TerminatesKeyWordFullIdent(const TerminatesKeyWordFullIdent &);
  TerminatesKeyWordFullIdent &operator=(const TerminatesKeyWordFullIdent &);
  TerminatesKeyWordFullIdent();
  ~TerminatesKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual TerminatesKeyWordFullIdent *clone() const;
  void swap(TerminatesKeyWordFullIdent &);
};

class TypeKeyWordFullIdent : public FullIdentifier
{
public:

  TypeKeyWordFullIdent(const TypeKeyWordFullIdent &);
  TypeKeyWordFullIdent &operator=(const TypeKeyWordFullIdent &);
  TypeKeyWordFullIdent();
  ~TypeKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual TypeKeyWordFullIdent *clone() const;
  void swap(TypeKeyWordFullIdent &);
};

class VariantKeyWordFullIdent : public FullIdentifier
{
public:

  VariantKeyWordFullIdent(const VariantKeyWordFullIdent &);
  VariantKeyWordFullIdent &operator=(const VariantKeyWordFullIdent &);
  VariantKeyWordFullIdent();
  ~VariantKeyWordFullIdent();
  virtual void accept(Visitor *v);
  virtual VariantKeyWordFullIdent *clone() const;
  void swap(VariantKeyWordFullIdent &);
};

class IdentExtCodeAnnotFullIdent : public FullIdentifier
{
public:
  EXT_CODE_ANNOT ext_code_annot_;

  IdentExtCodeAnnotFullIdent(const IdentExtCodeAnnotFullIdent &);
  IdentExtCodeAnnotFullIdent &operator=(const IdentExtCodeAnnotFullIdent &);
  IdentExtCodeAnnotFullIdent(EXT_CODE_ANNOT p1);
  ~IdentExtCodeAnnotFullIdent();
  virtual void accept(Visitor *v);
  virtual IdentExtCodeAnnotFullIdent *clone() const;
  void swap(IdentExtCodeAnnotFullIdent &);
};

class IdentExtContractFullIdent : public FullIdentifier
{
public:
  EXT_CONTRACT ext_contract_;

  IdentExtContractFullIdent(const IdentExtContractFullIdent &);
  IdentExtContractFullIdent &operator=(const IdentExtContractFullIdent &);
  IdentExtContractFullIdent(EXT_CONTRACT p1);
  ~IdentExtContractFullIdent();
  virtual void accept(Visitor *v);
  virtual IdentExtContractFullIdent *clone() const;
  void swap(IdentExtContractFullIdent &);
};

class IdentExtGlobalFullIdent : public FullIdentifier
{
public:
  EXT_GLOBAL ext_global_;

  IdentExtGlobalFullIdent(const IdentExtGlobalFullIdent &);
  IdentExtGlobalFullIdent &operator=(const IdentExtGlobalFullIdent &);
  IdentExtGlobalFullIdent(EXT_GLOBAL p1);
  ~IdentExtGlobalFullIdent();
  virtual void accept(Visitor *v);
  virtual IdentExtGlobalFullIdent *clone() const;
  void swap(IdentExtGlobalFullIdent &);
};

class IdentExtGlobalBlockFullIdent : public FullIdentifier
{
public:
  EXT_GLOBAL_BLOCK ext_global_block_;

  IdentExtGlobalBlockFullIdent(const IdentExtGlobalBlockFullIdent &);
  IdentExtGlobalBlockFullIdent &operator=(const IdentExtGlobalBlockFullIdent &);
  IdentExtGlobalBlockFullIdent(EXT_GLOBAL_BLOCK p1);
  ~IdentExtGlobalBlockFullIdent();
  virtual void accept(Visitor *v);
  virtual IdentExtGlobalBlockFullIdent *clone() const;
  void swap(IdentExtGlobalBlockFullIdent &);
};

class ExrSpec : public ExtSpec
{
public:
  ExtGlobalClausesOpt *extglobalclausesopt_;
  ExtModuleSpecsOpt *extmodulespecsopt_;
  ExtGlobalSpecsOpt *extglobalspecsopt_;

  ExrSpec(const ExrSpec &);
  ExrSpec &operator=(const ExrSpec &);
  ExrSpec(ExtGlobalClausesOpt *p1, ExtModuleSpecsOpt *p2, ExtGlobalSpecsOpt *p3);
  ~ExrSpec();
  virtual void accept(Visitor *v);
  virtual ExrSpec *clone() const;
  void swap(ExrSpec &);
};

class EmptyExtGlobalClauses : public ExtGlobalClausesOpt
{
public:

  EmptyExtGlobalClauses(const EmptyExtGlobalClauses &);
  EmptyExtGlobalClauses &operator=(const EmptyExtGlobalClauses &);
  EmptyExtGlobalClauses();
  ~EmptyExtGlobalClauses();
  virtual void accept(Visitor *v);
  virtual EmptyExtGlobalClauses *clone() const;
  void swap(EmptyExtGlobalClauses &);
};

class SomeExtGlobalClauses : public ExtGlobalClausesOpt
{
public:
  ListExtGlobalClause *listextglobalclause_;

  SomeExtGlobalClauses(const SomeExtGlobalClauses &);
  SomeExtGlobalClauses &operator=(const SomeExtGlobalClauses &);
  SomeExtGlobalClauses(ListExtGlobalClause *p1);
  ~SomeExtGlobalClauses();
  virtual void accept(Visitor *v);
  virtual SomeExtGlobalClauses *clone() const;
  void swap(SomeExtGlobalClauses &);
};

class DeclClause : public ExtGlobalClause
{
public:
  Decl *decl_;

  DeclClause(const DeclClause &);
  DeclClause &operator=(const DeclClause &);
  DeclClause(Decl *p1);
  ~DeclClause();
  virtual void accept(Visitor *v);
  virtual DeclClause *clone() const;
  void swap(DeclClause &);
};

class LetClause : public ExtGlobalClause
{
public:
  AnyIdentifier *anyidentifier_;
  Lexpr *lexpr_;

  LetClause(const LetClause &);
  LetClause &operator=(const LetClause &);
  LetClause(AnyIdentifier *p1, Lexpr *p2);
  ~LetClause();
  virtual void accept(Visitor *v);
  virtual LetClause *clone() const;
  void swap(LetClause &);
};

class GlobalLetClause : public ExtGlobalClause
{
public:
  AnyIdentifier *anyidentifier_;
  Lexpr *lexpr_;

  GlobalLetClause(const GlobalLetClause &);
  GlobalLetClause &operator=(const GlobalLetClause &);
  GlobalLetClause(AnyIdentifier *p1, Lexpr *p2);
  ~GlobalLetClause();
  virtual void accept(Visitor *v);
  virtual GlobalLetClause *clone() const;
  void swap(GlobalLetClause &);
};

class IncludeClause : public ExtGlobalClause
{
public:
  ListSTRING_LITERAL *liststring_literal_;

  IncludeClause(const IncludeClause &);
  IncludeClause &operator=(const IncludeClause &);
  IncludeClause(ListSTRING_LITERAL *p1);
  ~IncludeClause();
  virtual void accept(Visitor *v);
  virtual IncludeClause *clone() const;
  void swap(IncludeClause &);
};

class EmptyExtGlobalSpecs : public ExtGlobalSpecsOpt
{
public:

  EmptyExtGlobalSpecs(const EmptyExtGlobalSpecs &);
  EmptyExtGlobalSpecs &operator=(const EmptyExtGlobalSpecs &);
  EmptyExtGlobalSpecs();
  ~EmptyExtGlobalSpecs();
  virtual void accept(Visitor *v);
  virtual EmptyExtGlobalSpecs *clone() const;
  void swap(EmptyExtGlobalSpecs &);
};

class SomeExtGlobalSpecs : public ExtGlobalSpecsOpt
{
public:
  ListExtGlobalSpec *listextglobalspec_;

  SomeExtGlobalSpecs(const SomeExtGlobalSpecs &);
  SomeExtGlobalSpecs &operator=(const SomeExtGlobalSpecs &);
  SomeExtGlobalSpecs(ListExtGlobalSpec *p1);
  ~SomeExtGlobalSpecs();
  virtual void accept(Visitor *v);
  virtual SomeExtGlobalSpecs *clone() const;
  void swap(SomeExtGlobalSpecs &);
};

class ExtGlobalSpecClauseModule : public ExtGlobalSpec
{
public:
  AnyIdentifier *anyidentifier_;
  ListExtGlobalClause *listextglobalclause_;
  ListExtModuleSpec *listextmodulespec_;

  ExtGlobalSpecClauseModule(const ExtGlobalSpecClauseModule &);
  ExtGlobalSpecClauseModule &operator=(const ExtGlobalSpecClauseModule &);
  ExtGlobalSpecClauseModule(AnyIdentifier *p1, ListExtGlobalClause *p2, ListExtModuleSpec *p3);
  ~ExtGlobalSpecClauseModule();
  virtual void accept(Visitor *v);
  virtual ExtGlobalSpecClauseModule *clone() const;
  void swap(ExtGlobalSpecClauseModule &);
};

class ExtGlobalSpecModule : public ExtGlobalSpec
{
public:
  AnyIdentifier *anyidentifier_;
  ListExtModuleSpec *listextmodulespec_;

  ExtGlobalSpecModule(const ExtGlobalSpecModule &);
  ExtGlobalSpecModule &operator=(const ExtGlobalSpecModule &);
  ExtGlobalSpecModule(AnyIdentifier *p1, ListExtModuleSpec *p2);
  ~ExtGlobalSpecModule();
  virtual void accept(Visitor *v);
  virtual ExtGlobalSpecModule *clone() const;
  void swap(ExtGlobalSpecModule &);
};

class ExtGlobalSpecClause : public ExtGlobalSpec
{
public:
  AnyIdentifier *anyidentifier_;
  ListExtGlobalClause *listextglobalclause_;

  ExtGlobalSpecClause(const ExtGlobalSpecClause &);
  ExtGlobalSpecClause &operator=(const ExtGlobalSpecClause &);
  ExtGlobalSpecClause(AnyIdentifier *p1, ListExtGlobalClause *p2);
  ~ExtGlobalSpecClause();
  virtual void accept(Visitor *v);
  virtual ExtGlobalSpecClause *clone() const;
  void swap(ExtGlobalSpecClause &);
};

class ExtGlobalSpecSimple : public ExtGlobalSpec
{
public:
  AnyIdentifier *anyidentifier_;

  ExtGlobalSpecSimple(const ExtGlobalSpecSimple &);
  ExtGlobalSpecSimple &operator=(const ExtGlobalSpecSimple &);
  ExtGlobalSpecSimple(AnyIdentifier *p1);
  ~ExtGlobalSpecSimple();
  virtual void accept(Visitor *v);
  virtual ExtGlobalSpecSimple *clone() const;
  void swap(ExtGlobalSpecSimple &);
};

class EmptyExtModuleSpecs : public ExtModuleSpecsOpt
{
public:

  EmptyExtModuleSpecs(const EmptyExtModuleSpecs &);
  EmptyExtModuleSpecs &operator=(const EmptyExtModuleSpecs &);
  EmptyExtModuleSpecs();
  ~EmptyExtModuleSpecs();
  virtual void accept(Visitor *v);
  virtual EmptyExtModuleSpecs *clone() const;
  void swap(EmptyExtModuleSpecs &);
};

class ListExtModuleSpecs : public ExtModuleSpecsOpt
{
public:
  ListExtModuleSpec *listextmodulespec_;

  ListExtModuleSpecs(const ListExtModuleSpecs &);
  ListExtModuleSpecs &operator=(const ListExtModuleSpecs &);
  ListExtModuleSpecs(ListExtModuleSpec *p1);
  ~ListExtModuleSpecs();
  virtual void accept(Visitor *v);
  virtual ListExtModuleSpecs *clone() const;
  void swap(ListExtModuleSpecs &);
};

class FunSpecExtModuleSpecs : public ExtModuleSpecsOpt
{
public:
  ListExtFunSpec *listextfunspec_;

  FunSpecExtModuleSpecs(const FunSpecExtModuleSpecs &);
  FunSpecExtModuleSpecs &operator=(const FunSpecExtModuleSpecs &);
  FunSpecExtModuleSpecs(ListExtFunSpec *p1);
  ~FunSpecExtModuleSpecs();
  virtual void accept(Visitor *v);
  virtual FunSpecExtModuleSpecs *clone() const;
  void swap(FunSpecExtModuleSpecs &);
};

class FunSpecWithListModules : public ExtModuleSpecsOpt
{
public:
  ListExtFunSpec *listextfunspec_;
  ListExtModuleSpec *listextmodulespec_;

  FunSpecWithListModules(const FunSpecWithListModules &);
  FunSpecWithListModules &operator=(const FunSpecWithListModules &);
  FunSpecWithListModules(ListExtFunSpec *p1, ListExtModuleSpec *p2);
  ~FunSpecWithListModules();
  virtual void accept(Visitor *v);
  virtual FunSpecWithListModules *clone() const;
  void swap(FunSpecWithListModules &);
};

class AnExtModuleSpec : public ExtModuleSpec
{
public:
  AnyIdentifier *anyidentifier_;
  ExtFunctionSpecsOpt *extfunctionspecsopt_;

  AnExtModuleSpec(const AnExtModuleSpec &);
  AnExtModuleSpec &operator=(const AnExtModuleSpec &);
  AnExtModuleSpec(AnyIdentifier *p1, ExtFunctionSpecsOpt *p2);
  ~AnExtModuleSpec();
  virtual void accept(Visitor *v);
  virtual AnExtModuleSpec *clone() const;
  void swap(AnExtModuleSpec &);
};

class NoExtFunctionSpecs : public ExtFunctionSpecsOpt
{
public:

  NoExtFunctionSpecs(const NoExtFunctionSpecs &);
  NoExtFunctionSpecs &operator=(const NoExtFunctionSpecs &);
  NoExtFunctionSpecs();
  ~NoExtFunctionSpecs();
  virtual void accept(Visitor *v);
  virtual NoExtFunctionSpecs *clone() const;
  void swap(NoExtFunctionSpecs &);
};

class SomeExtFunctionSpecs : public ExtFunctionSpecsOpt
{
public:
  ExtFunctionSpecs *extfunctionspecs_;

  SomeExtFunctionSpecs(const SomeExtFunctionSpecs &);
  SomeExtFunctionSpecs &operator=(const SomeExtFunctionSpecs &);
  SomeExtFunctionSpecs(ExtFunctionSpecs *p1);
  ~SomeExtFunctionSpecs();
  virtual void accept(Visitor *v);
  virtual SomeExtFunctionSpecs *clone() const;
  void swap(SomeExtFunctionSpecs &);
};

class AtMarkup : public ExtFunctionSpecs
{
public:
  ListStmtMarkup *liststmtmarkup_;

  AtMarkup(const AtMarkup &);
  AtMarkup &operator=(const AtMarkup &);
  AtMarkup(ListStmtMarkup *p1);
  ~AtMarkup();
  virtual void accept(Visitor *v);
  virtual AtMarkup *clone() const;
  void swap(AtMarkup &);
};

class ListFunctionSpecs : public ExtFunctionSpecs
{
public:
  ListExtFunctionSpec *listextfunctionspec_;

  ListFunctionSpecs(const ListFunctionSpecs &);
  ListFunctionSpecs &operator=(const ListFunctionSpecs &);
  ListFunctionSpecs(ListExtFunctionSpec *p1);
  ~ListFunctionSpecs();
  virtual void accept(Visitor *v);
  virtual ListFunctionSpecs *clone() const;
  void swap(ListFunctionSpecs &);
};

class ListFunctionSpecsAtMarkup : public ExtFunctionSpecs
{
public:
  ListExtFunctionSpec *listextfunctionspec_;
  ListStmtMarkup *liststmtmarkup_;

  ListFunctionSpecsAtMarkup(const ListFunctionSpecsAtMarkup &);
  ListFunctionSpecsAtMarkup &operator=(const ListFunctionSpecsAtMarkup &);
  ListFunctionSpecsAtMarkup(ListExtFunctionSpec *p1, ListStmtMarkup *p2);
  ~ListFunctionSpecsAtMarkup();
  virtual void accept(Visitor *v);
  virtual ListFunctionSpecsAtMarkup *clone() const;
  void swap(ListFunctionSpecsAtMarkup &);
};

class AnExtGlobalClause : public ExtFunctionSpec
{
public:
  ExtGlobalClause *extglobalclause_;

  AnExtGlobalClause(const AnExtGlobalClause &);
  AnExtGlobalClause &operator=(const AnExtGlobalClause &);
  AnExtGlobalClause(ExtGlobalClause *p1);
  ~AnExtGlobalClause();
  virtual void accept(Visitor *v);
  virtual AnExtGlobalClause *clone() const;
  void swap(AnExtGlobalClause &);
};

class AnExtFunSpec : public ExtFunctionSpec
{
public:
  ExtFunSpec *extfunspec_;

  AnExtFunSpec(const AnExtFunSpec &);
  AnExtFunSpec &operator=(const AnExtFunSpec &);
  AnExtFunSpec(ExtFunSpec *p1);
  ~AnExtFunSpec();
  virtual void accept(Visitor *v);
  virtual AnExtFunSpec *clone() const;
  void swap(AnExtFunSpec &);
};

class FunSpecAtAnnotation : public ExtFunSpec
{
public:
  ListStmtMarkup *liststmtmarkup_;
  Annotation *annotation_;

  FunSpecAtAnnotation(const FunSpecAtAnnotation &);
  FunSpecAtAnnotation &operator=(const FunSpecAtAnnotation &);
  FunSpecAtAnnotation(ListStmtMarkup *p1, Annotation *p2);
  ~FunSpecAtAnnotation();
  virtual void accept(Visitor *v);
  virtual FunSpecAtAnnotation *clone() const;
  void swap(FunSpecAtAnnotation &);
};

class FunSpecAtContract : public ExtFunSpec
{
public:
  ListStmtMarkup *liststmtmarkup_;
  ExtIdentifierOpt *extidentifieropt_;
  Contract *contract_;

  FunSpecAtContract(const FunSpecAtContract &);
  FunSpecAtContract &operator=(const FunSpecAtContract &);
  FunSpecAtContract(ListStmtMarkup *p1, ExtIdentifierOpt *p2, Contract *p3);
  ~FunSpecAtContract();
  virtual void accept(Visitor *v);
  virtual FunSpecAtContract *clone() const;
  void swap(FunSpecAtContract &);
};

class FunSpecContract : public ExtFunSpec
{
public:
  ExtIdentifierOpt *extidentifieropt_;
  Contract *contract_;

  FunSpecContract(const FunSpecContract &);
  FunSpecContract &operator=(const FunSpecContract &);
  FunSpecContract(ExtIdentifierOpt *p1, Contract *p2);
  ~FunSpecContract();
  virtual void accept(Visitor *v);
  virtual FunSpecContract *clone() const;
  void swap(FunSpecContract &);
};

class ExtIdentifierEmpty : public ExtIdentifierOpt
{
public:

  ExtIdentifierEmpty(const ExtIdentifierEmpty &);
  ExtIdentifierEmpty &operator=(const ExtIdentifierEmpty &);
  ExtIdentifierEmpty();
  ~ExtIdentifierEmpty();
  virtual void accept(Visitor *v);
  virtual ExtIdentifierEmpty *clone() const;
  void swap(ExtIdentifierEmpty &);
};

class ExtIdentifierSome : public ExtIdentifierOpt
{
public:
  AnyIdentifier *anyidentifier_;

  ExtIdentifierSome(const ExtIdentifierSome &);
  ExtIdentifierSome &operator=(const ExtIdentifierSome &);
  ExtIdentifierSome(AnyIdentifier *p1);
  ~ExtIdentifierSome();
  virtual void accept(Visitor *v);
  virtual ExtIdentifierSome *clone() const;
  void swap(ExtIdentifierSome &);
};

class MarkupStmtIdentifier : public StmtMarkup
{
public:
  AnyIdentifier *anyidentifier_;

  MarkupStmtIdentifier(const MarkupStmtIdentifier &);
  MarkupStmtIdentifier &operator=(const MarkupStmtIdentifier &);
  MarkupStmtIdentifier(AnyIdentifier *p1);
  ~MarkupStmtIdentifier();
  virtual void accept(Visitor *v);
  virtual MarkupStmtIdentifier *clone() const;
  void swap(MarkupStmtIdentifier &);
};

class MarkupIntConstant : public StmtMarkup
{
public:
  Integer integer_;

  MarkupIntConstant(const MarkupIntConstant &);
  MarkupIntConstant &operator=(const MarkupIntConstant &);
  MarkupIntConstant(Integer p1);
  ~MarkupIntConstant();
  virtual void accept(Visitor *v);
  virtual MarkupIntConstant *clone() const;
  void swap(MarkupIntConstant &);
};

class SpecConstract : public Spec
{
public:
  Contract *contract_;

  SpecConstract(const SpecConstract &);
  SpecConstract &operator=(const SpecConstract &);
  SpecConstract(Contract *p1);
  ~SpecConstract();
  virtual void accept(Visitor *v);
  virtual SpecConstract *clone() const;
  void swap(SpecConstract &);
};

class SimpleContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  CompleteOrDisjoint *completeordisjoint_;

  SimpleContract(const SimpleContract &);
  SimpleContract &operator=(const SimpleContract &);
  SimpleContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, CompleteOrDisjoint *p6);
  ~SimpleContract();
  virtual void accept(Visitor *v);
  virtual SimpleContract *clone() const;
  void swap(SimpleContract &);
};

class TerminatesRequiresContract : public Contract
{
public:
  Requires *requires_;
  NETerminates *neterminates_;

  TerminatesRequiresContract(const TerminatesRequiresContract &);
  TerminatesRequiresContract &operator=(const TerminatesRequiresContract &);
  TerminatesRequiresContract(Requires *p1, NETerminates *p2);
  ~TerminatesRequiresContract();
  virtual void accept(Visitor *v);
  virtual TerminatesRequiresContract *clone() const;
  void swap(TerminatesRequiresContract &);
};

class DecreasesRequiresContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  NEDecreases *nedecreases_;

  DecreasesRequiresContract(const DecreasesRequiresContract &);
  DecreasesRequiresContract &operator=(const DecreasesRequiresContract &);
  DecreasesRequiresContract(Requires *p1, Terminates *p2, NEDecreases *p3);
  ~DecreasesRequiresContract();
  virtual void accept(Visitor *v);
  virtual DecreasesRequiresContract *clone() const;
  void swap(DecreasesRequiresContract &);
};

class DecreasesTerminatesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  NEDecreases *nedecreases_;

  DecreasesTerminatesContract(const DecreasesTerminatesContract &);
  DecreasesTerminatesContract &operator=(const DecreasesTerminatesContract &);
  DecreasesTerminatesContract(Requires *p1, Terminates *p2, NEDecreases *p3);
  ~DecreasesTerminatesContract();
  virtual void accept(Visitor *v);
  virtual DecreasesTerminatesContract *clone() const;
  void swap(DecreasesTerminatesContract &);
};

class ClausesRequiresContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  NESimpleClauses *nesimpleclauses_;

  ClausesRequiresContract(const ClausesRequiresContract &);
  ClausesRequiresContract &operator=(const ClausesRequiresContract &);
  ClausesRequiresContract(Requires *p1, Terminates *p2, Decreases *p3, NESimpleClauses *p4);
  ~ClausesRequiresContract();
  virtual void accept(Visitor *v);
  virtual ClausesRequiresContract *clone() const;
  void swap(ClausesRequiresContract &);
};

class ClausesTerminatesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  NESimpleClauses *nesimpleclauses_;

  ClausesTerminatesContract(const ClausesTerminatesContract &);
  ClausesTerminatesContract &operator=(const ClausesTerminatesContract &);
  ClausesTerminatesContract(Requires *p1, Terminates *p2, Decreases *p3, NESimpleClauses *p4);
  ~ClausesTerminatesContract();
  virtual void accept(Visitor *v);
  virtual ClausesTerminatesContract *clone() const;
  void swap(ClausesTerminatesContract &);
};

class ClausesDecreasesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  NESimpleClauses *nesimpleclauses_;

  ClausesDecreasesContract(const ClausesDecreasesContract &);
  ClausesDecreasesContract &operator=(const ClausesDecreasesContract &);
  ClausesDecreasesContract(Requires *p1, Terminates *p2, Decreases *p3, NESimpleClauses *p4);
  ~ClausesDecreasesContract();
  virtual void accept(Visitor *v);
  virtual ClausesDecreasesContract *clone() const;
  void swap(ClausesDecreasesContract &);
};

class BehaviorsTerminatesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  NEBehaviors *nebehaviors_;

  BehaviorsTerminatesContract(const BehaviorsTerminatesContract &);
  BehaviorsTerminatesContract &operator=(const BehaviorsTerminatesContract &);
  BehaviorsTerminatesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, NEBehaviors *p5);
  ~BehaviorsTerminatesContract();
  virtual void accept(Visitor *v);
  virtual BehaviorsTerminatesContract *clone() const;
  void swap(BehaviorsTerminatesContract &);
};

class BehaviorsDecreasesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  NEBehaviors *nebehaviors_;

  BehaviorsDecreasesContract(const BehaviorsDecreasesContract &);
  BehaviorsDecreasesContract &operator=(const BehaviorsDecreasesContract &);
  BehaviorsDecreasesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, NEBehaviors *p5);
  ~BehaviorsDecreasesContract();
  virtual void accept(Visitor *v);
  virtual BehaviorsDecreasesContract *clone() const;
  void swap(BehaviorsDecreasesContract &);
};

class ComplDisjRequiresContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjRequiresContract(const ComplDisjRequiresContract &);
  ComplDisjRequiresContract &operator=(const ComplDisjRequiresContract &);
  ComplDisjRequiresContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjRequiresContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjRequiresContract *clone() const;
  void swap(ComplDisjRequiresContract &);
};

class ComplDisjTerminatesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjTerminatesContract(const ComplDisjTerminatesContract &);
  ComplDisjTerminatesContract &operator=(const ComplDisjTerminatesContract &);
  ComplDisjTerminatesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjTerminatesContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjTerminatesContract *clone() const;
  void swap(ComplDisjTerminatesContract &);
};

class ComplDisjDecreasesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjDecreasesContract(const ComplDisjDecreasesContract &);
  ComplDisjDecreasesContract &operator=(const ComplDisjDecreasesContract &);
  ComplDisjDecreasesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjDecreasesContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjDecreasesContract *clone() const;
  void swap(ComplDisjDecreasesContract &);
};

class ComplDisjBehaviorContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjBehaviorContract(const ComplDisjBehaviorContract &);
  ComplDisjBehaviorContract &operator=(const ComplDisjBehaviorContract &);
  ComplDisjBehaviorContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjBehaviorContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjBehaviorContract *clone() const;
  void swap(ComplDisjBehaviorContract &);
};

class ComplDisjAssignsContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjAssignsContract(const ComplDisjAssignsContract &);
  ComplDisjAssignsContract &operator=(const ComplDisjAssignsContract &);
  ComplDisjAssignsContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjAssignsContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjAssignsContract *clone() const;
  void swap(ComplDisjAssignsContract &);
};

class ComplDisjAllocatesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjAllocatesContract(const ComplDisjAllocatesContract &);
  ComplDisjAllocatesContract &operator=(const ComplDisjAllocatesContract &);
  ComplDisjAllocatesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjAllocatesContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjAllocatesContract *clone() const;
  void swap(ComplDisjAllocatesContract &);
};

class ComplDisjFreesContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;

  ComplDisjFreesContract(const ComplDisjFreesContract &);
  ComplDisjFreesContract &operator=(const ComplDisjFreesContract &);
  ComplDisjFreesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6);
  ~ComplDisjFreesContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjFreesContract *clone() const;
  void swap(ComplDisjFreesContract &);
};

class ComplDisjPostCondContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  NECompleteOrDisjoint *necompleteordisjoint_;
  PostCond *postcond_;

  ComplDisjPostCondContract(const ComplDisjPostCondContract &);
  ComplDisjPostCondContract &operator=(const ComplDisjPostCondContract &);
  ComplDisjPostCondContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6, PostCond *p7);
  ~ComplDisjPostCondContract();
  virtual void accept(Visitor *v);
  virtual ComplDisjPostCondContract *clone() const;
  void swap(ComplDisjPostCondContract &);
};

class AdmitRequiresClause : public ClauseKW
{
public:

  AdmitRequiresClause(const AdmitRequiresClause &);
  AdmitRequiresClause &operator=(const AdmitRequiresClause &);
  AdmitRequiresClause();
  ~AdmitRequiresClause();
  virtual void accept(Visitor *v);
  virtual AdmitRequiresClause *clone() const;
  void swap(AdmitRequiresClause &);
};

class AdmitInvariantClause : public ClauseKW
{
public:

  AdmitInvariantClause(const AdmitInvariantClause &);
  AdmitInvariantClause &operator=(const AdmitInvariantClause &);
  AdmitInvariantClause();
  ~AdmitInvariantClause();
  virtual void accept(Visitor *v);
  virtual AdmitInvariantClause *clone() const;
  void swap(AdmitInvariantClause &);
};

class AdmitLemmaClause : public ClauseKW
{
public:

  AdmitLemmaClause(const AdmitLemmaClause &);
  AdmitLemmaClause &operator=(const AdmitLemmaClause &);
  AdmitLemmaClause();
  ~AdmitLemmaClause();
  virtual void accept(Visitor *v);
  virtual AdmitLemmaClause *clone() const;
  void swap(AdmitLemmaClause &);
};

class AdmitLoopClause : public ClauseKW
{
public:

  AdmitLoopClause(const AdmitLoopClause &);
  AdmitLoopClause &operator=(const AdmitLoopClause &);
  AdmitLoopClause();
  ~AdmitLoopClause();
  virtual void accept(Visitor *v);
  virtual AdmitLoopClause *clone() const;
  void swap(AdmitLoopClause &);
};

class CheckRequiresClause : public ClauseKW
{
public:

  CheckRequiresClause(const CheckRequiresClause &);
  CheckRequiresClause &operator=(const CheckRequiresClause &);
  CheckRequiresClause();
  ~CheckRequiresClause();
  virtual void accept(Visitor *v);
  virtual CheckRequiresClause *clone() const;
  void swap(CheckRequiresClause &);
};

class CheckInvariantClause : public ClauseKW
{
public:

  CheckInvariantClause(const CheckInvariantClause &);
  CheckInvariantClause &operator=(const CheckInvariantClause &);
  CheckInvariantClause();
  ~CheckInvariantClause();
  virtual void accept(Visitor *v);
  virtual CheckInvariantClause *clone() const;
  void swap(CheckInvariantClause &);
};

class CheckLemmaClause : public ClauseKW
{
public:

  CheckLemmaClause(const CheckLemmaClause &);
  CheckLemmaClause &operator=(const CheckLemmaClause &);
  CheckLemmaClause();
  ~CheckLemmaClause();
  virtual void accept(Visitor *v);
  virtual CheckLemmaClause *clone() const;
  void swap(CheckLemmaClause &);
};

class CheckLoopClause : public ClauseKW
{
public:

  CheckLoopClause(const CheckLoopClause &);
  CheckLoopClause &operator=(const CheckLoopClause &);
  CheckLoopClause();
  ~CheckLoopClause();
  virtual void accept(Visitor *v);
  virtual CheckLoopClause *clone() const;
  void swap(CheckLoopClause &);
};

class RequiresClause : public ClauseKW
{
public:

  RequiresClause(const RequiresClause &);
  RequiresClause &operator=(const RequiresClause &);
  RequiresClause();
  ~RequiresClause();
  virtual void accept(Visitor *v);
  virtual RequiresClause *clone() const;
  void swap(RequiresClause &);
};

class AssumesClause : public ClauseKW
{
public:

  AssumesClause(const AssumesClause &);
  AssumesClause &operator=(const AssumesClause &);
  AssumesClause();
  ~AssumesClause();
  virtual void accept(Visitor *v);
  virtual AssumesClause *clone() const;
  void swap(AssumesClause &);
};

class AssignsClause : public ClauseKW
{
public:

  AssignsClause(const AssignsClause &);
  AssignsClause &operator=(const AssignsClause &);
  AssignsClause();
  ~AssignsClause();
  virtual void accept(Visitor *v);
  virtual AssignsClause *clone() const;
  void swap(AssignsClause &);
};

class PostCondClause : public ClauseKW
{
public:
  PostCond *postcond_;

  PostCondClause(const PostCondClause &);
  PostCondClause &operator=(const PostCondClause &);
  PostCondClause(PostCond *p1);
  ~PostCondClause();
  virtual void accept(Visitor *v);
  virtual PostCondClause *clone() const;
  void swap(PostCondClause &);
};

class DecreasesClause : public ClauseKW
{
public:

  DecreasesClause(const DecreasesClause &);
  DecreasesClause &operator=(const DecreasesClause &);
  DecreasesClause();
  ~DecreasesClause();
  virtual void accept(Visitor *v);
  virtual DecreasesClause *clone() const;
  void swap(DecreasesClause &);
};

class BehaviorClause : public ClauseKW
{
public:

  BehaviorClause(const BehaviorClause &);
  BehaviorClause &operator=(const BehaviorClause &);
  BehaviorClause();
  ~BehaviorClause();
  virtual void accept(Visitor *v);
  virtual BehaviorClause *clone() const;
  void swap(BehaviorClause &);
};

class AllocatesClause : public ClauseKW
{
public:

  AllocatesClause(const AllocatesClause &);
  AllocatesClause &operator=(const AllocatesClause &);
  AllocatesClause();
  ~AllocatesClause();
  virtual void accept(Visitor *v);
  virtual AllocatesClause *clone() const;
  void swap(AllocatesClause &);
};

class FreesClause : public ClauseKW
{
public:

  FreesClause(const FreesClause &);
  FreesClause &operator=(const FreesClause &);
  FreesClause();
  ~FreesClause();
  virtual void accept(Visitor *v);
  virtual FreesClause *clone() const;
  void swap(FreesClause &);
};

class CompleteClause : public ClauseKW
{
public:

  CompleteClause(const CompleteClause &);
  CompleteClause &operator=(const CompleteClause &);
  CompleteClause();
  ~CompleteClause();
  virtual void accept(Visitor *v);
  virtual CompleteClause *clone() const;
  void swap(CompleteClause &);
};

class DisjointClause : public ClauseKW
{
public:

  DisjointClause(const DisjointClause &);
  DisjointClause &operator=(const DisjointClause &);
  DisjointClause();
  ~DisjointClause();
  virtual void accept(Visitor *v);
  virtual DisjointClause *clone() const;
  void swap(DisjointClause &);
};

class ClauseExtConstract : public ClauseKW
{
public:
  EXT_CONTRACT ext_contract_;

  ClauseExtConstract(const ClauseExtConstract &);
  ClauseExtConstract &operator=(const ClauseExtConstract &);
  ClauseExtConstract(EXT_CONTRACT p1);
  ~ClauseExtConstract();
  virtual void accept(Visitor *v);
  virtual ClauseExtConstract *clone() const;
  void swap(ClauseExtConstract &);
};

class EmptyClauseKW : public ClauseKW
{
public:

  EmptyClauseKW(const EmptyClauseKW &);
  EmptyClauseKW &operator=(const EmptyClauseKW &);
  EmptyClauseKW();
  ~EmptyClauseKW();
  virtual void accept(Visitor *v);
  virtual EmptyClauseKW *clone() const;
  void swap(EmptyClauseKW &);
};

class NoRequires : public Requires
{
public:

  NoRequires(const NoRequires &);
  NoRequires &operator=(const NoRequires &);
  NoRequires();
  ~NoRequires();
  virtual void accept(Visitor *v);
  virtual NoRequires *clone() const;
  void swap(NoRequires &);
};

class SomeRequires : public Requires
{
public:
  NERequires *nerequires_;

  SomeRequires(const SomeRequires &);
  SomeRequires &operator=(const SomeRequires &);
  SomeRequires(NERequires *p1);
  ~SomeRequires();
  virtual void accept(Visitor *v);
  virtual SomeRequires *clone() const;
  void swap(SomeRequires &);
};

class SimpleRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  Requires *requires_;

  SimpleRequires(const SimpleRequires &);
  SimpleRequires &operator=(const SimpleRequires &);
  SimpleRequires(Lexpr *p1, Requires *p2);
  ~SimpleRequires();
  virtual void accept(Visitor *v);
  virtual SimpleRequires *clone() const;
  void swap(SimpleRequires &);
};

class CheckRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  Requires *requires_;

  CheckRequires(const CheckRequires &);
  CheckRequires &operator=(const CheckRequires &);
  CheckRequires(Lexpr *p1, Requires *p2);
  ~CheckRequires();
  virtual void accept(Visitor *v);
  virtual CheckRequires *clone() const;
  void swap(CheckRequires &);
};

class AdimtRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  Requires *requires_;

  AdimtRequires(const AdimtRequires &);
  AdimtRequires &operator=(const AdimtRequires &);
  AdimtRequires(Lexpr *p1, Requires *p2);
  ~AdimtRequires();
  virtual void accept(Visitor *v);
  virtual AdimtRequires *clone() const;
  void swap(AdimtRequires &);
};

class ClauseSimpleRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  ClauseKW *clausekw_;

  ClauseSimpleRequires(const ClauseSimpleRequires &);
  ClauseSimpleRequires &operator=(const ClauseSimpleRequires &);
  ClauseSimpleRequires(Lexpr *p1, ClauseKW *p2);
  ~ClauseSimpleRequires();
  virtual void accept(Visitor *v);
  virtual ClauseSimpleRequires *clone() const;
  void swap(ClauseSimpleRequires &);
};

class ClauseCheckRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  ClauseKW *clausekw_;

  ClauseCheckRequires(const ClauseCheckRequires &);
  ClauseCheckRequires &operator=(const ClauseCheckRequires &);
  ClauseCheckRequires(Lexpr *p1, ClauseKW *p2);
  ~ClauseCheckRequires();
  virtual void accept(Visitor *v);
  virtual ClauseCheckRequires *clone() const;
  void swap(ClauseCheckRequires &);
};

class ClauseAdimtRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  ClauseKW *clausekw_;

  ClauseAdimtRequires(const ClauseAdimtRequires &);
  ClauseAdimtRequires &operator=(const ClauseAdimtRequires &);
  ClauseAdimtRequires(Lexpr *p1, ClauseKW *p2);
  ~ClauseAdimtRequires();
  virtual void accept(Visitor *v);
  virtual ClauseAdimtRequires *clone() const;
  void swap(ClauseAdimtRequires &);
};

class NoTerminate : public Terminates
{
public:

  NoTerminate(const NoTerminate &);
  NoTerminate &operator=(const NoTerminate &);
  NoTerminate();
  ~NoTerminate();
  virtual void accept(Visitor *v);
  virtual NoTerminate *clone() const;
  void swap(NoTerminate &);
};

class SomeTerminate : public Terminates
{
public:
  NETerminates *neterminates_;

  SomeTerminate(const SomeTerminate &);
  SomeTerminate &operator=(const SomeTerminate &);
  SomeTerminate(NETerminates *p1);
  ~SomeTerminate();
  virtual void accept(Visitor *v);
  virtual SomeTerminate *clone() const;
  void swap(SomeTerminate &);
};

class SimpleTerminates : public NETerminates
{
public:
  Lexpr *lexpr_;

  SimpleTerminates(const SimpleTerminates &);
  SimpleTerminates &operator=(const SimpleTerminates &);
  SimpleTerminates(Lexpr *p1);
  ~SimpleTerminates();
  virtual void accept(Visitor *v);
  virtual SimpleTerminates *clone() const;
  void swap(SimpleTerminates &);
};

class ClauseTerminates : public NETerminates
{
public:
  Lexpr *lexpr_;
  ClauseKW *clausekw_;

  ClauseTerminates(const ClauseTerminates &);
  ClauseTerminates &operator=(const ClauseTerminates &);
  ClauseTerminates(Lexpr *p1, ClauseKW *p2);
  ~ClauseTerminates();
  virtual void accept(Visitor *v);
  virtual ClauseTerminates *clone() const;
  void swap(ClauseTerminates &);
};

class NoDecreases : public Decreases
{
public:

  NoDecreases(const NoDecreases &);
  NoDecreases &operator=(const NoDecreases &);
  NoDecreases();
  ~NoDecreases();
  virtual void accept(Visitor *v);
  virtual NoDecreases *clone() const;
  void swap(NoDecreases &);
};

class SomeDecreases : public Decreases
{
public:
  NEDecreases *nedecreases_;

  SomeDecreases(const SomeDecreases &);
  SomeDecreases &operator=(const SomeDecreases &);
  SomeDecreases(NEDecreases *p1);
  ~SomeDecreases();
  virtual void accept(Visitor *v);
  virtual SomeDecreases *clone() const;
  void swap(SomeDecreases &);
};

class SimpleDecreases : public NEDecreases
{
public:
  Variant *variant_;

  SimpleDecreases(const SimpleDecreases &);
  SimpleDecreases &operator=(const SimpleDecreases &);
  SimpleDecreases(Variant *p1);
  ~SimpleDecreases();
  virtual void accept(Visitor *v);
  virtual SimpleDecreases *clone() const;
  void swap(SimpleDecreases &);
};

class ClauseDecreases : public NEDecreases
{
public:
  Variant *variant_;
  ClauseKW *clausekw_;

  ClauseDecreases(const ClauseDecreases &);
  ClauseDecreases &operator=(const ClauseDecreases &);
  ClauseDecreases(Variant *p1, ClauseKW *p2);
  ~ClauseDecreases();
  virtual void accept(Visitor *v);
  virtual ClauseDecreases *clone() const;
  void swap(ClauseDecreases &);
};

class ForVariant : public Variant
{
public:
  Lexpr *lexpr_;
  AnyIdentifier *anyidentifier_;

  ForVariant(const ForVariant &);
  ForVariant &operator=(const ForVariant &);
  ForVariant(Lexpr *p1, AnyIdentifier *p2);
  ~ForVariant();
  virtual void accept(Visitor *v);
  virtual ForVariant *clone() const;
  void swap(ForVariant &);
};

class LexprVariant : public Variant
{
public:
  Lexpr *lexpr_;

  LexprVariant(const LexprVariant &);
  LexprVariant &operator=(const LexprVariant &);
  LexprVariant(Lexpr *p1);
  ~LexprVariant();
  virtual void accept(Visitor *v);
  virtual LexprVariant *clone() const;
  void swap(LexprVariant &);
};

class NoSimpleClauses : public SimpleClauses
{
public:

  NoSimpleClauses(const NoSimpleClauses &);
  NoSimpleClauses &operator=(const NoSimpleClauses &);
  NoSimpleClauses();
  ~NoSimpleClauses();
  virtual void accept(Visitor *v);
  virtual NoSimpleClauses *clone() const;
  void swap(NoSimpleClauses &);
};

class SomeSimpleClauses : public SimpleClauses
{
public:
  NESimpleClauses *nesimpleclauses_;

  SomeSimpleClauses(const SomeSimpleClauses &);
  SomeSimpleClauses &operator=(const SomeSimpleClauses &);
  SomeSimpleClauses(NESimpleClauses *p1);
  ~SomeSimpleClauses();
  virtual void accept(Visitor *v);
  virtual SomeSimpleClauses *clone() const;
  void swap(SomeSimpleClauses &);
};

class AllocatesZones : public Allocation
{
public:
  Zones *zones_;

  AllocatesZones(const AllocatesZones &);
  AllocatesZones &operator=(const AllocatesZones &);
  AllocatesZones(Zones *p1);
  ~AllocatesZones();
  virtual void accept(Visitor *v);
  virtual AllocatesZones *clone() const;
  void swap(AllocatesZones &);
};

class FreesZones : public Allocation
{
public:
  Zones *zones_;

  FreesZones(const FreesZones &);
  FreesZones &operator=(const FreesZones &);
  FreesZones(Zones *p1);
  ~FreesZones();
  virtual void accept(Visitor *v);
  virtual FreesZones *clone() const;
  void swap(FreesZones &);
};

class PostCondSimpleClauses : public NESimpleClauses
{
public:
  PostCond *postcond_;
  Lexpr *lexpr_;
  SimpleClauses *simpleclauses_;

  PostCondSimpleClauses(const PostCondSimpleClauses &);
  PostCondSimpleClauses &operator=(const PostCondSimpleClauses &);
  PostCondSimpleClauses(PostCond *p1, Lexpr *p2, SimpleClauses *p3);
  ~PostCondSimpleClauses();
  virtual void accept(Visitor *v);
  virtual PostCondSimpleClauses *clone() const;
  void swap(PostCondSimpleClauses &);
};

class AllocationSimpleClauses : public NESimpleClauses
{
public:
  Allocation *allocation_;
  SimpleClauses *simpleclauses_;

  AllocationSimpleClauses(const AllocationSimpleClauses &);
  AllocationSimpleClauses &operator=(const AllocationSimpleClauses &);
  AllocationSimpleClauses(Allocation *p1, SimpleClauses *p2);
  ~AllocationSimpleClauses();
  virtual void accept(Visitor *v);
  virtual AllocationSimpleClauses *clone() const;
  void swap(AllocationSimpleClauses &);
};

class AssignsSimpleClauses : public NESimpleClauses
{
public:
  Assigns *assigns_;
  SimpleClauses *simpleclauses_;

  AssignsSimpleClauses(const AssignsSimpleClauses &);
  AssignsSimpleClauses &operator=(const AssignsSimpleClauses &);
  AssignsSimpleClauses(Assigns *p1, SimpleClauses *p2);
  ~AssignsSimpleClauses();
  virtual void accept(Visitor *v);
  virtual AssignsSimpleClauses *clone() const;
  void swap(AssignsSimpleClauses &);
};

class ExtContractSimpleClauses : public NESimpleClauses
{
public:
  EXT_CONTRACT ext_contract_;
  ExtensionContent *extensioncontent_;
  SimpleClauses *simpleclauses_;

  ExtContractSimpleClauses(const ExtContractSimpleClauses &);
  ExtContractSimpleClauses &operator=(const ExtContractSimpleClauses &);
  ExtContractSimpleClauses(EXT_CONTRACT p1, ExtensionContent *p2, SimpleClauses *p3);
  ~ExtContractSimpleClauses();
  virtual void accept(Visitor *v);
  virtual ExtContractSimpleClauses *clone() const;
  void swap(ExtContractSimpleClauses &);
};

class ClausesPostCondSimpleClauses : public NESimpleClauses
{
public:
  PostCond *postcond_;
  Lexpr *lexpr_;
  ClauseKW *clausekw_;

  ClausesPostCondSimpleClauses(const ClausesPostCondSimpleClauses &);
  ClausesPostCondSimpleClauses &operator=(const ClausesPostCondSimpleClauses &);
  ClausesPostCondSimpleClauses(PostCond *p1, Lexpr *p2, ClauseKW *p3);
  ~ClausesPostCondSimpleClauses();
  virtual void accept(Visitor *v);
  virtual ClausesPostCondSimpleClauses *clone() const;
  void swap(ClausesPostCondSimpleClauses &);
};

class ClausesAllocationSimpleClauses : public NESimpleClauses
{
public:
  Allocation *allocation_;
  ClauseKW *clausekw_;

  ClausesAllocationSimpleClauses(const ClausesAllocationSimpleClauses &);
  ClausesAllocationSimpleClauses &operator=(const ClausesAllocationSimpleClauses &);
  ClausesAllocationSimpleClauses(Allocation *p1, ClauseKW *p2);
  ~ClausesAllocationSimpleClauses();
  virtual void accept(Visitor *v);
  virtual ClausesAllocationSimpleClauses *clone() const;
  void swap(ClausesAllocationSimpleClauses &);
};

class ClausesAssignsSimpleClauses : public NESimpleClauses
{
public:
  Assigns *assigns_;
  ClauseKW *clausekw_;

  ClausesAssignsSimpleClauses(const ClausesAssignsSimpleClauses &);
  ClausesAssignsSimpleClauses &operator=(const ClausesAssignsSimpleClauses &);
  ClausesAssignsSimpleClauses(Assigns *p1, ClauseKW *p2);
  ~ClausesAssignsSimpleClauses();
  virtual void accept(Visitor *v);
  virtual ClausesAssignsSimpleClauses *clone() const;
  void swap(ClausesAssignsSimpleClauses &);
};

class ExtConClausestractSimpleClauses : public NESimpleClauses
{
public:
  EXT_CONTRACT ext_contract_;
  Zones *zones_;
  ClauseKW *clausekw_;

  ExtConClausestractSimpleClauses(const ExtConClausestractSimpleClauses &);
  ExtConClausestractSimpleClauses &operator=(const ExtConClausestractSimpleClauses &);
  ExtConClausestractSimpleClauses(EXT_CONTRACT p1, Zones *p2, ClauseKW *p3);
  ~ExtConClausestractSimpleClauses();
  virtual void accept(Visitor *v);
  virtual ExtConClausestractSimpleClauses *clone() const;
  void swap(ExtConClausestractSimpleClauses &);
};

class NoExtensionContent : public ExtensionContent
{
public:

  NoExtensionContent(const NoExtensionContent &);
  NoExtensionContent &operator=(const NoExtensionContent &);
  NoExtensionContent();
  ~NoExtensionContent();
  virtual void accept(Visitor *v);
  virtual NoExtensionContent *clone() const;
  void swap(NoExtensionContent &);
};

class SomeExtensionContent : public ExtensionContent
{
public:
  Zones *zones_;

  SomeExtensionContent(const SomeExtensionContent &);
  SomeExtensionContent &operator=(const SomeExtensionContent &);
  SomeExtensionContent(Zones *p1);
  ~SomeExtensionContent();
  virtual void accept(Visitor *v);
  virtual SomeExtensionContent *clone() const;
  void swap(SomeExtensionContent &);
};

class NoBehaviors : public Behaviors
{
public:

  NoBehaviors(const NoBehaviors &);
  NoBehaviors &operator=(const NoBehaviors &);
  NoBehaviors();
  ~NoBehaviors();
  virtual void accept(Visitor *v);
  virtual NoBehaviors *clone() const;
  void swap(NoBehaviors &);
};

class SomeBehaviors : public Behaviors
{
public:
  NEBehaviors *nebehaviors_;

  SomeBehaviors(const SomeBehaviors &);
  SomeBehaviors &operator=(const SomeBehaviors &);
  SomeBehaviors(NEBehaviors *p1);
  ~SomeBehaviors();
  virtual void accept(Visitor *v);
  virtual SomeBehaviors *clone() const;
  void swap(SomeBehaviors &);
};

class TheBehaviors : public NEBehaviors
{
public:
  BehaviorName *behaviorname_;
  BehaviorBody *behaviorbody_;
  Behaviors *behaviors_;

  TheBehaviors(const TheBehaviors &);
  TheBehaviors &operator=(const TheBehaviors &);
  TheBehaviors(BehaviorName *p1, BehaviorBody *p2, Behaviors *p3);
  ~TheBehaviors();
  virtual void accept(Visitor *v);
  virtual TheBehaviors *clone() const;
  void swap(TheBehaviors &);
};

class SimpleClausesBehavior : public BehaviorBody
{
public:
  Assumes *assumes_;
  Requires *requires_;
  SimpleClauses *simpleclauses_;

  SimpleClausesBehavior(const SimpleClausesBehavior &);
  SimpleClausesBehavior &operator=(const SimpleClausesBehavior &);
  SimpleClausesBehavior(Assumes *p1, Requires *p2, SimpleClauses *p3);
  ~SimpleClausesBehavior();
  virtual void accept(Visitor *v);
  virtual SimpleClausesBehavior *clone() const;
  void swap(SimpleClausesBehavior &);
};

class RequiresAssumes : public BehaviorBody
{
public:
  Assumes *assumes_;
  NERequires *nerequires_;

  RequiresAssumes(const RequiresAssumes &);
  RequiresAssumes &operator=(const RequiresAssumes &);
  RequiresAssumes(Assumes *p1, NERequires *p2);
  ~RequiresAssumes();
  virtual void accept(Visitor *v);
  virtual RequiresAssumes *clone() const;
  void swap(RequiresAssumes &);
};

class SimpleClausesAssumes : public BehaviorBody
{
public:
  Assumes *assumes_;
  Requires *requires_;
  NESimpleClauses *nesimpleclauses_;

  SimpleClausesAssumes(const SimpleClausesAssumes &);
  SimpleClausesAssumes &operator=(const SimpleClausesAssumes &);
  SimpleClausesAssumes(Assumes *p1, Requires *p2, NESimpleClauses *p3);
  ~SimpleClausesAssumes();
  virtual void accept(Visitor *v);
  virtual SimpleClausesAssumes *clone() const;
  void swap(SimpleClausesAssumes &);
};

class RequiresRequires : public BehaviorBody
{
public:
  Assumes *assumes_;
  Requires *requires_;
  NESimpleClauses *nesimpleclauses_;

  RequiresRequires(const RequiresRequires &);
  RequiresRequires &operator=(const RequiresRequires &);
  RequiresRequires(Assumes *p1, Requires *p2, NESimpleClauses *p3);
  ~RequiresRequires();
  virtual void accept(Visitor *v);
  virtual RequiresRequires *clone() const;
  void swap(RequiresRequires &);
};

class NoAssumes : public Assumes
{
public:

  NoAssumes(const NoAssumes &);
  NoAssumes &operator=(const NoAssumes &);
  NoAssumes();
  ~NoAssumes();
  virtual void accept(Visitor *v);
  virtual NoAssumes *clone() const;
  void swap(NoAssumes &);
};

class SimpleAssumes : public Assumes
{
public:
  Lexpr *lexpr_;
  Assumes *assumes_;

  SimpleAssumes(const SimpleAssumes &);
  SimpleAssumes &operator=(const SimpleAssumes &);
  SimpleAssumes(Lexpr *p1, Assumes *p2);
  ~SimpleAssumes();
  virtual void accept(Visitor *v);
  virtual SimpleAssumes *clone() const;
  void swap(SimpleAssumes &);
};

class ClauseAssumes : public Assumes
{
public:
  Lexpr *lexpr_;
  ClauseKW *clausekw_;

  ClauseAssumes(const ClauseAssumes &);
  ClauseAssumes &operator=(const ClauseAssumes &);
  ClauseAssumes(Lexpr *p1, ClauseKW *p2);
  ~ClauseAssumes();
  virtual void accept(Visitor *v);
  virtual ClauseAssumes *clone() const;
  void swap(ClauseAssumes &);
};

class NoComplDisj : public CompleteOrDisjoint
{
public:

  NoComplDisj(const NoComplDisj &);
  NoComplDisj &operator=(const NoComplDisj &);
  NoComplDisj();
  ~NoComplDisj();
  virtual void accept(Visitor *v);
  virtual NoComplDisj *clone() const;
  void swap(NoComplDisj &);
};

class SomeComplDisj : public CompleteOrDisjoint
{
public:
  NECompleteOrDisjoint *necompleteordisjoint_;

  SomeComplDisj(const SomeComplDisj &);
  SomeComplDisj &operator=(const SomeComplDisj &);
  SomeComplDisj(NECompleteOrDisjoint *p1);
  ~SomeComplDisj();
  virtual void accept(Visitor *v);
  virtual SomeComplDisj *clone() const;
  void swap(SomeComplDisj &);
};

class CompleteBehavior : public NECompleteOrDisjoint
{
public:
  BehaviorNameList *behaviornamelist_;
  CompleteOrDisjoint *completeordisjoint_;

  CompleteBehavior(const CompleteBehavior &);
  CompleteBehavior &operator=(const CompleteBehavior &);
  CompleteBehavior(BehaviorNameList *p1, CompleteOrDisjoint *p2);
  ~CompleteBehavior();
  virtual void accept(Visitor *v);
  virtual CompleteBehavior *clone() const;
  void swap(CompleteBehavior &);
};

class DisjointBehavior : public NECompleteOrDisjoint
{
public:
  BehaviorNameList *behaviornamelist_;
  CompleteOrDisjoint *completeordisjoint_;

  DisjointBehavior(const DisjointBehavior &);
  DisjointBehavior &operator=(const DisjointBehavior &);
  DisjointBehavior(BehaviorNameList *p1, CompleteOrDisjoint *p2);
  ~DisjointBehavior();
  virtual void accept(Visitor *v);
  virtual DisjointBehavior *clone() const;
  void swap(DisjointBehavior &);
};

class CompleteBehaviorClause : public NECompleteOrDisjoint
{
public:
  ListBehaviorName *listbehaviorname_;
  ClauseKW *clausekw_;

  CompleteBehaviorClause(const CompleteBehaviorClause &);
  CompleteBehaviorClause &operator=(const CompleteBehaviorClause &);
  CompleteBehaviorClause(ListBehaviorName *p1, ClauseKW *p2);
  ~CompleteBehaviorClause();
  virtual void accept(Visitor *v);
  virtual CompleteBehaviorClause *clone() const;
  void swap(CompleteBehaviorClause &);
};

class DisjointBehaviorClause : public NECompleteOrDisjoint
{
public:
  ListBehaviorName *listbehaviorname_;
  ClauseKW *clausekw_;

  DisjointBehaviorClause(const DisjointBehaviorClause &);
  DisjointBehaviorClause &operator=(const DisjointBehaviorClause &);
  DisjointBehaviorClause(ListBehaviorName *p1, ClauseKW *p2);
  ~DisjointBehaviorClause();
  virtual void accept(Visitor *v);
  virtual DisjointBehaviorClause *clone() const;
  void swap(DisjointBehaviorClause &);
};

class AssignZone : public Assigns
{
public:
  Zones *zones_;

  AssignZone(const AssignZone &);
  AssignZone &operator=(const AssignZone &);
  AssignZone(Zones *p1);
  ~AssignZone();
  virtual void accept(Visitor *v);
  virtual AssignZone *clone() const;
  void swap(AssignZone &);
};

class AssignZoneFromZone : public Assigns
{
public:
  ListLexpr *listlexpr_;
  Zones *zones_;

  AssignZoneFromZone(const AssignZoneFromZone &);
  AssignZoneFromZone &operator=(const AssignZoneFromZone &);
  AssignZoneFromZone(ListLexpr *p1, Zones *p2);
  ~AssignZoneFromZone();
  virtual void accept(Visitor *v);
  virtual AssignZoneFromZone *clone() const;
  void swap(AssignZoneFromZone &);
};

class SomeZone : public Zones
{
public:
  ListLexpr *listlexpr_;

  SomeZone(const SomeZone &);
  SomeZone &operator=(const SomeZone &);
  SomeZone(ListLexpr *p1);
  ~SomeZone();
  virtual void accept(Visitor *v);
  virtual SomeZone *clone() const;
  void swap(SomeZone &);
};

class NoZone : public Zones
{
public:

  NoZone(const NoZone &);
  NoZone &operator=(const NoZone &);
  NoZone();
  ~NoZone();
  virtual void accept(Visitor *v);
  virtual NoZone *clone() const;
  void swap(NoZone &);
};

class AnAnnotation : public Annot
{
public:
  Annotation *annotation_;

  AnAnnotation(const AnAnnotation &);
  AnAnnotation &operator=(const AnAnnotation &);
  AnAnnotation(Annotation *p1);
  ~AnAnnotation();
  virtual void accept(Visitor *v);
  virtual AnAnnotation *clone() const;
  void swap(AnAnnotation &);
};

class ACSLSpec : public Annot
{
public:
  IsACSLSpec *isacslspec_;
  ListWildcard *listwildcard_;

  ACSLSpec(const ACSLSpec &);
  ACSLSpec &operator=(const ACSLSpec &);
  ACSLSpec(IsACSLSpec *p1, ListWildcard *p2);
  ~ACSLSpec();
  virtual void accept(Visitor *v);
  virtual ACSLSpec *clone() const;
  void swap(ACSLSpec &);
};

class AnnotDecl : public Annot
{
public:
  ListDecl *listdecl_;

  AnnotDecl(const AnnotDecl &);
  AnnotDecl &operator=(const AnnotDecl &);
  AnnotDecl(ListDecl *p1);
  ~AnnotDecl();
  virtual void accept(Visitor *v);
  virtual AnnotDecl *clone() const;
  void swap(AnnotDecl &);
};

class LoopAnnotation : public Annotation
{
public:
  LoopAnnotStack *loopannotstack_;

  LoopAnnotation(const LoopAnnotation &);
  LoopAnnotation &operator=(const LoopAnnotation &);
  LoopAnnotation(LoopAnnotStack *p1);
  ~LoopAnnotation();
  virtual void accept(Visitor *v);
  virtual LoopAnnotation *clone() const;
  void swap(LoopAnnotation &);
};

class ForContractAnnotation : public Annotation
{
public:
  ListBehaviorName *listbehaviorname_;
  Contract *contract_;

  ForContractAnnotation(const ForContractAnnotation &);
  ForContractAnnotation &operator=(const ForContractAnnotation &);
  ForContractAnnotation(ListBehaviorName *p1, Contract *p2);
  ~ForContractAnnotation();
  virtual void accept(Visitor *v);
  virtual ForContractAnnotation *clone() const;
  void swap(ForContractAnnotation &);
};

class ForCodeAnnotation : public Annotation
{
public:
  ListBehaviorName *listbehaviorname_;
  CodeAnnotation *codeannotation_;

  ForCodeAnnotation(const ForCodeAnnotation &);
  ForCodeAnnotation &operator=(const ForCodeAnnotation &);
  ForCodeAnnotation(ListBehaviorName *p1, CodeAnnotation *p2);
  ~ForCodeAnnotation();
  virtual void accept(Visitor *v);
  virtual ForCodeAnnotation *clone() const;
  void swap(ForCodeAnnotation &);
};

class SimplePragmaOrCodeAnnotation : public Annotation
{
public:
  PragmaOrCodeAnnotation *pragmaorcodeannotation_;

  SimplePragmaOrCodeAnnotation(const SimplePragmaOrCodeAnnotation &);
  SimplePragmaOrCodeAnnotation &operator=(const SimplePragmaOrCodeAnnotation &);
  SimplePragmaOrCodeAnnotation(PragmaOrCodeAnnotation *p1);
  ~SimplePragmaOrCodeAnnotation();
  virtual void accept(Visitor *v);
  virtual SimplePragmaOrCodeAnnotation *clone() const;
  void swap(SimplePragmaOrCodeAnnotation &);
};

class PragmaOrCodeAnnotationBeg : public Annotation
{
public:
  PragmaOrCodeAnnotation *pragmaorcodeannotation_;
  BegPragmaOrCodeAnnotation *begpragmaorcodeannotation_;

  PragmaOrCodeAnnotationBeg(const PragmaOrCodeAnnotationBeg &);
  PragmaOrCodeAnnotationBeg &operator=(const PragmaOrCodeAnnotationBeg &);
  PragmaOrCodeAnnotationBeg(PragmaOrCodeAnnotation *p1, BegPragmaOrCodeAnnotation *p2);
  ~PragmaOrCodeAnnotationBeg();
  virtual void accept(Visitor *v);
  virtual PragmaOrCodeAnnotationBeg *clone() const;
  void swap(PragmaOrCodeAnnotationBeg &);
};

class IdentifierAnnotation : public Annotation
{
public:
  Identifier *identifier_;

  IdentifierAnnotation(const IdentifierAnnotation &);
  IdentifierAnnotation &operator=(const IdentifierAnnotation &);
  IdentifierAnnotation(Identifier *p1);
  ~IdentifierAnnotation();
  virtual void accept(Visitor *v);
  virtual IdentifierAnnotation *clone() const;
  void swap(IdentifierAnnotation &);
};

class GhostAnnotation : public Annotation
{
public:

  GhostAnnotation(const GhostAnnotation &);
  GhostAnnotation &operator=(const GhostAnnotation &);
  GhostAnnotation();
  ~GhostAnnotation();
  virtual void accept(Visitor *v);
  virtual GhostAnnotation *clone() const;
  void swap(GhostAnnotation &);
};

class LoopAnnotStackInvariant : public LoopAnnotStack
{
public:
  LoopInvariant *loopinvariant_;
  LoopAnnotOpt *loopannotopt_;

  LoopAnnotStackInvariant(const LoopAnnotStackInvariant &);
  LoopAnnotStackInvariant &operator=(const LoopAnnotStackInvariant &);
  LoopAnnotStackInvariant(LoopInvariant *p1, LoopAnnotOpt *p2);
  ~LoopAnnotStackInvariant();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackInvariant *clone() const;
  void swap(LoopAnnotStackInvariant &);
};

class LoopAnnotStackEffects : public LoopAnnotStack
{
public:
  LoopEffects *loopeffects_;
  LoopAnnotOpt *loopannotopt_;

  LoopAnnotStackEffects(const LoopAnnotStackEffects &);
  LoopAnnotStackEffects &operator=(const LoopAnnotStackEffects &);
  LoopAnnotStackEffects(LoopEffects *p1, LoopAnnotOpt *p2);
  ~LoopAnnotStackEffects();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackEffects *clone() const;
  void swap(LoopAnnotStackEffects &);
};

class LoopAnnotStackAllocation : public LoopAnnotStack
{
public:
  LoopAllocation *loopallocation_;
  LoopAnnotOpt *loopannotopt_;

  LoopAnnotStackAllocation(const LoopAnnotStackAllocation &);
  LoopAnnotStackAllocation &operator=(const LoopAnnotStackAllocation &);
  LoopAnnotStackAllocation(LoopAllocation *p1, LoopAnnotOpt *p2);
  ~LoopAnnotStackAllocation();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackAllocation *clone() const;
  void swap(LoopAnnotStackAllocation &);
};

class LoopAnnotStackForBehavior : public LoopAnnotStack
{
public:
  ListBehaviorName *listbehaviorname_;
  LoopAnnotStack *loopannotstack_;

  LoopAnnotStackForBehavior(const LoopAnnotStackForBehavior &);
  LoopAnnotStackForBehavior &operator=(const LoopAnnotStackForBehavior &);
  LoopAnnotStackForBehavior(ListBehaviorName *p1, LoopAnnotStack *p2);
  ~LoopAnnotStackForBehavior();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackForBehavior *clone() const;
  void swap(LoopAnnotStackForBehavior &);
};

class LoopAnnotStackVariant : public LoopAnnotStack
{
public:
  LoopVariant *loopvariant_;
  LoopAnnotOpt *loopannotopt_;

  LoopAnnotStackVariant(const LoopAnnotStackVariant &);
  LoopAnnotStackVariant &operator=(const LoopAnnotStackVariant &);
  LoopAnnotStackVariant(LoopVariant *p1, LoopAnnotOpt *p2);
  ~LoopAnnotStackVariant();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackVariant *clone() const;
  void swap(LoopAnnotStackVariant &);
};

class LoopAnnotStackPragma : public LoopAnnotStack
{
public:
  LoopPragma *looppragma_;
  LoopAnnotOpt *loopannotopt_;

  LoopAnnotStackPragma(const LoopAnnotStackPragma &);
  LoopAnnotStackPragma &operator=(const LoopAnnotStackPragma &);
  LoopAnnotStackPragma(LoopPragma *p1, LoopAnnotOpt *p2);
  ~LoopAnnotStackPragma();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackPragma *clone() const;
  void swap(LoopAnnotStackPragma &);
};

class LoopAnnotStackGrammarExten : public LoopAnnotStack
{
public:
  LoopGrammarExtension *loopgrammarextension_;
  LoopAnnotOpt *loopannotopt_;

  LoopAnnotStackGrammarExten(const LoopAnnotStackGrammarExten &);
  LoopAnnotStackGrammarExten &operator=(const LoopAnnotStackGrammarExten &);
  LoopAnnotStackGrammarExten(LoopGrammarExtension *p1, LoopAnnotOpt *p2);
  ~LoopAnnotStackGrammarExten();
  virtual void accept(Visitor *v);
  virtual LoopAnnotStackGrammarExten *clone() const;
  void swap(LoopAnnotStackGrammarExten &);
};

class NoLoopAnnot : public LoopAnnotOpt
{
public:

  NoLoopAnnot(const NoLoopAnnot &);
  NoLoopAnnot &operator=(const NoLoopAnnot &);
  NoLoopAnnot();
  ~NoLoopAnnot();
  virtual void accept(Visitor *v);
  virtual NoLoopAnnot *clone() const;
  void swap(NoLoopAnnot &);
};

class SomeLoopAnnot : public LoopAnnotOpt
{
public:
  LoopAnnotStack *loopannotstack_;

  SomeLoopAnnot(const SomeLoopAnnot &);
  SomeLoopAnnot &operator=(const SomeLoopAnnot &);
  SomeLoopAnnot(LoopAnnotStack *p1);
  ~SomeLoopAnnot();
  virtual void accept(Visitor *v);
  virtual SomeLoopAnnot *clone() const;
  void swap(SomeLoopAnnot &);
};

class LoopAssigns : public LoopEffects
{
public:
  Assigns *assigns_;

  LoopAssigns(const LoopAssigns &);
  LoopAssigns &operator=(const LoopAssigns &);
  LoopAssigns(Assigns *p1);
  ~LoopAssigns();
  virtual void accept(Visitor *v);
  virtual LoopAssigns *clone() const;
  void swap(LoopAssigns &);
};

class SimpleLoopAllocation : public LoopAllocation
{
public:
  Allocation *allocation_;

  SimpleLoopAllocation(const SimpleLoopAllocation &);
  SimpleLoopAllocation &operator=(const SimpleLoopAllocation &);
  SimpleLoopAllocation(Allocation *p1);
  ~SimpleLoopAllocation();
  virtual void accept(Visitor *v);
  virtual SimpleLoopAllocation *clone() const;
  void swap(SimpleLoopAllocation &);
};

class SimpleLoopInvariant : public LoopInvariant
{
public:
  Lexpr *lexpr_;

  SimpleLoopInvariant(const SimpleLoopInvariant &);
  SimpleLoopInvariant &operator=(const SimpleLoopInvariant &);
  SimpleLoopInvariant(Lexpr *p1);
  ~SimpleLoopInvariant();
  virtual void accept(Visitor *v);
  virtual SimpleLoopInvariant *clone() const;
  void swap(SimpleLoopInvariant &);
};

class CheckLoopInvariant : public LoopInvariant
{
public:
  Lexpr *lexpr_;

  CheckLoopInvariant(const CheckLoopInvariant &);
  CheckLoopInvariant &operator=(const CheckLoopInvariant &);
  CheckLoopInvariant(Lexpr *p1);
  ~CheckLoopInvariant();
  virtual void accept(Visitor *v);
  virtual CheckLoopInvariant *clone() const;
  void swap(CheckLoopInvariant &);
};

class AdmitLoopInvariant : public LoopInvariant
{
public:
  Lexpr *lexpr_;

  AdmitLoopInvariant(const AdmitLoopInvariant &);
  AdmitLoopInvariant &operator=(const AdmitLoopInvariant &);
  AdmitLoopInvariant(Lexpr *p1);
  ~AdmitLoopInvariant();
  virtual void accept(Visitor *v);
  virtual AdmitLoopInvariant *clone() const;
  void swap(AdmitLoopInvariant &);
};

class SimpleLoopVariant : public LoopVariant
{
public:
  Variant *variant_;

  SimpleLoopVariant(const SimpleLoopVariant &);
  SimpleLoopVariant &operator=(const SimpleLoopVariant &);
  SimpleLoopVariant(Variant *p1);
  ~SimpleLoopVariant();
  virtual void accept(Visitor *v);
  virtual SimpleLoopVariant *clone() const;
  void swap(SimpleLoopVariant &);
};

class SimpleLoopGrammarExten : public LoopGrammarExtension
{
public:
  EXT_CODE_ANNOT ext_code_annot_;
  ExtensionContent *extensioncontent_;

  SimpleLoopGrammarExten(const SimpleLoopGrammarExten &);
  SimpleLoopGrammarExten &operator=(const SimpleLoopGrammarExten &);
  SimpleLoopGrammarExten(EXT_CODE_ANNOT p1, ExtensionContent *p2);
  ~SimpleLoopGrammarExten();
  virtual void accept(Visitor *v);
  virtual SimpleLoopGrammarExten *clone() const;
  void swap(SimpleLoopGrammarExten &);
};

class PragmaLoop : public LoopPragma
{
public:
  AnyIdentifier *anyidentifier_;
  ListLexpr *listlexpr_;

  PragmaLoop(const PragmaLoop &);
  PragmaLoop &operator=(const PragmaLoop &);
  PragmaLoop(AnyIdentifier *p1, ListLexpr *p2);
  ~PragmaLoop();
  virtual void accept(Visitor *v);
  virtual PragmaLoop *clone() const;
  void swap(PragmaLoop &);
};

class ImpactKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  ImpactKeyWordBegPragma(const ImpactKeyWordBegPragma &);
  ImpactKeyWordBegPragma &operator=(const ImpactKeyWordBegPragma &);
  ImpactKeyWordBegPragma();
  ~ImpactKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual ImpactKeyWordBegPragma *clone() const;
  void swap(ImpactKeyWordBegPragma &);
};

class SliceKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  SliceKeyWordBegPragma(const SliceKeyWordBegPragma &);
  SliceKeyWordBegPragma &operator=(const SliceKeyWordBegPragma &);
  SliceKeyWordBegPragma();
  ~SliceKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual SliceKeyWordBegPragma *clone() const;
  void swap(SliceKeyWordBegPragma &);
};

class ForKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  ForKeyWordBegPragma(const ForKeyWordBegPragma &);
  ForKeyWordBegPragma &operator=(const ForKeyWordBegPragma &);
  ForKeyWordBegPragma();
  ~ForKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual ForKeyWordBegPragma *clone() const;
  void swap(ForKeyWordBegPragma &);
};

class AssertKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  AssertKeyWordBegPragma(const AssertKeyWordBegPragma &);
  AssertKeyWordBegPragma &operator=(const AssertKeyWordBegPragma &);
  AssertKeyWordBegPragma();
  ~AssertKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual AssertKeyWordBegPragma *clone() const;
  void swap(AssertKeyWordBegPragma &);
};

class CheckKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  CheckKeyWordBegPragma(const CheckKeyWordBegPragma &);
  CheckKeyWordBegPragma &operator=(const CheckKeyWordBegPragma &);
  CheckKeyWordBegPragma();
  ~CheckKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual CheckKeyWordBegPragma *clone() const;
  void swap(CheckKeyWordBegPragma &);
};

class AdmitKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  AdmitKeyWordBegPragma(const AdmitKeyWordBegPragma &);
  AdmitKeyWordBegPragma &operator=(const AdmitKeyWordBegPragma &);
  AdmitKeyWordBegPragma();
  ~AdmitKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual AdmitKeyWordBegPragma *clone() const;
  void swap(AdmitKeyWordBegPragma &);
};

class InvariantKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  InvariantKeyWordBegPragma(const InvariantKeyWordBegPragma &);
  InvariantKeyWordBegPragma &operator=(const InvariantKeyWordBegPragma &);
  InvariantKeyWordBegPragma();
  ~InvariantKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual InvariantKeyWordBegPragma *clone() const;
  void swap(InvariantKeyWordBegPragma &);
};

class CheckInvariantKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  CheckInvariantKeyWordBegPragma(const CheckInvariantKeyWordBegPragma &);
  CheckInvariantKeyWordBegPragma &operator=(const CheckInvariantKeyWordBegPragma &);
  CheckInvariantKeyWordBegPragma();
  ~CheckInvariantKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual CheckInvariantKeyWordBegPragma *clone() const;
  void swap(CheckInvariantKeyWordBegPragma &);
};

class AdmitInvariantKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  AdmitInvariantKeyWordBegPragma(const AdmitInvariantKeyWordBegPragma &);
  AdmitInvariantKeyWordBegPragma &operator=(const AdmitInvariantKeyWordBegPragma &);
  AdmitInvariantKeyWordBegPragma();
  ~AdmitInvariantKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual AdmitInvariantKeyWordBegPragma *clone() const;
  void swap(AdmitInvariantKeyWordBegPragma &);
};

class CheckLoopKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  CheckLoopKeyWordBegPragma(const CheckLoopKeyWordBegPragma &);
  CheckLoopKeyWordBegPragma &operator=(const CheckLoopKeyWordBegPragma &);
  CheckLoopKeyWordBegPragma();
  ~CheckLoopKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual CheckLoopKeyWordBegPragma *clone() const;
  void swap(CheckLoopKeyWordBegPragma &);
};

class AdmitLoopKeyWordBegPragma : public BegPragmaOrCodeAnnotation
{
public:

  AdmitLoopKeyWordBegPragma(const AdmitLoopKeyWordBegPragma &);
  AdmitLoopKeyWordBegPragma &operator=(const AdmitLoopKeyWordBegPragma &);
  AdmitLoopKeyWordBegPragma();
  ~AdmitLoopKeyWordBegPragma();
  virtual void accept(Visitor *v);
  virtual AdmitLoopKeyWordBegPragma *clone() const;
  void swap(AdmitLoopKeyWordBegPragma &);
};

class BegExtCodeAnnotBegPragma : public BegPragmaOrCodeAnnotation
{
public:
  EXT_CODE_ANNOT ext_code_annot_;

  BegExtCodeAnnotBegPragma(const BegExtCodeAnnotBegPragma &);
  BegExtCodeAnnotBegPragma &operator=(const BegExtCodeAnnotBegPragma &);
  BegExtCodeAnnotBegPragma(EXT_CODE_ANNOT p1);
  ~BegExtCodeAnnotBegPragma();
  virtual void accept(Visitor *v);
  virtual BegExtCodeAnnotBegPragma *clone() const;
  void swap(BegExtCodeAnnotBegPragma &);
};

class PragmaCodeAnnotSlice : public PragmaOrCodeAnnotation
{
public:
  SlicePragma *slicepragma_;

  PragmaCodeAnnotSlice(const PragmaCodeAnnotSlice &);
  PragmaCodeAnnotSlice &operator=(const PragmaCodeAnnotSlice &);
  PragmaCodeAnnotSlice(SlicePragma *p1);
  ~PragmaCodeAnnotSlice();
  virtual void accept(Visitor *v);
  virtual PragmaCodeAnnotSlice *clone() const;
  void swap(PragmaCodeAnnotSlice &);
};

class PragmaCodeAnnotImpact : public PragmaOrCodeAnnotation
{
public:
  ImpactPragma *impactpragma_;

  PragmaCodeAnnotImpact(const PragmaCodeAnnotImpact &);
  PragmaCodeAnnotImpact &operator=(const PragmaCodeAnnotImpact &);
  PragmaCodeAnnotImpact(ImpactPragma *p1);
  ~PragmaCodeAnnotImpact();
  virtual void accept(Visitor *v);
  virtual PragmaCodeAnnotImpact *clone() const;
  void swap(PragmaCodeAnnotImpact &);
};

class CodeAnnot : public PragmaOrCodeAnnotation
{
public:
  CodeAnnotation *codeannotation_;

  CodeAnnot(const CodeAnnot &);
  CodeAnnot &operator=(const CodeAnnot &);
  CodeAnnot(CodeAnnotation *p1);
  ~CodeAnnot();
  virtual void accept(Visitor *v);
  virtual CodeAnnot *clone() const;
  void swap(CodeAnnot &);
};

class AssertCodeAnnot : public CodeAnnotation
{
public:
  Lexpr *lexpr_;

  AssertCodeAnnot(const AssertCodeAnnot &);
  AssertCodeAnnot &operator=(const AssertCodeAnnot &);
  AssertCodeAnnot(Lexpr *p1);
  ~AssertCodeAnnot();
  virtual void accept(Visitor *v);
  virtual AssertCodeAnnot *clone() const;
  void swap(AssertCodeAnnot &);
};

class CheckCodeAnnot : public CodeAnnotation
{
public:
  Lexpr *lexpr_;

  CheckCodeAnnot(const CheckCodeAnnot &);
  CheckCodeAnnot &operator=(const CheckCodeAnnot &);
  CheckCodeAnnot(Lexpr *p1);
  ~CheckCodeAnnot();
  virtual void accept(Visitor *v);
  virtual CheckCodeAnnot *clone() const;
  void swap(CheckCodeAnnot &);
};

class AdmitCodeAnnot : public CodeAnnotation
{
public:
  Lexpr *lexpr_;

  AdmitCodeAnnot(const AdmitCodeAnnot &);
  AdmitCodeAnnot &operator=(const AdmitCodeAnnot &);
  AdmitCodeAnnot(Lexpr *p1);
  ~AdmitCodeAnnot();
  virtual void accept(Visitor *v);
  virtual AdmitCodeAnnot *clone() const;
  void swap(AdmitCodeAnnot &);
};

class InvariantCodeAnnot : public CodeAnnotation
{
public:
  Lexpr *lexpr_;

  InvariantCodeAnnot(const InvariantCodeAnnot &);
  InvariantCodeAnnot &operator=(const InvariantCodeAnnot &);
  InvariantCodeAnnot(Lexpr *p1);
  ~InvariantCodeAnnot();
  virtual void accept(Visitor *v);
  virtual InvariantCodeAnnot *clone() const;
  void swap(InvariantCodeAnnot &);
};

class CheckInvariantCodeAnnot : public CodeAnnotation
{
public:
  Lexpr *lexpr_;

  CheckInvariantCodeAnnot(const CheckInvariantCodeAnnot &);
  CheckInvariantCodeAnnot &operator=(const CheckInvariantCodeAnnot &);
  CheckInvariantCodeAnnot(Lexpr *p1);
  ~CheckInvariantCodeAnnot();
  virtual void accept(Visitor *v);
  virtual CheckInvariantCodeAnnot *clone() const;
  void swap(CheckInvariantCodeAnnot &);
};

class AdmitInvariantCodeAnnot : public CodeAnnotation
{
public:
  Lexpr *lexpr_;

  AdmitInvariantCodeAnnot(const AdmitInvariantCodeAnnot &);
  AdmitInvariantCodeAnnot &operator=(const AdmitInvariantCodeAnnot &);
  AdmitInvariantCodeAnnot(Lexpr *p1);
  ~AdmitInvariantCodeAnnot();
  virtual void accept(Visitor *v);
  virtual AdmitInvariantCodeAnnot *clone() const;
  void swap(AdmitInvariantCodeAnnot &);
};

class ExtCodeAnnotCodeAnnot : public CodeAnnotation
{
public:
  EXT_CODE_ANNOT ext_code_annot_;
  ExtensionContent *extensioncontent_;

  ExtCodeAnnotCodeAnnot(const ExtCodeAnnotCodeAnnot &);
  ExtCodeAnnotCodeAnnot &operator=(const ExtCodeAnnotCodeAnnot &);
  ExtCodeAnnotCodeAnnot(EXT_CODE_ANNOT p1, ExtensionContent *p2);
  ~ExtCodeAnnotCodeAnnot();
  virtual void accept(Visitor *v);
  virtual ExtCodeAnnotCodeAnnot *clone() const;
  void swap(ExtCodeAnnotCodeAnnot &);
};

class PragmaSliceLexpr : public SlicePragma
{
public:
  AnyIdentifier *anyidentifier_;
  Lexpr *lexpr_;

  PragmaSliceLexpr(const PragmaSliceLexpr &);
  PragmaSliceLexpr &operator=(const PragmaSliceLexpr &);
  PragmaSliceLexpr(AnyIdentifier *p1, Lexpr *p2);
  ~PragmaSliceLexpr();
  virtual void accept(Visitor *v);
  virtual PragmaSliceLexpr *clone() const;
  void swap(PragmaSliceLexpr &);
};

class PragmaSlice : public SlicePragma
{
public:
  AnyIdentifier *anyidentifier_;

  PragmaSlice(const PragmaSlice &);
  PragmaSlice &operator=(const PragmaSlice &);
  PragmaSlice(AnyIdentifier *p1);
  ~PragmaSlice();
  virtual void accept(Visitor *v);
  virtual PragmaSlice *clone() const;
  void swap(PragmaSlice &);
};

class ImpactPragmaLexpr : public ImpactPragma
{
public:
  AnyIdentifier *anyidentifier_;
  Lexpr *lexpr_;

  ImpactPragmaLexpr(const ImpactPragmaLexpr &);
  ImpactPragmaLexpr &operator=(const ImpactPragmaLexpr &);
  ImpactPragmaLexpr(AnyIdentifier *p1, Lexpr *p2);
  ~ImpactPragmaLexpr();
  virtual void accept(Visitor *v);
  virtual ImpactPragmaLexpr *clone() const;
  void swap(ImpactPragmaLexpr &);
};

class AnImpactPragma : public ImpactPragma
{
public:
  AnyIdentifier *anyidentifier_;

  AnImpactPragma(const AnImpactPragma &);
  AnImpactPragma &operator=(const AnImpactPragma &);
  AnImpactPragma(AnyIdentifier *p1);
  ~AnImpactPragma();
  virtual void accept(Visitor *v);
  virtual AnImpactPragma *clone() const;
  void swap(AnImpactPragma &);
};

class DeclGlobalInvariant : public Decl
{
public:
  AnyIdentifier *anyidentifier_;
  Lexpr *lexpr_;

  DeclGlobalInvariant(const DeclGlobalInvariant &);
  DeclGlobalInvariant &operator=(const DeclGlobalInvariant &);
  DeclGlobalInvariant(AnyIdentifier *p1, Lexpr *p2);
  ~DeclGlobalInvariant();
  virtual void accept(Visitor *v);
  virtual DeclGlobalInvariant *clone() const;
  void swap(DeclGlobalInvariant &);
};

class DeclVolatile : public Decl
{
public:
  ListLexpr *listlexpr_;
  ListVolatileOpt *listvolatileopt_;

  DeclVolatile(const DeclVolatile &);
  DeclVolatile &operator=(const DeclVolatile &);
  DeclVolatile(ListLexpr *p1, ListVolatileOpt *p2);
  ~DeclVolatile();
  virtual void accept(Visitor *v);
  virtual DeclVolatile *clone() const;
  void swap(DeclVolatile &);
};

class DeclTypeAnnot : public Decl
{
public:
  TypeAnnot *typeannot_;

  DeclTypeAnnot(const DeclTypeAnnot &);
  DeclTypeAnnot &operator=(const DeclTypeAnnot &);
  DeclTypeAnnot(TypeAnnot *p1);
  ~DeclTypeAnnot();
  virtual void accept(Visitor *v);
  virtual DeclTypeAnnot *clone() const;
  void swap(DeclTypeAnnot &);
};

class DeclModelAnnot : public Decl
{
public:
  ModelAnnot *modelannot_;

  DeclModelAnnot(const DeclModelAnnot &);
  DeclModelAnnot &operator=(const DeclModelAnnot &);
  DeclModelAnnot(ModelAnnot *p1);
  ~DeclModelAnnot();
  virtual void accept(Visitor *v);
  virtual DeclModelAnnot *clone() const;
  void swap(DeclModelAnnot &);
};

class DeclLogicDef : public Decl
{
public:
  LogicDef *logicdef_;

  DeclLogicDef(const DeclLogicDef &);
  DeclLogicDef &operator=(const DeclLogicDef &);
  DeclLogicDef(LogicDef *p1);
  ~DeclLogicDef();
  virtual void accept(Visitor *v);
  virtual DeclLogicDef *clone() const;
  void swap(DeclLogicDef &);
};

class DeclExt : public Decl
{
public:
  ExtDecl *extdecl_;

  DeclExt(const DeclExt &);
  DeclExt &operator=(const DeclExt &);
  DeclExt(ExtDecl *p1);
  ~DeclExt();
  virtual void accept(Visitor *v);
  virtual DeclExt *clone() const;
  void swap(DeclExt &);
};

class DeclDeprecatedLogic : public Decl
{
public:
  DeprecatedLogicDecl *deprecatedlogicdecl_;

  DeclDeprecatedLogic(const DeclDeprecatedLogic &);
  DeclDeprecatedLogic &operator=(const DeclDeprecatedLogic &);
  DeclDeprecatedLogic(DeprecatedLogicDecl *p1);
  ~DeclDeprecatedLogic();
  virtual void accept(Visitor *v);
  virtual DeclDeprecatedLogic *clone() const;
  void swap(DeclDeprecatedLogic &);
};

class ExtGlobalDecl : public ExtDecl
{
public:
  EXT_GLOBAL ext_global_;
  ExtensionContent *extensioncontent_;

  ExtGlobalDecl(const ExtGlobalDecl &);
  ExtGlobalDecl &operator=(const ExtGlobalDecl &);
  ExtGlobalDecl(EXT_GLOBAL p1, ExtensionContent *p2);
  ~ExtGlobalDecl();
  virtual void accept(Visitor *v);
  virtual ExtGlobalDecl *clone() const;
  void swap(ExtGlobalDecl &);
};

class ExtGlobalBlockDecl : public ExtDecl
{
public:
  EXT_GLOBAL_BLOCK ext_global_block_;
  AnyIdentifier *anyidentifier_;
  ListExtDecl *listextdecl_;

  ExtGlobalBlockDecl(const ExtGlobalBlockDecl &);
  ExtGlobalBlockDecl &operator=(const ExtGlobalBlockDecl &);
  ExtGlobalBlockDecl(EXT_GLOBAL_BLOCK p1, AnyIdentifier *p2, ListExtDecl *p3);
  ~ExtGlobalBlockDecl();
  virtual void accept(Visitor *v);
  virtual ExtGlobalBlockDecl *clone() const;
  void swap(ExtGlobalBlockDecl &);
};

class ReadVolotile : public VolatileOpt
{
public:
  AnyIdentifier *anyidentifier_;

  ReadVolotile(const ReadVolotile &);
  ReadVolotile &operator=(const ReadVolotile &);
  ReadVolotile(AnyIdentifier *p1);
  ~ReadVolotile();
  virtual void accept(Visitor *v);
  virtual ReadVolotile *clone() const;
  void swap(ReadVolotile &);
};

class WriteVolotile : public VolatileOpt
{
public:
  AnyIdentifier *anyidentifier_;

  WriteVolotile(const WriteVolotile &);
  WriteVolotile &operator=(const WriteVolotile &);
  WriteVolotile(AnyIdentifier *p1);
  ~WriteVolotile();
  virtual void accept(Visitor *v);
  virtual WriteVolotile *clone() const;
  void swap(WriteVolotile &);
};

class TypeInvariant : public TypeAnnot
{
public:
  AnyIdentifier *anyidentifier_;
  Parameter *parameter_;
  Lexpr *lexpr_;

  TypeInvariant(const TypeInvariant &);
  TypeInvariant &operator=(const TypeInvariant &);
  TypeInvariant(AnyIdentifier *p1, Parameter *p2, Lexpr *p3);
  ~TypeInvariant();
  virtual void accept(Visitor *v);
  virtual TypeInvariant *clone() const;
  void swap(TypeInvariant &);
};

class NoSemicolon : public OptSemicolon
{
public:

  NoSemicolon(const NoSemicolon &);
  NoSemicolon &operator=(const NoSemicolon &);
  NoSemicolon();
  ~NoSemicolon();
  virtual void accept(Visitor *v);
  virtual NoSemicolon *clone() const;
  void swap(NoSemicolon &);
};

class Semicolon : public OptSemicolon
{
public:

  Semicolon(const Semicolon &);
  Semicolon &operator=(const Semicolon &);
  Semicolon();
  ~Semicolon();
  virtual void accept(Visitor *v);
  virtual Semicolon *clone() const;
  void swap(Semicolon &);
};

class ModelAnnotation : public ModelAnnot
{
public:
  TypeSpecOFTYPENAME *typespecoftypename_;
  Parameter *parameter_;
  OptSemicolon *optsemicolon_;

  ModelAnnotation(const ModelAnnotation &);
  ModelAnnotation &operator=(const ModelAnnotation &);
  ModelAnnotation(TypeSpecOFTYPENAME *p1, Parameter *p2, OptSemicolon *p3);
  ~ModelAnnotation();
  virtual void accept(Visitor *v);
  virtual ModelAnnotation *clone() const;
  void swap(ModelAnnotation &);
};

class SimplePolyIdType : public PolyIdType
{
public:
  FullIdentifier *fullidentifier_;

  SimplePolyIdType(const SimplePolyIdType &);
  SimplePolyIdType &operator=(const SimplePolyIdType &);
  SimplePolyIdType(FullIdentifier *p1);
  ~SimplePolyIdType();
  virtual void accept(Visitor *v);
  virtual SimplePolyIdType *clone() const;
  void swap(SimplePolyIdType &);
};

class PolyIdTypeAngles : public PolyIdType
{
public:
  FullIdentifier *fullidentifier_;
  ListFullIdentifier *listfullidentifier_;

  PolyIdTypeAngles(const PolyIdTypeAngles &);
  PolyIdTypeAngles &operator=(const PolyIdTypeAngles &);
  PolyIdTypeAngles(FullIdentifier *p1, ListFullIdentifier *p2);
  ~PolyIdTypeAngles();
  virtual void accept(Visitor *v);
  virtual PolyIdTypeAngles *clone() const;
  void swap(PolyIdTypeAngles &);
};

class PolyTypeId : public PolyId
{
public:
  PolyIdType *polyidtype_;

  PolyTypeId(const PolyTypeId &);
  PolyTypeId &operator=(const PolyTypeId &);
  PolyTypeId(PolyIdType *p1);
  ~PolyTypeId();
  virtual void accept(Visitor *v);
  virtual PolyTypeId *clone() const;
  void swap(PolyTypeId &);
};

class PolyIdTypeSquares : public PolyId
{
public:
  FullIdentifier *fullidentifier_;
  ListLabelName *listlabelname_;

  PolyIdTypeSquares(const PolyIdTypeSquares &);
  PolyIdTypeSquares &operator=(const PolyIdTypeSquares &);
  PolyIdTypeSquares(FullIdentifier *p1, ListLabelName *p2);
  ~PolyIdTypeSquares();
  virtual void accept(Visitor *v);
  virtual PolyIdTypeSquares *clone() const;
  void swap(PolyIdTypeSquares &);
};

class PolyIdTypeSquaresAngles : public PolyId
{
public:
  FullIdentifier *fullidentifier_;
  ListLabelName *listlabelname_;
  ListFullIdentifier *listfullidentifier_;

  PolyIdTypeSquaresAngles(const PolyIdTypeSquaresAngles &);
  PolyIdTypeSquaresAngles &operator=(const PolyIdTypeSquaresAngles &);
  PolyIdTypeSquaresAngles(FullIdentifier *p1, ListLabelName *p2, ListFullIdentifier *p3);
  ~PolyIdTypeSquaresAngles();
  virtual void accept(Visitor *v);
  virtual PolyIdTypeSquaresAngles *clone() const;
  void swap(PolyIdTypeSquaresAngles &);
};

class NoParameters : public OptParameters
{
public:

  NoParameters(const NoParameters &);
  NoParameters &operator=(const NoParameters &);
  NoParameters();
  ~NoParameters();
  virtual void accept(Visitor *v);
  virtual NoParameters *clone() const;
  void swap(NoParameters &);
};

class SomeParameters : public OptParameters
{
public:
  Parameters *parameters_;

  SomeParameters(const SomeParameters &);
  SomeParameters &operator=(const SomeParameters &);
  SomeParameters(Parameters *p1);
  ~SomeParameters();
  virtual void accept(Visitor *v);
  virtual SomeParameters *clone() const;
  void swap(SomeParameters &);
};

class AParameters : public Parameters
{
public:
  ListParameter *listparameter_;

  AParameters(const AParameters &);
  AParameters &operator=(const AParameters &);
  AParameters(ListParameter *p1);
  ~AParameters();
  virtual void accept(Visitor *v);
  virtual AParameters *clone() const;
  void swap(AParameters &);
};

class SimpleLogicDef : public LogicDef
{
public:
  LogicRtType *logicrttype_;
  PolyId *polyid_;
  OptParameters *optparameters_;
  Lexpr *lexpr_;

  SimpleLogicDef(const SimpleLogicDef &);
  SimpleLogicDef &operator=(const SimpleLogicDef &);
  SimpleLogicDef(LogicRtType *p1, PolyId *p2, OptParameters *p3, Lexpr *p4);
  ~SimpleLogicDef();
  virtual void accept(Visitor *v);
  virtual SimpleLogicDef *clone() const;
  void swap(SimpleLogicDef &);
};

class PredicateLogicDef : public LogicDef
{
public:
  PolyId *polyid_;
  OptParameters *optparameters_;
  Lexpr *lexpr_;

  PredicateLogicDef(const PredicateLogicDef &);
  PredicateLogicDef &operator=(const PredicateLogicDef &);
  PredicateLogicDef(PolyId *p1, OptParameters *p2, Lexpr *p3);
  ~PredicateLogicDef();
  virtual void accept(Visitor *v);
  virtual PredicateLogicDef *clone() const;
  void swap(PredicateLogicDef &);
};

class InductiveLogicDef : public LogicDef
{
public:
  PolyId *polyid_;
  Parameters *parameters_;
  ListIndcase *listindcase_;

  InductiveLogicDef(const InductiveLogicDef &);
  InductiveLogicDef &operator=(const InductiveLogicDef &);
  InductiveLogicDef(PolyId *p1, Parameters *p2, ListIndcase *p3);
  ~InductiveLogicDef();
  virtual void accept(Visitor *v);
  virtual InductiveLogicDef *clone() const;
  void swap(InductiveLogicDef &);
};

class LemmaLogicDef : public LogicDef
{
public:
  PolyId *polyid_;
  Lexpr *lexpr_;

  LemmaLogicDef(const LemmaLogicDef &);
  LemmaLogicDef &operator=(const LemmaLogicDef &);
  LemmaLogicDef(PolyId *p1, Lexpr *p2);
  ~LemmaLogicDef();
  virtual void accept(Visitor *v);
  virtual LemmaLogicDef *clone() const;
  void swap(LemmaLogicDef &);
};

class CheckLemmaLogicDef : public LogicDef
{
public:
  PolyId *polyid_;
  Lexpr *lexpr_;

  CheckLemmaLogicDef(const CheckLemmaLogicDef &);
  CheckLemmaLogicDef &operator=(const CheckLemmaLogicDef &);
  CheckLemmaLogicDef(PolyId *p1, Lexpr *p2);
  ~CheckLemmaLogicDef();
  virtual void accept(Visitor *v);
  virtual CheckLemmaLogicDef *clone() const;
  void swap(CheckLemmaLogicDef &);
};

class AdmitLemmaLogicDef : public LogicDef
{
public:
  PolyId *polyid_;
  Lexpr *lexpr_;

  AdmitLemmaLogicDef(const AdmitLemmaLogicDef &);
  AdmitLemmaLogicDef &operator=(const AdmitLemmaLogicDef &);
  AdmitLemmaLogicDef(PolyId *p1, Lexpr *p2);
  ~AdmitLemmaLogicDef();
  virtual void accept(Visitor *v);
  virtual AdmitLemmaLogicDef *clone() const;
  void swap(AdmitLemmaLogicDef &);
};

class AxiomaticLogicDef : public LogicDef
{
public:
  AnyIdentifier *anyidentifier_;
  ListLogicDecl *listlogicdecl_;

  AxiomaticLogicDef(const AxiomaticLogicDef &);
  AxiomaticLogicDef &operator=(const AxiomaticLogicDef &);
  AxiomaticLogicDef(AnyIdentifier *p1, ListLogicDecl *p2);
  ~AxiomaticLogicDef();
  virtual void accept(Visitor *v);
  virtual AxiomaticLogicDef *clone() const;
  void swap(AxiomaticLogicDef &);
};

class TypeLogicDef : public LogicDef
{
public:
  PolyIdType *polyidtype_;
  Typedef *typedef_;

  TypeLogicDef(const TypeLogicDef &);
  TypeLogicDef &operator=(const TypeLogicDef &);
  TypeLogicDef(PolyIdType *p1, Typedef *p2);
  ~TypeLogicDef();
  virtual void accept(Visitor *v);
  virtual TypeLogicDef *clone() const;
  void swap(TypeLogicDef &);
};

class SimpleDeprecatedLogicDecl : public DeprecatedLogicDecl
{
public:
  LogicRtType *logicrttype_;
  PolyId *polyid_;
  OptParameters *optparameters_;

  SimpleDeprecatedLogicDecl(const SimpleDeprecatedLogicDecl &);
  SimpleDeprecatedLogicDecl &operator=(const SimpleDeprecatedLogicDecl &);
  SimpleDeprecatedLogicDecl(LogicRtType *p1, PolyId *p2, OptParameters *p3);
  ~SimpleDeprecatedLogicDecl();
  virtual void accept(Visitor *v);
  virtual SimpleDeprecatedLogicDecl *clone() const;
  void swap(SimpleDeprecatedLogicDecl &);
};

class PredicateDeprecatedLogicDecl : public DeprecatedLogicDecl
{
public:
  PolyId *polyid_;
  OptParameters *optparameters_;

  PredicateDeprecatedLogicDecl(const PredicateDeprecatedLogicDecl &);
  PredicateDeprecatedLogicDecl &operator=(const PredicateDeprecatedLogicDecl &);
  PredicateDeprecatedLogicDecl(PolyId *p1, OptParameters *p2);
  ~PredicateDeprecatedLogicDecl();
  virtual void accept(Visitor *v);
  virtual PredicateDeprecatedLogicDecl *clone() const;
  void swap(PredicateDeprecatedLogicDecl &);
};

class TypeDeprecatedLogicDecl : public DeprecatedLogicDecl
{
public:
  PolyIdType *polyidtype_;

  TypeDeprecatedLogicDecl(const TypeDeprecatedLogicDecl &);
  TypeDeprecatedLogicDecl &operator=(const TypeDeprecatedLogicDecl &);
  TypeDeprecatedLogicDecl(PolyIdType *p1);
  ~TypeDeprecatedLogicDecl();
  virtual void accept(Visitor *v);
  virtual TypeDeprecatedLogicDecl *clone() const;
  void swap(TypeDeprecatedLogicDecl &);
};

class AxiomDeprecatedLogicDecl : public DeprecatedLogicDecl
{
public:
  PolyId *polyid_;
  Lexpr *lexpr_;

  AxiomDeprecatedLogicDecl(const AxiomDeprecatedLogicDecl &);
  AxiomDeprecatedLogicDecl &operator=(const AxiomDeprecatedLogicDecl &);
  AxiomDeprecatedLogicDecl(PolyId *p1, Lexpr *p2);
  ~AxiomDeprecatedLogicDecl();
  virtual void accept(Visitor *v);
  virtual AxiomDeprecatedLogicDecl *clone() const;
  void swap(AxiomDeprecatedLogicDecl &);
};

class LocidDeclDef : public LogicDecl
{
public:
  LogicDef *logicdef_;

  LocidDeclDef(const LocidDeclDef &);
  LocidDeclDef &operator=(const LocidDeclDef &);
  LocidDeclDef(LogicDef *p1);
  ~LocidDeclDef();
  virtual void accept(Visitor *v);
  virtual LocidDeclDef *clone() const;
  void swap(LocidDeclDef &);
};

class SimpleLogicDecl : public LogicDecl
{
public:
  LogicRtType *logicrttype_;
  PolyId *polyid_;
  OptParameters *optparameters_;
  ReadsClause *readsclause_;

  SimpleLogicDecl(const SimpleLogicDecl &);
  SimpleLogicDecl &operator=(const SimpleLogicDecl &);
  SimpleLogicDecl(LogicRtType *p1, PolyId *p2, OptParameters *p3, ReadsClause *p4);
  ~SimpleLogicDecl();
  virtual void accept(Visitor *v);
  virtual SimpleLogicDecl *clone() const;
  void swap(SimpleLogicDecl &);
};

class PredicateLogicDecl : public LogicDecl
{
public:
  PolyId *polyid_;
  OptParameters *optparameters_;
  ReadsClause *readsclause_;

  PredicateLogicDecl(const PredicateLogicDecl &);
  PredicateLogicDecl &operator=(const PredicateLogicDecl &);
  PredicateLogicDecl(PolyId *p1, OptParameters *p2, ReadsClause *p3);
  ~PredicateLogicDecl();
  virtual void accept(Visitor *v);
  virtual PredicateLogicDecl *clone() const;
  void swap(PredicateLogicDecl &);
};

class TypeLogicDecl : public LogicDecl
{
public:
  PolyIdType *polyidtype_;

  TypeLogicDecl(const TypeLogicDecl &);
  TypeLogicDecl &operator=(const TypeLogicDecl &);
  TypeLogicDecl(PolyIdType *p1);
  ~TypeLogicDecl();
  virtual void accept(Visitor *v);
  virtual TypeLogicDecl *clone() const;
  void swap(TypeLogicDecl &);
};

class AxiomLogicDecl : public LogicDecl
{
public:
  PolyId *polyid_;
  Lexpr *lexpr_;

  AxiomLogicDecl(const AxiomLogicDecl &);
  AxiomLogicDecl &operator=(const AxiomLogicDecl &);
  AxiomLogicDecl(PolyId *p1, Lexpr *p2);
  ~AxiomLogicDecl();
  virtual void accept(Visitor *v);
  virtual AxiomLogicDecl *clone() const;
  void swap(AxiomLogicDecl &);
};

class NoReadsClause : public ReadsClause
{
public:

  NoReadsClause(const NoReadsClause &);
  NoReadsClause &operator=(const NoReadsClause &);
  NoReadsClause();
  ~NoReadsClause();
  virtual void accept(Visitor *v);
  virtual NoReadsClause *clone() const;
  void swap(NoReadsClause &);
};

class SomeReadsClause : public ReadsClause
{
public:
  Zones *zones_;

  SomeReadsClause(const SomeReadsClause &);
  SomeReadsClause &operator=(const SomeReadsClause &);
  SomeReadsClause(Zones *p1);
  ~SomeReadsClause();
  virtual void accept(Visitor *v);
  virtual SomeReadsClause *clone() const;
  void swap(SomeReadsClause &);
};

class ListOfDatacons : public Typedef
{
public:
  ListDataconsWithSeparator *listdataconswithseparator_;

  ListOfDatacons(const ListOfDatacons &);
  ListOfDatacons &operator=(const ListOfDatacons &);
  ListOfDatacons(ListDataconsWithSeparator *p1);
  ~ListOfDatacons();
  virtual void accept(Visitor *v);
  virtual ListOfDatacons *clone() const;
  void swap(ListOfDatacons &);
};

class TypedefLogicTypeGen : public Typedef
{
public:
  LogicTypeGenOFTYPENAME *logictypegenoftypename_;

  TypedefLogicTypeGen(const TypedefLogicTypeGen &);
  TypedefLogicTypeGen &operator=(const TypedefLogicTypeGen &);
  TypedefLogicTypeGen(LogicTypeGenOFTYPENAME *p1);
  ~TypedefLogicTypeGen();
  virtual void accept(Visitor *v);
  virtual TypedefLogicTypeGen *clone() const;
  void swap(TypedefLogicTypeGen &);
};

class SimpleDataCons : public DataconsWithSeparator
{
public:
  Datacons *datacons_;

  SimpleDataCons(const SimpleDataCons &);
  SimpleDataCons &operator=(const SimpleDataCons &);
  SimpleDataCons(Datacons *p1);
  ~SimpleDataCons();
  virtual void accept(Visitor *v);
  virtual SimpleDataCons *clone() const;
  void swap(SimpleDataCons &);
};

class DataConsWithPipe : public DataconsWithSeparator
{
public:
  Datacons *datacons_;

  DataConsWithPipe(const DataConsWithPipe &);
  DataConsWithPipe &operator=(const DataConsWithPipe &);
  DataConsWithPipe(Datacons *p1);
  ~DataConsWithPipe();
  virtual void accept(Visitor *v);
  virtual DataConsWithPipe *clone() const;
  void swap(DataConsWithPipe &);
};

class DataConsFullIdentifier : public Datacons
{
public:
  FullIdentifier *fullidentifier_;

  DataConsFullIdentifier(const DataConsFullIdentifier &);
  DataConsFullIdentifier &operator=(const DataConsFullIdentifier &);
  DataConsFullIdentifier(FullIdentifier *p1);
  ~DataConsFullIdentifier();
  virtual void accept(Visitor *v);
  virtual DataConsFullIdentifier *clone() const;
  void swap(DataConsFullIdentifier &);
};

class DataConsFullIdentifierFun : public Datacons
{
public:
  FullIdentifier *fullidentifier_;
  ListLogicTypeGenOFTYPENAME *listlogictypegenoftypename_;

  DataConsFullIdentifierFun(const DataConsFullIdentifierFun &);
  DataConsFullIdentifierFun &operator=(const DataConsFullIdentifierFun &);
  DataConsFullIdentifierFun(FullIdentifier *p1, ListLogicTypeGenOFTYPENAME *p2);
  ~DataConsFullIdentifierFun();
  virtual void accept(Visitor *v);
  virtual DataConsFullIdentifierFun *clone() const;
  void swap(DataConsFullIdentifierFun &);
};

class IndCase : public Indcase
{
public:
  PolyId *polyid_;
  Lexpr *lexpr_;

  IndCase(const IndCase &);
  IndCase &operator=(const IndCase &);
  IndCase(PolyId *p1, Lexpr *p2);
  ~IndCase();
  virtual void accept(Visitor *v);
  virtual IndCase *clone() const;
  void swap(IndCase &);
};

class OptLabelOne : public OptLabel
{
public:
  OptLabelList *optlabellist_;

  OptLabelOne(const OptLabelOne &);
  OptLabelOne &operator=(const OptLabelOne &);
  OptLabelOne(OptLabelList *p1);
  ~OptLabelOne();
  virtual void accept(Visitor *v);
  virtual OptLabelOne *clone() const;
  void swap(OptLabelOne &);
};

class OptLabelTwo : public OptLabel
{
public:
  OptLabelList *optlabellist_;

  OptLabelTwo(const OptLabelTwo &);
  OptLabelTwo &operator=(const OptLabelTwo &);
  OptLabelTwo(OptLabelList *p1);
  ~OptLabelTwo();
  virtual void accept(Visitor *v);
  virtual OptLabelTwo *clone() const;
  void swap(OptLabelTwo &);
};

class NoLableList : public OptLabelList
{
public:

  NoLableList(const NoLableList &);
  NoLableList &operator=(const NoLableList &);
  NoLableList();
  ~NoLableList();
  virtual void accept(Visitor *v);
  virtual NoLableList *clone() const;
  void swap(NoLableList &);
};

class LableList : public OptLabelList
{
public:
  ListLabelName *listlabelname_;

  LableList(const LableList &);
  LableList &operator=(const LableList &);
  LableList(ListLabelName *p1);
  ~LableList();
  virtual void accept(Visitor *v);
  virtual LableList *clone() const;
  void swap(LableList &);
};

class LableName : public LabelName
{
public:
  AnyIdentifier *anyidentifier_;

  LableName(const LableName &);
  LableName &operator=(const LableName &);
  LableName(AnyIdentifier *p1);
  ~LableName();
  virtual void accept(Visitor *v);
  virtual LableName *clone() const;
  void swap(LableName &);
};

class EmptyBehaviorNameList : public BehaviorNameList
{
public:

  EmptyBehaviorNameList(const EmptyBehaviorNameList &);
  EmptyBehaviorNameList &operator=(const EmptyBehaviorNameList &);
  EmptyBehaviorNameList();
  ~EmptyBehaviorNameList();
  virtual void accept(Visitor *v);
  virtual EmptyBehaviorNameList *clone() const;
  void swap(EmptyBehaviorNameList &);
};

class AnBehaviorNameList : public BehaviorNameList
{
public:
  ListBehaviorName *listbehaviorname_;

  AnBehaviorNameList(const AnBehaviorNameList &);
  AnBehaviorNameList &operator=(const AnBehaviorNameList &);
  AnBehaviorNameList(ListBehaviorName *p1);
  ~AnBehaviorNameList();
  virtual void accept(Visitor *v);
  virtual AnBehaviorNameList *clone() const;
  void swap(AnBehaviorNameList &);
};

class BehaviorNameAnyIdent : public BehaviorName
{
public:
  AnyIdentifier *anyidentifier_;

  BehaviorNameAnyIdent(const BehaviorNameAnyIdent &);
  BehaviorNameAnyIdent &operator=(const BehaviorNameAnyIdent &);
  BehaviorNameAnyIdent(AnyIdentifier *p1);
  ~BehaviorNameAnyIdent();
  virtual void accept(Visitor *v);
  virtual BehaviorNameAnyIdent *clone() const;
  void swap(BehaviorNameAnyIdent &);
};

class SimpleIdentifierAny : public AnyIdentifier
{
public:
  Identifier *identifier_;

  SimpleIdentifierAny(const SimpleIdentifierAny &);
  SimpleIdentifierAny &operator=(const SimpleIdentifierAny &);
  SimpleIdentifierAny(Identifier *p1);
  ~SimpleIdentifierAny();
  virtual void accept(Visitor *v);
  virtual SimpleIdentifierAny *clone() const;
  void swap(SimpleIdentifierAny &);
};

class ACSLTypenameIdentifier : public AnyIdentifier
{
public:
  IsACSLTypename *isacsltypename_;

  ACSLTypenameIdentifier(const ACSLTypenameIdentifier &);
  ACSLTypenameIdentifier &operator=(const ACSLTypenameIdentifier &);
  ACSLTypenameIdentifier(IsACSLTypename *p1);
  ~ACSLTypenameIdentifier();
  virtual void accept(Visitor *v);
  virtual ACSLTypenameIdentifier *clone() const;
  void swap(ACSLTypenameIdentifier &);
};

class TypenameIdentifier : public AnyIdentifier
{
public:
  TYPENAME typename_;

  TypenameIdentifier(const TypenameIdentifier &);
  TypenameIdentifier &operator=(const TypenameIdentifier &);
  TypenameIdentifier(TYPENAME p1);
  ~TypenameIdentifier();
  virtual void accept(Visitor *v);
  virtual TypenameIdentifier *clone() const;
  void swap(TypenameIdentifier &);
};

class KeywordIdentifier : public AnyIdentifier
{
public:
  Keyword *keyword_;

  KeywordIdentifier(const KeywordIdentifier &);
  KeywordIdentifier &operator=(const KeywordIdentifier &);
  KeywordIdentifier(Keyword *p1);
  ~KeywordIdentifier();
  virtual void accept(Visitor *v);
  virtual KeywordIdentifier *clone() const;
  void swap(KeywordIdentifier &);
};

class Typename : public IdentifierOrTypename
{
public:
  TYPENAME typename_;

  Typename(const Typename &);
  Typename &operator=(const Typename &);
  Typename(TYPENAME p1);
  ~Typename();
  virtual void accept(Visitor *v);
  virtual Typename *clone() const;
  void swap(Typename &);
};

class AnFullIdentifier : public IdentifierOrTypename
{
public:
  FullIdentifier *fullidentifier_;

  AnFullIdentifier(const AnFullIdentifier &);
  AnFullIdentifier &operator=(const AnFullIdentifier &);
  AnFullIdentifier(FullIdentifier *p1);
  ~AnFullIdentifier();
  virtual void accept(Visitor *v);
  virtual AnFullIdentifier *clone() const;
  void swap(AnFullIdentifier &);
};

class ACSLTypename : public IdentifierOrTypenameFull
{
public:
  IsACSLTypename *isacsltypename_;

  ACSLTypename(const ACSLTypename &);
  ACSLTypename &operator=(const ACSLTypename &);
  ACSLTypename(IsACSLTypename *p1);
  ~ACSLTypename();
  virtual void accept(Visitor *v);
  virtual ACSLTypename *clone() const;
  void swap(ACSLTypename &);
};

class AnIdentifierOrTypename : public IdentifierOrTypenameFull
{
public:
  IdentifierOrTypename *identifierortypename_;

  AnIdentifierOrTypename(const AnIdentifierOrTypename &);
  AnIdentifierOrTypename &operator=(const AnIdentifierOrTypename &);
  AnIdentifierOrTypename(IdentifierOrTypename *p1);
  ~AnIdentifierOrTypename();
  virtual void accept(Visitor *v);
  virtual AnIdentifierOrTypename *clone() const;
  void swap(AnIdentifierOrTypename &);
};

class IdentifierIdent : public Identifier
{
public:
  Ident ident_;

  IdentifierIdent(const IdentifierIdent &);
  IdentifierIdent &operator=(const IdentifierIdent &);
  IdentifierIdent(Ident p1);
  ~IdentifierIdent();
  virtual void accept(Visitor *v);
  virtual IdentifierIdent *clone() const;
  void swap(IdentifierIdent &);
};

class BehaviorsKeyWord : public Identifier
{
public:

  BehaviorsKeyWord(const BehaviorsKeyWord &);
  BehaviorsKeyWord &operator=(const BehaviorsKeyWord &);
  BehaviorsKeyWord();
  ~BehaviorsKeyWord();
  virtual void accept(Visitor *v);
  virtual BehaviorsKeyWord *clone() const;
  void swap(BehaviorsKeyWord &);
};

class LabelKeyWord : public Identifier
{
public:

  LabelKeyWord(const LabelKeyWord &);
  LabelKeyWord &operator=(const LabelKeyWord &);
  LabelKeyWord();
  ~LabelKeyWord();
  virtual void accept(Visitor *v);
  virtual LabelKeyWord *clone() const;
  void swap(LabelKeyWord &);
};

class ReadsKeyWord : public Identifier
{
public:

  ReadsKeyWord(const ReadsKeyWord &);
  ReadsKeyWord &operator=(const ReadsKeyWord &);
  ReadsKeyWord();
  ~ReadsKeyWord();
  virtual void accept(Visitor *v);
  virtual ReadsKeyWord *clone() const;
  void swap(ReadsKeyWord &);
};

class WritesKeyWord : public Identifier
{
public:

  WritesKeyWord(const WritesKeyWord &);
  WritesKeyWord &operator=(const WritesKeyWord &);
  WritesKeyWord();
  ~WritesKeyWord();
  virtual void accept(Visitor *v);
  virtual WritesKeyWord *clone() const;
  void swap(WritesKeyWord &);
};

class BoendedVarFullIdentifier : public BoundedVar
{
public:
  FullIdentifier *fullidentifier_;

  BoendedVarFullIdentifier(const BoendedVarFullIdentifier &);
  BoendedVarFullIdentifier &operator=(const BoendedVarFullIdentifier &);
  BoendedVarFullIdentifier(FullIdentifier *p1);
  ~BoendedVarFullIdentifier();
  virtual void accept(Visitor *v);
  virtual BoendedVarFullIdentifier *clone() const;
  void swap(BoendedVarFullIdentifier &);
};

class BoendedVarACSLTypename : public BoundedVar
{
public:
  IsACSLTypename *isacsltypename_;

  BoendedVarACSLTypename(const BoendedVarACSLTypename &);
  BoendedVarACSLTypename &operator=(const BoendedVarACSLTypename &);
  BoendedVarACSLTypename(IsACSLTypename *p1);
  ~BoendedVarACSLTypename();
  virtual void accept(Visitor *v);
  virtual BoendedVarACSLTypename *clone() const;
  void swap(BoendedVarACSLTypename &);
};

class BoendedVarTypename : public BoundedVar
{
public:
  TYPENAME typename_;

  BoendedVarTypename(const BoendedVarTypename &);
  BoendedVarTypename &operator=(const BoendedVarTypename &);
  BoendedVarTypename(TYPENAME p1);
  ~BoendedVarTypename();
  virtual void accept(Visitor *v);
  virtual BoendedVarTypename *clone() const;
  void swap(BoendedVarTypename &);
};

class CharKeyWord : public CKeyword
{
public:

  CharKeyWord(const CharKeyWord &);
  CharKeyWord &operator=(const CharKeyWord &);
  CharKeyWord();
  ~CharKeyWord();
  virtual void accept(Visitor *v);
  virtual CharKeyWord *clone() const;
  void swap(CharKeyWord &);
};

class BooleanKeyWord : public CKeyword
{
public:

  BooleanKeyWord(const BooleanKeyWord &);
  BooleanKeyWord &operator=(const BooleanKeyWord &);
  BooleanKeyWord();
  ~BooleanKeyWord();
  virtual void accept(Visitor *v);
  virtual BooleanKeyWord *clone() const;
  void swap(BooleanKeyWord &);
};

class BoolKeyWord : public CKeyword
{
public:

  BoolKeyWord(const BoolKeyWord &);
  BoolKeyWord &operator=(const BoolKeyWord &);
  BoolKeyWord();
  ~BoolKeyWord();
  virtual void accept(Visitor *v);
  virtual BoolKeyWord *clone() const;
  void swap(BoolKeyWord &);
};

class ConstKeyWord : public CKeyword
{
public:

  ConstKeyWord(const ConstKeyWord &);
  ConstKeyWord &operator=(const ConstKeyWord &);
  ConstKeyWord();
  ~ConstKeyWord();
  virtual void accept(Visitor *v);
  virtual ConstKeyWord *clone() const;
  void swap(ConstKeyWord &);
};

class DoubleKeyWord : public CKeyword
{
public:

  DoubleKeyWord(const DoubleKeyWord &);
  DoubleKeyWord &operator=(const DoubleKeyWord &);
  DoubleKeyWord();
  ~DoubleKeyWord();
  virtual void accept(Visitor *v);
  virtual DoubleKeyWord *clone() const;
  void swap(DoubleKeyWord &);
};

class EnumKeyWord : public CKeyword
{
public:

  EnumKeyWord(const EnumKeyWord &);
  EnumKeyWord &operator=(const EnumKeyWord &);
  EnumKeyWord();
  ~EnumKeyWord();
  virtual void accept(Visitor *v);
  virtual EnumKeyWord *clone() const;
  void swap(EnumKeyWord &);
};

class ElseKeyWord : public CKeyword
{
public:

  ElseKeyWord(const ElseKeyWord &);
  ElseKeyWord &operator=(const ElseKeyWord &);
  ElseKeyWord();
  ~ElseKeyWord();
  virtual void accept(Visitor *v);
  virtual ElseKeyWord *clone() const;
  void swap(ElseKeyWord &);
};

class FloatKeyWord : public CKeyword
{
public:

  FloatKeyWord(const FloatKeyWord &);
  FloatKeyWord &operator=(const FloatKeyWord &);
  FloatKeyWord();
  ~FloatKeyWord();
  virtual void accept(Visitor *v);
  virtual FloatKeyWord *clone() const;
  void swap(FloatKeyWord &);
};

class IfKeyWord : public CKeyword
{
public:

  IfKeyWord(const IfKeyWord &);
  IfKeyWord &operator=(const IfKeyWord &);
  IfKeyWord();
  ~IfKeyWord();
  virtual void accept(Visitor *v);
  virtual IfKeyWord *clone() const;
  void swap(IfKeyWord &);
};

class IntKeyWord : public CKeyword
{
public:

  IntKeyWord(const IntKeyWord &);
  IntKeyWord &operator=(const IntKeyWord &);
  IntKeyWord();
  ~IntKeyWord();
  virtual void accept(Visitor *v);
  virtual IntKeyWord *clone() const;
  void swap(IntKeyWord &);
};

class LongKeyWord : public CKeyword
{
public:

  LongKeyWord(const LongKeyWord &);
  LongKeyWord &operator=(const LongKeyWord &);
  LongKeyWord();
  ~LongKeyWord();
  virtual void accept(Visitor *v);
  virtual LongKeyWord *clone() const;
  void swap(LongKeyWord &);
};

class ShortKeyWord : public CKeyword
{
public:

  ShortKeyWord(const ShortKeyWord &);
  ShortKeyWord &operator=(const ShortKeyWord &);
  ShortKeyWord();
  ~ShortKeyWord();
  virtual void accept(Visitor *v);
  virtual ShortKeyWord *clone() const;
  void swap(ShortKeyWord &);
};

class SignedKeyWord : public CKeyword
{
public:

  SignedKeyWord(const SignedKeyWord &);
  SignedKeyWord &operator=(const SignedKeyWord &);
  SignedKeyWord();
  ~SignedKeyWord();
  virtual void accept(Visitor *v);
  virtual SignedKeyWord *clone() const;
  void swap(SignedKeyWord &);
};

class SizeofKeyWord : public CKeyword
{
public:

  SizeofKeyWord(const SizeofKeyWord &);
  SizeofKeyWord &operator=(const SizeofKeyWord &);
  SizeofKeyWord();
  ~SizeofKeyWord();
  virtual void accept(Visitor *v);
  virtual SizeofKeyWord *clone() const;
  void swap(SizeofKeyWord &);
};

class StaticKeyWord : public CKeyword
{
public:

  StaticKeyWord(const StaticKeyWord &);
  StaticKeyWord &operator=(const StaticKeyWord &);
  StaticKeyWord();
  ~StaticKeyWord();
  virtual void accept(Visitor *v);
  virtual StaticKeyWord *clone() const;
  void swap(StaticKeyWord &);
};

class StructKeyWord : public CKeyword
{
public:

  StructKeyWord(const StructKeyWord &);
  StructKeyWord &operator=(const StructKeyWord &);
  StructKeyWord();
  ~StructKeyWord();
  virtual void accept(Visitor *v);
  virtual StructKeyWord *clone() const;
  void swap(StructKeyWord &);
};

class UnionKeyWord : public CKeyword
{
public:

  UnionKeyWord(const UnionKeyWord &);
  UnionKeyWord &operator=(const UnionKeyWord &);
  UnionKeyWord();
  ~UnionKeyWord();
  virtual void accept(Visitor *v);
  virtual UnionKeyWord *clone() const;
  void swap(UnionKeyWord &);
};

class UnsignedKeyWord : public CKeyword
{
public:

  UnsignedKeyWord(const UnsignedKeyWord &);
  UnsignedKeyWord &operator=(const UnsignedKeyWord &);
  UnsignedKeyWord();
  ~UnsignedKeyWord();
  virtual void accept(Visitor *v);
  virtual UnsignedKeyWord *clone() const;
  void swap(UnsignedKeyWord &);
};

class VoidKeyWord : public CKeyword
{
public:

  VoidKeyWord(const VoidKeyWord &);
  VoidKeyWord &operator=(const VoidKeyWord &);
  VoidKeyWord();
  ~VoidKeyWord();
  virtual void accept(Visitor *v);
  virtual VoidKeyWord *clone() const;
  void swap(VoidKeyWord &);
};

class CaseKeyWord : public ACSLCKeyword
{
public:

  CaseKeyWord(const CaseKeyWord &);
  CaseKeyWord &operator=(const CaseKeyWord &);
  CaseKeyWord();
  ~CaseKeyWord();
  virtual void accept(Visitor *v);
  virtual CaseKeyWord *clone() const;
  void swap(CaseKeyWord &);
};

class ForKeyWord : public ACSLCKeyword
{
public:

  ForKeyWord(const ForKeyWord &);
  ForKeyWord &operator=(const ForKeyWord &);
  ForKeyWord();
  ~ForKeyWord();
  virtual void accept(Visitor *v);
  virtual ForKeyWord *clone() const;
  void swap(ForKeyWord &);
};

class VolatileKeyWord : public ACSLCKeyword
{
public:

  VolatileKeyWord(const VolatileKeyWord &);
  VolatileKeyWord &operator=(const VolatileKeyWord &);
  VolatileKeyWord();
  ~VolatileKeyWord();
  virtual void accept(Visitor *v);
  virtual VolatileKeyWord *clone() const;
  void swap(VolatileKeyWord &);
};

class EnsuresKeyWord : public PostCond
{
public:

  EnsuresKeyWord(const EnsuresKeyWord &);
  EnsuresKeyWord &operator=(const EnsuresKeyWord &);
  EnsuresKeyWord();
  ~EnsuresKeyWord();
  virtual void accept(Visitor *v);
  virtual EnsuresKeyWord *clone() const;
  void swap(EnsuresKeyWord &);
};

class ExitsKeyWord : public PostCond
{
public:

  ExitsKeyWord(const ExitsKeyWord &);
  ExitsKeyWord &operator=(const ExitsKeyWord &);
  ExitsKeyWord();
  ~ExitsKeyWord();
  virtual void accept(Visitor *v);
  virtual ExitsKeyWord *clone() const;
  void swap(ExitsKeyWord &);
};

class BreaksKeyWord : public PostCond
{
public:

  BreaksKeyWord(const BreaksKeyWord &);
  BreaksKeyWord &operator=(const BreaksKeyWord &);
  BreaksKeyWord();
  ~BreaksKeyWord();
  virtual void accept(Visitor *v);
  virtual BreaksKeyWord *clone() const;
  void swap(BreaksKeyWord &);
};

class ContinuesKeyWord : public PostCond
{
public:

  ContinuesKeyWord(const ContinuesKeyWord &);
  ContinuesKeyWord &operator=(const ContinuesKeyWord &);
  ContinuesKeyWord();
  ~ContinuesKeyWord();
  virtual void accept(Visitor *v);
  virtual ContinuesKeyWord *clone() const;
  void swap(ContinuesKeyWord &);
};

class ReturnsKeyWord : public PostCond
{
public:

  ReturnsKeyWord(const ReturnsKeyWord &);
  ReturnsKeyWord &operator=(const ReturnsKeyWord &);
  ReturnsKeyWord();
  ~ReturnsKeyWord();
  virtual void accept(Visitor *v);
  virtual ReturnsKeyWord *clone() const;
  void swap(ReturnsKeyWord &);
};

class CheckEnsuresKeyWord : public PostCond
{
public:

  CheckEnsuresKeyWord(const CheckEnsuresKeyWord &);
  CheckEnsuresKeyWord &operator=(const CheckEnsuresKeyWord &);
  CheckEnsuresKeyWord();
  ~CheckEnsuresKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckEnsuresKeyWord *clone() const;
  void swap(CheckEnsuresKeyWord &);
};

class CheckExitsKeyWord : public PostCond
{
public:

  CheckExitsKeyWord(const CheckExitsKeyWord &);
  CheckExitsKeyWord &operator=(const CheckExitsKeyWord &);
  CheckExitsKeyWord();
  ~CheckExitsKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckExitsKeyWord *clone() const;
  void swap(CheckExitsKeyWord &);
};

class CheckBreaksKeyWord : public PostCond
{
public:

  CheckBreaksKeyWord(const CheckBreaksKeyWord &);
  CheckBreaksKeyWord &operator=(const CheckBreaksKeyWord &);
  CheckBreaksKeyWord();
  ~CheckBreaksKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckBreaksKeyWord *clone() const;
  void swap(CheckBreaksKeyWord &);
};

class CheckContinuesKeyWord : public PostCond
{
public:

  CheckContinuesKeyWord(const CheckContinuesKeyWord &);
  CheckContinuesKeyWord &operator=(const CheckContinuesKeyWord &);
  CheckContinuesKeyWord();
  ~CheckContinuesKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckContinuesKeyWord *clone() const;
  void swap(CheckContinuesKeyWord &);
};

class CheckReturnsKeyWord : public PostCond
{
public:

  CheckReturnsKeyWord(const CheckReturnsKeyWord &);
  CheckReturnsKeyWord &operator=(const CheckReturnsKeyWord &);
  CheckReturnsKeyWord();
  ~CheckReturnsKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckReturnsKeyWord *clone() const;
  void swap(CheckReturnsKeyWord &);
};

class AdmitEnsuresKeyWord : public PostCond
{
public:

  AdmitEnsuresKeyWord(const AdmitEnsuresKeyWord &);
  AdmitEnsuresKeyWord &operator=(const AdmitEnsuresKeyWord &);
  AdmitEnsuresKeyWord();
  ~AdmitEnsuresKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitEnsuresKeyWord *clone() const;
  void swap(AdmitEnsuresKeyWord &);
};

class AdmitExitsKeyWord : public PostCond
{
public:

  AdmitExitsKeyWord(const AdmitExitsKeyWord &);
  AdmitExitsKeyWord &operator=(const AdmitExitsKeyWord &);
  AdmitExitsKeyWord();
  ~AdmitExitsKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitExitsKeyWord *clone() const;
  void swap(AdmitExitsKeyWord &);
};

class AdmitBreaksKeyWord : public PostCond
{
public:

  AdmitBreaksKeyWord(const AdmitBreaksKeyWord &);
  AdmitBreaksKeyWord &operator=(const AdmitBreaksKeyWord &);
  AdmitBreaksKeyWord();
  ~AdmitBreaksKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitBreaksKeyWord *clone() const;
  void swap(AdmitBreaksKeyWord &);
};

class AdmitContinuesKeyWord : public PostCond
{
public:

  AdmitContinuesKeyWord(const AdmitContinuesKeyWord &);
  AdmitContinuesKeyWord &operator=(const AdmitContinuesKeyWord &);
  AdmitContinuesKeyWord();
  ~AdmitContinuesKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitContinuesKeyWord *clone() const;
  void swap(AdmitContinuesKeyWord &);
};

class AdmitReturnsKeyWord : public PostCond
{
public:

  AdmitReturnsKeyWord(const AdmitReturnsKeyWord &);
  AdmitReturnsKeyWord &operator=(const AdmitReturnsKeyWord &);
  AdmitReturnsKeyWord();
  ~AdmitReturnsKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitReturnsKeyWord *clone() const;
  void swap(AdmitReturnsKeyWord &);
};

class PostCondKeyWord : public IsACSLSpec
{
public:
  PostCond *postcond_;

  PostCondKeyWord(const PostCondKeyWord &);
  PostCondKeyWord &operator=(const PostCondKeyWord &);
  PostCondKeyWord(PostCond *p1);
  ~PostCondKeyWord();
  virtual void accept(Visitor *v);
  virtual PostCondKeyWord *clone() const;
  void swap(PostCondKeyWord &);
};

class ExtContractKeyWord : public IsACSLSpec
{
public:
  EXT_CONTRACT ext_contract_;

  ExtContractKeyWord(const ExtContractKeyWord &);
  ExtContractKeyWord &operator=(const ExtContractKeyWord &);
  ExtContractKeyWord(EXT_CONTRACT p1);
  ~ExtContractKeyWord();
  virtual void accept(Visitor *v);
  virtual ExtContractKeyWord *clone() const;
  void swap(ExtContractKeyWord &);
};

class AssignsKeyWord : public IsACSLSpec
{
public:

  AssignsKeyWord(const AssignsKeyWord &);
  AssignsKeyWord &operator=(const AssignsKeyWord &);
  AssignsKeyWord();
  ~AssignsKeyWord();
  virtual void accept(Visitor *v);
  virtual AssignsKeyWord *clone() const;
  void swap(AssignsKeyWord &);
};

class AllocatesKeyWord : public IsACSLSpec
{
public:

  AllocatesKeyWord(const AllocatesKeyWord &);
  AllocatesKeyWord &operator=(const AllocatesKeyWord &);
  AllocatesKeyWord();
  ~AllocatesKeyWord();
  virtual void accept(Visitor *v);
  virtual AllocatesKeyWord *clone() const;
  void swap(AllocatesKeyWord &);
};

class FreesKeyWord : public IsACSLSpec
{
public:

  FreesKeyWord(const FreesKeyWord &);
  FreesKeyWord &operator=(const FreesKeyWord &);
  FreesKeyWord();
  ~FreesKeyWord();
  virtual void accept(Visitor *v);
  virtual FreesKeyWord *clone() const;
  void swap(FreesKeyWord &);
};

class BehaviorKeyWord : public IsACSLSpec
{
public:

  BehaviorKeyWord(const BehaviorKeyWord &);
  BehaviorKeyWord &operator=(const BehaviorKeyWord &);
  BehaviorKeyWord();
  ~BehaviorKeyWord();
  virtual void accept(Visitor *v);
  virtual BehaviorKeyWord *clone() const;
  void swap(BehaviorKeyWord &);
};

class RequiresKeyWord : public IsACSLSpec
{
public:

  RequiresKeyWord(const RequiresKeyWord &);
  RequiresKeyWord &operator=(const RequiresKeyWord &);
  RequiresKeyWord();
  ~RequiresKeyWord();
  virtual void accept(Visitor *v);
  virtual RequiresKeyWord *clone() const;
  void swap(RequiresKeyWord &);
};

class CheckRequiresKeyWord : public IsACSLSpec
{
public:

  CheckRequiresKeyWord(const CheckRequiresKeyWord &);
  CheckRequiresKeyWord &operator=(const CheckRequiresKeyWord &);
  CheckRequiresKeyWord();
  ~CheckRequiresKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckRequiresKeyWord *clone() const;
  void swap(CheckRequiresKeyWord &);
};

class AdmitRequiresKeyWord : public IsACSLSpec
{
public:

  AdmitRequiresKeyWord(const AdmitRequiresKeyWord &);
  AdmitRequiresKeyWord &operator=(const AdmitRequiresKeyWord &);
  AdmitRequiresKeyWord();
  ~AdmitRequiresKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitRequiresKeyWord *clone() const;
  void swap(AdmitRequiresKeyWord &);
};

class TerminatesKeyWord : public IsACSLSpec
{
public:

  TerminatesKeyWord(const TerminatesKeyWord &);
  TerminatesKeyWord &operator=(const TerminatesKeyWord &);
  TerminatesKeyWord();
  ~TerminatesKeyWord();
  virtual void accept(Visitor *v);
  virtual TerminatesKeyWord *clone() const;
  void swap(TerminatesKeyWord &);
};

class CompleteKeyWord : public IsACSLSpec
{
public:

  CompleteKeyWord(const CompleteKeyWord &);
  CompleteKeyWord &operator=(const CompleteKeyWord &);
  CompleteKeyWord();
  ~CompleteKeyWord();
  virtual void accept(Visitor *v);
  virtual CompleteKeyWord *clone() const;
  void swap(CompleteKeyWord &);
};

class DecreasesKeyWord : public IsACSLSpec
{
public:

  DecreasesKeyWord(const DecreasesKeyWord &);
  DecreasesKeyWord &operator=(const DecreasesKeyWord &);
  DecreasesKeyWord();
  ~DecreasesKeyWord();
  virtual void accept(Visitor *v);
  virtual DecreasesKeyWord *clone() const;
  void swap(DecreasesKeyWord &);
};

class DisjointKeyWord : public IsACSLSpec
{
public:

  DisjointKeyWord(const DisjointKeyWord &);
  DisjointKeyWord &operator=(const DisjointKeyWord &);
  DisjointKeyWord();
  ~DisjointKeyWord();
  virtual void accept(Visitor *v);
  virtual DisjointKeyWord *clone() const;
  void swap(DisjointKeyWord &);
};

class ExtCodeAnnotKeyWord : public IsACSLDeclOrCodeAnnot
{
public:
  EXT_CODE_ANNOT ext_code_annot_;

  ExtCodeAnnotKeyWord(const ExtCodeAnnotKeyWord &);
  ExtCodeAnnotKeyWord &operator=(const ExtCodeAnnotKeyWord &);
  ExtCodeAnnotKeyWord(EXT_CODE_ANNOT p1);
  ~ExtCodeAnnotKeyWord();
  virtual void accept(Visitor *v);
  virtual ExtCodeAnnotKeyWord *clone() const;
  void swap(ExtCodeAnnotKeyWord &);
};

class ExtGlobalKeyWord : public IsACSLDeclOrCodeAnnot
{
public:
  EXT_GLOBAL ext_global_;

  ExtGlobalKeyWord(const ExtGlobalKeyWord &);
  ExtGlobalKeyWord &operator=(const ExtGlobalKeyWord &);
  ExtGlobalKeyWord(EXT_GLOBAL p1);
  ~ExtGlobalKeyWord();
  virtual void accept(Visitor *v);
  virtual ExtGlobalKeyWord *clone() const;
  void swap(ExtGlobalKeyWord &);
};

class ExtGlobalBlockKeyWord : public IsACSLDeclOrCodeAnnot
{
public:
  EXT_GLOBAL_BLOCK ext_global_block_;

  ExtGlobalBlockKeyWord(const ExtGlobalBlockKeyWord &);
  ExtGlobalBlockKeyWord &operator=(const ExtGlobalBlockKeyWord &);
  ExtGlobalBlockKeyWord(EXT_GLOBAL_BLOCK p1);
  ~ExtGlobalBlockKeyWord();
  virtual void accept(Visitor *v);
  virtual ExtGlobalBlockKeyWord *clone() const;
  void swap(ExtGlobalBlockKeyWord &);
};

class AssumesKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AssumesKeyWord(const AssumesKeyWord &);
  AssumesKeyWord &operator=(const AssumesKeyWord &);
  AssumesKeyWord();
  ~AssumesKeyWord();
  virtual void accept(Visitor *v);
  virtual AssumesKeyWord *clone() const;
  void swap(AssumesKeyWord &);
};

class AssertKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AssertKeyWord(const AssertKeyWord &);
  AssertKeyWord &operator=(const AssertKeyWord &);
  AssertKeyWord();
  ~AssertKeyWord();
  virtual void accept(Visitor *v);
  virtual AssertKeyWord *clone() const;
  void swap(AssertKeyWord &);
};

class CheckKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  CheckKeyWord(const CheckKeyWord &);
  CheckKeyWord &operator=(const CheckKeyWord &);
  CheckKeyWord();
  ~CheckKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckKeyWord *clone() const;
  void swap(CheckKeyWord &);
};

class AdmitKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AdmitKeyWord(const AdmitKeyWord &);
  AdmitKeyWord &operator=(const AdmitKeyWord &);
  AdmitKeyWord();
  ~AdmitKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitKeyWord *clone() const;
  void swap(AdmitKeyWord &);
};

class GlobalKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  GlobalKeyWord(const GlobalKeyWord &);
  GlobalKeyWord &operator=(const GlobalKeyWord &);
  GlobalKeyWord();
  ~GlobalKeyWord();
  virtual void accept(Visitor *v);
  virtual GlobalKeyWord *clone() const;
  void swap(GlobalKeyWord &);
};

class ImpactKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  ImpactKeyWord(const ImpactKeyWord &);
  ImpactKeyWord &operator=(const ImpactKeyWord &);
  ImpactKeyWord();
  ~ImpactKeyWord();
  virtual void accept(Visitor *v);
  virtual ImpactKeyWord *clone() const;
  void swap(ImpactKeyWord &);
};

class InductiveKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  InductiveKeyWord(const InductiveKeyWord &);
  InductiveKeyWord &operator=(const InductiveKeyWord &);
  InductiveKeyWord();
  ~InductiveKeyWord();
  virtual void accept(Visitor *v);
  virtual InductiveKeyWord *clone() const;
  void swap(InductiveKeyWord &);
};

class InvariantKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  InvariantKeyWord(const InvariantKeyWord &);
  InvariantKeyWord &operator=(const InvariantKeyWord &);
  InvariantKeyWord();
  ~InvariantKeyWord();
  virtual void accept(Visitor *v);
  virtual InvariantKeyWord *clone() const;
  void swap(InvariantKeyWord &);
};

class AdmitInvariantKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AdmitInvariantKeyWord(const AdmitInvariantKeyWord &);
  AdmitInvariantKeyWord &operator=(const AdmitInvariantKeyWord &);
  AdmitInvariantKeyWord();
  ~AdmitInvariantKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitInvariantKeyWord *clone() const;
  void swap(AdmitInvariantKeyWord &);
};

class CheckInvariantKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  CheckInvariantKeyWord(const CheckInvariantKeyWord &);
  CheckInvariantKeyWord &operator=(const CheckInvariantKeyWord &);
  CheckInvariantKeyWord();
  ~CheckInvariantKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckInvariantKeyWord *clone() const;
  void swap(CheckInvariantKeyWord &);
};

class LemmaKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  LemmaKeyWord(const LemmaKeyWord &);
  LemmaKeyWord &operator=(const LemmaKeyWord &);
  LemmaKeyWord();
  ~LemmaKeyWord();
  virtual void accept(Visitor *v);
  virtual LemmaKeyWord *clone() const;
  void swap(LemmaKeyWord &);
};

class AdmitLemmaKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AdmitLemmaKeyWord(const AdmitLemmaKeyWord &);
  AdmitLemmaKeyWord &operator=(const AdmitLemmaKeyWord &);
  AdmitLemmaKeyWord();
  ~AdmitLemmaKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitLemmaKeyWord *clone() const;
  void swap(AdmitLemmaKeyWord &);
};

class CheckLemmaKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  CheckLemmaKeyWord(const CheckLemmaKeyWord &);
  CheckLemmaKeyWord &operator=(const CheckLemmaKeyWord &);
  CheckLemmaKeyWord();
  ~CheckLemmaKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckLemmaKeyWord *clone() const;
  void swap(CheckLemmaKeyWord &);
};

class LoopKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  LoopKeyWord(const LoopKeyWord &);
  LoopKeyWord &operator=(const LoopKeyWord &);
  LoopKeyWord();
  ~LoopKeyWord();
  virtual void accept(Visitor *v);
  virtual LoopKeyWord *clone() const;
  void swap(LoopKeyWord &);
};

class AdmitLoopKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AdmitLoopKeyWord(const AdmitLoopKeyWord &);
  AdmitLoopKeyWord &operator=(const AdmitLoopKeyWord &);
  AdmitLoopKeyWord();
  ~AdmitLoopKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitLoopKeyWord *clone() const;
  void swap(AdmitLoopKeyWord &);
};

class CheckLoopKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  CheckLoopKeyWord(const CheckLoopKeyWord &);
  CheckLoopKeyWord &operator=(const CheckLoopKeyWord &);
  CheckLoopKeyWord();
  ~CheckLoopKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckLoopKeyWord *clone() const;
  void swap(CheckLoopKeyWord &);
};

class PragmaKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  PragmaKeyWord(const PragmaKeyWord &);
  PragmaKeyWord &operator=(const PragmaKeyWord &);
  PragmaKeyWord();
  ~PragmaKeyWord();
  virtual void accept(Visitor *v);
  virtual PragmaKeyWord *clone() const;
  void swap(PragmaKeyWord &);
};

class PredicateKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  PredicateKeyWord(const PredicateKeyWord &);
  PredicateKeyWord &operator=(const PredicateKeyWord &);
  PredicateKeyWord();
  ~PredicateKeyWord();
  virtual void accept(Visitor *v);
  virtual PredicateKeyWord *clone() const;
  void swap(PredicateKeyWord &);
};

class SliceKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  SliceKeyWord(const SliceKeyWord &);
  SliceKeyWord &operator=(const SliceKeyWord &);
  SliceKeyWord();
  ~SliceKeyWord();
  virtual void accept(Visitor *v);
  virtual SliceKeyWord *clone() const;
  void swap(SliceKeyWord &);
};

class TypeKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  TypeKeyWord(const TypeKeyWord &);
  TypeKeyWord &operator=(const TypeKeyWord &);
  TypeKeyWord();
  ~TypeKeyWord();
  virtual void accept(Visitor *v);
  virtual TypeKeyWord *clone() const;
  void swap(TypeKeyWord &);
};

class ModelKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  ModelKeyWord(const ModelKeyWord &);
  ModelKeyWord &operator=(const ModelKeyWord &);
  ModelKeyWord();
  ~ModelKeyWord();
  virtual void accept(Visitor *v);
  virtual ModelKeyWord *clone() const;
  void swap(ModelKeyWord &);
};

class AxiomKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AxiomKeyWord(const AxiomKeyWord &);
  AxiomKeyWord &operator=(const AxiomKeyWord &);
  AxiomKeyWord();
  ~AxiomKeyWord();
  virtual void accept(Visitor *v);
  virtual AxiomKeyWord *clone() const;
  void swap(AxiomKeyWord &);
};

class VariantKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  VariantKeyWord(const VariantKeyWord &);
  VariantKeyWord &operator=(const VariantKeyWord &);
  VariantKeyWord();
  ~VariantKeyWord();
  virtual void accept(Visitor *v);
  virtual VariantKeyWord *clone() const;
  void swap(VariantKeyWord &);
};

class AxiomaticKeyWord : public IsACSLDeclOrCodeAnnot
{
public:

  AxiomaticKeyWord(const AxiomaticKeyWord &);
  AxiomaticKeyWord &operator=(const AxiomaticKeyWord &);
  AxiomaticKeyWord();
  ~AxiomaticKeyWord();
  virtual void accept(Visitor *v);
  virtual AxiomaticKeyWord *clone() const;
  void swap(AxiomaticKeyWord &);
};

class Integer : public IsACSLTypename
{
public:

  Integer(const Integer &);
  Integer &operator=(const Integer &);
  Integer();
  ~Integer();
  virtual void accept(Visitor *v);
  virtual Integer *clone() const;
  void swap(Integer &);
};

class Real : public IsACSLTypename
{
public:

  Real(const Real &);
  Real &operator=(const Real &);
  Real();
  ~Real();
  virtual void accept(Visitor *v);
  virtual Real *clone() const;
  void swap(Real &);
};

class ContractKeyWord : public IsExtSpec
{
public:

  ContractKeyWord(const ContractKeyWord &);
  ContractKeyWord &operator=(const ContractKeyWord &);
  ContractKeyWord();
  ~ContractKeyWord();
  virtual void accept(Visitor *v);
  virtual ContractKeyWord *clone() const;
  void swap(ContractKeyWord &);
};

class FunctionKeyWord : public IsExtSpec
{
public:

  FunctionKeyWord(const FunctionKeyWord &);
  FunctionKeyWord &operator=(const FunctionKeyWord &);
  FunctionKeyWord();
  ~FunctionKeyWord();
  virtual void accept(Visitor *v);
  virtual FunctionKeyWord *clone() const;
  void swap(FunctionKeyWord &);
};

class ModuleKeyWord : public IsExtSpec
{
public:

  ModuleKeyWord(const ModuleKeyWord &);
  ModuleKeyWord &operator=(const ModuleKeyWord &);
  ModuleKeyWord();
  ~ModuleKeyWord();
  virtual void accept(Visitor *v);
  virtual ModuleKeyWord *clone() const;
  void swap(ModuleKeyWord &);
};

class IncludeKeyWord : public IsExtSpec
{
public:

  IncludeKeyWord(const IncludeKeyWord &);
  IncludeKeyWord &operator=(const IncludeKeyWord &);
  IncludeKeyWord();
  ~IncludeKeyWord();
  virtual void accept(Visitor *v);
  virtual IncludeKeyWord *clone() const;
  void swap(IncludeKeyWord &);
};

class AtKeyWord : public IsExtSpec
{
public:

  AtKeyWord(const AtKeyWord &);
  AtKeyWord &operator=(const AtKeyWord &);
  AtKeyWord();
  ~AtKeyWord();
  virtual void accept(Visitor *v);
  virtual AtKeyWord *clone() const;
  void swap(AtKeyWord &);
};

class LetKeyWord : public IsExtSpec
{
public:

  LetKeyWord(const LetKeyWord &);
  LetKeyWord &operator=(const LetKeyWord &);
  LetKeyWord();
  ~LetKeyWord();
  virtual void accept(Visitor *v);
  virtual LetKeyWord *clone() const;
  void swap(LetKeyWord &);
};

class LogicKeyWord : public Keyword
{
public:

  LogicKeyWord(const LogicKeyWord &);
  LogicKeyWord &operator=(const LogicKeyWord &);
  LogicKeyWord();
  ~LogicKeyWord();
  virtual void accept(Visitor *v);
  virtual LogicKeyWord *clone() const;
  void swap(LogicKeyWord &);
};

class CKeyWord : public Keyword
{
public:
  CKeyword *ckeyword_;

  CKeyWord(const CKeyWord &);
  CKeyWord &operator=(const CKeyWord &);
  CKeyWord(CKeyword *p1);
  ~CKeyWord();
  virtual void accept(Visitor *v);
  virtual CKeyWord *clone() const;
  void swap(CKeyWord &);
};

class ACSLCKeyWord : public Keyword
{
public:
  ACSLCKeyword *acslckeyword_;

  ACSLCKeyWord(const ACSLCKeyWord &);
  ACSLCKeyWord &operator=(const ACSLCKeyWord &);
  ACSLCKeyWord(ACSLCKeyword *p1);
  ~ACSLCKeyWord();
  virtual void accept(Visitor *v);
  virtual ACSLCKeyWord *clone() const;
  void swap(ACSLCKeyWord &);
};

class ExtSpecKeyWord : public Keyword
{
public:
  IsExtSpec *isextspec_;

  ExtSpecKeyWord(const ExtSpecKeyWord &);
  ExtSpecKeyWord &operator=(const ExtSpecKeyWord &);
  ExtSpecKeyWord(IsExtSpec *p1);
  ~ExtSpecKeyWord();
  virtual void accept(Visitor *v);
  virtual ExtSpecKeyWord *clone() const;
  void swap(ExtSpecKeyWord &);
};

class ACSLSpecKeyWord : public Keyword
{
public:
  IsACSLSpec *isacslspec_;

  ACSLSpecKeyWord(const ACSLSpecKeyWord &);
  ACSLSpecKeyWord &operator=(const ACSLSpecKeyWord &);
  ACSLSpecKeyWord(IsACSLSpec *p1);
  ~ACSLSpecKeyWord();
  virtual void accept(Visitor *v);
  virtual ACSLSpecKeyWord *clone() const;
  void swap(ACSLSpecKeyWord &);
};

class ACSLDeclCodeAnnotKeyWord : public Keyword
{
public:
  IsACSLDeclOrCodeAnnot *isacsldeclorcodeannot_;

  ACSLDeclCodeAnnotKeyWord(const ACSLDeclCodeAnnotKeyWord &);
  ACSLDeclCodeAnnotKeyWord &operator=(const ACSLDeclCodeAnnotKeyWord &);
  ACSLDeclCodeAnnotKeyWord(IsACSLDeclOrCodeAnnot *p1);
  ~ACSLDeclCodeAnnotKeyWord();
  virtual void accept(Visitor *v);
  virtual ACSLDeclCodeAnnotKeyWord *clone() const;
  void swap(ACSLDeclCodeAnnotKeyWord &);
};

class SlashAllocableKeyWord : public BSKeyword
{
public:

  SlashAllocableKeyWord(const SlashAllocableKeyWord &);
  SlashAllocableKeyWord &operator=(const SlashAllocableKeyWord &);
  SlashAllocableKeyWord();
  ~SlashAllocableKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashAllocableKeyWord *clone() const;
  void swap(SlashAllocableKeyWord &);
};

class SlashAllocationKeyWord : public BSKeyword
{
public:

  SlashAllocationKeyWord(const SlashAllocationKeyWord &);
  SlashAllocationKeyWord &operator=(const SlashAllocationKeyWord &);
  SlashAllocationKeyWord();
  ~SlashAllocationKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashAllocationKeyWord *clone() const;
  void swap(SlashAllocationKeyWord &);
};

class SlashAutomaticKeyWord : public BSKeyword
{
public:

  SlashAutomaticKeyWord(const SlashAutomaticKeyWord &);
  SlashAutomaticKeyWord &operator=(const SlashAutomaticKeyWord &);
  SlashAutomaticKeyWord();
  ~SlashAutomaticKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashAutomaticKeyWord *clone() const;
  void swap(SlashAutomaticKeyWord &);
};

class SlashAtKeyWord : public BSKeyword
{
public:

  SlashAtKeyWord(const SlashAtKeyWord &);
  SlashAtKeyWord &operator=(const SlashAtKeyWord &);
  SlashAtKeyWord();
  ~SlashAtKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashAtKeyWord *clone() const;
  void swap(SlashAtKeyWord &);
};

class SlashBaseAddrKeyWord : public BSKeyword
{
public:

  SlashBaseAddrKeyWord(const SlashBaseAddrKeyWord &);
  SlashBaseAddrKeyWord &operator=(const SlashBaseAddrKeyWord &);
  SlashBaseAddrKeyWord();
  ~SlashBaseAddrKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashBaseAddrKeyWord *clone() const;
  void swap(SlashBaseAddrKeyWord &);
};

class SlashBlockLengthKeyWord : public BSKeyword
{
public:

  SlashBlockLengthKeyWord(const SlashBlockLengthKeyWord &);
  SlashBlockLengthKeyWord &operator=(const SlashBlockLengthKeyWord &);
  SlashBlockLengthKeyWord();
  ~SlashBlockLengthKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashBlockLengthKeyWord *clone() const;
  void swap(SlashBlockLengthKeyWord &);
};

class SlashGhostKeyWord : public BSKeyword
{
public:

  SlashGhostKeyWord(const SlashGhostKeyWord &);
  SlashGhostKeyWord &operator=(const SlashGhostKeyWord &);
  SlashGhostKeyWord();
  ~SlashGhostKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashGhostKeyWord *clone() const;
  void swap(SlashGhostKeyWord &);
};

class SlashDynamicKeyWord : public BSKeyword
{
public:

  SlashDynamicKeyWord(const SlashDynamicKeyWord &);
  SlashDynamicKeyWord &operator=(const SlashDynamicKeyWord &);
  SlashDynamicKeyWord();
  ~SlashDynamicKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashDynamicKeyWord *clone() const;
  void swap(SlashDynamicKeyWord &);
};

class SlashEmptyKeyWord : public BSKeyword
{
public:

  SlashEmptyKeyWord(const SlashEmptyKeyWord &);
  SlashEmptyKeyWord &operator=(const SlashEmptyKeyWord &);
  SlashEmptyKeyWord();
  ~SlashEmptyKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashEmptyKeyWord *clone() const;
  void swap(SlashEmptyKeyWord &);
};

class SlashFalseKeyWord : public BSKeyword
{
public:

  SlashFalseKeyWord(const SlashFalseKeyWord &);
  SlashFalseKeyWord &operator=(const SlashFalseKeyWord &);
  SlashFalseKeyWord();
  ~SlashFalseKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashFalseKeyWord *clone() const;
  void swap(SlashFalseKeyWord &);
};

class SlashForallKeyWord : public BSKeyword
{
public:

  SlashForallKeyWord(const SlashForallKeyWord &);
  SlashForallKeyWord &operator=(const SlashForallKeyWord &);
  SlashForallKeyWord();
  ~SlashForallKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashForallKeyWord *clone() const;
  void swap(SlashForallKeyWord &);
};

class SlashFreeableKeyWord : public BSKeyword
{
public:

  SlashFreeableKeyWord(const SlashFreeableKeyWord &);
  SlashFreeableKeyWord &operator=(const SlashFreeableKeyWord &);
  SlashFreeableKeyWord();
  ~SlashFreeableKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashFreeableKeyWord *clone() const;
  void swap(SlashFreeableKeyWord &);
};

class SlashFreshKeyWord : public BSKeyword
{
public:

  SlashFreshKeyWord(const SlashFreshKeyWord &);
  SlashFreshKeyWord &operator=(const SlashFreshKeyWord &);
  SlashFreshKeyWord();
  ~SlashFreshKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashFreshKeyWord *clone() const;
  void swap(SlashFreshKeyWord &);
};

class SlashFromKeyWord : public BSKeyword
{
public:

  SlashFromKeyWord(const SlashFromKeyWord &);
  SlashFromKeyWord &operator=(const SlashFromKeyWord &);
  SlashFromKeyWord();
  ~SlashFromKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashFromKeyWord *clone() const;
  void swap(SlashFromKeyWord &);
};

class SlashInterKeyWord : public BSKeyword
{
public:

  SlashInterKeyWord(const SlashInterKeyWord &);
  SlashInterKeyWord &operator=(const SlashInterKeyWord &);
  SlashInterKeyWord();
  ~SlashInterKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashInterKeyWord *clone() const;
  void swap(SlashInterKeyWord &);
};

class SlashLambdaKeyWord : public BSKeyword
{
public:

  SlashLambdaKeyWord(const SlashLambdaKeyWord &);
  SlashLambdaKeyWord &operator=(const SlashLambdaKeyWord &);
  SlashLambdaKeyWord();
  ~SlashLambdaKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashLambdaKeyWord *clone() const;
  void swap(SlashLambdaKeyWord &);
};

class SlashLetKeyWord : public BSKeyword
{
public:

  SlashLetKeyWord(const SlashLetKeyWord &);
  SlashLetKeyWord &operator=(const SlashLetKeyWord &);
  SlashLetKeyWord();
  ~SlashLetKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashLetKeyWord *clone() const;
  void swap(SlashLetKeyWord &);
};

class SlashNothingKeyWord : public BSKeyword
{
public:

  SlashNothingKeyWord(const SlashNothingKeyWord &);
  SlashNothingKeyWord &operator=(const SlashNothingKeyWord &);
  SlashNothingKeyWord();
  ~SlashNothingKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashNothingKeyWord *clone() const;
  void swap(SlashNothingKeyWord &);
};

class SlashNullKeyWord : public BSKeyword
{
public:

  SlashNullKeyWord(const SlashNullKeyWord &);
  SlashNullKeyWord &operator=(const SlashNullKeyWord &);
  SlashNullKeyWord();
  ~SlashNullKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashNullKeyWord *clone() const;
  void swap(SlashNullKeyWord &);
};

class SlashOldKeyWord : public BSKeyword
{
public:

  SlashOldKeyWord(const SlashOldKeyWord &);
  SlashOldKeyWord &operator=(const SlashOldKeyWord &);
  SlashOldKeyWord();
  ~SlashOldKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashOldKeyWord *clone() const;
  void swap(SlashOldKeyWord &);
};

class SlashOffsetKeyWord : public BSKeyword
{
public:

  SlashOffsetKeyWord(const SlashOffsetKeyWord &);
  SlashOffsetKeyWord &operator=(const SlashOffsetKeyWord &);
  SlashOffsetKeyWord();
  ~SlashOffsetKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashOffsetKeyWord *clone() const;
  void swap(SlashOffsetKeyWord &);
};

class SlashRegisterKeyWord : public BSKeyword
{
public:

  SlashRegisterKeyWord(const SlashRegisterKeyWord &);
  SlashRegisterKeyWord &operator=(const SlashRegisterKeyWord &);
  SlashRegisterKeyWord();
  ~SlashRegisterKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashRegisterKeyWord *clone() const;
  void swap(SlashRegisterKeyWord &);
};

class SlashResultKeyWord : public BSKeyword
{
public:

  SlashResultKeyWord(const SlashResultKeyWord &);
  SlashResultKeyWord &operator=(const SlashResultKeyWord &);
  SlashResultKeyWord();
  ~SlashResultKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashResultKeyWord *clone() const;
  void swap(SlashResultKeyWord &);
};

class SlashSeparatedKeyWord : public BSKeyword
{
public:

  SlashSeparatedKeyWord(const SlashSeparatedKeyWord &);
  SlashSeparatedKeyWord &operator=(const SlashSeparatedKeyWord &);
  SlashSeparatedKeyWord();
  ~SlashSeparatedKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashSeparatedKeyWord *clone() const;
  void swap(SlashSeparatedKeyWord &);
};

class SlashTrueKeyWord : public BSKeyword
{
public:

  SlashTrueKeyWord(const SlashTrueKeyWord &);
  SlashTrueKeyWord &operator=(const SlashTrueKeyWord &);
  SlashTrueKeyWord();
  ~SlashTrueKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashTrueKeyWord *clone() const;
  void swap(SlashTrueKeyWord &);
};

class SlashTypeKeyWord : public BSKeyword
{
public:

  SlashTypeKeyWord(const SlashTypeKeyWord &);
  SlashTypeKeyWord &operator=(const SlashTypeKeyWord &);
  SlashTypeKeyWord();
  ~SlashTypeKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashTypeKeyWord *clone() const;
  void swap(SlashTypeKeyWord &);
};

class SlashTypeofKeyWord : public BSKeyword
{
public:

  SlashTypeofKeyWord(const SlashTypeofKeyWord &);
  SlashTypeofKeyWord &operator=(const SlashTypeofKeyWord &);
  SlashTypeofKeyWord();
  ~SlashTypeofKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashTypeofKeyWord *clone() const;
  void swap(SlashTypeofKeyWord &);
};

class SlashUnionKeyWord : public BSKeyword
{
public:

  SlashUnionKeyWord(const SlashUnionKeyWord &);
  SlashUnionKeyWord &operator=(const SlashUnionKeyWord &);
  SlashUnionKeyWord();
  ~SlashUnionKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashUnionKeyWord *clone() const;
  void swap(SlashUnionKeyWord &);
};

class SlashUnallocatedKeyWord : public BSKeyword
{
public:

  SlashUnallocatedKeyWord(const SlashUnallocatedKeyWord &);
  SlashUnallocatedKeyWord &operator=(const SlashUnallocatedKeyWord &);
  SlashUnallocatedKeyWord();
  ~SlashUnallocatedKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashUnallocatedKeyWord *clone() const;
  void swap(SlashUnallocatedKeyWord &);
};

class SlashObjectPointerKeyWord : public BSKeyword
{
public:

  SlashObjectPointerKeyWord(const SlashObjectPointerKeyWord &);
  SlashObjectPointerKeyWord &operator=(const SlashObjectPointerKeyWord &);
  SlashObjectPointerKeyWord();
  ~SlashObjectPointerKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashObjectPointerKeyWord *clone() const;
  void swap(SlashObjectPointerKeyWord &);
};

class SlashValidKeyWord : public BSKeyword
{
public:

  SlashValidKeyWord(const SlashValidKeyWord &);
  SlashValidKeyWord &operator=(const SlashValidKeyWord &);
  SlashValidKeyWord();
  ~SlashValidKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashValidKeyWord *clone() const;
  void swap(SlashValidKeyWord &);
};

class SlashValidIndexKeyWord : public BSKeyword
{
public:

  SlashValidIndexKeyWord(const SlashValidIndexKeyWord &);
  SlashValidIndexKeyWord &operator=(const SlashValidIndexKeyWord &);
  SlashValidIndexKeyWord();
  ~SlashValidIndexKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashValidIndexKeyWord *clone() const;
  void swap(SlashValidIndexKeyWord &);
};

class SlashValidRangeKeyWord : public BSKeyword
{
public:

  SlashValidRangeKeyWord(const SlashValidRangeKeyWord &);
  SlashValidRangeKeyWord &operator=(const SlashValidRangeKeyWord &);
  SlashValidRangeKeyWord();
  ~SlashValidRangeKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashValidRangeKeyWord *clone() const;
  void swap(SlashValidRangeKeyWord &);
};

class SlashValidReadKeyWord : public BSKeyword
{
public:

  SlashValidReadKeyWord(const SlashValidReadKeyWord &);
  SlashValidReadKeyWord &operator=(const SlashValidReadKeyWord &);
  SlashValidReadKeyWord();
  ~SlashValidReadKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashValidReadKeyWord *clone() const;
  void swap(SlashValidReadKeyWord &);
};

class SlashValidFunctionKeyWord : public BSKeyword
{
public:

  SlashValidFunctionKeyWord(const SlashValidFunctionKeyWord &);
  SlashValidFunctionKeyWord &operator=(const SlashValidFunctionKeyWord &);
  SlashValidFunctionKeyWord();
  ~SlashValidFunctionKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashValidFunctionKeyWord *clone() const;
  void swap(SlashValidFunctionKeyWord &);
};

class SlashInitializedKeyWord : public BSKeyword
{
public:

  SlashInitializedKeyWord(const SlashInitializedKeyWord &);
  SlashInitializedKeyWord &operator=(const SlashInitializedKeyWord &);
  SlashInitializedKeyWord();
  ~SlashInitializedKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashInitializedKeyWord *clone() const;
  void swap(SlashInitializedKeyWord &);
};

class SlashDanglingKeyWord : public BSKeyword
{
public:

  SlashDanglingKeyWord(const SlashDanglingKeyWord &);
  SlashDanglingKeyWord &operator=(const SlashDanglingKeyWord &);
  SlashDanglingKeyWord();
  ~SlashDanglingKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashDanglingKeyWord *clone() const;
  void swap(SlashDanglingKeyWord &);
};

class SlashWithKeyWord : public BSKeyword
{
public:

  SlashWithKeyWord(const SlashWithKeyWord &);
  SlashWithKeyWord &operator=(const SlashWithKeyWord &);
  SlashWithKeyWord();
  ~SlashWithKeyWord();
  virtual void accept(Visitor *v);
  virtual SlashWithKeyWord *clone() const;
  void swap(SlashWithKeyWord &);
};

class WildCardAnyIdent : public Wildcard
{
public:
  AnyIdentifier *anyidentifier_;

  WildCardAnyIdent(const WildCardAnyIdent &);
  WildCardAnyIdent &operator=(const WildCardAnyIdent &);
  WildCardAnyIdent(AnyIdentifier *p1);
  ~WildCardAnyIdent();
  virtual void accept(Visitor *v);
  virtual WildCardAnyIdent *clone() const;
  void swap(WildCardAnyIdent &);
};

class WildCardBSKeyWord : public Wildcard
{
public:
  BSKeyword *bskeyword_;

  WildCardBSKeyWord(const WildCardBSKeyWord &);
  WildCardBSKeyWord &operator=(const WildCardBSKeyWord &);
  WildCardBSKeyWord(BSKeyword *p1);
  ~WildCardBSKeyWord();
  virtual void accept(Visitor *v);
  virtual WildCardBSKeyWord *clone() const;
  void swap(WildCardBSKeyWord &);
};

class Amp : public Wildcard
{
public:

  Amp(const Amp &);
  Amp &operator=(const Amp &);
  Amp();
  ~Amp();
  virtual void accept(Visitor *v);
  virtual Amp *clone() const;
  void swap(Amp &);
};

class And : public Wildcard
{
public:

  And(const And &);
  And &operator=(const And &);
  And();
  ~And();
  virtual void accept(Visitor *v);
  virtual And *clone() const;
  void swap(And &);
};

class Arrow : public Wildcard
{
public:

  Arrow(const Arrow &);
  Arrow &operator=(const Arrow &);
  Arrow();
  ~Arrow();
  virtual void accept(Visitor *v);
  virtual Arrow *clone() const;
  void swap(Arrow &);
};

class BIff : public Wildcard
{
public:

  BIff(const BIff &);
  BIff &operator=(const BIff &);
  BIff();
  ~BIff();
  virtual void accept(Visitor *v);
  virtual BIff *clone() const;
  void swap(BIff &);
};

class BImplicate : public Wildcard
{
public:

  BImplicate(const BImplicate &);
  BImplicate &operator=(const BImplicate &);
  BImplicate();
  ~BImplicate();
  virtual void accept(Visitor *v);
  virtual BImplicate *clone() const;
  void swap(BImplicate &);
};

class Colon : public Wildcard
{
public:

  Colon(const Colon &);
  Colon &operator=(const Colon &);
  Colon();
  ~Colon();
  virtual void accept(Visitor *v);
  virtual Colon *clone() const;
  void swap(Colon &);
};

class ColonColon : public Wildcard
{
public:

  ColonColon(const ColonColon &);
  ColonColon &operator=(const ColonColon &);
  ColonColon();
  ~ColonColon();
  virtual void accept(Visitor *v);
  virtual ColonColon *clone() const;
  void swap(ColonColon &);
};

class Comma : public Wildcard
{
public:

  Comma(const Comma &);
  Comma &operator=(const Comma &);
  Comma();
  ~Comma();
  virtual void accept(Visitor *v);
  virtual Comma *clone() const;
  void swap(Comma &);
};

class IntConstant : public Wildcard
{
public:
  Integer integer_;

  IntConstant(const IntConstant &);
  IntConstant &operator=(const IntConstant &);
  IntConstant(Integer p1);
  ~IntConstant();
  virtual void accept(Visitor *v);
  virtual IntConstant *clone() const;
  void swap(IntConstant &);
};

class FloatConstant : public Wildcard
{
public:
  Double double_;

  FloatConstant(const FloatConstant &);
  FloatConstant &operator=(const FloatConstant &);
  FloatConstant(Double p1);
  ~FloatConstant();
  virtual void accept(Visitor *v);
  virtual FloatConstant *clone() const;
  void swap(FloatConstant &);
};

class StringConstant : public Wildcard
{
public:
  String string_;

  StringConstant(const StringConstant &);
  StringConstant &operator=(const StringConstant &);
  StringConstant(String p1);
  ~StringConstant();
  virtual void accept(Visitor *v);
  virtual StringConstant *clone() const;
  void swap(StringConstant &);
};

class WstringConstant : public Wildcard
{
public:
  WSTRING_CONSTANT wstring_constant_;

  WstringConstant(const WstringConstant &);
  WstringConstant &operator=(const WstringConstant &);
  WstringConstant(WSTRING_CONSTANT p1);
  ~WstringConstant();
  virtual void accept(Visitor *v);
  virtual WstringConstant *clone() const;
  void swap(WstringConstant &);
};

class Dollar : public Wildcard
{
public:

  Dollar(const Dollar &);
  Dollar &operator=(const Dollar &);
  Dollar();
  ~Dollar();
  virtual void accept(Visitor *v);
  virtual Dollar *clone() const;
  void swap(Dollar &);
};

class Dot : public Wildcard
{
public:

  Dot(const Dot &);
  Dot &operator=(const Dot &);
  Dot();
  ~Dot();
  virtual void accept(Visitor *v);
  virtual Dot *clone() const;
  void swap(Dot &);
};

class DotDot : public Wildcard
{
public:

  DotDot(const DotDot &);
  DotDot &operator=(const DotDot &);
  DotDot();
  ~DotDot();
  virtual void accept(Visitor *v);
  virtual DotDot *clone() const;
  void swap(DotDot &);
};

class DotDotDot : public Wildcard
{
public:

  DotDotDot(const DotDotDot &);
  DotDotDot &operator=(const DotDotDot &);
  DotDotDot();
  ~DotDotDot();
  virtual void accept(Visitor *v);
  virtual DotDotDot *clone() const;
  void swap(DotDotDot &);
};

class EQ : public Wildcard
{
public:

  EQ(const EQ &);
  EQ &operator=(const EQ &);
  EQ();
  ~EQ();
  virtual void accept(Visitor *v);
  virtual EQ *clone() const;
  void swap(EQ &);
};

class Equal : public Wildcard
{
public:

  Equal(const Equal &);
  Equal &operator=(const Equal &);
  Equal();
  ~Equal();
  virtual void accept(Visitor *v);
  virtual Equal *clone() const;
  void swap(Equal &);
};

class ExistsKeyWord : public Wildcard
{
public:

  ExistsKeyWord(const ExistsKeyWord &);
  ExistsKeyWord &operator=(const ExistsKeyWord &);
  ExistsKeyWord();
  ~ExistsKeyWord();
  virtual void accept(Visitor *v);
  virtual ExistsKeyWord *clone() const;
  void swap(ExistsKeyWord &);
};

class GreaterEq : public Wildcard
{
public:

  GreaterEq(const GreaterEq &);
  GreaterEq &operator=(const GreaterEq &);
  GreaterEq();
  ~GreaterEq();
  virtual void accept(Visitor *v);
  virtual GreaterEq *clone() const;
  void swap(GreaterEq &);
};

class GhostKeyWord : public Wildcard
{
public:

  GhostKeyWord(const GhostKeyWord &);
  GhostKeyWord &operator=(const GhostKeyWord &);
  GhostKeyWord();
  ~GhostKeyWord();
  virtual void accept(Visitor *v);
  virtual GhostKeyWord *clone() const;
  void swap(GhostKeyWord &);
};

class Greater : public Wildcard
{
public:

  Greater(const Greater &);
  Greater &operator=(const Greater &);
  Greater();
  ~Greater();
  virtual void accept(Visitor *v);
  virtual Greater *clone() const;
  void swap(Greater &);
};

class GreaterGreater : public Wildcard
{
public:

  GreaterGreater(const GreaterGreater &);
  GreaterGreater &operator=(const GreaterGreater &);
  GreaterGreater();
  ~GreaterGreater();
  virtual void accept(Visitor *v);
  virtual GreaterGreater *clone() const;
  void swap(GreaterGreater &);
};

class Hat : public Wildcard
{
public:

  Hat(const Hat &);
  Hat &operator=(const Hat &);
  Hat();
  ~Hat();
  virtual void accept(Visitor *v);
  virtual Hat *clone() const;
  void swap(Hat &);
};

class HatHat : public Wildcard
{
public:

  HatHat(const HatHat &);
  HatHat &operator=(const HatHat &);
  HatHat();
  ~HatHat();
  virtual void accept(Visitor *v);
  virtual HatHat *clone() const;
  void swap(HatHat &);
};

class Iff : public Wildcard
{
public:

  Iff(const Iff &);
  Iff &operator=(const Iff &);
  Iff();
  ~Iff();
  virtual void accept(Visitor *v);
  virtual Iff *clone() const;
  void swap(Iff &);
};

class Implicate : public Wildcard
{
public:

  Implicate(const Implicate &);
  Implicate &operator=(const Implicate &);
  Implicate();
  ~Implicate();
  virtual void accept(Visitor *v);
  virtual Implicate *clone() const;
  void swap(Implicate &);
};

class LeftBrace : public Wildcard
{
public:

  LeftBrace(const LeftBrace &);
  LeftBrace &operator=(const LeftBrace &);
  LeftBrace();
  ~LeftBrace();
  virtual void accept(Visitor *v);
  virtual LeftBrace *clone() const;
  void swap(LeftBrace &);
};

class LessEq : public Wildcard
{
public:

  LessEq(const LessEq &);
  LessEq &operator=(const LessEq &);
  LessEq();
  ~LessEq();
  virtual void accept(Visitor *v);
  virtual LessEq *clone() const;
  void swap(LessEq &);
};

class LeftPar : public Wildcard
{
public:

  LeftPar(const LeftPar &);
  LeftPar &operator=(const LeftPar &);
  LeftPar();
  ~LeftPar();
  virtual void accept(Visitor *v);
  virtual LeftPar *clone() const;
  void swap(LeftPar &);
};

class LeftSquare : public Wildcard
{
public:

  LeftSquare(const LeftSquare &);
  LeftSquare &operator=(const LeftSquare &);
  LeftSquare();
  ~LeftSquare();
  virtual void accept(Visitor *v);
  virtual LeftSquare *clone() const;
  void swap(LeftSquare &);
};

class LeftSquarePipe : public Wildcard
{
public:

  LeftSquarePipe(const LeftSquarePipe &);
  LeftSquarePipe &operator=(const LeftSquarePipe &);
  LeftSquarePipe();
  ~LeftSquarePipe();
  virtual void accept(Visitor *v);
  virtual LeftSquarePipe *clone() const;
  void swap(LeftSquarePipe &);
};

class Less : public Wildcard
{
public:

  Less(const Less &);
  Less &operator=(const Less &);
  Less();
  ~Less();
  virtual void accept(Visitor *v);
  virtual Less *clone() const;
  void swap(Less &);
};

class LessLess : public Wildcard
{
public:

  LessLess(const LessLess &);
  LessLess &operator=(const LessLess &);
  LessLess();
  ~LessLess();
  virtual void accept(Visitor *v);
  virtual LessLess *clone() const;
  void swap(LessLess &);
};

class Minus : public Wildcard
{
public:

  Minus(const Minus &);
  Minus &operator=(const Minus &);
  Minus();
  ~Minus();
  virtual void accept(Visitor *v);
  virtual Minus *clone() const;
  void swap(Minus &);
};

class NotEq : public Wildcard
{
public:

  NotEq(const NotEq &);
  NotEq &operator=(const NotEq &);
  NotEq();
  ~NotEq();
  virtual void accept(Visitor *v);
  virtual NotEq *clone() const;
  void swap(NotEq &);
};

class Not : public Wildcard
{
public:

  Not(const Not &);
  Not &operator=(const Not &);
  Not();
  ~Not();
  virtual void accept(Visitor *v);
  virtual Not *clone() const;
  void swap(Not &);
};

class PipePipe : public Wildcard
{
public:

  PipePipe(const PipePipe &);
  PipePipe &operator=(const PipePipe &);
  PipePipe();
  ~PipePipe();
  virtual void accept(Visitor *v);
  virtual PipePipe *clone() const;
  void swap(PipePipe &);
};

class Mod : public Wildcard
{
public:

  Mod(const Mod &);
  Mod &operator=(const Mod &);
  Mod();
  ~Mod();
  virtual void accept(Visitor *v);
  virtual Mod *clone() const;
  void swap(Mod &);
};

class PiKeyWord : public Wildcard
{
public:

  PiKeyWord(const PiKeyWord &);
  PiKeyWord &operator=(const PiKeyWord &);
  PiKeyWord();
  ~PiKeyWord();
  virtual void accept(Visitor *v);
  virtual PiKeyWord *clone() const;
  void swap(PiKeyWord &);
};

class Pipe : public Wildcard
{
public:

  Pipe(const Pipe &);
  Pipe &operator=(const Pipe &);
  Pipe();
  ~Pipe();
  virtual void accept(Visitor *v);
  virtual Pipe *clone() const;
  void swap(Pipe &);
};

class Plus : public Wildcard
{
public:

  Plus(const Plus &);
  Plus &operator=(const Plus &);
  Plus();
  ~Plus();
  virtual void accept(Visitor *v);
  virtual Plus *clone() const;
  void swap(Plus &);
};

class Question : public Wildcard
{
public:

  Question(const Question &);
  Question &operator=(const Question &);
  Question();
  ~Question();
  virtual void accept(Visitor *v);
  virtual Question *clone() const;
  void swap(Question &);
};

class RightBrace : public Wildcard
{
public:

  RightBrace(const RightBrace &);
  RightBrace &operator=(const RightBrace &);
  RightBrace();
  ~RightBrace();
  virtual void accept(Visitor *v);
  virtual RightBrace *clone() const;
  void swap(RightBrace &);
};

class RightPar : public Wildcard
{
public:

  RightPar(const RightPar &);
  RightPar &operator=(const RightPar &);
  RightPar();
  ~RightPar();
  virtual void accept(Visitor *v);
  virtual RightPar *clone() const;
  void swap(RightPar &);
};

class RightSquare : public Wildcard
{
public:

  RightSquare(const RightSquare &);
  RightSquare &operator=(const RightSquare &);
  RightSquare();
  ~RightSquare();
  virtual void accept(Visitor *v);
  virtual RightSquare *clone() const;
  void swap(RightSquare &);
};

class RightSquarePipe : public Wildcard
{
public:

  RightSquarePipe(const RightSquarePipe &);
  RightSquarePipe &operator=(const RightSquarePipe &);
  RightSquarePipe();
  ~RightSquarePipe();
  virtual void accept(Visitor *v);
  virtual RightSquarePipe *clone() const;
  void swap(RightSquarePipe &);
};

class SemiColon : public Wildcard
{
public:

  SemiColon(const SemiColon &);
  SemiColon &operator=(const SemiColon &);
  SemiColon();
  ~SemiColon();
  virtual void accept(Visitor *v);
  virtual SemiColon *clone() const;
  void swap(SemiColon &);
};

class Divide : public Wildcard
{
public:

  Divide(const Divide &);
  Divide &operator=(const Divide &);
  Divide();
  ~Divide();
  virtual void accept(Visitor *v);
  virtual Divide *clone() const;
  void swap(Divide &);
};

class Mult : public Wildcard
{
public:

  Mult(const Mult &);
  Mult &operator=(const Mult &);
  Mult();
  ~Mult();
  virtual void accept(Visitor *v);
  virtual Mult *clone() const;
  void swap(Mult &);
};

class MultHat : public Wildcard
{
public:

  MultHat(const MultHat &);
  MultHat &operator=(const MultHat &);
  MultHat();
  ~MultHat();
  virtual void accept(Visitor *v);
  virtual MultHat *clone() const;
  void swap(MultHat &);
};

class StringLiteral : public Wildcard
{
public:
  STRING_LITERAL string_literal_;

  StringLiteral(const StringLiteral &);
  StringLiteral &operator=(const StringLiteral &);
  StringLiteral(STRING_LITERAL p1);
  ~StringLiteral();
  virtual void accept(Visitor *v);
  virtual StringLiteral *clone() const;
  void swap(StringLiteral &);
};

class TildeKeyWord : public Wildcard
{
public:

  TildeKeyWord(const TildeKeyWord &);
  TildeKeyWord &operator=(const TildeKeyWord &);
  TildeKeyWord();
  ~TildeKeyWord();
  virtual void accept(Visitor *v);
  virtual TildeKeyWord *clone() const;
  void swap(TildeKeyWord &);
};

class InKeyWord : public Wildcard
{
public:

  InKeyWord(const InKeyWord &);
  InKeyWord &operator=(const InKeyWord &);
  InKeyWord();
  ~InKeyWord();
  virtual void accept(Visitor *v);
  virtual InKeyWord *clone() const;
  void swap(InKeyWord &);
};



class ListLexpr : public Visitable, public std::vector<Lexpr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLexpr *clone() const;
};

ListLexpr* consListLexpr(Lexpr* x, ListLexpr* xs);

class ListLexprRelInner : public Visitable, public std::vector<LexprRelInner*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLexprRelInner *clone() const;
};

ListLexprRelInner* consListLexprRelInner(LexprRelInner* x, ListLexprRelInner* xs);

class ListSTRING_LITERAL : public Visitable, public std::vector<STRING_LITERAL>
{
public:
  virtual void accept(Visitor *v);
  virtual ListSTRING_LITERAL *clone() const;
};

ListSTRING_LITERAL* consListSTRING_LITERAL(STRING_LITERAL x, ListSTRING_LITERAL* xs);

class ListFieldInitElt : public Visitable, public std::vector<FieldInitElt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFieldInitElt *clone() const;
};

ListFieldInitElt* consListFieldInitElt(FieldInitElt* x, ListFieldInitElt* xs);

class ListArrayInitElt : public Visitable, public std::vector<ArrayInitElt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArrayInitElt *clone() const;
};

ListArrayInitElt* consListArrayInitElt(ArrayInitElt* x, ListArrayInitElt* xs);

class ListUpdateElt : public Visitable, public std::vector<UpdateElt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListUpdateElt *clone() const;
};

ListUpdateElt* consListUpdateElt(UpdateElt* x, ListUpdateElt* xs);

class ListPathElt : public Visitable, public std::vector<PathElt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPathElt *clone() const;
};

ListPathElt* consListPathElt(PathElt* x, ListPathElt* xs);

class ListBindersReentrance : public Visitable, public std::vector<BindersReentrance*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBindersReentrance *clone() const;
};

ListBindersReentrance* consListBindersReentrance(BindersReentrance* x, ListBindersReentrance* xs);

class ListAbsParam : public Visitable, public std::vector<AbsParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListAbsParam *clone() const;
};

ListAbsParam* consListAbsParam(AbsParam* x, ListAbsParam* xs);

class ListParameter : public Visitable, public std::vector<Parameter*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListParameter *clone() const;
};

ListParameter* consListParameter(Parameter* x, ListParameter* xs);

class ListLogicTypeGenOFTYPENAME : public Visitable, public std::vector<LogicTypeGenOFTYPENAME*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLogicTypeGenOFTYPENAME *clone() const;
};

ListLogicTypeGenOFTYPENAME* consListLogicTypeGenOFTYPENAME(LogicTypeGenOFTYPENAME* x, ListLogicTypeGenOFTYPENAME* xs);

class ListLogicTypeGenOFIdentifierOrTypename : public Visitable, public std::vector<LogicTypeGenOFIdentifierOrTypename*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLogicTypeGenOFIdentifierOrTypename *clone() const;
};

ListLogicTypeGenOFIdentifierOrTypename* consListLogicTypeGenOFIdentifierOrTypename(LogicTypeGenOFIdentifierOrTypename* x, ListLogicTypeGenOFIdentifierOrTypename* xs);

class ListCV : public Visitable, public std::vector<CV*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListCV *clone() const;
};

ListCV* consListCV(CV* x, ListCV* xs);

class ListStars : public Visitable, public std::vector<Stars*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStars *clone() const;
};

ListStars* consListStars(Stars* x, ListStars* xs);

class ListStarsCV : public Visitable, public std::vector<StarsCV*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStarsCV *clone() const;
};

ListStarsCV* consListStarsCV(StarsCV* x, ListStarsCV* xs);

class ListTabs : public Visitable, public std::vector<Tabs*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTabs *clone() const;
};

ListTabs* consListTabs(Tabs* x, ListTabs* xs);

class ListFullIdentifier : public Visitable, public std::vector<FullIdentifier*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFullIdentifier *clone() const;
};

ListFullIdentifier* consListFullIdentifier(FullIdentifier* x, ListFullIdentifier* xs);

class ListExtGlobalClause : public Visitable, public std::vector<ExtGlobalClause*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExtGlobalClause *clone() const;
};

ListExtGlobalClause* consListExtGlobalClause(ExtGlobalClause* x, ListExtGlobalClause* xs);

class ListExtGlobalSpec : public Visitable, public std::vector<ExtGlobalSpec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExtGlobalSpec *clone() const;
};

ListExtGlobalSpec* consListExtGlobalSpec(ExtGlobalSpec* x, ListExtGlobalSpec* xs);

class ListExtModuleSpec : public Visitable, public std::vector<ExtModuleSpec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExtModuleSpec *clone() const;
};

ListExtModuleSpec* consListExtModuleSpec(ExtModuleSpec* x, ListExtModuleSpec* xs);

class ListExtFunctionSpec : public Visitable, public std::vector<ExtFunctionSpec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExtFunctionSpec *clone() const;
};

ListExtFunctionSpec* consListExtFunctionSpec(ExtFunctionSpec* x, ListExtFunctionSpec* xs);

class ListExtFunSpec : public Visitable, public std::vector<ExtFunSpec*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExtFunSpec *clone() const;
};

ListExtFunSpec* consListExtFunSpec(ExtFunSpec* x, ListExtFunSpec* xs);

class ListStmtMarkup : public Visitable, public std::vector<StmtMarkup*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStmtMarkup *clone() const;
};

ListStmtMarkup* consListStmtMarkup(StmtMarkup* x, ListStmtMarkup* xs);

class ListDecl : public Visitable, public std::vector<Decl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDecl *clone() const;
};

ListDecl* consListDecl(Decl* x, ListDecl* xs);

class ListExtDecl : public Visitable, public std::vector<ExtDecl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExtDecl *clone() const;
};

ListExtDecl* consListExtDecl(ExtDecl* x, ListExtDecl* xs);

class ListVolatileOpt : public Visitable, public std::vector<VolatileOpt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListVolatileOpt *clone() const;
};

ListVolatileOpt* consListVolatileOpt(VolatileOpt* x, ListVolatileOpt* xs);

class ListLogicDecl : public Visitable, public std::vector<LogicDecl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLogicDecl *clone() const;
};

ListLogicDecl* consListLogicDecl(LogicDecl* x, ListLogicDecl* xs);

class ListDataconsWithSeparator : public Visitable, public std::vector<DataconsWithSeparator*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDataconsWithSeparator *clone() const;
};

ListDataconsWithSeparator* consListDataconsWithSeparator(DataconsWithSeparator* x, ListDataconsWithSeparator* xs);

class ListIndcase : public Visitable, public std::vector<Indcase*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIndcase *clone() const;
};

ListIndcase* consListIndcase(Indcase* x, ListIndcase* xs);

class ListLabelName : public Visitable, public std::vector<LabelName*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLabelName *clone() const;
};

ListLabelName* consListLabelName(LabelName* x, ListLabelName* xs);

class ListBehaviorName : public Visitable, public std::vector<BehaviorName*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBehaviorName *clone() const;
};

ListBehaviorName* consListBehaviorName(BehaviorName* x, ListBehaviorName* xs);

class ListIdentifierOrTypenameFull : public Visitable, public std::vector<IdentifierOrTypenameFull*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdentifierOrTypenameFull *clone() const;
};

ListIdentifierOrTypenameFull* consListIdentifierOrTypenameFull(IdentifierOrTypenameFull* x, ListIdentifierOrTypenameFull* xs);

class ListWildcard : public Visitable, public std::vector<Wildcard*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListWildcard *clone() const;
};

ListWildcard* consListWildcard(Wildcard* x, ListWildcard* xs);




}
#endif
