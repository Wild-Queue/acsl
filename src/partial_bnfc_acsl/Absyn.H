/* File generated by the BNF Converter (bnfc 2.9.4.1). */

#ifndef PARTIAL_BNFC_ACSL_ABSYN_HEADER
#define PARTIAL_BNFC_ACSL_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.
namespace partial_bnfc_acsl
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Annot;
class Code_Annot;
class Contract;
class Requires;
class NERequires;
class ClauseKW;
class Terminates;
class Decreases;
class SimpleClauses;
class NESimpleClauses;
class Behaviors;
class CompleteOrDisjoint;
class Lexpr;
class LexprRelInner;
class Relation;
class PostCond;
class FullIdentifier;
class Identifier;
class AProgram;
class CodeAnnot;
class CodeAnnotContract;
class SimpleContract;
class NoRequires;
class SomeRequires;
class SimpleRequires;
class CheckRequires;
class AdimtRequires;
class AdmitRequiresClause;
class AdmitInvariantClause;
class AdmitLemmaClause;
class AdmitLoopClause;
class CheckRequiresClause;
class CheckInvariantClause;
class CheckLemmaClause;
class CheckLoopClause;
class RequiresClause;
class AssumesClause;
class AssignsClause;
class PostCondClause;
class DecreasesClause;
class BehaviorClause;
class AllocatesClause;
class FreesClause;
class CompleteClause;
class DisjointClause;
class EmptyClauseKW;
class NoTerminate;
class NoDecreases;
class NoSimpleClauses;
class SomeSimpleClauses;
class PostCondSimpleClauses;
class NoBehaviors;
class NoComplDisj;
class NoLexpr;
class ImplLexpr;
class IffLexpr;
class OrLexpr;
class AndLexpr;
class HatHatLexpr;
class AmpLexpr;
class PipeLexpr;
class HatLexpr;
class BimpliesLexpr;
class BiffLexpr;
class InLexpr;
class TernaryLexpr;
class RelationLexpr;
class RelInnerLexpr;
class LessRel;
class GreaterRel;
class LessEqRel;
class GreaterEqRel;
class EqRel;
class NotEqRel;
class NotLexprInner;
class TrueLexpr;
class FalseLexpr;
class AutomaticLexpr;
class DynamicLexpr;
class RegisterLexpr;
class StaticLexpr;
class UnallocatedLexpr;
class NullLexpr;
class LexprIntConst;
class LexprFloatConst;
class LexprStringConst;
class AddLexpr;
class SubtrLexpr;
class MultLexpr;
class DivLexpr;
class ModLexpr;
class StarHatLexpr;
class SquaresLexpr;
class MinusLexpr;
class PlusLexpr;
class TildeLexpr;
class StarLexpr;
class AmpUnaryLexpr;
class SizeOfLexpr;
class OldLexpr;
class ResultLexpr;
class SeparatedLexpr;
class FullIdParenLexpr;
class FullId;
class PiLexpr;
class LessLessLexpr;
class GreaterGreaterLexpr;
class TypeOfLexpr;
class EnsuresKeyWord;
class ExitsKeyWord;
class BreaksKeyWord;
class ContinuesKeyWord;
class ReturnsKeyWord;
class CheckEnsuresKeyWord;
class CheckExitsKeyWord;
class CheckBreaksKeyWord;
class CheckContinuesKeyWord;
class CheckReturnsKeyWord;
class AdmitEnsuresKeyWord;
class AdmitExitsKeyWord;
class AdmitBreaksKeyWord;
class AdmitContinuesKeyWord;
class AdmitReturnsKeyWord;
class SimpleIdentifierFull;
class IdentifierIdent;
class ListAnnot;
class ListLexpr;
class ListLexprRelInner;
class ListFullIdentifier;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitAnnot(Annot *p) = 0;
  virtual void visitCode_Annot(Code_Annot *p) = 0;
  virtual void visitContract(Contract *p) = 0;
  virtual void visitRequires(Requires *p) = 0;
  virtual void visitNERequires(NERequires *p) = 0;
  virtual void visitClauseKW(ClauseKW *p) = 0;
  virtual void visitTerminates(Terminates *p) = 0;
  virtual void visitDecreases(Decreases *p) = 0;
  virtual void visitSimpleClauses(SimpleClauses *p) = 0;
  virtual void visitNESimpleClauses(NESimpleClauses *p) = 0;
  virtual void visitBehaviors(Behaviors *p) = 0;
  virtual void visitCompleteOrDisjoint(CompleteOrDisjoint *p) = 0;
  virtual void visitLexpr(Lexpr *p) = 0;
  virtual void visitLexprRelInner(LexprRelInner *p) = 0;
  virtual void visitRelation(Relation *p) = 0;
  virtual void visitPostCond(PostCond *p) = 0;
  virtual void visitFullIdentifier(FullIdentifier *p) = 0;
  virtual void visitIdentifier(Identifier *p) = 0;
  virtual void visitAProgram(AProgram *p) = 0;
  virtual void visitCodeAnnot(CodeAnnot *p) = 0;
  virtual void visitCodeAnnotContract(CodeAnnotContract *p) = 0;
  virtual void visitSimpleContract(SimpleContract *p) = 0;
  virtual void visitNoRequires(NoRequires *p) = 0;
  virtual void visitSomeRequires(SomeRequires *p) = 0;
  virtual void visitSimpleRequires(SimpleRequires *p) = 0;
  virtual void visitCheckRequires(CheckRequires *p) = 0;
  virtual void visitAdimtRequires(AdimtRequires *p) = 0;
  virtual void visitAdmitRequiresClause(AdmitRequiresClause *p) = 0;
  virtual void visitAdmitInvariantClause(AdmitInvariantClause *p) = 0;
  virtual void visitAdmitLemmaClause(AdmitLemmaClause *p) = 0;
  virtual void visitAdmitLoopClause(AdmitLoopClause *p) = 0;
  virtual void visitCheckRequiresClause(CheckRequiresClause *p) = 0;
  virtual void visitCheckInvariantClause(CheckInvariantClause *p) = 0;
  virtual void visitCheckLemmaClause(CheckLemmaClause *p) = 0;
  virtual void visitCheckLoopClause(CheckLoopClause *p) = 0;
  virtual void visitRequiresClause(RequiresClause *p) = 0;
  virtual void visitAssumesClause(AssumesClause *p) = 0;
  virtual void visitAssignsClause(AssignsClause *p) = 0;
  virtual void visitPostCondClause(PostCondClause *p) = 0;
  virtual void visitDecreasesClause(DecreasesClause *p) = 0;
  virtual void visitBehaviorClause(BehaviorClause *p) = 0;
  virtual void visitAllocatesClause(AllocatesClause *p) = 0;
  virtual void visitFreesClause(FreesClause *p) = 0;
  virtual void visitCompleteClause(CompleteClause *p) = 0;
  virtual void visitDisjointClause(DisjointClause *p) = 0;
  virtual void visitEmptyClauseKW(EmptyClauseKW *p) = 0;
  virtual void visitNoTerminate(NoTerminate *p) = 0;
  virtual void visitNoDecreases(NoDecreases *p) = 0;
  virtual void visitNoSimpleClauses(NoSimpleClauses *p) = 0;
  virtual void visitSomeSimpleClauses(SomeSimpleClauses *p) = 0;
  virtual void visitPostCondSimpleClauses(PostCondSimpleClauses *p) = 0;
  virtual void visitNoBehaviors(NoBehaviors *p) = 0;
  virtual void visitNoComplDisj(NoComplDisj *p) = 0;
  virtual void visitNoLexpr(NoLexpr *p) = 0;
  virtual void visitImplLexpr(ImplLexpr *p) = 0;
  virtual void visitIffLexpr(IffLexpr *p) = 0;
  virtual void visitOrLexpr(OrLexpr *p) = 0;
  virtual void visitAndLexpr(AndLexpr *p) = 0;
  virtual void visitHatHatLexpr(HatHatLexpr *p) = 0;
  virtual void visitAmpLexpr(AmpLexpr *p) = 0;
  virtual void visitPipeLexpr(PipeLexpr *p) = 0;
  virtual void visitHatLexpr(HatLexpr *p) = 0;
  virtual void visitBimpliesLexpr(BimpliesLexpr *p) = 0;
  virtual void visitBiffLexpr(BiffLexpr *p) = 0;
  virtual void visitInLexpr(InLexpr *p) = 0;
  virtual void visitTernaryLexpr(TernaryLexpr *p) = 0;
  virtual void visitRelationLexpr(RelationLexpr *p) = 0;
  virtual void visitRelInnerLexpr(RelInnerLexpr *p) = 0;
  virtual void visitLessRel(LessRel *p) = 0;
  virtual void visitGreaterRel(GreaterRel *p) = 0;
  virtual void visitLessEqRel(LessEqRel *p) = 0;
  virtual void visitGreaterEqRel(GreaterEqRel *p) = 0;
  virtual void visitEqRel(EqRel *p) = 0;
  virtual void visitNotEqRel(NotEqRel *p) = 0;
  virtual void visitNotLexprInner(NotLexprInner *p) = 0;
  virtual void visitTrueLexpr(TrueLexpr *p) = 0;
  virtual void visitFalseLexpr(FalseLexpr *p) = 0;
  virtual void visitAutomaticLexpr(AutomaticLexpr *p) = 0;
  virtual void visitDynamicLexpr(DynamicLexpr *p) = 0;
  virtual void visitRegisterLexpr(RegisterLexpr *p) = 0;
  virtual void visitStaticLexpr(StaticLexpr *p) = 0;
  virtual void visitUnallocatedLexpr(UnallocatedLexpr *p) = 0;
  virtual void visitNullLexpr(NullLexpr *p) = 0;
  virtual void visitLexprIntConst(LexprIntConst *p) = 0;
  virtual void visitLexprFloatConst(LexprFloatConst *p) = 0;
  virtual void visitLexprStringConst(LexprStringConst *p) = 0;
  virtual void visitAddLexpr(AddLexpr *p) = 0;
  virtual void visitSubtrLexpr(SubtrLexpr *p) = 0;
  virtual void visitMultLexpr(MultLexpr *p) = 0;
  virtual void visitDivLexpr(DivLexpr *p) = 0;
  virtual void visitModLexpr(ModLexpr *p) = 0;
  virtual void visitStarHatLexpr(StarHatLexpr *p) = 0;
  virtual void visitSquaresLexpr(SquaresLexpr *p) = 0;
  virtual void visitMinusLexpr(MinusLexpr *p) = 0;
  virtual void visitPlusLexpr(PlusLexpr *p) = 0;
  virtual void visitTildeLexpr(TildeLexpr *p) = 0;
  virtual void visitStarLexpr(StarLexpr *p) = 0;
  virtual void visitAmpUnaryLexpr(AmpUnaryLexpr *p) = 0;
  virtual void visitSizeOfLexpr(SizeOfLexpr *p) = 0;
  virtual void visitOldLexpr(OldLexpr *p) = 0;
  virtual void visitResultLexpr(ResultLexpr *p) = 0;
  virtual void visitSeparatedLexpr(SeparatedLexpr *p) = 0;
  virtual void visitFullIdParenLexpr(FullIdParenLexpr *p) = 0;
  virtual void visitFullId(FullId *p) = 0;
  virtual void visitPiLexpr(PiLexpr *p) = 0;
  virtual void visitLessLessLexpr(LessLessLexpr *p) = 0;
  virtual void visitGreaterGreaterLexpr(GreaterGreaterLexpr *p) = 0;
  virtual void visitTypeOfLexpr(TypeOfLexpr *p) = 0;
  virtual void visitEnsuresKeyWord(EnsuresKeyWord *p) = 0;
  virtual void visitExitsKeyWord(ExitsKeyWord *p) = 0;
  virtual void visitBreaksKeyWord(BreaksKeyWord *p) = 0;
  virtual void visitContinuesKeyWord(ContinuesKeyWord *p) = 0;
  virtual void visitReturnsKeyWord(ReturnsKeyWord *p) = 0;
  virtual void visitCheckEnsuresKeyWord(CheckEnsuresKeyWord *p) = 0;
  virtual void visitCheckExitsKeyWord(CheckExitsKeyWord *p) = 0;
  virtual void visitCheckBreaksKeyWord(CheckBreaksKeyWord *p) = 0;
  virtual void visitCheckContinuesKeyWord(CheckContinuesKeyWord *p) = 0;
  virtual void visitCheckReturnsKeyWord(CheckReturnsKeyWord *p) = 0;
  virtual void visitAdmitEnsuresKeyWord(AdmitEnsuresKeyWord *p) = 0;
  virtual void visitAdmitExitsKeyWord(AdmitExitsKeyWord *p) = 0;
  virtual void visitAdmitBreaksKeyWord(AdmitBreaksKeyWord *p) = 0;
  virtual void visitAdmitContinuesKeyWord(AdmitContinuesKeyWord *p) = 0;
  virtual void visitAdmitReturnsKeyWord(AdmitReturnsKeyWord *p) = 0;
  virtual void visitSimpleIdentifierFull(SimpleIdentifierFull *p) = 0;
  virtual void visitIdentifierIdent(IdentifierIdent *p) = 0;
  virtual void visitListAnnot(ListAnnot *p) = 0;
  virtual void visitListLexpr(ListLexpr *p) = 0;
  virtual void visitListLexprRelInner(ListLexprRelInner *p) = 0;
  virtual void visitListFullIdentifier(ListFullIdentifier *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;
  int line_number, char_number;
};

class Annot : public Visitable
{
public:
  virtual Annot *clone() const = 0;
  int line_number, char_number;
};

class Code_Annot : public Visitable
{
public:
  virtual Code_Annot *clone() const = 0;
  int line_number, char_number;
};

class Contract : public Visitable
{
public:
  virtual Contract *clone() const = 0;
  int line_number, char_number;
};

class Requires : public Visitable
{
public:
  virtual Requires *clone() const = 0;
  int line_number, char_number;
};

class NERequires : public Visitable
{
public:
  virtual NERequires *clone() const = 0;
  int line_number, char_number;
};

class ClauseKW : public Visitable
{
public:
  virtual ClauseKW *clone() const = 0;
  int line_number, char_number;
};

class Terminates : public Visitable
{
public:
  virtual Terminates *clone() const = 0;
  int line_number, char_number;
};

class Decreases : public Visitable
{
public:
  virtual Decreases *clone() const = 0;
  int line_number, char_number;
};

class SimpleClauses : public Visitable
{
public:
  virtual SimpleClauses *clone() const = 0;
  int line_number, char_number;
};

class NESimpleClauses : public Visitable
{
public:
  virtual NESimpleClauses *clone() const = 0;
  int line_number, char_number;
};

class Behaviors : public Visitable
{
public:
  virtual Behaviors *clone() const = 0;
  int line_number, char_number;
};

class CompleteOrDisjoint : public Visitable
{
public:
  virtual CompleteOrDisjoint *clone() const = 0;
  int line_number, char_number;
};

class Lexpr : public Visitable
{
public:
  virtual Lexpr *clone() const = 0;
  int line_number, char_number;
};

class LexprRelInner : public Visitable
{
public:
  virtual LexprRelInner *clone() const = 0;
  int line_number, char_number;
};

class Relation : public Visitable
{
public:
  virtual Relation *clone() const = 0;
  int line_number, char_number;
};

class PostCond : public Visitable
{
public:
  virtual PostCond *clone() const = 0;
  int line_number, char_number;
};

class FullIdentifier : public Visitable
{
public:
  virtual FullIdentifier *clone() const = 0;
  int line_number, char_number;
};

class Identifier : public Visitable
{
public:
  virtual Identifier *clone() const = 0;
  int line_number, char_number;
};



class AProgram : public Program
{
public:
  Annot *annot_;

  AProgram(const AProgram &);
  AProgram &operator=(const AProgram &);
  AProgram(Annot *p1);
  ~AProgram();
  virtual void accept(Visitor *v);
  virtual AProgram *clone() const;
  void swap(AProgram &);
};

class CodeAnnot : public Annot
{
public:
  Code_Annot *code_annot_;

  CodeAnnot(const CodeAnnot &);
  CodeAnnot &operator=(const CodeAnnot &);
  CodeAnnot(Code_Annot *p1);
  ~CodeAnnot();
  virtual void accept(Visitor *v);
  virtual CodeAnnot *clone() const;
  void swap(CodeAnnot &);
};

class CodeAnnotContract : public Code_Annot
{
public:
  Contract *contract_;

  CodeAnnotContract(const CodeAnnotContract &);
  CodeAnnotContract &operator=(const CodeAnnotContract &);
  CodeAnnotContract(Contract *p1);
  ~CodeAnnotContract();
  virtual void accept(Visitor *v);
  virtual CodeAnnotContract *clone() const;
  void swap(CodeAnnotContract &);
};

class SimpleContract : public Contract
{
public:
  Requires *requires_;
  Terminates *terminates_;
  Decreases *decreases_;
  SimpleClauses *simpleclauses_;
  Behaviors *behaviors_;
  CompleteOrDisjoint *completeordisjoint_;

  SimpleContract(const SimpleContract &);
  SimpleContract &operator=(const SimpleContract &);
  SimpleContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, CompleteOrDisjoint *p6);
  ~SimpleContract();
  virtual void accept(Visitor *v);
  virtual SimpleContract *clone() const;
  void swap(SimpleContract &);
};

class NoRequires : public Requires
{
public:

  NoRequires(const NoRequires &);
  NoRequires &operator=(const NoRequires &);
  NoRequires();
  ~NoRequires();
  virtual void accept(Visitor *v);
  virtual NoRequires *clone() const;
  void swap(NoRequires &);
};

class SomeRequires : public Requires
{
public:
  NERequires *nerequires_;

  SomeRequires(const SomeRequires &);
  SomeRequires &operator=(const SomeRequires &);
  SomeRequires(NERequires *p1);
  ~SomeRequires();
  virtual void accept(Visitor *v);
  virtual SomeRequires *clone() const;
  void swap(SomeRequires &);
};

class SimpleRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  Requires *requires_;

  SimpleRequires(const SimpleRequires &);
  SimpleRequires &operator=(const SimpleRequires &);
  SimpleRequires(Lexpr *p1, Requires *p2);
  ~SimpleRequires();
  virtual void accept(Visitor *v);
  virtual SimpleRequires *clone() const;
  void swap(SimpleRequires &);
};

class CheckRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  Requires *requires_;

  CheckRequires(const CheckRequires &);
  CheckRequires &operator=(const CheckRequires &);
  CheckRequires(Lexpr *p1, Requires *p2);
  ~CheckRequires();
  virtual void accept(Visitor *v);
  virtual CheckRequires *clone() const;
  void swap(CheckRequires &);
};

class AdimtRequires : public NERequires
{
public:
  Lexpr *lexpr_;
  Requires *requires_;

  AdimtRequires(const AdimtRequires &);
  AdimtRequires &operator=(const AdimtRequires &);
  AdimtRequires(Lexpr *p1, Requires *p2);
  ~AdimtRequires();
  virtual void accept(Visitor *v);
  virtual AdimtRequires *clone() const;
  void swap(AdimtRequires &);
};

class AdmitRequiresClause : public ClauseKW
{
public:

  AdmitRequiresClause(const AdmitRequiresClause &);
  AdmitRequiresClause &operator=(const AdmitRequiresClause &);
  AdmitRequiresClause();
  ~AdmitRequiresClause();
  virtual void accept(Visitor *v);
  virtual AdmitRequiresClause *clone() const;
  void swap(AdmitRequiresClause &);
};

class AdmitInvariantClause : public ClauseKW
{
public:

  AdmitInvariantClause(const AdmitInvariantClause &);
  AdmitInvariantClause &operator=(const AdmitInvariantClause &);
  AdmitInvariantClause();
  ~AdmitInvariantClause();
  virtual void accept(Visitor *v);
  virtual AdmitInvariantClause *clone() const;
  void swap(AdmitInvariantClause &);
};

class AdmitLemmaClause : public ClauseKW
{
public:

  AdmitLemmaClause(const AdmitLemmaClause &);
  AdmitLemmaClause &operator=(const AdmitLemmaClause &);
  AdmitLemmaClause();
  ~AdmitLemmaClause();
  virtual void accept(Visitor *v);
  virtual AdmitLemmaClause *clone() const;
  void swap(AdmitLemmaClause &);
};

class AdmitLoopClause : public ClauseKW
{
public:

  AdmitLoopClause(const AdmitLoopClause &);
  AdmitLoopClause &operator=(const AdmitLoopClause &);
  AdmitLoopClause();
  ~AdmitLoopClause();
  virtual void accept(Visitor *v);
  virtual AdmitLoopClause *clone() const;
  void swap(AdmitLoopClause &);
};

class CheckRequiresClause : public ClauseKW
{
public:

  CheckRequiresClause(const CheckRequiresClause &);
  CheckRequiresClause &operator=(const CheckRequiresClause &);
  CheckRequiresClause();
  ~CheckRequiresClause();
  virtual void accept(Visitor *v);
  virtual CheckRequiresClause *clone() const;
  void swap(CheckRequiresClause &);
};

class CheckInvariantClause : public ClauseKW
{
public:

  CheckInvariantClause(const CheckInvariantClause &);
  CheckInvariantClause &operator=(const CheckInvariantClause &);
  CheckInvariantClause();
  ~CheckInvariantClause();
  virtual void accept(Visitor *v);
  virtual CheckInvariantClause *clone() const;
  void swap(CheckInvariantClause &);
};

class CheckLemmaClause : public ClauseKW
{
public:

  CheckLemmaClause(const CheckLemmaClause &);
  CheckLemmaClause &operator=(const CheckLemmaClause &);
  CheckLemmaClause();
  ~CheckLemmaClause();
  virtual void accept(Visitor *v);
  virtual CheckLemmaClause *clone() const;
  void swap(CheckLemmaClause &);
};

class CheckLoopClause : public ClauseKW
{
public:

  CheckLoopClause(const CheckLoopClause &);
  CheckLoopClause &operator=(const CheckLoopClause &);
  CheckLoopClause();
  ~CheckLoopClause();
  virtual void accept(Visitor *v);
  virtual CheckLoopClause *clone() const;
  void swap(CheckLoopClause &);
};

class RequiresClause : public ClauseKW
{
public:

  RequiresClause(const RequiresClause &);
  RequiresClause &operator=(const RequiresClause &);
  RequiresClause();
  ~RequiresClause();
  virtual void accept(Visitor *v);
  virtual RequiresClause *clone() const;
  void swap(RequiresClause &);
};

class AssumesClause : public ClauseKW
{
public:

  AssumesClause(const AssumesClause &);
  AssumesClause &operator=(const AssumesClause &);
  AssumesClause();
  ~AssumesClause();
  virtual void accept(Visitor *v);
  virtual AssumesClause *clone() const;
  void swap(AssumesClause &);
};

class AssignsClause : public ClauseKW
{
public:

  AssignsClause(const AssignsClause &);
  AssignsClause &operator=(const AssignsClause &);
  AssignsClause();
  ~AssignsClause();
  virtual void accept(Visitor *v);
  virtual AssignsClause *clone() const;
  void swap(AssignsClause &);
};

class PostCondClause : public ClauseKW
{
public:
  PostCond *postcond_;

  PostCondClause(const PostCondClause &);
  PostCondClause &operator=(const PostCondClause &);
  PostCondClause(PostCond *p1);
  ~PostCondClause();
  virtual void accept(Visitor *v);
  virtual PostCondClause *clone() const;
  void swap(PostCondClause &);
};

class DecreasesClause : public ClauseKW
{
public:

  DecreasesClause(const DecreasesClause &);
  DecreasesClause &operator=(const DecreasesClause &);
  DecreasesClause();
  ~DecreasesClause();
  virtual void accept(Visitor *v);
  virtual DecreasesClause *clone() const;
  void swap(DecreasesClause &);
};

class BehaviorClause : public ClauseKW
{
public:

  BehaviorClause(const BehaviorClause &);
  BehaviorClause &operator=(const BehaviorClause &);
  BehaviorClause();
  ~BehaviorClause();
  virtual void accept(Visitor *v);
  virtual BehaviorClause *clone() const;
  void swap(BehaviorClause &);
};

class AllocatesClause : public ClauseKW
{
public:

  AllocatesClause(const AllocatesClause &);
  AllocatesClause &operator=(const AllocatesClause &);
  AllocatesClause();
  ~AllocatesClause();
  virtual void accept(Visitor *v);
  virtual AllocatesClause *clone() const;
  void swap(AllocatesClause &);
};

class FreesClause : public ClauseKW
{
public:

  FreesClause(const FreesClause &);
  FreesClause &operator=(const FreesClause &);
  FreesClause();
  ~FreesClause();
  virtual void accept(Visitor *v);
  virtual FreesClause *clone() const;
  void swap(FreesClause &);
};

class CompleteClause : public ClauseKW
{
public:

  CompleteClause(const CompleteClause &);
  CompleteClause &operator=(const CompleteClause &);
  CompleteClause();
  ~CompleteClause();
  virtual void accept(Visitor *v);
  virtual CompleteClause *clone() const;
  void swap(CompleteClause &);
};

class DisjointClause : public ClauseKW
{
public:

  DisjointClause(const DisjointClause &);
  DisjointClause &operator=(const DisjointClause &);
  DisjointClause();
  ~DisjointClause();
  virtual void accept(Visitor *v);
  virtual DisjointClause *clone() const;
  void swap(DisjointClause &);
};

class EmptyClauseKW : public ClauseKW
{
public:

  EmptyClauseKW(const EmptyClauseKW &);
  EmptyClauseKW &operator=(const EmptyClauseKW &);
  EmptyClauseKW();
  ~EmptyClauseKW();
  virtual void accept(Visitor *v);
  virtual EmptyClauseKW *clone() const;
  void swap(EmptyClauseKW &);
};

class NoTerminate : public Terminates
{
public:

  NoTerminate(const NoTerminate &);
  NoTerminate &operator=(const NoTerminate &);
  NoTerminate();
  ~NoTerminate();
  virtual void accept(Visitor *v);
  virtual NoTerminate *clone() const;
  void swap(NoTerminate &);
};

class NoDecreases : public Decreases
{
public:

  NoDecreases(const NoDecreases &);
  NoDecreases &operator=(const NoDecreases &);
  NoDecreases();
  ~NoDecreases();
  virtual void accept(Visitor *v);
  virtual NoDecreases *clone() const;
  void swap(NoDecreases &);
};

class NoSimpleClauses : public SimpleClauses
{
public:

  NoSimpleClauses(const NoSimpleClauses &);
  NoSimpleClauses &operator=(const NoSimpleClauses &);
  NoSimpleClauses();
  ~NoSimpleClauses();
  virtual void accept(Visitor *v);
  virtual NoSimpleClauses *clone() const;
  void swap(NoSimpleClauses &);
};

class SomeSimpleClauses : public SimpleClauses
{
public:
  NESimpleClauses *nesimpleclauses_;

  SomeSimpleClauses(const SomeSimpleClauses &);
  SomeSimpleClauses &operator=(const SomeSimpleClauses &);
  SomeSimpleClauses(NESimpleClauses *p1);
  ~SomeSimpleClauses();
  virtual void accept(Visitor *v);
  virtual SomeSimpleClauses *clone() const;
  void swap(SomeSimpleClauses &);
};

class PostCondSimpleClauses : public NESimpleClauses
{
public:
  PostCond *postcond_;
  Lexpr *lexpr_;
  SimpleClauses *simpleclauses_;

  PostCondSimpleClauses(const PostCondSimpleClauses &);
  PostCondSimpleClauses &operator=(const PostCondSimpleClauses &);
  PostCondSimpleClauses(PostCond *p1, Lexpr *p2, SimpleClauses *p3);
  ~PostCondSimpleClauses();
  virtual void accept(Visitor *v);
  virtual PostCondSimpleClauses *clone() const;
  void swap(PostCondSimpleClauses &);
};

class NoBehaviors : public Behaviors
{
public:

  NoBehaviors(const NoBehaviors &);
  NoBehaviors &operator=(const NoBehaviors &);
  NoBehaviors();
  ~NoBehaviors();
  virtual void accept(Visitor *v);
  virtual NoBehaviors *clone() const;
  void swap(NoBehaviors &);
};

class NoComplDisj : public CompleteOrDisjoint
{
public:

  NoComplDisj(const NoComplDisj &);
  NoComplDisj &operator=(const NoComplDisj &);
  NoComplDisj();
  ~NoComplDisj();
  virtual void accept(Visitor *v);
  virtual NoComplDisj *clone() const;
  void swap(NoComplDisj &);
};

class NoLexpr : public Lexpr
{
public:

  NoLexpr(const NoLexpr &);
  NoLexpr &operator=(const NoLexpr &);
  NoLexpr();
  ~NoLexpr();
  virtual void accept(Visitor *v);
  virtual NoLexpr *clone() const;
  void swap(NoLexpr &);
};

class ImplLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  ImplLexpr(const ImplLexpr &);
  ImplLexpr &operator=(const ImplLexpr &);
  ImplLexpr(Lexpr *p1, Lexpr *p2);
  ~ImplLexpr();
  virtual void accept(Visitor *v);
  virtual ImplLexpr *clone() const;
  void swap(ImplLexpr &);
};

class IffLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  IffLexpr(const IffLexpr &);
  IffLexpr &operator=(const IffLexpr &);
  IffLexpr(Lexpr *p1, Lexpr *p2);
  ~IffLexpr();
  virtual void accept(Visitor *v);
  virtual IffLexpr *clone() const;
  void swap(IffLexpr &);
};

class OrLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  OrLexpr(const OrLexpr &);
  OrLexpr &operator=(const OrLexpr &);
  OrLexpr(Lexpr *p1, Lexpr *p2);
  ~OrLexpr();
  virtual void accept(Visitor *v);
  virtual OrLexpr *clone() const;
  void swap(OrLexpr &);
};

class AndLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AndLexpr(const AndLexpr &);
  AndLexpr &operator=(const AndLexpr &);
  AndLexpr(Lexpr *p1, Lexpr *p2);
  ~AndLexpr();
  virtual void accept(Visitor *v);
  virtual AndLexpr *clone() const;
  void swap(AndLexpr &);
};

class HatHatLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  HatHatLexpr(const HatHatLexpr &);
  HatHatLexpr &operator=(const HatHatLexpr &);
  HatHatLexpr(Lexpr *p1, Lexpr *p2);
  ~HatHatLexpr();
  virtual void accept(Visitor *v);
  virtual HatHatLexpr *clone() const;
  void swap(HatHatLexpr &);
};

class AmpLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AmpLexpr(const AmpLexpr &);
  AmpLexpr &operator=(const AmpLexpr &);
  AmpLexpr(Lexpr *p1, Lexpr *p2);
  ~AmpLexpr();
  virtual void accept(Visitor *v);
  virtual AmpLexpr *clone() const;
  void swap(AmpLexpr &);
};

class PipeLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  PipeLexpr(const PipeLexpr &);
  PipeLexpr &operator=(const PipeLexpr &);
  PipeLexpr(Lexpr *p1, Lexpr *p2);
  ~PipeLexpr();
  virtual void accept(Visitor *v);
  virtual PipeLexpr *clone() const;
  void swap(PipeLexpr &);
};

class HatLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  HatLexpr(const HatLexpr &);
  HatLexpr &operator=(const HatLexpr &);
  HatLexpr(Lexpr *p1, Lexpr *p2);
  ~HatLexpr();
  virtual void accept(Visitor *v);
  virtual HatLexpr *clone() const;
  void swap(HatLexpr &);
};

class BimpliesLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  BimpliesLexpr(const BimpliesLexpr &);
  BimpliesLexpr &operator=(const BimpliesLexpr &);
  BimpliesLexpr(Lexpr *p1, Lexpr *p2);
  ~BimpliesLexpr();
  virtual void accept(Visitor *v);
  virtual BimpliesLexpr *clone() const;
  void swap(BimpliesLexpr &);
};

class BiffLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  BiffLexpr(const BiffLexpr &);
  BiffLexpr &operator=(const BiffLexpr &);
  BiffLexpr(Lexpr *p1, Lexpr *p2);
  ~BiffLexpr();
  virtual void accept(Visitor *v);
  virtual BiffLexpr *clone() const;
  void swap(BiffLexpr &);
};

class InLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  InLexpr(const InLexpr &);
  InLexpr &operator=(const InLexpr &);
  InLexpr(Lexpr *p1, Lexpr *p2);
  ~InLexpr();
  virtual void accept(Visitor *v);
  virtual InLexpr *clone() const;
  void swap(InLexpr &);
};

class TernaryLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;
  Lexpr *lexpr_3;

  TernaryLexpr(const TernaryLexpr &);
  TernaryLexpr &operator=(const TernaryLexpr &);
  TernaryLexpr(Lexpr *p1, Lexpr *p2, Lexpr *p3);
  ~TernaryLexpr();
  virtual void accept(Visitor *v);
  virtual TernaryLexpr *clone() const;
  void swap(TernaryLexpr &);
};

class RelationLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  ListLexprRelInner *listlexprrelinner_;
  Relation *relation_;
  Lexpr *lexpr_2;

  RelationLexpr(const RelationLexpr &);
  RelationLexpr &operator=(const RelationLexpr &);
  RelationLexpr(Lexpr *p1, ListLexprRelInner *p2, Relation *p3, Lexpr *p4);
  ~RelationLexpr();
  virtual void accept(Visitor *v);
  virtual RelationLexpr *clone() const;
  void swap(RelationLexpr &);
};

class NotLexprInner : public Lexpr
{
public:
  Lexpr *lexpr_;

  NotLexprInner(const NotLexprInner &);
  NotLexprInner &operator=(const NotLexprInner &);
  NotLexprInner(Lexpr *p1);
  ~NotLexprInner();
  virtual void accept(Visitor *v);
  virtual NotLexprInner *clone() const;
  void swap(NotLexprInner &);
};

class TrueLexpr : public Lexpr
{
public:

  TrueLexpr(const TrueLexpr &);
  TrueLexpr &operator=(const TrueLexpr &);
  TrueLexpr();
  ~TrueLexpr();
  virtual void accept(Visitor *v);
  virtual TrueLexpr *clone() const;
  void swap(TrueLexpr &);
};

class FalseLexpr : public Lexpr
{
public:

  FalseLexpr(const FalseLexpr &);
  FalseLexpr &operator=(const FalseLexpr &);
  FalseLexpr();
  ~FalseLexpr();
  virtual void accept(Visitor *v);
  virtual FalseLexpr *clone() const;
  void swap(FalseLexpr &);
};

class AutomaticLexpr : public Lexpr
{
public:

  AutomaticLexpr(const AutomaticLexpr &);
  AutomaticLexpr &operator=(const AutomaticLexpr &);
  AutomaticLexpr();
  ~AutomaticLexpr();
  virtual void accept(Visitor *v);
  virtual AutomaticLexpr *clone() const;
  void swap(AutomaticLexpr &);
};

class DynamicLexpr : public Lexpr
{
public:

  DynamicLexpr(const DynamicLexpr &);
  DynamicLexpr &operator=(const DynamicLexpr &);
  DynamicLexpr();
  ~DynamicLexpr();
  virtual void accept(Visitor *v);
  virtual DynamicLexpr *clone() const;
  void swap(DynamicLexpr &);
};

class RegisterLexpr : public Lexpr
{
public:

  RegisterLexpr(const RegisterLexpr &);
  RegisterLexpr &operator=(const RegisterLexpr &);
  RegisterLexpr();
  ~RegisterLexpr();
  virtual void accept(Visitor *v);
  virtual RegisterLexpr *clone() const;
  void swap(RegisterLexpr &);
};

class StaticLexpr : public Lexpr
{
public:

  StaticLexpr(const StaticLexpr &);
  StaticLexpr &operator=(const StaticLexpr &);
  StaticLexpr();
  ~StaticLexpr();
  virtual void accept(Visitor *v);
  virtual StaticLexpr *clone() const;
  void swap(StaticLexpr &);
};

class UnallocatedLexpr : public Lexpr
{
public:

  UnallocatedLexpr(const UnallocatedLexpr &);
  UnallocatedLexpr &operator=(const UnallocatedLexpr &);
  UnallocatedLexpr();
  ~UnallocatedLexpr();
  virtual void accept(Visitor *v);
  virtual UnallocatedLexpr *clone() const;
  void swap(UnallocatedLexpr &);
};

class NullLexpr : public Lexpr
{
public:

  NullLexpr(const NullLexpr &);
  NullLexpr &operator=(const NullLexpr &);
  NullLexpr();
  ~NullLexpr();
  virtual void accept(Visitor *v);
  virtual NullLexpr *clone() const;
  void swap(NullLexpr &);
};

class LexprIntConst : public Lexpr
{
public:
  Integer integer_;

  LexprIntConst(const LexprIntConst &);
  LexprIntConst &operator=(const LexprIntConst &);
  LexprIntConst(Integer p1);
  ~LexprIntConst();
  virtual void accept(Visitor *v);
  virtual LexprIntConst *clone() const;
  void swap(LexprIntConst &);
};

class LexprFloatConst : public Lexpr
{
public:
  Double double_;

  LexprFloatConst(const LexprFloatConst &);
  LexprFloatConst &operator=(const LexprFloatConst &);
  LexprFloatConst(Double p1);
  ~LexprFloatConst();
  virtual void accept(Visitor *v);
  virtual LexprFloatConst *clone() const;
  void swap(LexprFloatConst &);
};

class LexprStringConst : public Lexpr
{
public:
  String string_;

  LexprStringConst(const LexprStringConst &);
  LexprStringConst &operator=(const LexprStringConst &);
  LexprStringConst(String p1);
  ~LexprStringConst();
  virtual void accept(Visitor *v);
  virtual LexprStringConst *clone() const;
  void swap(LexprStringConst &);
};

class AddLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  AddLexpr(const AddLexpr &);
  AddLexpr &operator=(const AddLexpr &);
  AddLexpr(Lexpr *p1, Lexpr *p2);
  ~AddLexpr();
  virtual void accept(Visitor *v);
  virtual AddLexpr *clone() const;
  void swap(AddLexpr &);
};

class SubtrLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  SubtrLexpr(const SubtrLexpr &);
  SubtrLexpr &operator=(const SubtrLexpr &);
  SubtrLexpr(Lexpr *p1, Lexpr *p2);
  ~SubtrLexpr();
  virtual void accept(Visitor *v);
  virtual SubtrLexpr *clone() const;
  void swap(SubtrLexpr &);
};

class MultLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  MultLexpr(const MultLexpr &);
  MultLexpr &operator=(const MultLexpr &);
  MultLexpr(Lexpr *p1, Lexpr *p2);
  ~MultLexpr();
  virtual void accept(Visitor *v);
  virtual MultLexpr *clone() const;
  void swap(MultLexpr &);
};

class DivLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  DivLexpr(const DivLexpr &);
  DivLexpr &operator=(const DivLexpr &);
  DivLexpr(Lexpr *p1, Lexpr *p2);
  ~DivLexpr();
  virtual void accept(Visitor *v);
  virtual DivLexpr *clone() const;
  void swap(DivLexpr &);
};

class ModLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  ModLexpr(const ModLexpr &);
  ModLexpr &operator=(const ModLexpr &);
  ModLexpr(Lexpr *p1, Lexpr *p2);
  ~ModLexpr();
  virtual void accept(Visitor *v);
  virtual ModLexpr *clone() const;
  void swap(ModLexpr &);
};

class StarHatLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  StarHatLexpr(const StarHatLexpr &);
  StarHatLexpr &operator=(const StarHatLexpr &);
  StarHatLexpr(Lexpr *p1, Lexpr *p2);
  ~StarHatLexpr();
  virtual void accept(Visitor *v);
  virtual StarHatLexpr *clone() const;
  void swap(StarHatLexpr &);
};

class SquaresLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  SquaresLexpr(const SquaresLexpr &);
  SquaresLexpr &operator=(const SquaresLexpr &);
  SquaresLexpr(Lexpr *p1, Lexpr *p2);
  ~SquaresLexpr();
  virtual void accept(Visitor *v);
  virtual SquaresLexpr *clone() const;
  void swap(SquaresLexpr &);
};

class MinusLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  MinusLexpr(const MinusLexpr &);
  MinusLexpr &operator=(const MinusLexpr &);
  MinusLexpr(Lexpr *p1);
  ~MinusLexpr();
  virtual void accept(Visitor *v);
  virtual MinusLexpr *clone() const;
  void swap(MinusLexpr &);
};

class PlusLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  PlusLexpr(const PlusLexpr &);
  PlusLexpr &operator=(const PlusLexpr &);
  PlusLexpr(Lexpr *p1);
  ~PlusLexpr();
  virtual void accept(Visitor *v);
  virtual PlusLexpr *clone() const;
  void swap(PlusLexpr &);
};

class TildeLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  TildeLexpr(const TildeLexpr &);
  TildeLexpr &operator=(const TildeLexpr &);
  TildeLexpr(Lexpr *p1);
  ~TildeLexpr();
  virtual void accept(Visitor *v);
  virtual TildeLexpr *clone() const;
  void swap(TildeLexpr &);
};

class StarLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  StarLexpr(const StarLexpr &);
  StarLexpr &operator=(const StarLexpr &);
  StarLexpr(Lexpr *p1);
  ~StarLexpr();
  virtual void accept(Visitor *v);
  virtual StarLexpr *clone() const;
  void swap(StarLexpr &);
};

class AmpUnaryLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  AmpUnaryLexpr(const AmpUnaryLexpr &);
  AmpUnaryLexpr &operator=(const AmpUnaryLexpr &);
  AmpUnaryLexpr(Lexpr *p1);
  ~AmpUnaryLexpr();
  virtual void accept(Visitor *v);
  virtual AmpUnaryLexpr *clone() const;
  void swap(AmpUnaryLexpr &);
};

class SizeOfLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  SizeOfLexpr(const SizeOfLexpr &);
  SizeOfLexpr &operator=(const SizeOfLexpr &);
  SizeOfLexpr(Lexpr *p1);
  ~SizeOfLexpr();
  virtual void accept(Visitor *v);
  virtual SizeOfLexpr *clone() const;
  void swap(SizeOfLexpr &);
};

class OldLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  OldLexpr(const OldLexpr &);
  OldLexpr &operator=(const OldLexpr &);
  OldLexpr(Lexpr *p1);
  ~OldLexpr();
  virtual void accept(Visitor *v);
  virtual OldLexpr *clone() const;
  void swap(OldLexpr &);
};

class ResultLexpr : public Lexpr
{
public:

  ResultLexpr(const ResultLexpr &);
  ResultLexpr &operator=(const ResultLexpr &);
  ResultLexpr();
  ~ResultLexpr();
  virtual void accept(Visitor *v);
  virtual ResultLexpr *clone() const;
  void swap(ResultLexpr &);
};

class SeparatedLexpr : public Lexpr
{
public:
  ListLexpr *listlexpr_;

  SeparatedLexpr(const SeparatedLexpr &);
  SeparatedLexpr &operator=(const SeparatedLexpr &);
  SeparatedLexpr(ListLexpr *p1);
  ~SeparatedLexpr();
  virtual void accept(Visitor *v);
  virtual SeparatedLexpr *clone() const;
  void swap(SeparatedLexpr &);
};

class FullIdParenLexpr : public Lexpr
{
public:
  FullIdentifier *fullidentifier_;
  ListLexpr *listlexpr_;

  FullIdParenLexpr(const FullIdParenLexpr &);
  FullIdParenLexpr &operator=(const FullIdParenLexpr &);
  FullIdParenLexpr(FullIdentifier *p1, ListLexpr *p2);
  ~FullIdParenLexpr();
  virtual void accept(Visitor *v);
  virtual FullIdParenLexpr *clone() const;
  void swap(FullIdParenLexpr &);
};

class FullId : public Lexpr
{
public:
  FullIdentifier *fullidentifier_;

  FullId(const FullId &);
  FullId &operator=(const FullId &);
  FullId(FullIdentifier *p1);
  ~FullId();
  virtual void accept(Visitor *v);
  virtual FullId *clone() const;
  void swap(FullId &);
};

class PiLexpr : public Lexpr
{
public:

  PiLexpr(const PiLexpr &);
  PiLexpr &operator=(const PiLexpr &);
  PiLexpr();
  ~PiLexpr();
  virtual void accept(Visitor *v);
  virtual PiLexpr *clone() const;
  void swap(PiLexpr &);
};

class LessLessLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  LessLessLexpr(const LessLessLexpr &);
  LessLessLexpr &operator=(const LessLessLexpr &);
  LessLessLexpr(Lexpr *p1, Lexpr *p2);
  ~LessLessLexpr();
  virtual void accept(Visitor *v);
  virtual LessLessLexpr *clone() const;
  void swap(LessLessLexpr &);
};

class GreaterGreaterLexpr : public Lexpr
{
public:
  Lexpr *lexpr_1;
  Lexpr *lexpr_2;

  GreaterGreaterLexpr(const GreaterGreaterLexpr &);
  GreaterGreaterLexpr &operator=(const GreaterGreaterLexpr &);
  GreaterGreaterLexpr(Lexpr *p1, Lexpr *p2);
  ~GreaterGreaterLexpr();
  virtual void accept(Visitor *v);
  virtual GreaterGreaterLexpr *clone() const;
  void swap(GreaterGreaterLexpr &);
};

class TypeOfLexpr : public Lexpr
{
public:
  Lexpr *lexpr_;

  TypeOfLexpr(const TypeOfLexpr &);
  TypeOfLexpr &operator=(const TypeOfLexpr &);
  TypeOfLexpr(Lexpr *p1);
  ~TypeOfLexpr();
  virtual void accept(Visitor *v);
  virtual TypeOfLexpr *clone() const;
  void swap(TypeOfLexpr &);
};

class RelInnerLexpr : public LexprRelInner
{
public:
  Relation *relation_;
  Lexpr *lexpr_;

  RelInnerLexpr(const RelInnerLexpr &);
  RelInnerLexpr &operator=(const RelInnerLexpr &);
  RelInnerLexpr(Relation *p1, Lexpr *p2);
  ~RelInnerLexpr();
  virtual void accept(Visitor *v);
  virtual RelInnerLexpr *clone() const;
  void swap(RelInnerLexpr &);
};

class LessRel : public Relation
{
public:

  LessRel(const LessRel &);
  LessRel &operator=(const LessRel &);
  LessRel();
  ~LessRel();
  virtual void accept(Visitor *v);
  virtual LessRel *clone() const;
  void swap(LessRel &);
};

class GreaterRel : public Relation
{
public:

  GreaterRel(const GreaterRel &);
  GreaterRel &operator=(const GreaterRel &);
  GreaterRel();
  ~GreaterRel();
  virtual void accept(Visitor *v);
  virtual GreaterRel *clone() const;
  void swap(GreaterRel &);
};

class LessEqRel : public Relation
{
public:

  LessEqRel(const LessEqRel &);
  LessEqRel &operator=(const LessEqRel &);
  LessEqRel();
  ~LessEqRel();
  virtual void accept(Visitor *v);
  virtual LessEqRel *clone() const;
  void swap(LessEqRel &);
};

class GreaterEqRel : public Relation
{
public:

  GreaterEqRel(const GreaterEqRel &);
  GreaterEqRel &operator=(const GreaterEqRel &);
  GreaterEqRel();
  ~GreaterEqRel();
  virtual void accept(Visitor *v);
  virtual GreaterEqRel *clone() const;
  void swap(GreaterEqRel &);
};

class EqRel : public Relation
{
public:

  EqRel(const EqRel &);
  EqRel &operator=(const EqRel &);
  EqRel();
  ~EqRel();
  virtual void accept(Visitor *v);
  virtual EqRel *clone() const;
  void swap(EqRel &);
};

class NotEqRel : public Relation
{
public:

  NotEqRel(const NotEqRel &);
  NotEqRel &operator=(const NotEqRel &);
  NotEqRel();
  ~NotEqRel();
  virtual void accept(Visitor *v);
  virtual NotEqRel *clone() const;
  void swap(NotEqRel &);
};

class EnsuresKeyWord : public PostCond
{
public:

  EnsuresKeyWord(const EnsuresKeyWord &);
  EnsuresKeyWord &operator=(const EnsuresKeyWord &);
  EnsuresKeyWord();
  ~EnsuresKeyWord();
  virtual void accept(Visitor *v);
  virtual EnsuresKeyWord *clone() const;
  void swap(EnsuresKeyWord &);
};

class ExitsKeyWord : public PostCond
{
public:

  ExitsKeyWord(const ExitsKeyWord &);
  ExitsKeyWord &operator=(const ExitsKeyWord &);
  ExitsKeyWord();
  ~ExitsKeyWord();
  virtual void accept(Visitor *v);
  virtual ExitsKeyWord *clone() const;
  void swap(ExitsKeyWord &);
};

class BreaksKeyWord : public PostCond
{
public:

  BreaksKeyWord(const BreaksKeyWord &);
  BreaksKeyWord &operator=(const BreaksKeyWord &);
  BreaksKeyWord();
  ~BreaksKeyWord();
  virtual void accept(Visitor *v);
  virtual BreaksKeyWord *clone() const;
  void swap(BreaksKeyWord &);
};

class ContinuesKeyWord : public PostCond
{
public:

  ContinuesKeyWord(const ContinuesKeyWord &);
  ContinuesKeyWord &operator=(const ContinuesKeyWord &);
  ContinuesKeyWord();
  ~ContinuesKeyWord();
  virtual void accept(Visitor *v);
  virtual ContinuesKeyWord *clone() const;
  void swap(ContinuesKeyWord &);
};

class ReturnsKeyWord : public PostCond
{
public:

  ReturnsKeyWord(const ReturnsKeyWord &);
  ReturnsKeyWord &operator=(const ReturnsKeyWord &);
  ReturnsKeyWord();
  ~ReturnsKeyWord();
  virtual void accept(Visitor *v);
  virtual ReturnsKeyWord *clone() const;
  void swap(ReturnsKeyWord &);
};

class CheckEnsuresKeyWord : public PostCond
{
public:

  CheckEnsuresKeyWord(const CheckEnsuresKeyWord &);
  CheckEnsuresKeyWord &operator=(const CheckEnsuresKeyWord &);
  CheckEnsuresKeyWord();
  ~CheckEnsuresKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckEnsuresKeyWord *clone() const;
  void swap(CheckEnsuresKeyWord &);
};

class CheckExitsKeyWord : public PostCond
{
public:

  CheckExitsKeyWord(const CheckExitsKeyWord &);
  CheckExitsKeyWord &operator=(const CheckExitsKeyWord &);
  CheckExitsKeyWord();
  ~CheckExitsKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckExitsKeyWord *clone() const;
  void swap(CheckExitsKeyWord &);
};

class CheckBreaksKeyWord : public PostCond
{
public:

  CheckBreaksKeyWord(const CheckBreaksKeyWord &);
  CheckBreaksKeyWord &operator=(const CheckBreaksKeyWord &);
  CheckBreaksKeyWord();
  ~CheckBreaksKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckBreaksKeyWord *clone() const;
  void swap(CheckBreaksKeyWord &);
};

class CheckContinuesKeyWord : public PostCond
{
public:

  CheckContinuesKeyWord(const CheckContinuesKeyWord &);
  CheckContinuesKeyWord &operator=(const CheckContinuesKeyWord &);
  CheckContinuesKeyWord();
  ~CheckContinuesKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckContinuesKeyWord *clone() const;
  void swap(CheckContinuesKeyWord &);
};

class CheckReturnsKeyWord : public PostCond
{
public:

  CheckReturnsKeyWord(const CheckReturnsKeyWord &);
  CheckReturnsKeyWord &operator=(const CheckReturnsKeyWord &);
  CheckReturnsKeyWord();
  ~CheckReturnsKeyWord();
  virtual void accept(Visitor *v);
  virtual CheckReturnsKeyWord *clone() const;
  void swap(CheckReturnsKeyWord &);
};

class AdmitEnsuresKeyWord : public PostCond
{
public:

  AdmitEnsuresKeyWord(const AdmitEnsuresKeyWord &);
  AdmitEnsuresKeyWord &operator=(const AdmitEnsuresKeyWord &);
  AdmitEnsuresKeyWord();
  ~AdmitEnsuresKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitEnsuresKeyWord *clone() const;
  void swap(AdmitEnsuresKeyWord &);
};

class AdmitExitsKeyWord : public PostCond
{
public:

  AdmitExitsKeyWord(const AdmitExitsKeyWord &);
  AdmitExitsKeyWord &operator=(const AdmitExitsKeyWord &);
  AdmitExitsKeyWord();
  ~AdmitExitsKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitExitsKeyWord *clone() const;
  void swap(AdmitExitsKeyWord &);
};

class AdmitBreaksKeyWord : public PostCond
{
public:

  AdmitBreaksKeyWord(const AdmitBreaksKeyWord &);
  AdmitBreaksKeyWord &operator=(const AdmitBreaksKeyWord &);
  AdmitBreaksKeyWord();
  ~AdmitBreaksKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitBreaksKeyWord *clone() const;
  void swap(AdmitBreaksKeyWord &);
};

class AdmitContinuesKeyWord : public PostCond
{
public:

  AdmitContinuesKeyWord(const AdmitContinuesKeyWord &);
  AdmitContinuesKeyWord &operator=(const AdmitContinuesKeyWord &);
  AdmitContinuesKeyWord();
  ~AdmitContinuesKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitContinuesKeyWord *clone() const;
  void swap(AdmitContinuesKeyWord &);
};

class AdmitReturnsKeyWord : public PostCond
{
public:

  AdmitReturnsKeyWord(const AdmitReturnsKeyWord &);
  AdmitReturnsKeyWord &operator=(const AdmitReturnsKeyWord &);
  AdmitReturnsKeyWord();
  ~AdmitReturnsKeyWord();
  virtual void accept(Visitor *v);
  virtual AdmitReturnsKeyWord *clone() const;
  void swap(AdmitReturnsKeyWord &);
};

class SimpleIdentifierFull : public FullIdentifier
{
public:
  Identifier *identifier_;

  SimpleIdentifierFull(const SimpleIdentifierFull &);
  SimpleIdentifierFull &operator=(const SimpleIdentifierFull &);
  SimpleIdentifierFull(Identifier *p1);
  ~SimpleIdentifierFull();
  virtual void accept(Visitor *v);
  virtual SimpleIdentifierFull *clone() const;
  void swap(SimpleIdentifierFull &);
};

class IdentifierIdent : public Identifier
{
public:
  Ident ident_;

  IdentifierIdent(const IdentifierIdent &);
  IdentifierIdent &operator=(const IdentifierIdent &);
  IdentifierIdent(Ident p1);
  ~IdentifierIdent();
  virtual void accept(Visitor *v);
  virtual IdentifierIdent *clone() const;
  void swap(IdentifierIdent &);
};



class ListAnnot : public Visitable, public std::vector<Annot*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListAnnot *clone() const;
};

ListAnnot* consListAnnot(Annot* x, ListAnnot* xs);

class ListLexpr : public Visitable, public std::vector<Lexpr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLexpr *clone() const;
};

ListLexpr* consListLexpr(Lexpr* x, ListLexpr* xs);

class ListLexprRelInner : public Visitable, public std::vector<LexprRelInner*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLexprRelInner *clone() const;
};

ListLexprRelInner* consListLexprRelInner(LexprRelInner* x, ListLexprRelInner* xs);

class ListFullIdentifier : public Visitable, public std::vector<FullIdentifier*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFullIdentifier *clone() const;
};

ListFullIdentifier* consListFullIdentifier(FullIdentifier* x, ListFullIdentifier* xs);




}
#endif
