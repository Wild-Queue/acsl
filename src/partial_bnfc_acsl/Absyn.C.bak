/* File generated by the BNF Converter (bnfc 2.9.4.1). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace partial_bnfc_acsl
{
/********************   AProgram    ********************/
AProgram::AProgram(Annot *p1)
{
  annot_ = p1;

}

AProgram::AProgram(const AProgram & other)
{
  annot_ = other.annot_->clone();

}

AProgram &AProgram::operator=(const AProgram & other)
{
  AProgram tmp(other);
  swap(tmp);
  return *this;
}

void AProgram::swap(AProgram & other)
{
  std::swap(annot_, other.annot_);

}

AProgram::~AProgram()
{
  delete(annot_);

}

void AProgram::accept(Visitor *v)
{
  v->visitAProgram(this);
}

AProgram *AProgram::clone() const
{
  return new AProgram(*this);
}



/********************   CodeAnnot    ********************/
CodeAnnot::CodeAnnot(Code_Annot *p1)
{
  code_annot_ = p1;

}

CodeAnnot::CodeAnnot(const CodeAnnot & other)
{
  code_annot_ = other.code_annot_->clone();

}

CodeAnnot &CodeAnnot::operator=(const CodeAnnot & other)
{
  CodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void CodeAnnot::swap(CodeAnnot & other)
{
  std::swap(code_annot_, other.code_annot_);

}

CodeAnnot::~CodeAnnot()
{
  delete(code_annot_);

}

void CodeAnnot::accept(Visitor *v)
{
  v->visitCodeAnnot(this);
}

CodeAnnot *CodeAnnot::clone() const
{
  return new CodeAnnot(*this);
}



/********************   CodeAnnotContract    ********************/
CodeAnnotContract::CodeAnnotContract(Contract *p1)
{
  contract_ = p1;

}

CodeAnnotContract::CodeAnnotContract(const CodeAnnotContract & other)
{
  contract_ = other.contract_->clone();

}

CodeAnnotContract &CodeAnnotContract::operator=(const CodeAnnotContract & other)
{
  CodeAnnotContract tmp(other);
  swap(tmp);
  return *this;
}

void CodeAnnotContract::swap(CodeAnnotContract & other)
{
  std::swap(contract_, other.contract_);

}

CodeAnnotContract::~CodeAnnotContract()
{
  delete(contract_);

}

void CodeAnnotContract::accept(Visitor *v)
{
  v->visitCodeAnnotContract(this);
}

CodeAnnotContract *CodeAnnotContract::clone() const
{
  return new CodeAnnotContract(*this);
}



/********************   SimpleContract    ********************/
SimpleContract::SimpleContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, CompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  completeordisjoint_ = p6;

}

SimpleContract::SimpleContract(const SimpleContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  completeordisjoint_ = other.completeordisjoint_->clone();

}

SimpleContract &SimpleContract::operator=(const SimpleContract & other)
{
  SimpleContract tmp(other);
  swap(tmp);
  return *this;
}

void SimpleContract::swap(SimpleContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(completeordisjoint_, other.completeordisjoint_);

}

SimpleContract::~SimpleContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(completeordisjoint_);

}

void SimpleContract::accept(Visitor *v)
{
  v->visitSimpleContract(this);
}

SimpleContract *SimpleContract::clone() const
{
  return new SimpleContract(*this);
}



/********************   NoRequires    ********************/
NoRequires::NoRequires()
{

}

NoRequires::NoRequires(const NoRequires & other)
{

}

NoRequires &NoRequires::operator=(const NoRequires & other)
{
  NoRequires tmp(other);
  swap(tmp);
  return *this;
}

void NoRequires::swap(NoRequires & other)
{

}

NoRequires::~NoRequires()
{

}

void NoRequires::accept(Visitor *v)
{
  v->visitNoRequires(this);
}

NoRequires *NoRequires::clone() const
{
  return new NoRequires(*this);
}



/********************   SomeRequires    ********************/
SomeRequires::SomeRequires(NERequires *p1)
{
  nerequires_ = p1;

}

SomeRequires::SomeRequires(const SomeRequires & other)
{
  nerequires_ = other.nerequires_->clone();

}

SomeRequires &SomeRequires::operator=(const SomeRequires & other)
{
  SomeRequires tmp(other);
  swap(tmp);
  return *this;
}

void SomeRequires::swap(SomeRequires & other)
{
  std::swap(nerequires_, other.nerequires_);

}

SomeRequires::~SomeRequires()
{
  delete(nerequires_);

}

void SomeRequires::accept(Visitor *v)
{
  v->visitSomeRequires(this);
}

SomeRequires *SomeRequires::clone() const
{
  return new SomeRequires(*this);
}



/********************   SimpleRequires    ********************/
SimpleRequires::SimpleRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

SimpleRequires::SimpleRequires(const SimpleRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

SimpleRequires &SimpleRequires::operator=(const SimpleRequires & other)
{
  SimpleRequires tmp(other);
  swap(tmp);
  return *this;
}

void SimpleRequires::swap(SimpleRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

SimpleRequires::~SimpleRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void SimpleRequires::accept(Visitor *v)
{
  v->visitSimpleRequires(this);
}

SimpleRequires *SimpleRequires::clone() const
{
  return new SimpleRequires(*this);
}



/********************   CheckRequires    ********************/
CheckRequires::CheckRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

CheckRequires::CheckRequires(const CheckRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

CheckRequires &CheckRequires::operator=(const CheckRequires & other)
{
  CheckRequires tmp(other);
  swap(tmp);
  return *this;
}

void CheckRequires::swap(CheckRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

CheckRequires::~CheckRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void CheckRequires::accept(Visitor *v)
{
  v->visitCheckRequires(this);
}

CheckRequires *CheckRequires::clone() const
{
  return new CheckRequires(*this);
}



/********************   AdimtRequires    ********************/
AdimtRequires::AdimtRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

AdimtRequires::AdimtRequires(const AdimtRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

AdimtRequires &AdimtRequires::operator=(const AdimtRequires & other)
{
  AdimtRequires tmp(other);
  swap(tmp);
  return *this;
}

void AdimtRequires::swap(AdimtRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

AdimtRequires::~AdimtRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void AdimtRequires::accept(Visitor *v)
{
  v->visitAdimtRequires(this);
}

AdimtRequires *AdimtRequires::clone() const
{
  return new AdimtRequires(*this);
}



/********************   NoTerminate    ********************/
NoTerminate::NoTerminate()
{

}

NoTerminate::NoTerminate(const NoTerminate & other)
{

}

NoTerminate &NoTerminate::operator=(const NoTerminate & other)
{
  NoTerminate tmp(other);
  swap(tmp);
  return *this;
}

void NoTerminate::swap(NoTerminate & other)
{

}

NoTerminate::~NoTerminate()
{

}

void NoTerminate::accept(Visitor *v)
{
  v->visitNoTerminate(this);
}

NoTerminate *NoTerminate::clone() const
{
  return new NoTerminate(*this);
}



/********************   NoDecreases    ********************/
NoDecreases::NoDecreases()
{

}

NoDecreases::NoDecreases(const NoDecreases & other)
{

}

NoDecreases &NoDecreases::operator=(const NoDecreases & other)
{
  NoDecreases tmp(other);
  swap(tmp);
  return *this;
}

void NoDecreases::swap(NoDecreases & other)
{

}

NoDecreases::~NoDecreases()
{

}

void NoDecreases::accept(Visitor *v)
{
  v->visitNoDecreases(this);
}

NoDecreases *NoDecreases::clone() const
{
  return new NoDecreases(*this);
}



/********************   NoSimpleClauses    ********************/
NoSimpleClauses::NoSimpleClauses()
{

}

NoSimpleClauses::NoSimpleClauses(const NoSimpleClauses & other)
{

}

NoSimpleClauses &NoSimpleClauses::operator=(const NoSimpleClauses & other)
{
  NoSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void NoSimpleClauses::swap(NoSimpleClauses & other)
{

}

NoSimpleClauses::~NoSimpleClauses()
{

}

void NoSimpleClauses::accept(Visitor *v)
{
  v->visitNoSimpleClauses(this);
}

NoSimpleClauses *NoSimpleClauses::clone() const
{
  return new NoSimpleClauses(*this);
}



/********************   SomeSimpleClauses    ********************/
SomeSimpleClauses::SomeSimpleClauses(NESimpleClauses *p1)
{
  nesimpleclauses_ = p1;

}

SomeSimpleClauses::SomeSimpleClauses(const SomeSimpleClauses & other)
{
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

SomeSimpleClauses &SomeSimpleClauses::operator=(const SomeSimpleClauses & other)
{
  SomeSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void SomeSimpleClauses::swap(SomeSimpleClauses & other)
{
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

SomeSimpleClauses::~SomeSimpleClauses()
{
  delete(nesimpleclauses_);

}

void SomeSimpleClauses::accept(Visitor *v)
{
  v->visitSomeSimpleClauses(this);
}

SomeSimpleClauses *SomeSimpleClauses::clone() const
{
  return new SomeSimpleClauses(*this);
}



/********************   PostCondSimpleClauses    ********************/
PostCondSimpleClauses::PostCondSimpleClauses(PostCond *p1, Lexpr *p2, SimpleClauses *p3)
{
  postcond_ = p1;
  lexpr_ = p2;
  simpleclauses_ = p3;

}

PostCondSimpleClauses::PostCondSimpleClauses(const PostCondSimpleClauses & other)
{
  postcond_ = other.postcond_->clone();
  lexpr_ = other.lexpr_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

PostCondSimpleClauses &PostCondSimpleClauses::operator=(const PostCondSimpleClauses & other)
{
  PostCondSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void PostCondSimpleClauses::swap(PostCondSimpleClauses & other)
{
  std::swap(postcond_, other.postcond_);
  std::swap(lexpr_, other.lexpr_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

PostCondSimpleClauses::~PostCondSimpleClauses()
{
  delete(postcond_);
  delete(lexpr_);
  delete(simpleclauses_);

}

void PostCondSimpleClauses::accept(Visitor *v)
{
  v->visitPostCondSimpleClauses(this);
}

PostCondSimpleClauses *PostCondSimpleClauses::clone() const
{
  return new PostCondSimpleClauses(*this);
}



/********************   NoBehaviors    ********************/
NoBehaviors::NoBehaviors()
{

}

NoBehaviors::NoBehaviors(const NoBehaviors & other)
{

}

NoBehaviors &NoBehaviors::operator=(const NoBehaviors & other)
{
  NoBehaviors tmp(other);
  swap(tmp);
  return *this;
}

void NoBehaviors::swap(NoBehaviors & other)
{

}

NoBehaviors::~NoBehaviors()
{

}

void NoBehaviors::accept(Visitor *v)
{
  v->visitNoBehaviors(this);
}

NoBehaviors *NoBehaviors::clone() const
{
  return new NoBehaviors(*this);
}



/********************   NoComplDisj    ********************/
NoComplDisj::NoComplDisj()
{

}

NoComplDisj::NoComplDisj(const NoComplDisj & other)
{

}

NoComplDisj &NoComplDisj::operator=(const NoComplDisj & other)
{
  NoComplDisj tmp(other);
  swap(tmp);
  return *this;
}

void NoComplDisj::swap(NoComplDisj & other)
{

}

NoComplDisj::~NoComplDisj()
{

}

void NoComplDisj::accept(Visitor *v)
{
  v->visitNoComplDisj(this);
}

NoComplDisj *NoComplDisj::clone() const
{
  return new NoComplDisj(*this);
}



/********************   NoLexpr    ********************/
NoLexpr::NoLexpr()
{

}

NoLexpr::NoLexpr(const NoLexpr & other)
{

}

NoLexpr &NoLexpr::operator=(const NoLexpr & other)
{
  NoLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NoLexpr::swap(NoLexpr & other)
{

}

NoLexpr::~NoLexpr()
{

}

void NoLexpr::accept(Visitor *v)
{
  v->visitNoLexpr(this);
}

NoLexpr *NoLexpr::clone() const
{
  return new NoLexpr(*this);
}



/********************   ImplLexpr    ********************/
ImplLexpr::ImplLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

ImplLexpr::ImplLexpr(const ImplLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

ImplLexpr &ImplLexpr::operator=(const ImplLexpr & other)
{
  ImplLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ImplLexpr::swap(ImplLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

ImplLexpr::~ImplLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void ImplLexpr::accept(Visitor *v)
{
  v->visitImplLexpr(this);
}

ImplLexpr *ImplLexpr::clone() const
{
  return new ImplLexpr(*this);
}



/********************   IffLexpr    ********************/
IffLexpr::IffLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

IffLexpr::IffLexpr(const IffLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

IffLexpr &IffLexpr::operator=(const IffLexpr & other)
{
  IffLexpr tmp(other);
  swap(tmp);
  return *this;
}

void IffLexpr::swap(IffLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

IffLexpr::~IffLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void IffLexpr::accept(Visitor *v)
{
  v->visitIffLexpr(this);
}

IffLexpr *IffLexpr::clone() const
{
  return new IffLexpr(*this);
}



/********************   OrLexpr    ********************/
OrLexpr::OrLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

OrLexpr::OrLexpr(const OrLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

OrLexpr &OrLexpr::operator=(const OrLexpr & other)
{
  OrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void OrLexpr::swap(OrLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

OrLexpr::~OrLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void OrLexpr::accept(Visitor *v)
{
  v->visitOrLexpr(this);
}

OrLexpr *OrLexpr::clone() const
{
  return new OrLexpr(*this);
}



/********************   AndLexpr    ********************/
AndLexpr::AndLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AndLexpr::AndLexpr(const AndLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AndLexpr &AndLexpr::operator=(const AndLexpr & other)
{
  AndLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AndLexpr::swap(AndLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AndLexpr::~AndLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AndLexpr::accept(Visitor *v)
{
  v->visitAndLexpr(this);
}

AndLexpr *AndLexpr::clone() const
{
  return new AndLexpr(*this);
}



/********************   HatHatLexpr    ********************/
HatHatLexpr::HatHatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

HatHatLexpr::HatHatLexpr(const HatHatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

HatHatLexpr &HatHatLexpr::operator=(const HatHatLexpr & other)
{
  HatHatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void HatHatLexpr::swap(HatHatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

HatHatLexpr::~HatHatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void HatHatLexpr::accept(Visitor *v)
{
  v->visitHatHatLexpr(this);
}

HatHatLexpr *HatHatLexpr::clone() const
{
  return new HatHatLexpr(*this);
}



/********************   AmpLexpr    ********************/
AmpLexpr::AmpLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AmpLexpr::AmpLexpr(const AmpLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AmpLexpr &AmpLexpr::operator=(const AmpLexpr & other)
{
  AmpLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AmpLexpr::swap(AmpLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AmpLexpr::~AmpLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AmpLexpr::accept(Visitor *v)
{
  v->visitAmpLexpr(this);
}

AmpLexpr *AmpLexpr::clone() const
{
  return new AmpLexpr(*this);
}



/********************   PipeLexpr    ********************/
PipeLexpr::PipeLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

PipeLexpr::PipeLexpr(const PipeLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

PipeLexpr &PipeLexpr::operator=(const PipeLexpr & other)
{
  PipeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PipeLexpr::swap(PipeLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

PipeLexpr::~PipeLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void PipeLexpr::accept(Visitor *v)
{
  v->visitPipeLexpr(this);
}

PipeLexpr *PipeLexpr::clone() const
{
  return new PipeLexpr(*this);
}



/********************   HatLexpr    ********************/
HatLexpr::HatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

HatLexpr::HatLexpr(const HatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

HatLexpr &HatLexpr::operator=(const HatLexpr & other)
{
  HatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void HatLexpr::swap(HatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

HatLexpr::~HatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void HatLexpr::accept(Visitor *v)
{
  v->visitHatLexpr(this);
}

HatLexpr *HatLexpr::clone() const
{
  return new HatLexpr(*this);
}



/********************   BimpliesLexpr    ********************/
BimpliesLexpr::BimpliesLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

BimpliesLexpr::BimpliesLexpr(const BimpliesLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

BimpliesLexpr &BimpliesLexpr::operator=(const BimpliesLexpr & other)
{
  BimpliesLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BimpliesLexpr::swap(BimpliesLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

BimpliesLexpr::~BimpliesLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void BimpliesLexpr::accept(Visitor *v)
{
  v->visitBimpliesLexpr(this);
}

BimpliesLexpr *BimpliesLexpr::clone() const
{
  return new BimpliesLexpr(*this);
}



/********************   BiffLexpr    ********************/
BiffLexpr::BiffLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

BiffLexpr::BiffLexpr(const BiffLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

BiffLexpr &BiffLexpr::operator=(const BiffLexpr & other)
{
  BiffLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BiffLexpr::swap(BiffLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

BiffLexpr::~BiffLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void BiffLexpr::accept(Visitor *v)
{
  v->visitBiffLexpr(this);
}

BiffLexpr *BiffLexpr::clone() const
{
  return new BiffLexpr(*this);
}



/********************   InLexpr    ********************/
InLexpr::InLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

InLexpr::InLexpr(const InLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

InLexpr &InLexpr::operator=(const InLexpr & other)
{
  InLexpr tmp(other);
  swap(tmp);
  return *this;
}

void InLexpr::swap(InLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

InLexpr::~InLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void InLexpr::accept(Visitor *v)
{
  v->visitInLexpr(this);
}

InLexpr *InLexpr::clone() const
{
  return new InLexpr(*this);
}



/********************   TernaryLexpr    ********************/
TernaryLexpr::TernaryLexpr(Lexpr *p1, Lexpr *p2, Lexpr *p3)
{
  lexpr_1 = p1;
  lexpr_2 = p2;
  lexpr_3 = p3;

}

TernaryLexpr::TernaryLexpr(const TernaryLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();
  lexpr_3 = other.lexpr_3->clone();

}

TernaryLexpr &TernaryLexpr::operator=(const TernaryLexpr & other)
{
  TernaryLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TernaryLexpr::swap(TernaryLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);
  std::swap(lexpr_3, other.lexpr_3);

}

TernaryLexpr::~TernaryLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);
  delete(lexpr_3);

}

void TernaryLexpr::accept(Visitor *v)
{
  v->visitTernaryLexpr(this);
}

TernaryLexpr *TernaryLexpr::clone() const
{
  return new TernaryLexpr(*this);
}



/********************   RelationLexpr    ********************/
RelationLexpr::RelationLexpr(Lexpr *p1, ListLexprRelInner *p2, Relation *p3, Lexpr *p4)
{
  lexpr_1 = p1;
  listlexprrelinner_ = p2;
  relation_ = p3;
  lexpr_2 = p4;

}

RelationLexpr::RelationLexpr(const RelationLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  listlexprrelinner_ = other.listlexprrelinner_->clone();
  relation_ = other.relation_->clone();
  lexpr_2 = other.lexpr_2->clone();

}

RelationLexpr &RelationLexpr::operator=(const RelationLexpr & other)
{
  RelationLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RelationLexpr::swap(RelationLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(listlexprrelinner_, other.listlexprrelinner_);
  std::swap(relation_, other.relation_);
  std::swap(lexpr_2, other.lexpr_2);

}

RelationLexpr::~RelationLexpr()
{
  delete(lexpr_1);
  delete(listlexprrelinner_);
  delete(relation_);
  delete(lexpr_2);

}

void RelationLexpr::accept(Visitor *v)
{
  v->visitRelationLexpr(this);
}

RelationLexpr *RelationLexpr::clone() const
{
  return new RelationLexpr(*this);
}



/********************   NotLexprInner    ********************/
NotLexprInner::NotLexprInner(Lexpr *p1)
{
  lexpr_ = p1;

}

NotLexprInner::NotLexprInner(const NotLexprInner & other)
{
  lexpr_ = other.lexpr_->clone();

}

NotLexprInner &NotLexprInner::operator=(const NotLexprInner & other)
{
  NotLexprInner tmp(other);
  swap(tmp);
  return *this;
}

void NotLexprInner::swap(NotLexprInner & other)
{
  std::swap(lexpr_, other.lexpr_);

}

NotLexprInner::~NotLexprInner()
{
  delete(lexpr_);

}

void NotLexprInner::accept(Visitor *v)
{
  v->visitNotLexprInner(this);
}

NotLexprInner *NotLexprInner::clone() const
{
  return new NotLexprInner(*this);
}



/********************   TrueLexpr    ********************/
TrueLexpr::TrueLexpr()
{

}

TrueLexpr::TrueLexpr(const TrueLexpr & other)
{

}

TrueLexpr &TrueLexpr::operator=(const TrueLexpr & other)
{
  TrueLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TrueLexpr::swap(TrueLexpr & other)
{

}

TrueLexpr::~TrueLexpr()
{

}

void TrueLexpr::accept(Visitor *v)
{
  v->visitTrueLexpr(this);
}

TrueLexpr *TrueLexpr::clone() const
{
  return new TrueLexpr(*this);
}



/********************   FalseLexpr    ********************/
FalseLexpr::FalseLexpr()
{

}

FalseLexpr::FalseLexpr(const FalseLexpr & other)
{

}

FalseLexpr &FalseLexpr::operator=(const FalseLexpr & other)
{
  FalseLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FalseLexpr::swap(FalseLexpr & other)
{

}

FalseLexpr::~FalseLexpr()
{

}

void FalseLexpr::accept(Visitor *v)
{
  v->visitFalseLexpr(this);
}

FalseLexpr *FalseLexpr::clone() const
{
  return new FalseLexpr(*this);
}



/********************   AutomaticLexpr    ********************/
AutomaticLexpr::AutomaticLexpr()
{

}

AutomaticLexpr::AutomaticLexpr(const AutomaticLexpr & other)
{

}

AutomaticLexpr &AutomaticLexpr::operator=(const AutomaticLexpr & other)
{
  AutomaticLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AutomaticLexpr::swap(AutomaticLexpr & other)
{

}

AutomaticLexpr::~AutomaticLexpr()
{

}

void AutomaticLexpr::accept(Visitor *v)
{
  v->visitAutomaticLexpr(this);
}

AutomaticLexpr *AutomaticLexpr::clone() const
{
  return new AutomaticLexpr(*this);
}



/********************   DynamicLexpr    ********************/
DynamicLexpr::DynamicLexpr()
{

}

DynamicLexpr::DynamicLexpr(const DynamicLexpr & other)
{

}

DynamicLexpr &DynamicLexpr::operator=(const DynamicLexpr & other)
{
  DynamicLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DynamicLexpr::swap(DynamicLexpr & other)
{

}

DynamicLexpr::~DynamicLexpr()
{

}

void DynamicLexpr::accept(Visitor *v)
{
  v->visitDynamicLexpr(this);
}

DynamicLexpr *DynamicLexpr::clone() const
{
  return new DynamicLexpr(*this);
}



/********************   RegisterLexpr    ********************/
RegisterLexpr::RegisterLexpr()
{

}

RegisterLexpr::RegisterLexpr(const RegisterLexpr & other)
{

}

RegisterLexpr &RegisterLexpr::operator=(const RegisterLexpr & other)
{
  RegisterLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RegisterLexpr::swap(RegisterLexpr & other)
{

}

RegisterLexpr::~RegisterLexpr()
{

}

void RegisterLexpr::accept(Visitor *v)
{
  v->visitRegisterLexpr(this);
}

RegisterLexpr *RegisterLexpr::clone() const
{
  return new RegisterLexpr(*this);
}



/********************   StaticLexpr    ********************/
StaticLexpr::StaticLexpr()
{

}

StaticLexpr::StaticLexpr(const StaticLexpr & other)
{

}

StaticLexpr &StaticLexpr::operator=(const StaticLexpr & other)
{
  StaticLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StaticLexpr::swap(StaticLexpr & other)
{

}

StaticLexpr::~StaticLexpr()
{

}

void StaticLexpr::accept(Visitor *v)
{
  v->visitStaticLexpr(this);
}

StaticLexpr *StaticLexpr::clone() const
{
  return new StaticLexpr(*this);
}



/********************   UnallocatedLexpr    ********************/
UnallocatedLexpr::UnallocatedLexpr()
{

}

UnallocatedLexpr::UnallocatedLexpr(const UnallocatedLexpr & other)
{

}

UnallocatedLexpr &UnallocatedLexpr::operator=(const UnallocatedLexpr & other)
{
  UnallocatedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void UnallocatedLexpr::swap(UnallocatedLexpr & other)
{

}

UnallocatedLexpr::~UnallocatedLexpr()
{

}

void UnallocatedLexpr::accept(Visitor *v)
{
  v->visitUnallocatedLexpr(this);
}

UnallocatedLexpr *UnallocatedLexpr::clone() const
{
  return new UnallocatedLexpr(*this);
}



/********************   NullLexpr    ********************/
NullLexpr::NullLexpr()
{

}

NullLexpr::NullLexpr(const NullLexpr & other)
{

}

NullLexpr &NullLexpr::operator=(const NullLexpr & other)
{
  NullLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NullLexpr::swap(NullLexpr & other)
{

}

NullLexpr::~NullLexpr()
{

}

void NullLexpr::accept(Visitor *v)
{
  v->visitNullLexpr(this);
}

NullLexpr *NullLexpr::clone() const
{
  return new NullLexpr(*this);
}



/********************   LexprIntConst    ********************/
LexprIntConst::LexprIntConst(Integer p1)
{
  integer_ = p1;

}

LexprIntConst::LexprIntConst(const LexprIntConst & other)
{
  integer_ = other.integer_;

}

LexprIntConst &LexprIntConst::operator=(const LexprIntConst & other)
{
  LexprIntConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprIntConst::swap(LexprIntConst & other)
{
  std::swap(integer_, other.integer_);

}

LexprIntConst::~LexprIntConst()
{

}

void LexprIntConst::accept(Visitor *v)
{
  v->visitLexprIntConst(this);
}

LexprIntConst *LexprIntConst::clone() const
{
  return new LexprIntConst(*this);
}



/********************   LexprFloatConst    ********************/
LexprFloatConst::LexprFloatConst(Double p1)
{
  double_ = p1;

}

LexprFloatConst::LexprFloatConst(const LexprFloatConst & other)
{
  double_ = other.double_;

}

LexprFloatConst &LexprFloatConst::operator=(const LexprFloatConst & other)
{
  LexprFloatConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprFloatConst::swap(LexprFloatConst & other)
{
  std::swap(double_, other.double_);

}

LexprFloatConst::~LexprFloatConst()
{

}

void LexprFloatConst::accept(Visitor *v)
{
  v->visitLexprFloatConst(this);
}

LexprFloatConst *LexprFloatConst::clone() const
{
  return new LexprFloatConst(*this);
}



/********************   LexprStringConst    ********************/
LexprStringConst::LexprStringConst(String p1)
{
  string_ = p1;

}

LexprStringConst::LexprStringConst(const LexprStringConst & other)
{
  string_ = other.string_;

}

LexprStringConst &LexprStringConst::operator=(const LexprStringConst & other)
{
  LexprStringConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprStringConst::swap(LexprStringConst & other)
{
  std::swap(string_, other.string_);

}

LexprStringConst::~LexprStringConst()
{

}

void LexprStringConst::accept(Visitor *v)
{
  v->visitLexprStringConst(this);
}

LexprStringConst *LexprStringConst::clone() const
{
  return new LexprStringConst(*this);
}



/********************   AddLexpr    ********************/
AddLexpr::AddLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AddLexpr::AddLexpr(const AddLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AddLexpr &AddLexpr::operator=(const AddLexpr & other)
{
  AddLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AddLexpr::swap(AddLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AddLexpr::~AddLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AddLexpr::accept(Visitor *v)
{
  v->visitAddLexpr(this);
}

AddLexpr *AddLexpr::clone() const
{
  return new AddLexpr(*this);
}



/********************   SubtrLexpr    ********************/
SubtrLexpr::SubtrLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

SubtrLexpr::SubtrLexpr(const SubtrLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

SubtrLexpr &SubtrLexpr::operator=(const SubtrLexpr & other)
{
  SubtrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SubtrLexpr::swap(SubtrLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

SubtrLexpr::~SubtrLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void SubtrLexpr::accept(Visitor *v)
{
  v->visitSubtrLexpr(this);
}

SubtrLexpr *SubtrLexpr::clone() const
{
  return new SubtrLexpr(*this);
}



/********************   MultLexpr    ********************/
MultLexpr::MultLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

MultLexpr::MultLexpr(const MultLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

MultLexpr &MultLexpr::operator=(const MultLexpr & other)
{
  MultLexpr tmp(other);
  swap(tmp);
  return *this;
}

void MultLexpr::swap(MultLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

MultLexpr::~MultLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void MultLexpr::accept(Visitor *v)
{
  v->visitMultLexpr(this);
}

MultLexpr *MultLexpr::clone() const
{
  return new MultLexpr(*this);
}



/********************   DivLexpr    ********************/
DivLexpr::DivLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

DivLexpr::DivLexpr(const DivLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

DivLexpr &DivLexpr::operator=(const DivLexpr & other)
{
  DivLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DivLexpr::swap(DivLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

DivLexpr::~DivLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void DivLexpr::accept(Visitor *v)
{
  v->visitDivLexpr(this);
}

DivLexpr *DivLexpr::clone() const
{
  return new DivLexpr(*this);
}



/********************   ModLexpr    ********************/
ModLexpr::ModLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

ModLexpr::ModLexpr(const ModLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

ModLexpr &ModLexpr::operator=(const ModLexpr & other)
{
  ModLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ModLexpr::swap(ModLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

ModLexpr::~ModLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void ModLexpr::accept(Visitor *v)
{
  v->visitModLexpr(this);
}

ModLexpr *ModLexpr::clone() const
{
  return new ModLexpr(*this);
}



/********************   StarHatLexpr    ********************/
StarHatLexpr::StarHatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

StarHatLexpr::StarHatLexpr(const StarHatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

StarHatLexpr &StarHatLexpr::operator=(const StarHatLexpr & other)
{
  StarHatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StarHatLexpr::swap(StarHatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

StarHatLexpr::~StarHatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void StarHatLexpr::accept(Visitor *v)
{
  v->visitStarHatLexpr(this);
}

StarHatLexpr *StarHatLexpr::clone() const
{
  return new StarHatLexpr(*this);
}



/********************   SquaresLexpr    ********************/
SquaresLexpr::SquaresLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

SquaresLexpr::SquaresLexpr(const SquaresLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

SquaresLexpr &SquaresLexpr::operator=(const SquaresLexpr & other)
{
  SquaresLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SquaresLexpr::swap(SquaresLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

SquaresLexpr::~SquaresLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void SquaresLexpr::accept(Visitor *v)
{
  v->visitSquaresLexpr(this);
}

SquaresLexpr *SquaresLexpr::clone() const
{
  return new SquaresLexpr(*this);
}



/********************   MinusLexpr    ********************/
MinusLexpr::MinusLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

MinusLexpr::MinusLexpr(const MinusLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

MinusLexpr &MinusLexpr::operator=(const MinusLexpr & other)
{
  MinusLexpr tmp(other);
  swap(tmp);
  return *this;
}

void MinusLexpr::swap(MinusLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

MinusLexpr::~MinusLexpr()
{
  delete(lexpr_);

}

void MinusLexpr::accept(Visitor *v)
{
  v->visitMinusLexpr(this);
}

MinusLexpr *MinusLexpr::clone() const
{
  return new MinusLexpr(*this);
}



/********************   PlusLexpr    ********************/
PlusLexpr::PlusLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

PlusLexpr::PlusLexpr(const PlusLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

PlusLexpr &PlusLexpr::operator=(const PlusLexpr & other)
{
  PlusLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PlusLexpr::swap(PlusLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

PlusLexpr::~PlusLexpr()
{
  delete(lexpr_);

}

void PlusLexpr::accept(Visitor *v)
{
  v->visitPlusLexpr(this);
}

PlusLexpr *PlusLexpr::clone() const
{
  return new PlusLexpr(*this);
}



/********************   TildeLexpr    ********************/
TildeLexpr::TildeLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

TildeLexpr::TildeLexpr(const TildeLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

TildeLexpr &TildeLexpr::operator=(const TildeLexpr & other)
{
  TildeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TildeLexpr::swap(TildeLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

TildeLexpr::~TildeLexpr()
{
  delete(lexpr_);

}

void TildeLexpr::accept(Visitor *v)
{
  v->visitTildeLexpr(this);
}

TildeLexpr *TildeLexpr::clone() const
{
  return new TildeLexpr(*this);
}



/********************   StarLexpr    ********************/
StarLexpr::StarLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

StarLexpr::StarLexpr(const StarLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

StarLexpr &StarLexpr::operator=(const StarLexpr & other)
{
  StarLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StarLexpr::swap(StarLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

StarLexpr::~StarLexpr()
{
  delete(lexpr_);

}

void StarLexpr::accept(Visitor *v)
{
  v->visitStarLexpr(this);
}

StarLexpr *StarLexpr::clone() const
{
  return new StarLexpr(*this);
}



/********************   AmpUnaryLexpr    ********************/
AmpUnaryLexpr::AmpUnaryLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

AmpUnaryLexpr::AmpUnaryLexpr(const AmpUnaryLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

AmpUnaryLexpr &AmpUnaryLexpr::operator=(const AmpUnaryLexpr & other)
{
  AmpUnaryLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AmpUnaryLexpr::swap(AmpUnaryLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AmpUnaryLexpr::~AmpUnaryLexpr()
{
  delete(lexpr_);

}

void AmpUnaryLexpr::accept(Visitor *v)
{
  v->visitAmpUnaryLexpr(this);
}

AmpUnaryLexpr *AmpUnaryLexpr::clone() const
{
  return new AmpUnaryLexpr(*this);
}



/********************   SizeOfLexpr    ********************/
SizeOfLexpr::SizeOfLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

SizeOfLexpr::SizeOfLexpr(const SizeOfLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

SizeOfLexpr &SizeOfLexpr::operator=(const SizeOfLexpr & other)
{
  SizeOfLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SizeOfLexpr::swap(SizeOfLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SizeOfLexpr::~SizeOfLexpr()
{
  delete(lexpr_);

}

void SizeOfLexpr::accept(Visitor *v)
{
  v->visitSizeOfLexpr(this);
}

SizeOfLexpr *SizeOfLexpr::clone() const
{
  return new SizeOfLexpr(*this);
}



/********************   OldLexpr    ********************/
OldLexpr::OldLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

OldLexpr::OldLexpr(const OldLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

OldLexpr &OldLexpr::operator=(const OldLexpr & other)
{
  OldLexpr tmp(other);
  swap(tmp);
  return *this;
}

void OldLexpr::swap(OldLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

OldLexpr::~OldLexpr()
{
  delete(lexpr_);

}

void OldLexpr::accept(Visitor *v)
{
  v->visitOldLexpr(this);
}

OldLexpr *OldLexpr::clone() const
{
  return new OldLexpr(*this);
}



/********************   ResultLexpr    ********************/
ResultLexpr::ResultLexpr()
{

}

ResultLexpr::ResultLexpr(const ResultLexpr & other)
{

}

ResultLexpr &ResultLexpr::operator=(const ResultLexpr & other)
{
  ResultLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ResultLexpr::swap(ResultLexpr & other)
{

}

ResultLexpr::~ResultLexpr()
{

}

void ResultLexpr::accept(Visitor *v)
{
  v->visitResultLexpr(this);
}

ResultLexpr *ResultLexpr::clone() const
{
  return new ResultLexpr(*this);
}



/********************   SeparatedLexpr    ********************/
SeparatedLexpr::SeparatedLexpr(ListLexpr *p1)
{
  listlexpr_ = p1;

}

SeparatedLexpr::SeparatedLexpr(const SeparatedLexpr & other)
{
  listlexpr_ = other.listlexpr_->clone();

}

SeparatedLexpr &SeparatedLexpr::operator=(const SeparatedLexpr & other)
{
  SeparatedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SeparatedLexpr::swap(SeparatedLexpr & other)
{
  std::swap(listlexpr_, other.listlexpr_);

}

SeparatedLexpr::~SeparatedLexpr()
{
  delete(listlexpr_);

}

void SeparatedLexpr::accept(Visitor *v)
{
  v->visitSeparatedLexpr(this);
}

SeparatedLexpr *SeparatedLexpr::clone() const
{
  return new SeparatedLexpr(*this);
}



/********************   FullIdParenLexpr    ********************/
FullIdParenLexpr::FullIdParenLexpr(FullIdentifier *p1, ListLexpr *p2)
{
  fullidentifier_ = p1;
  listlexpr_ = p2;

}

FullIdParenLexpr::FullIdParenLexpr(const FullIdParenLexpr & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listlexpr_ = other.listlexpr_->clone();

}

FullIdParenLexpr &FullIdParenLexpr::operator=(const FullIdParenLexpr & other)
{
  FullIdParenLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FullIdParenLexpr::swap(FullIdParenLexpr & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listlexpr_, other.listlexpr_);

}

FullIdParenLexpr::~FullIdParenLexpr()
{
  delete(fullidentifier_);
  delete(listlexpr_);

}

void FullIdParenLexpr::accept(Visitor *v)
{
  v->visitFullIdParenLexpr(this);
}

FullIdParenLexpr *FullIdParenLexpr::clone() const
{
  return new FullIdParenLexpr(*this);
}



/********************   FullId    ********************/
FullId::FullId(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

FullId::FullId(const FullId & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

FullId &FullId::operator=(const FullId & other)
{
  FullId tmp(other);
  swap(tmp);
  return *this;
}

void FullId::swap(FullId & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

FullId::~FullId()
{
  delete(fullidentifier_);

}

void FullId::accept(Visitor *v)
{
  v->visitFullId(this);
}

FullId *FullId::clone() const
{
  return new FullId(*this);
}



/********************   PiLexpr    ********************/
PiLexpr::PiLexpr()
{

}

PiLexpr::PiLexpr(const PiLexpr & other)
{

}

PiLexpr &PiLexpr::operator=(const PiLexpr & other)
{
  PiLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PiLexpr::swap(PiLexpr & other)
{

}

PiLexpr::~PiLexpr()
{

}

void PiLexpr::accept(Visitor *v)
{
  v->visitPiLexpr(this);
}

PiLexpr *PiLexpr::clone() const
{
  return new PiLexpr(*this);
}



/********************   LessLessLexpr    ********************/
LessLessLexpr::LessLessLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

LessLessLexpr::LessLessLexpr(const LessLessLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

LessLessLexpr &LessLessLexpr::operator=(const LessLessLexpr & other)
{
  LessLessLexpr tmp(other);
  swap(tmp);
  return *this;
}

void LessLessLexpr::swap(LessLessLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

LessLessLexpr::~LessLessLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void LessLessLexpr::accept(Visitor *v)
{
  v->visitLessLessLexpr(this);
}

LessLessLexpr *LessLessLexpr::clone() const
{
  return new LessLessLexpr(*this);
}



/********************   GreaterGreaterLexpr    ********************/
GreaterGreaterLexpr::GreaterGreaterLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

GreaterGreaterLexpr::GreaterGreaterLexpr(const GreaterGreaterLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

GreaterGreaterLexpr &GreaterGreaterLexpr::operator=(const GreaterGreaterLexpr & other)
{
  GreaterGreaterLexpr tmp(other);
  swap(tmp);
  return *this;
}

void GreaterGreaterLexpr::swap(GreaterGreaterLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

GreaterGreaterLexpr::~GreaterGreaterLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void GreaterGreaterLexpr::accept(Visitor *v)
{
  v->visitGreaterGreaterLexpr(this);
}

GreaterGreaterLexpr *GreaterGreaterLexpr::clone() const
{
  return new GreaterGreaterLexpr(*this);
}



/********************   TypeOfLexpr    ********************/
TypeOfLexpr::TypeOfLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

TypeOfLexpr::TypeOfLexpr(const TypeOfLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

TypeOfLexpr &TypeOfLexpr::operator=(const TypeOfLexpr & other)
{
  TypeOfLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TypeOfLexpr::swap(TypeOfLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

TypeOfLexpr::~TypeOfLexpr()
{
  delete(lexpr_);

}

void TypeOfLexpr::accept(Visitor *v)
{
  v->visitTypeOfLexpr(this);
}

TypeOfLexpr *TypeOfLexpr::clone() const
{
  return new TypeOfLexpr(*this);
}



/********************   RelInnerLexpr    ********************/
RelInnerLexpr::RelInnerLexpr(Relation *p1, Lexpr *p2)
{
  relation_ = p1;
  lexpr_ = p2;

}

RelInnerLexpr::RelInnerLexpr(const RelInnerLexpr & other)
{
  relation_ = other.relation_->clone();
  lexpr_ = other.lexpr_->clone();

}

RelInnerLexpr &RelInnerLexpr::operator=(const RelInnerLexpr & other)
{
  RelInnerLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RelInnerLexpr::swap(RelInnerLexpr & other)
{
  std::swap(relation_, other.relation_);
  std::swap(lexpr_, other.lexpr_);

}

RelInnerLexpr::~RelInnerLexpr()
{
  delete(relation_);
  delete(lexpr_);

}

void RelInnerLexpr::accept(Visitor *v)
{
  v->visitRelInnerLexpr(this);
}

RelInnerLexpr *RelInnerLexpr::clone() const
{
  return new RelInnerLexpr(*this);
}



/********************   LessRel    ********************/
LessRel::LessRel()
{

}

LessRel::LessRel(const LessRel & other)
{

}

LessRel &LessRel::operator=(const LessRel & other)
{
  LessRel tmp(other);
  swap(tmp);
  return *this;
}

void LessRel::swap(LessRel & other)
{

}

LessRel::~LessRel()
{

}

void LessRel::accept(Visitor *v)
{
  v->visitLessRel(this);
}

LessRel *LessRel::clone() const
{
  return new LessRel(*this);
}



/********************   GreaterRel    ********************/
GreaterRel::GreaterRel()
{

}

GreaterRel::GreaterRel(const GreaterRel & other)
{

}

GreaterRel &GreaterRel::operator=(const GreaterRel & other)
{
  GreaterRel tmp(other);
  swap(tmp);
  return *this;
}

void GreaterRel::swap(GreaterRel & other)
{

}

GreaterRel::~GreaterRel()
{

}

void GreaterRel::accept(Visitor *v)
{
  v->visitGreaterRel(this);
}

GreaterRel *GreaterRel::clone() const
{
  return new GreaterRel(*this);
}



/********************   LessEqRel    ********************/
LessEqRel::LessEqRel()
{

}

LessEqRel::LessEqRel(const LessEqRel & other)
{

}

LessEqRel &LessEqRel::operator=(const LessEqRel & other)
{
  LessEqRel tmp(other);
  swap(tmp);
  return *this;
}

void LessEqRel::swap(LessEqRel & other)
{

}

LessEqRel::~LessEqRel()
{

}

void LessEqRel::accept(Visitor *v)
{
  v->visitLessEqRel(this);
}

LessEqRel *LessEqRel::clone() const
{
  return new LessEqRel(*this);
}



/********************   GreaterEqRel    ********************/
GreaterEqRel::GreaterEqRel()
{

}

GreaterEqRel::GreaterEqRel(const GreaterEqRel & other)
{

}

GreaterEqRel &GreaterEqRel::operator=(const GreaterEqRel & other)
{
  GreaterEqRel tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqRel::swap(GreaterEqRel & other)
{

}

GreaterEqRel::~GreaterEqRel()
{

}

void GreaterEqRel::accept(Visitor *v)
{
  v->visitGreaterEqRel(this);
}

GreaterEqRel *GreaterEqRel::clone() const
{
  return new GreaterEqRel(*this);
}



/********************   EqRel    ********************/
EqRel::EqRel()
{

}

EqRel::EqRel(const EqRel & other)
{

}

EqRel &EqRel::operator=(const EqRel & other)
{
  EqRel tmp(other);
  swap(tmp);
  return *this;
}

void EqRel::swap(EqRel & other)
{

}

EqRel::~EqRel()
{

}

void EqRel::accept(Visitor *v)
{
  v->visitEqRel(this);
}

EqRel *EqRel::clone() const
{
  return new EqRel(*this);
}



/********************   NotEqRel    ********************/
NotEqRel::NotEqRel()
{

}

NotEqRel::NotEqRel(const NotEqRel & other)
{

}

NotEqRel &NotEqRel::operator=(const NotEqRel & other)
{
  NotEqRel tmp(other);
  swap(tmp);
  return *this;
}

void NotEqRel::swap(NotEqRel & other)
{

}

NotEqRel::~NotEqRel()
{

}

void NotEqRel::accept(Visitor *v)
{
  v->visitNotEqRel(this);
}

NotEqRel *NotEqRel::clone() const
{
  return new NotEqRel(*this);
}



/********************   EnsuresKeyWord    ********************/
EnsuresKeyWord::EnsuresKeyWord()
{

}

EnsuresKeyWord::EnsuresKeyWord(const EnsuresKeyWord & other)
{

}

EnsuresKeyWord &EnsuresKeyWord::operator=(const EnsuresKeyWord & other)
{
  EnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void EnsuresKeyWord::swap(EnsuresKeyWord & other)
{

}

EnsuresKeyWord::~EnsuresKeyWord()
{

}

void EnsuresKeyWord::accept(Visitor *v)
{
  v->visitEnsuresKeyWord(this);
}

EnsuresKeyWord *EnsuresKeyWord::clone() const
{
  return new EnsuresKeyWord(*this);
}



/********************   ExitsKeyWord    ********************/
ExitsKeyWord::ExitsKeyWord()
{

}

ExitsKeyWord::ExitsKeyWord(const ExitsKeyWord & other)
{

}

ExitsKeyWord &ExitsKeyWord::operator=(const ExitsKeyWord & other)
{
  ExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExitsKeyWord::swap(ExitsKeyWord & other)
{

}

ExitsKeyWord::~ExitsKeyWord()
{

}

void ExitsKeyWord::accept(Visitor *v)
{
  v->visitExitsKeyWord(this);
}

ExitsKeyWord *ExitsKeyWord::clone() const
{
  return new ExitsKeyWord(*this);
}



/********************   BreaksKeyWord    ********************/
BreaksKeyWord::BreaksKeyWord()
{

}

BreaksKeyWord::BreaksKeyWord(const BreaksKeyWord & other)
{

}

BreaksKeyWord &BreaksKeyWord::operator=(const BreaksKeyWord & other)
{
  BreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BreaksKeyWord::swap(BreaksKeyWord & other)
{

}

BreaksKeyWord::~BreaksKeyWord()
{

}

void BreaksKeyWord::accept(Visitor *v)
{
  v->visitBreaksKeyWord(this);
}

BreaksKeyWord *BreaksKeyWord::clone() const
{
  return new BreaksKeyWord(*this);
}



/********************   ContinuesKeyWord    ********************/
ContinuesKeyWord::ContinuesKeyWord()
{

}

ContinuesKeyWord::ContinuesKeyWord(const ContinuesKeyWord & other)
{

}

ContinuesKeyWord &ContinuesKeyWord::operator=(const ContinuesKeyWord & other)
{
  ContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ContinuesKeyWord::swap(ContinuesKeyWord & other)
{

}

ContinuesKeyWord::~ContinuesKeyWord()
{

}

void ContinuesKeyWord::accept(Visitor *v)
{
  v->visitContinuesKeyWord(this);
}

ContinuesKeyWord *ContinuesKeyWord::clone() const
{
  return new ContinuesKeyWord(*this);
}



/********************   ReturnsKeyWord    ********************/
ReturnsKeyWord::ReturnsKeyWord()
{

}

ReturnsKeyWord::ReturnsKeyWord(const ReturnsKeyWord & other)
{

}

ReturnsKeyWord &ReturnsKeyWord::operator=(const ReturnsKeyWord & other)
{
  ReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ReturnsKeyWord::swap(ReturnsKeyWord & other)
{

}

ReturnsKeyWord::~ReturnsKeyWord()
{

}

void ReturnsKeyWord::accept(Visitor *v)
{
  v->visitReturnsKeyWord(this);
}

ReturnsKeyWord *ReturnsKeyWord::clone() const
{
  return new ReturnsKeyWord(*this);
}



/********************   CheckEnsuresKeyWord    ********************/
CheckEnsuresKeyWord::CheckEnsuresKeyWord()
{

}

CheckEnsuresKeyWord::CheckEnsuresKeyWord(const CheckEnsuresKeyWord & other)
{

}

CheckEnsuresKeyWord &CheckEnsuresKeyWord::operator=(const CheckEnsuresKeyWord & other)
{
  CheckEnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckEnsuresKeyWord::swap(CheckEnsuresKeyWord & other)
{

}

CheckEnsuresKeyWord::~CheckEnsuresKeyWord()
{

}

void CheckEnsuresKeyWord::accept(Visitor *v)
{
  v->visitCheckEnsuresKeyWord(this);
}

CheckEnsuresKeyWord *CheckEnsuresKeyWord::clone() const
{
  return new CheckEnsuresKeyWord(*this);
}



/********************   CheckExitsKeyWord    ********************/
CheckExitsKeyWord::CheckExitsKeyWord()
{

}

CheckExitsKeyWord::CheckExitsKeyWord(const CheckExitsKeyWord & other)
{

}

CheckExitsKeyWord &CheckExitsKeyWord::operator=(const CheckExitsKeyWord & other)
{
  CheckExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckExitsKeyWord::swap(CheckExitsKeyWord & other)
{

}

CheckExitsKeyWord::~CheckExitsKeyWord()
{

}

void CheckExitsKeyWord::accept(Visitor *v)
{
  v->visitCheckExitsKeyWord(this);
}

CheckExitsKeyWord *CheckExitsKeyWord::clone() const
{
  return new CheckExitsKeyWord(*this);
}



/********************   CheckBreaksKeyWord    ********************/
CheckBreaksKeyWord::CheckBreaksKeyWord()
{

}

CheckBreaksKeyWord::CheckBreaksKeyWord(const CheckBreaksKeyWord & other)
{

}

CheckBreaksKeyWord &CheckBreaksKeyWord::operator=(const CheckBreaksKeyWord & other)
{
  CheckBreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckBreaksKeyWord::swap(CheckBreaksKeyWord & other)
{

}

CheckBreaksKeyWord::~CheckBreaksKeyWord()
{

}

void CheckBreaksKeyWord::accept(Visitor *v)
{
  v->visitCheckBreaksKeyWord(this);
}

CheckBreaksKeyWord *CheckBreaksKeyWord::clone() const
{
  return new CheckBreaksKeyWord(*this);
}



/********************   CheckContinuesKeyWord    ********************/
CheckContinuesKeyWord::CheckContinuesKeyWord()
{

}

CheckContinuesKeyWord::CheckContinuesKeyWord(const CheckContinuesKeyWord & other)
{

}

CheckContinuesKeyWord &CheckContinuesKeyWord::operator=(const CheckContinuesKeyWord & other)
{
  CheckContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckContinuesKeyWord::swap(CheckContinuesKeyWord & other)
{

}

CheckContinuesKeyWord::~CheckContinuesKeyWord()
{

}

void CheckContinuesKeyWord::accept(Visitor *v)
{
  v->visitCheckContinuesKeyWord(this);
}

CheckContinuesKeyWord *CheckContinuesKeyWord::clone() const
{
  return new CheckContinuesKeyWord(*this);
}



/********************   CheckReturnsKeyWord    ********************/
CheckReturnsKeyWord::CheckReturnsKeyWord()
{

}

CheckReturnsKeyWord::CheckReturnsKeyWord(const CheckReturnsKeyWord & other)
{

}

CheckReturnsKeyWord &CheckReturnsKeyWord::operator=(const CheckReturnsKeyWord & other)
{
  CheckReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckReturnsKeyWord::swap(CheckReturnsKeyWord & other)
{

}

CheckReturnsKeyWord::~CheckReturnsKeyWord()
{

}

void CheckReturnsKeyWord::accept(Visitor *v)
{
  v->visitCheckReturnsKeyWord(this);
}

CheckReturnsKeyWord *CheckReturnsKeyWord::clone() const
{
  return new CheckReturnsKeyWord(*this);
}



/********************   AdmitEnsuresKeyWord    ********************/
AdmitEnsuresKeyWord::AdmitEnsuresKeyWord()
{

}

AdmitEnsuresKeyWord::AdmitEnsuresKeyWord(const AdmitEnsuresKeyWord & other)
{

}

AdmitEnsuresKeyWord &AdmitEnsuresKeyWord::operator=(const AdmitEnsuresKeyWord & other)
{
  AdmitEnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitEnsuresKeyWord::swap(AdmitEnsuresKeyWord & other)
{

}

AdmitEnsuresKeyWord::~AdmitEnsuresKeyWord()
{

}

void AdmitEnsuresKeyWord::accept(Visitor *v)
{
  v->visitAdmitEnsuresKeyWord(this);
}

AdmitEnsuresKeyWord *AdmitEnsuresKeyWord::clone() const
{
  return new AdmitEnsuresKeyWord(*this);
}



/********************   AdmitExitsKeyWord    ********************/
AdmitExitsKeyWord::AdmitExitsKeyWord()
{

}

AdmitExitsKeyWord::AdmitExitsKeyWord(const AdmitExitsKeyWord & other)
{

}

AdmitExitsKeyWord &AdmitExitsKeyWord::operator=(const AdmitExitsKeyWord & other)
{
  AdmitExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitExitsKeyWord::swap(AdmitExitsKeyWord & other)
{

}

AdmitExitsKeyWord::~AdmitExitsKeyWord()
{

}

void AdmitExitsKeyWord::accept(Visitor *v)
{
  v->visitAdmitExitsKeyWord(this);
}

AdmitExitsKeyWord *AdmitExitsKeyWord::clone() const
{
  return new AdmitExitsKeyWord(*this);
}



/********************   AdmitBreaksKeyWord    ********************/
AdmitBreaksKeyWord::AdmitBreaksKeyWord()
{

}

AdmitBreaksKeyWord::AdmitBreaksKeyWord(const AdmitBreaksKeyWord & other)
{

}

AdmitBreaksKeyWord &AdmitBreaksKeyWord::operator=(const AdmitBreaksKeyWord & other)
{
  AdmitBreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitBreaksKeyWord::swap(AdmitBreaksKeyWord & other)
{

}

AdmitBreaksKeyWord::~AdmitBreaksKeyWord()
{

}

void AdmitBreaksKeyWord::accept(Visitor *v)
{
  v->visitAdmitBreaksKeyWord(this);
}

AdmitBreaksKeyWord *AdmitBreaksKeyWord::clone() const
{
  return new AdmitBreaksKeyWord(*this);
}



/********************   AdmitContinuesKeyWord    ********************/
AdmitContinuesKeyWord::AdmitContinuesKeyWord()
{

}

AdmitContinuesKeyWord::AdmitContinuesKeyWord(const AdmitContinuesKeyWord & other)
{

}

AdmitContinuesKeyWord &AdmitContinuesKeyWord::operator=(const AdmitContinuesKeyWord & other)
{
  AdmitContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitContinuesKeyWord::swap(AdmitContinuesKeyWord & other)
{

}

AdmitContinuesKeyWord::~AdmitContinuesKeyWord()
{

}

void AdmitContinuesKeyWord::accept(Visitor *v)
{
  v->visitAdmitContinuesKeyWord(this);
}

AdmitContinuesKeyWord *AdmitContinuesKeyWord::clone() const
{
  return new AdmitContinuesKeyWord(*this);
}



/********************   AdmitReturnsKeyWord    ********************/
AdmitReturnsKeyWord::AdmitReturnsKeyWord()
{

}

AdmitReturnsKeyWord::AdmitReturnsKeyWord(const AdmitReturnsKeyWord & other)
{

}

AdmitReturnsKeyWord &AdmitReturnsKeyWord::operator=(const AdmitReturnsKeyWord & other)
{
  AdmitReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitReturnsKeyWord::swap(AdmitReturnsKeyWord & other)
{

}

AdmitReturnsKeyWord::~AdmitReturnsKeyWord()
{

}

void AdmitReturnsKeyWord::accept(Visitor *v)
{
  v->visitAdmitReturnsKeyWord(this);
}

AdmitReturnsKeyWord *AdmitReturnsKeyWord::clone() const
{
  return new AdmitReturnsKeyWord(*this);
}



/********************   SimpleIdentifierFull    ********************/
SimpleIdentifierFull::SimpleIdentifierFull(Identifier *p1)
{
  identifier_ = p1;

}

SimpleIdentifierFull::SimpleIdentifierFull(const SimpleIdentifierFull & other)
{
  identifier_ = other.identifier_->clone();

}

SimpleIdentifierFull &SimpleIdentifierFull::operator=(const SimpleIdentifierFull & other)
{
  SimpleIdentifierFull tmp(other);
  swap(tmp);
  return *this;
}

void SimpleIdentifierFull::swap(SimpleIdentifierFull & other)
{
  std::swap(identifier_, other.identifier_);

}

SimpleIdentifierFull::~SimpleIdentifierFull()
{
  delete(identifier_);

}

void SimpleIdentifierFull::accept(Visitor *v)
{
  v->visitSimpleIdentifierFull(this);
}

SimpleIdentifierFull *SimpleIdentifierFull::clone() const
{
  return new SimpleIdentifierFull(*this);
}



/********************   IdentifierIdent    ********************/
IdentifierIdent::IdentifierIdent(Ident p1)
{
  ident_ = p1;

}

IdentifierIdent::IdentifierIdent(const IdentifierIdent & other)
{
  ident_ = other.ident_;

}

IdentifierIdent &IdentifierIdent::operator=(const IdentifierIdent & other)
{
  IdentifierIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierIdent::swap(IdentifierIdent & other)
{
  std::swap(ident_, other.ident_);

}

IdentifierIdent::~IdentifierIdent()
{

}

void IdentifierIdent::accept(Visitor *v)
{
  v->visitIdentifierIdent(this);
}

IdentifierIdent *IdentifierIdent::clone() const
{
  return new IdentifierIdent(*this);
}




/********************   ListAnnot    ********************/

void ListAnnot::accept(Visitor *v)
{
  v->visitListAnnot(this);
}

ListAnnot *ListAnnot::clone() const
{
  return new ListAnnot(*this);
}

ListAnnot* consListAnnot(Annot* x, ListAnnot* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLexpr    ********************/

void ListLexpr::accept(Visitor *v)
{
  v->visitListLexpr(this);
}

ListLexpr *ListLexpr::clone() const
{
  return new ListLexpr(*this);
}

ListLexpr* consListLexpr(Lexpr* x, ListLexpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLexprRelInner    ********************/

void ListLexprRelInner::accept(Visitor *v)
{
  v->visitListLexprRelInner(this);
}

ListLexprRelInner *ListLexprRelInner::clone() const
{
  return new ListLexprRelInner(*this);
}

ListLexprRelInner* consListLexprRelInner(LexprRelInner* x, ListLexprRelInner* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFullIdentifier    ********************/

void ListFullIdentifier::accept(Visitor *v)
{
  v->visitListFullIdentifier(this);
}

ListFullIdentifier *ListFullIdentifier::clone() const
{
  return new ListFullIdentifier(*this);
}

ListFullIdentifier* consListFullIdentifier(FullIdentifier* x, ListFullIdentifier* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
