-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for C.

module C.CGrammar.Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified C.CGrammar.Abs

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print C.CGrammar.Abs.Ident where
  prt _ (C.CGrammar.Abs.Ident i) = doc $ showString i
instance Print C.CGrammar.Abs.TranslationUnit where
  prt i = \case
    C.CGrammar.Abs.ATranslationUnit externaldeclarations -> prPrec i 0 (concatD [prt 0 externaldeclarations])

instance Print C.CGrammar.Abs.External_Declaration where
  prt i = \case
    C.CGrammar.Abs.ExternalFunctionDeffinition functiondefinition -> prPrec i 0 (concatD [prt 0 functiondefinition])
    C.CGrammar.Abs.ExternalDeclaration declaration -> prPrec i 0 (concatD [prt 0 declaration])

instance Print [C.CGrammar.Abs.External_Declaration] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.FunctionDefinition where
  prt i = \case
    C.CGrammar.Abs.FunctionDeffinition declarationspecifiers declarator declarations compoundstatement -> prPrec i 0 (concatD [prt 0 declarationspecifiers, prt 0 declarator, prt 0 declarations, prt 0 compoundstatement])

instance Print C.CGrammar.Abs.DeclarationSpecifier where
  prt i = \case
    C.CGrammar.Abs.AStorageClassSpecifier storageclassspecifier -> prPrec i 0 (concatD [prt 0 storageclassspecifier])
    C.CGrammar.Abs.TypeSpecifierDeclSpec typespecifier -> prPrec i 0 (concatD [prt 0 typespecifier])
    C.CGrammar.Abs.TypeQualifierDeclSpec typequalifier -> prPrec i 0 (concatD [prt 0 typequalifier])

instance Print [C.CGrammar.Abs.DeclarationSpecifier] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.StorageClassSpecifier where
  prt i = \case
    C.CGrammar.Abs.AutoKeyWord -> prPrec i 0 (concatD [doc (showString "auto")])
    C.CGrammar.Abs.RegisterKeyWord -> prPrec i 0 (concatD [doc (showString "register")])
    C.CGrammar.Abs.StaticKeyWord -> prPrec i 0 (concatD [doc (showString "static")])
    C.CGrammar.Abs.ExternKeyWord -> prPrec i 0 (concatD [doc (showString "extern")])
    C.CGrammar.Abs.TypedefKeyWord -> prPrec i 0 (concatD [doc (showString "typedef")])

instance Print C.CGrammar.Abs.TypeSpecifier where
  prt i = \case
    C.CGrammar.Abs.VoidKeyWord -> prPrec i 0 (concatD [doc (showString "void")])
    C.CGrammar.Abs.CharKeyWord -> prPrec i 0 (concatD [doc (showString "char")])
    C.CGrammar.Abs.ShortKeyWord -> prPrec i 0 (concatD [doc (showString "short")])
    C.CGrammar.Abs.IntKeyWord -> prPrec i 0 (concatD [doc (showString "int")])
    C.CGrammar.Abs.LongKeyWord -> prPrec i 0 (concatD [doc (showString "long")])
    C.CGrammar.Abs.FloatKeyWord -> prPrec i 0 (concatD [doc (showString "float")])
    C.CGrammar.Abs.DoubleKeyWord -> prPrec i 0 (concatD [doc (showString "double")])
    C.CGrammar.Abs.SignedKeyWord -> prPrec i 0 (concatD [doc (showString "signed")])
    C.CGrammar.Abs.UnsignedKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned")])
    C.CGrammar.Abs.StructUnionSpecifier structorunionspecifier -> prPrec i 0 (concatD [prt 0 structorunionspecifier])
    C.CGrammar.Abs.AnEnumSpecifier enumspecifier -> prPrec i 0 (concatD [prt 0 enumspecifier])

instance Print C.CGrammar.Abs.StructOrUnionSpecifier where
  prt i = \case
    C.CGrammar.Abs.NamedStructUnionSpecifier structorunion id_ structdeclarations -> prPrec i 0 (concatD [prt 0 structorunion, prt 0 id_, doc (showString "{"), prt 0 structdeclarations, doc (showString "}")])
    C.CGrammar.Abs.NoNameStructUnionSpecifier structorunion structdeclarations -> prPrec i 0 (concatD [prt 0 structorunion, doc (showString "{"), prt 0 structdeclarations, doc (showString "}")])
    C.CGrammar.Abs.IdentStructUnionSpecifier structorunion id_ -> prPrec i 0 (concatD [prt 0 structorunion, prt 0 id_])

instance Print C.CGrammar.Abs.StructOrUnion where
  prt i = \case
    C.CGrammar.Abs.StructKeyWord -> prPrec i 0 (concatD [doc (showString "struct")])
    C.CGrammar.Abs.UnionKeyWord -> prPrec i 0 (concatD [doc (showString "union")])

instance Print C.CGrammar.Abs.StructDeclaration where
  prt i = \case
    C.CGrammar.Abs.AStructDeclaration specifierqualifiers structdeclarators -> prPrec i 0 (concatD [prt 0 specifierqualifiers, prt 0 structdeclarators])

instance Print [C.CGrammar.Abs.StructDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.SpecifierQualifier where
  prt i = \case
    C.CGrammar.Abs.TypeSpecifierSpecQual typespecifier -> prPrec i 0 (concatD [prt 0 typespecifier])
    C.CGrammar.Abs.TypeQualifierSpecQual typequalifier -> prPrec i 0 (concatD [prt 0 typequalifier])

instance Print [C.CGrammar.Abs.SpecifierQualifier] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.StructDeclarator where
  prt i = \case
    C.CGrammar.Abs.SimpleStructDeclarator declarator -> prPrec i 0 (concatD [prt 0 declarator])
    C.CGrammar.Abs.InitStructDeclarator declarator constantexpression -> prPrec i 0 (concatD [prt 0 declarator, doc (showString ":"), prt 0 constantexpression])
    C.CGrammar.Abs.ConstExprStructDeclarator constantexpression -> prPrec i 0 (concatD [doc (showString ":"), prt 0 constantexpression])

instance Print [C.CGrammar.Abs.StructDeclarator] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print C.CGrammar.Abs.Declarator where
  prt i = \case
    C.CGrammar.Abs.ADeclaratior pointer directdeclarator -> prPrec i 0 (concatD [prt 0 pointer, prt 0 directdeclarator])
    C.CGrammar.Abs.APointerDeclaratior directdeclarator -> prPrec i 0 (concatD [prt 0 directdeclarator])

instance Print C.CGrammar.Abs.Pointer where
  prt i = \case
    C.CGrammar.Abs.APointer typequalifiers -> prPrec i 0 (concatD [doc (showString "*"), prt 0 typequalifiers])

instance Print [C.CGrammar.Abs.Pointer] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.TypeQualifier where
  prt i = \case
    C.CGrammar.Abs.ConstKeyWord -> prPrec i 0 (concatD [doc (showString "const")])
    C.CGrammar.Abs.VolatileKeyWord -> prPrec i 0 (concatD [doc (showString "volatile")])

instance Print [C.CGrammar.Abs.TypeQualifier] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.DirectDeclarator where
  prt i = \case
    C.CGrammar.Abs.IdentDeclarator id_ -> prPrec i 0 (concatD [prt 0 id_])
    C.CGrammar.Abs.ParentDeclarator declarator -> prPrec i 0 (concatD [doc (showString "("), prt 0 declarator, doc (showString ")")])
    C.CGrammar.Abs.ArrayDeclarator directdeclarator constantexpression -> prPrec i 0 (concatD [prt 0 directdeclarator, doc (showString "["), prt 0 constantexpression, doc (showString "]")])
    C.CGrammar.Abs.ArrayEmptyDeclarator directdeclarator -> prPrec i 0 (concatD [prt 0 directdeclarator, doc (showString "["), doc (showString "]")])
    C.CGrammar.Abs.DeclaratorParameters directdeclarator parametertypelist -> prPrec i 0 (concatD [prt 0 directdeclarator, doc (showString "("), prt 0 parametertypelist, doc (showString ")")])
    C.CGrammar.Abs.DeclaratorIdentList directdeclarator ids -> prPrec i 0 (concatD [prt 0 directdeclarator, doc (showString "("), prt 0 ids, doc (showString ")")])

instance Print [C.CGrammar.Abs.Ident] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.ConstantExpression where
  prt i = \case
    C.CGrammar.Abs.CondConstantExpr expression -> prPrec i 0 (concatD [prt 2 expression])

instance Print C.CGrammar.Abs.Expression where
  prt i = \case
    C.CGrammar.Abs.TernaryCondExpr expression1 expression2 expression3 -> prPrec i 2 (concatD [prt 3 expression1, doc (showString "?"), prt 0 expression2, doc (showString ":"), prt 2 expression3])
    C.CGrammar.Abs.LogicalOrExpr expression1 expression2 -> prPrec i 3 (concatD [prt 3 expression1, doc (showString "||"), prt 4 expression2])
    C.CGrammar.Abs.LogicalAndExpr expression1 expression2 -> prPrec i 4 (concatD [prt 4 expression1, doc (showString "&&"), prt 5 expression2])
    C.CGrammar.Abs.BitOrExpr expression1 expression2 -> prPrec i 5 (concatD [prt 5 expression1, doc (showString "|"), prt 6 expression2])
    C.CGrammar.Abs.XorExpr expression1 expression2 -> prPrec i 6 (concatD [prt 6 expression1, doc (showString "^"), prt 7 expression2])
    C.CGrammar.Abs.BitAndExpr expression1 expression2 -> prPrec i 7 (concatD [prt 7 expression1, doc (showString "&"), prt 8 expression2])
    C.CGrammar.Abs.EqualExpr expression1 expression2 -> prPrec i 8 (concatD [prt 8 expression1, doc (showString "=="), prt 9 expression2])
    C.CGrammar.Abs.NotEqualExpr expression1 expression2 -> prPrec i 8 (concatD [prt 8 expression1, doc (showString "!="), prt 9 expression2])
    C.CGrammar.Abs.LessExpr expression1 expression2 -> prPrec i 9 (concatD [prt 9 expression1, doc (showString "<"), prt 10 expression2])
    C.CGrammar.Abs.GreaterExpr expression1 expression2 -> prPrec i 9 (concatD [prt 9 expression1, doc (showString ">"), prt 10 expression2])
    C.CGrammar.Abs.LessOrEqualExpr expression1 expression2 -> prPrec i 9 (concatD [prt 9 expression1, doc (showString "<="), prt 10 expression2])
    C.CGrammar.Abs.GreaterOrEqualExpr expression1 expression2 -> prPrec i 9 (concatD [prt 9 expression1, doc (showString ">="), prt 10 expression2])
    C.CGrammar.Abs.LeftShiftExpr expression1 expression2 -> prPrec i 10 (concatD [prt 10 expression1, doc (showString "<<"), prt 11 expression2])
    C.CGrammar.Abs.RightShiftExpr expression1 expression2 -> prPrec i 10 (concatD [prt 10 expression1, doc (showString ">>"), prt 11 expression2])
    C.CGrammar.Abs.PlusExpr expression1 expression2 -> prPrec i 11 (concatD [prt 11 expression1, doc (showString "+"), prt 12 expression2])
    C.CGrammar.Abs.MinusExpr expression1 expression2 -> prPrec i 11 (concatD [prt 11 expression1, doc (showString "-"), prt 12 expression2])
    C.CGrammar.Abs.MultExpr expression1 expression2 -> prPrec i 12 (concatD [prt 12 expression1, doc (showString "*"), prt 13 expression2])
    C.CGrammar.Abs.DivExpr expression1 expression2 -> prPrec i 12 (concatD [prt 12 expression1, doc (showString "/"), prt 13 expression2])
    C.CGrammar.Abs.ModExpr expression1 expression2 -> prPrec i 12 (concatD [prt 12 expression1, doc (showString "%"), prt 13 expression2])
    C.CGrammar.Abs.TypeCastExpr typename expression -> prPrec i 13 (concatD [doc (showString "("), prt 0 typename, doc (showString ")"), prt 13 expression])
    C.CGrammar.Abs.PrefixPlusPlusExpr expression -> prPrec i 14 (concatD [doc (showString "++"), prt 14 expression])
    C.CGrammar.Abs.PrefixMinusMinusExpr expression -> prPrec i 14 (concatD [doc (showString "--"), prt 14 expression])
    C.CGrammar.Abs.UnaryOpExpr unaryoperator expression -> prPrec i 14 (concatD [prt 0 unaryoperator, prt 13 expression])
    C.CGrammar.Abs.SizeOfExpr expression -> prPrec i 14 (concatD [doc (showString "sizeof"), prt 14 expression])
    C.CGrammar.Abs.SizeOfType typename -> prPrec i 14 (concatD [doc (showString "sizeof"), prt 0 typename])
    C.CGrammar.Abs.ArrayExpr expression1 expression2 -> prPrec i 15 (concatD [prt 15 expression1, doc (showString "["), prt 0 expression2, doc (showString "]")])
    C.CGrammar.Abs.PostfixParentExpr expression -> prPrec i 15 (concatD [prt 15 expression, doc (showString "("), doc (showString ")")])
    C.CGrammar.Abs.PostfixAssignExpr expression expressions -> prPrec i 15 (concatD [prt 15 expression, doc (showString "("), prt 1 expressions, doc (showString ")")])
    C.CGrammar.Abs.DotExpr expression id_ -> prPrec i 15 (concatD [prt 15 expression, doc (showString "."), prt 0 id_])
    C.CGrammar.Abs.ArrowExpr expression id_ -> prPrec i 15 (concatD [prt 15 expression, doc (showString "->"), prt 0 id_])
    C.CGrammar.Abs.PostfixPlusPlusExpr expression -> prPrec i 15 (concatD [prt 15 expression, doc (showString "++")])
    C.CGrammar.Abs.PostfixMinusMinusExpr expression -> prPrec i 15 (concatD [prt 15 expression, doc (showString "--")])
    C.CGrammar.Abs.IdentifierExpr id_ -> prPrec i 16 (concatD [prt 0 id_])
    C.CGrammar.Abs.ConstantExpr constant -> prPrec i 16 (concatD [prt 0 constant])
    C.CGrammar.Abs.StringExpr str -> prPrec i 16 (concatD [printString str])
    C.CGrammar.Abs.AnExpression expressions -> prPrec i 0 (concatD [prt 1 expressions])
    C.CGrammar.Abs.AssignmentExpr expression1 assignmentoperator expression2 -> prPrec i 1 (concatD [prt 14 expression1, prt 0 assignmentoperator, prt 1 expression2])

instance Print C.CGrammar.Abs.Constant where
  prt i = \case
    C.CGrammar.Abs.IntegerExpr n -> prPrec i 0 (concatD [prt 0 n])
    C.CGrammar.Abs.CharExpr c -> prPrec i 0 (concatD [prt 0 c])
    C.CGrammar.Abs.DoubleExpr d -> prPrec i 0 (concatD [prt 0 d])

instance Print [C.CGrammar.Abs.Expression] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 1 x]
  prt _ (x:xs) = concatD [prt 1 x, doc (showString ","), prt 1 xs]

instance Print C.CGrammar.Abs.AssignmentOperator where
  prt i = \case
    C.CGrammar.Abs.EqualOp -> prPrec i 0 (concatD [doc (showString "=")])
    C.CGrammar.Abs.MultEqualOp -> prPrec i 0 (concatD [doc (showString "*=")])
    C.CGrammar.Abs.DivEqualOp -> prPrec i 0 (concatD [doc (showString "/=")])
    C.CGrammar.Abs.ModEqualOp -> prPrec i 0 (concatD [doc (showString "%=")])
    C.CGrammar.Abs.PlusEqualOp -> prPrec i 0 (concatD [doc (showString "+=")])
    C.CGrammar.Abs.MinusEqualOp -> prPrec i 0 (concatD [doc (showString "-=")])
    C.CGrammar.Abs.LeftShiftEqualOp -> prPrec i 0 (concatD [doc (showString "<<=")])
    C.CGrammar.Abs.RoghtShiftEqualOp -> prPrec i 0 (concatD [doc (showString ">>=")])
    C.CGrammar.Abs.AndEqualOp -> prPrec i 0 (concatD [doc (showString "&=")])
    C.CGrammar.Abs.XorEqualOp -> prPrec i 0 (concatD [doc (showString "^=")])
    C.CGrammar.Abs.OrEqualOp -> prPrec i 0 (concatD [doc (showString "|=")])

instance Print C.CGrammar.Abs.UnaryOperator where
  prt i = \case
    C.CGrammar.Abs.UnaryAndOp -> prPrec i 0 (concatD [doc (showString "&")])
    C.CGrammar.Abs.UnaryMultOp -> prPrec i 0 (concatD [doc (showString "*")])
    C.CGrammar.Abs.UnaryPlusOp -> prPrec i 0 (concatD [doc (showString "+")])
    C.CGrammar.Abs.UnaryMinusOp -> prPrec i 0 (concatD [doc (showString "-")])
    C.CGrammar.Abs.UnaryTildeOp -> prPrec i 0 (concatD [doc (showString "~")])
    C.CGrammar.Abs.UnaryNotOp -> prPrec i 0 (concatD [doc (showString "!")])

instance Print C.CGrammar.Abs.TypeName where
  prt i = \case
    C.CGrammar.Abs.TypeNameAbstrDecl specifierqualifier specifierqualifiers abstractdeclarator -> prPrec i 0 (concatD [prt 0 specifierqualifier, prt 0 specifierqualifiers, prt 0 abstractdeclarator])
    C.CGrammar.Abs.ATypeName specifierqualifier specifierqualifiers -> prPrec i 0 (concatD [prt 0 specifierqualifier, prt 0 specifierqualifiers])

instance Print C.CGrammar.Abs.ParameterTypeList where
  prt i = \case
    C.CGrammar.Abs.SimpleParameters parameterdeclarations -> prPrec i 0 (concatD [prt 0 parameterdeclarations])
    C.CGrammar.Abs.ParametersDotDotDot parameterdeclarations -> prPrec i 0 (concatD [prt 0 parameterdeclarations, doc (showString ","), doc (showString "...")])

instance Print C.CGrammar.Abs.ParameterDeclaration where
  prt i = \case
    C.CGrammar.Abs.DeclaratorParameter declarationspecifier declarationspecifiers declarator -> prPrec i 0 (concatD [prt 0 declarationspecifier, prt 0 declarationspecifiers, prt 0 declarator])
    C.CGrammar.Abs.AbstractDeclaratorParameter declarationspecifier declarationspecifiers abstractdeclarator -> prPrec i 0 (concatD [prt 0 declarationspecifier, prt 0 declarationspecifiers, prt 0 abstractdeclarator])
    C.CGrammar.Abs.SimpleDeclaratorParameter declarationspecifier declarationspecifiers -> prPrec i 0 (concatD [prt 0 declarationspecifier, prt 0 declarationspecifiers])

instance Print [C.CGrammar.Abs.ParameterDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print C.CGrammar.Abs.AbstractDeclarator where
  prt i = \case
    C.CGrammar.Abs.PointerAbstractDeclarator pointers -> prPrec i 0 (concatD [prt 0 pointers])
    C.CGrammar.Abs.PointerDirectAbstractDeclarator pointers directabstractdeclarator -> prPrec i 0 (concatD [prt 0 pointers, prt 0 directabstractdeclarator])
    C.CGrammar.Abs.ADirectAbstractDeclarator directabstractdeclarator -> prPrec i 0 (concatD [prt 0 directabstractdeclarator])

instance Print C.CGrammar.Abs.DirectAbstractDeclarator where
  prt i = \case
    C.CGrammar.Abs.SimpleDirectAbstractDeclarator abstractdeclarator -> prPrec i 0 (concatD [doc (showString "("), prt 0 abstractdeclarator, doc (showString ")")])
    C.CGrammar.Abs.FullBracketsDirectAbstractDeclarator directabstractdeclarator constantexpression -> prPrec i 0 (concatD [prt 0 directabstractdeclarator, doc (showString "["), prt 0 constantexpression, doc (showString "]")])
    C.CGrammar.Abs.BracketsDirectAbstractDeclarator directabstractdeclarator -> prPrec i 0 (concatD [prt 0 directabstractdeclarator, doc (showString "["), doc (showString "]")])
    C.CGrammar.Abs.ConstExprDirectAbstractDeclarator constantexpression -> prPrec i 0 (concatD [doc (showString "["), prt 0 constantexpression, doc (showString "]")])
    C.CGrammar.Abs.SquareBracketsDirectAbstractDeclarator -> prPrec i 0 (concatD [doc (showString "["), doc (showString "]")])
    C.CGrammar.Abs.FullParamDirectAbstractDeclarator directabstractdeclarator parametertypelist -> prPrec i 0 (concatD [prt 0 directabstractdeclarator, doc (showString "("), prt 0 parametertypelist, doc (showString ")")])
    C.CGrammar.Abs.ParantNoParamDirectAbstractDeclarator directabstractdeclarator -> prPrec i 0 (concatD [prt 0 directabstractdeclarator, doc (showString "("), doc (showString ")")])
    C.CGrammar.Abs.ParamDirectAbstractDeclarator parametertypelist -> prPrec i 0 (concatD [doc (showString "("), prt 0 parametertypelist, doc (showString ")")])
    C.CGrammar.Abs.ParantDirectAbstractDeclarator -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")")])

instance Print C.CGrammar.Abs.EnumSpecifier where
  prt i = \case
    C.CGrammar.Abs.NamedInitEnum id_ enumerators -> prPrec i 0 (concatD [doc (showString "enum"), prt 0 id_, doc (showString "{"), prt 0 enumerators, doc (showString "}")])
    C.CGrammar.Abs.InitEnum enumerators -> prPrec i 0 (concatD [doc (showString "enum"), doc (showString "{"), prt 0 enumerators, doc (showString "}")])
    C.CGrammar.Abs.NamedEnum id_ -> prPrec i 0 (concatD [doc (showString "enum"), prt 0 id_])

instance Print C.CGrammar.Abs.Enumerator where
  prt i = \case
    C.CGrammar.Abs.DefaultEnumerator id_ -> prPrec i 0 (concatD [prt 0 id_])
    C.CGrammar.Abs.DefinedEnumerator id_ constantexpression -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 constantexpression])

instance Print [C.CGrammar.Abs.Enumerator] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print C.CGrammar.Abs.Declaration where
  prt i = \case
    C.CGrammar.Abs.ADeclaration declarationspecifier declarationspecifiers initdeclarators -> prPrec i 0 (concatD [prt 0 declarationspecifier, prt 0 declarationspecifiers, prt 0 initdeclarators, doc (showString ";")])

instance Print [C.CGrammar.Abs.Declaration] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.InitDeclarator where
  prt i = \case
    C.CGrammar.Abs.SimpleInitDeclarator declarator -> prPrec i 0 (concatD [prt 0 declarator])
    C.CGrammar.Abs.InitializedDeclarator declarator initializer -> prPrec i 0 (concatD [prt 0 declarator, doc (showString "="), prt 0 initializer])

instance Print [C.CGrammar.Abs.InitDeclarator] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.Initializer where
  prt i = \case
    C.CGrammar.Abs.AssignExprInitializer expression -> prPrec i 0 (concatD [prt 1 expression])
    C.CGrammar.Abs.BlockInitializer initializers -> prPrec i 0 (concatD [doc (showString "{"), prt 0 initializers, doc (showString "}")])
    C.CGrammar.Abs.BlockCommaInitializer initializers -> prPrec i 0 (concatD [doc (showString "{"), prt 0 initializers, doc (showString ","), doc (showString "}")])

instance Print [C.CGrammar.Abs.Initializer] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print C.CGrammar.Abs.Compound_Statement where
  prt i = \case
    C.CGrammar.Abs.CompoundStatement declarations statements -> prPrec i 0 (concatD [doc (showString "{"), prt 0 declarations, prt 0 statements, doc (showString "}")])

instance Print C.CGrammar.Abs.Statement where
  prt i = \case
    C.CGrammar.Abs.ALabeledStatement labeledstatement -> prPrec i 0 (concatD [prt 0 labeledstatement])
    C.CGrammar.Abs.AnExpressionStatement expressionstatement -> prPrec i 0 (concatD [prt 0 expressionstatement])
    C.CGrammar.Abs.ACompoundStatement compoundstatement -> prPrec i 0 (concatD [prt 0 compoundstatement])
    C.CGrammar.Abs.ASelectionStatement selectionstatement -> prPrec i 0 (concatD [prt 0 selectionstatement])
    C.CGrammar.Abs.AnIterationStatement iterationstatement -> prPrec i 0 (concatD [prt 0 iterationstatement])
    C.CGrammar.Abs.AJumpStatement jumpstatement -> prPrec i 0 (concatD [prt 0 jumpstatement])

instance Print [C.CGrammar.Abs.Statement] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print C.CGrammar.Abs.LabeledStatement where
  prt i = \case
    C.CGrammar.Abs.LableStatement id_ statement -> prPrec i 0 (concatD [prt 0 id_, doc (showString ":"), prt 0 statement])
    C.CGrammar.Abs.CaseStatement constantexpression statement -> prPrec i 0 (concatD [doc (showString "case"), prt 0 constantexpression, doc (showString ":"), prt 0 statement])
    C.CGrammar.Abs.DefaultStatement statement -> prPrec i 0 (concatD [doc (showString "default"), doc (showString ":"), prt 0 statement])

instance Print C.CGrammar.Abs.ExpressionStatement where
  prt i = \case
    C.CGrammar.Abs.ExprStatement maybeexpression -> prPrec i 0 (concatD [prt 0 maybeexpression, doc (showString ";")])

instance Print C.CGrammar.Abs.SelectionStatement where
  prt i = \case
    C.CGrammar.Abs.IfStatement expression statement -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expression, doc (showString ")"), prt 0 statement])
    C.CGrammar.Abs.IfElseStatement expression statement1 statement2 -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expression, doc (showString ")"), prt 0 statement1, doc (showString "else"), prt 0 statement2])
    C.CGrammar.Abs.SwitchStatement expression statement -> prPrec i 0 (concatD [doc (showString "switch"), doc (showString "("), prt 0 expression, doc (showString ")"), prt 0 statement])

instance Print C.CGrammar.Abs.IterationStatement where
  prt i = \case
    C.CGrammar.Abs.WhileStatement expression statement -> prPrec i 0 (concatD [doc (showString "while"), doc (showString "("), prt 0 expression, doc (showString ")"), prt 0 statement])
    C.CGrammar.Abs.DoWhileStatement statement expression -> prPrec i 0 (concatD [doc (showString "do"), prt 0 statement, doc (showString "while"), doc (showString "("), prt 0 expression, doc (showString ")"), doc (showString ";")])
    C.CGrammar.Abs.ForStatement maybeexpression1 maybeexpression2 maybeexpression3 statement -> prPrec i 0 (concatD [doc (showString "for"), doc (showString "("), prt 0 maybeexpression1, doc (showString ";"), prt 0 maybeexpression2, doc (showString ";"), prt 0 maybeexpression3, doc (showString ")"), prt 0 statement])

instance Print C.CGrammar.Abs.MayBeExpression where
  prt i = \case
    C.CGrammar.Abs.YesExpr expression -> prPrec i 0 (concatD [prt 0 expression])
    C.CGrammar.Abs.NoExpr -> prPrec i 0 (concatD [])

instance Print C.CGrammar.Abs.JumpStatement where
  prt i = \case
    C.CGrammar.Abs.GotoStatement id_ -> prPrec i 0 (concatD [doc (showString "goto"), prt 0 id_, doc (showString ";")])
    C.CGrammar.Abs.ContinueStatement -> prPrec i 0 (concatD [doc (showString "continue"), doc (showString ";")])
    C.CGrammar.Abs.BreakStatement -> prPrec i 0 (concatD [doc (showString "break"), doc (showString ";")])
    C.CGrammar.Abs.ReturnStatement maybeexpression -> prPrec i 0 (concatD [doc (showString "return"), prt 0 maybeexpression, doc (showString ";")])
