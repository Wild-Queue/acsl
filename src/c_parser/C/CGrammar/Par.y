-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module C.CGrammar.Par
  ( happyError
  , myLexer
  , pTranslationUnit
  , pExternal_Declaration
  , pListExternal_Declaration
  , pFunctionDefinition
  , pDeclarationSpecifier
  , pListDeclarationSpecifier
  , pStorageClassSpecifier
  , pTypeSpecifier
  , pStructOrUnionSpecifier
  , pStructOrUnion
  , pStructDeclaration
  , pListStructDeclaration
  , pSpecifierQualifier
  , pListSpecifierQualifier
  , pStructDeclarator
  , pListStructDeclarator
  , pDeclarator
  , pPointer
  , pListPointer
  , pTypeQualifier
  , pListTypeQualifier
  , pDirectDeclarator
  , pListIdent
  , pConstantExpression
  , pExpression2
  , pExpression3
  , pExpression4
  , pExpression5
  , pExpression6
  , pExpression7
  , pExpression8
  , pExpression9
  , pExpression10
  , pExpression11
  , pExpression12
  , pExpression13
  , pExpression14
  , pExpression15
  , pExpression16
  , pConstant
  , pExpression
  , pExpression1
  , pListExpression1
  , pAssignmentOperator
  , pUnaryOperator
  , pTypeName
  , pParameterTypeList
  , pParameterDeclaration
  , pListParameterDeclaration
  , pAbstractDeclarator
  , pDirectAbstractDeclarator
  , pEnumSpecifier
  , pEnumerator
  , pListEnumerator
  , pDeclaration
  , pListDeclaration
  , pInitDeclarator
  , pListInitDeclarator
  , pInitializer
  , pListInitializer
  , pCompound_Statement
  , pStatement
  , pListStatement
  , pLabeledStatement
  , pExpressionStatement
  , pSelectionStatement
  , pIterationStatement
  , pMayBeExpression
  , pJumpStatement
  ) where

import Prelude

import qualified C.CGrammar.Abs
import C.CGrammar.Lex

}

%name pTranslationUnit TranslationUnit
%name pExternal_Declaration External_Declaration
%name pListExternal_Declaration ListExternal_Declaration
%name pFunctionDefinition FunctionDefinition
%name pDeclarationSpecifier DeclarationSpecifier
%name pListDeclarationSpecifier ListDeclarationSpecifier
%name pStorageClassSpecifier StorageClassSpecifier
%name pTypeSpecifier TypeSpecifier
%name pStructOrUnionSpecifier StructOrUnionSpecifier
%name pStructOrUnion StructOrUnion
%name pStructDeclaration StructDeclaration
%name pListStructDeclaration ListStructDeclaration
%name pSpecifierQualifier SpecifierQualifier
%name pListSpecifierQualifier ListSpecifierQualifier
%name pStructDeclarator StructDeclarator
%name pListStructDeclarator ListStructDeclarator
%name pDeclarator Declarator
%name pPointer Pointer
%name pListPointer ListPointer
%name pTypeQualifier TypeQualifier
%name pListTypeQualifier ListTypeQualifier
%name pDirectDeclarator DirectDeclarator
%name pListIdent ListIdent
%name pConstantExpression ConstantExpression
%name pExpression2 Expression2
%name pExpression3 Expression3
%name pExpression4 Expression4
%name pExpression5 Expression5
%name pExpression6 Expression6
%name pExpression7 Expression7
%name pExpression8 Expression8
%name pExpression9 Expression9
%name pExpression10 Expression10
%name pExpression11 Expression11
%name pExpression12 Expression12
%name pExpression13 Expression13
%name pExpression14 Expression14
%name pExpression15 Expression15
%name pExpression16 Expression16
%name pConstant Constant
%name pExpression Expression
%name pExpression1 Expression1
%name pListExpression1 ListExpression1
%name pAssignmentOperator AssignmentOperator
%name pUnaryOperator UnaryOperator
%name pTypeName TypeName
%name pParameterTypeList ParameterTypeList
%name pParameterDeclaration ParameterDeclaration
%name pListParameterDeclaration ListParameterDeclaration
%name pAbstractDeclarator AbstractDeclarator
%name pDirectAbstractDeclarator DirectAbstractDeclarator
%name pEnumSpecifier EnumSpecifier
%name pEnumerator Enumerator
%name pListEnumerator ListEnumerator
%name pDeclaration Declaration
%name pListDeclaration ListDeclaration
%name pInitDeclarator InitDeclarator
%name pListInitDeclarator ListInitDeclarator
%name pInitializer Initializer
%name pListInitializer ListInitializer
%name pCompound_Statement Compound_Statement
%name pStatement Statement
%name pListStatement ListStatement
%name pLabeledStatement LabeledStatement
%name pExpressionStatement ExpressionStatement
%name pSelectionStatement SelectionStatement
%name pIterationStatement IterationStatement
%name pMayBeExpression MayBeExpression
%name pJumpStatement JumpStatement
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'        { PT _ (TS _ 1)  }
  '!='       { PT _ (TS _ 2)  }
  '%'        { PT _ (TS _ 3)  }
  '%='       { PT _ (TS _ 4)  }
  '&'        { PT _ (TS _ 5)  }
  '&&'       { PT _ (TS _ 6)  }
  '&='       { PT _ (TS _ 7)  }
  '('        { PT _ (TS _ 8)  }
  ')'        { PT _ (TS _ 9)  }
  '*'        { PT _ (TS _ 10) }
  '*='       { PT _ (TS _ 11) }
  '+'        { PT _ (TS _ 12) }
  '++'       { PT _ (TS _ 13) }
  '+='       { PT _ (TS _ 14) }
  ','        { PT _ (TS _ 15) }
  '-'        { PT _ (TS _ 16) }
  '--'       { PT _ (TS _ 17) }
  '-='       { PT _ (TS _ 18) }
  '->'       { PT _ (TS _ 19) }
  '.'        { PT _ (TS _ 20) }
  '...'      { PT _ (TS _ 21) }
  '/'        { PT _ (TS _ 22) }
  '/='       { PT _ (TS _ 23) }
  ':'        { PT _ (TS _ 24) }
  ';'        { PT _ (TS _ 25) }
  '<'        { PT _ (TS _ 26) }
  '<<'       { PT _ (TS _ 27) }
  '<<='      { PT _ (TS _ 28) }
  '<='       { PT _ (TS _ 29) }
  '='        { PT _ (TS _ 30) }
  '=='       { PT _ (TS _ 31) }
  '>'        { PT _ (TS _ 32) }
  '>='       { PT _ (TS _ 33) }
  '>>'       { PT _ (TS _ 34) }
  '>>='      { PT _ (TS _ 35) }
  '?'        { PT _ (TS _ 36) }
  '['        { PT _ (TS _ 37) }
  ']'        { PT _ (TS _ 38) }
  '^'        { PT _ (TS _ 39) }
  '^='       { PT _ (TS _ 40) }
  'auto'     { PT _ (TS _ 41) }
  'break'    { PT _ (TS _ 42) }
  'case'     { PT _ (TS _ 43) }
  'char'     { PT _ (TS _ 44) }
  'const'    { PT _ (TS _ 45) }
  'continue' { PT _ (TS _ 46) }
  'default'  { PT _ (TS _ 47) }
  'do'       { PT _ (TS _ 48) }
  'double'   { PT _ (TS _ 49) }
  'else'     { PT _ (TS _ 50) }
  'enum'     { PT _ (TS _ 51) }
  'extern'   { PT _ (TS _ 52) }
  'float'    { PT _ (TS _ 53) }
  'for'      { PT _ (TS _ 54) }
  'goto'     { PT _ (TS _ 55) }
  'if'       { PT _ (TS _ 56) }
  'int'      { PT _ (TS _ 57) }
  'long'     { PT _ (TS _ 58) }
  'register' { PT _ (TS _ 59) }
  'return'   { PT _ (TS _ 60) }
  'short'    { PT _ (TS _ 61) }
  'signed'   { PT _ (TS _ 62) }
  'sizeof'   { PT _ (TS _ 63) }
  'static'   { PT _ (TS _ 64) }
  'struct'   { PT _ (TS _ 65) }
  'switch'   { PT _ (TS _ 66) }
  'typedef'  { PT _ (TS _ 67) }
  'union'    { PT _ (TS _ 68) }
  'unsigned' { PT _ (TS _ 69) }
  'void'     { PT _ (TS _ 70) }
  'volatile' { PT _ (TS _ 71) }
  'while'    { PT _ (TS _ 72) }
  '{'        { PT _ (TS _ 73) }
  '|'        { PT _ (TS _ 74) }
  '|='       { PT _ (TS _ 75) }
  '||'       { PT _ (TS _ 76) }
  '}'        { PT _ (TS _ 77) }
  '~'        { PT _ (TS _ 78) }
  L_Ident    { PT _ (TV $$)   }
  L_charac   { PT _ (TC $$)   }
  L_doubl    { PT _ (TD $$)   }
  L_integ    { PT _ (TI $$)   }
  L_quoted   { PT _ (TL $$)   }

%%

Ident :: { C.CGrammar.Abs.Ident }
Ident  : L_Ident { C.CGrammar.Abs.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

TranslationUnit :: { C.CGrammar.Abs.TranslationUnit }
TranslationUnit
  : ListExternal_Declaration { C.CGrammar.Abs.ATranslationUnit $1 }

External_Declaration :: { C.CGrammar.Abs.External_Declaration }
External_Declaration
  : FunctionDefinition { C.CGrammar.Abs.ExternalFunctionDeffinition $1 }
  | Declaration { C.CGrammar.Abs.ExternalDeclaration $1 }

ListExternal_Declaration :: { [C.CGrammar.Abs.External_Declaration] }
ListExternal_Declaration
  : {- empty -} { [] }
  | External_Declaration ListExternal_Declaration { (:) $1 $2 }

FunctionDefinition :: { C.CGrammar.Abs.FunctionDefinition }
FunctionDefinition
  : ListDeclarationSpecifier Declarator ListDeclaration Compound_Statement { C.CGrammar.Abs.FunctionDeffinition $1 $2 $3 $4 }

DeclarationSpecifier :: { C.CGrammar.Abs.DeclarationSpecifier }
DeclarationSpecifier
  : StorageClassSpecifier { C.CGrammar.Abs.AStorageClassSpecifier $1 }
  | TypeSpecifier { C.CGrammar.Abs.TypeSpecifierDeclSpec $1 }
  | TypeQualifier { C.CGrammar.Abs.TypeQualifierDeclSpec $1 }

ListDeclarationSpecifier :: { [C.CGrammar.Abs.DeclarationSpecifier] }
ListDeclarationSpecifier
  : {- empty -} { [] }
  | DeclarationSpecifier ListDeclarationSpecifier { (:) $1 $2 }

StorageClassSpecifier :: { C.CGrammar.Abs.StorageClassSpecifier }
StorageClassSpecifier
  : 'auto' { C.CGrammar.Abs.AutoKeyWord }
  | 'register' { C.CGrammar.Abs.RegisterKeyWord }
  | 'static' { C.CGrammar.Abs.StaticKeyWord }
  | 'extern' { C.CGrammar.Abs.ExternKeyWord }
  | 'typedef' { C.CGrammar.Abs.TypedefKeyWord }

TypeSpecifier :: { C.CGrammar.Abs.TypeSpecifier }
TypeSpecifier
  : 'void' { C.CGrammar.Abs.VoidKeyWord }
  | 'char' { C.CGrammar.Abs.CharKeyWord }
  | 'short' { C.CGrammar.Abs.ShortKeyWord }
  | 'int' { C.CGrammar.Abs.IntKeyWord }
  | 'long' { C.CGrammar.Abs.LongKeyWord }
  | 'float' { C.CGrammar.Abs.FloatKeyWord }
  | 'double' { C.CGrammar.Abs.DoubleKeyWord }
  | 'signed' { C.CGrammar.Abs.SignedKeyWord }
  | 'unsigned' { C.CGrammar.Abs.UnsignedKeyWord }
  | StructOrUnionSpecifier { C.CGrammar.Abs.StructUnionSpecifier $1 }
  | EnumSpecifier { C.CGrammar.Abs.AnEnumSpecifier $1 }

StructOrUnionSpecifier :: { C.CGrammar.Abs.StructOrUnionSpecifier }
StructOrUnionSpecifier
  : StructOrUnion Ident '{' ListStructDeclaration '}' { C.CGrammar.Abs.NamedStructUnionSpecifier $1 $2 $4 }
  | StructOrUnion '{' ListStructDeclaration '}' { C.CGrammar.Abs.NoNameStructUnionSpecifier $1 $3 }
  | StructOrUnion Ident { C.CGrammar.Abs.IdentStructUnionSpecifier $1 $2 }

StructOrUnion :: { C.CGrammar.Abs.StructOrUnion }
StructOrUnion
  : 'struct' { C.CGrammar.Abs.StructKeyWord }
  | 'union' { C.CGrammar.Abs.UnionKeyWord }

StructDeclaration :: { C.CGrammar.Abs.StructDeclaration }
StructDeclaration
  : ListSpecifierQualifier ListStructDeclarator { C.CGrammar.Abs.AStructDeclaration $1 $2 }

ListStructDeclaration :: { [C.CGrammar.Abs.StructDeclaration] }
ListStructDeclaration
  : StructDeclaration { (:[]) $1 }
  | StructDeclaration ListStructDeclaration { (:) $1 $2 }

SpecifierQualifier :: { C.CGrammar.Abs.SpecifierQualifier }
SpecifierQualifier
  : TypeSpecifier { C.CGrammar.Abs.TypeSpecifierSpecQual $1 }
  | TypeQualifier { C.CGrammar.Abs.TypeQualifierSpecQual $1 }

ListSpecifierQualifier :: { [C.CGrammar.Abs.SpecifierQualifier] }
ListSpecifierQualifier
  : {- empty -} { [] }
  | SpecifierQualifier ListSpecifierQualifier { (:) $1 $2 }

StructDeclarator :: { C.CGrammar.Abs.StructDeclarator }
StructDeclarator
  : Declarator { C.CGrammar.Abs.SimpleStructDeclarator $1 }
  | Declarator ':' ConstantExpression { C.CGrammar.Abs.InitStructDeclarator $1 $3 }
  | ':' ConstantExpression { C.CGrammar.Abs.ConstExprStructDeclarator $2 }

ListStructDeclarator :: { [C.CGrammar.Abs.StructDeclarator] }
ListStructDeclarator
  : StructDeclarator { (:[]) $1 }
  | StructDeclarator ',' ListStructDeclarator { (:) $1 $3 }

Declarator :: { C.CGrammar.Abs.Declarator }
Declarator
  : Pointer DirectDeclarator { C.CGrammar.Abs.ADeclaratior $1 $2 }
  | DirectDeclarator { C.CGrammar.Abs.APointerDeclaratior $1 }

Pointer :: { C.CGrammar.Abs.Pointer }
Pointer : '*' ListTypeQualifier { C.CGrammar.Abs.APointer $2 }

ListPointer :: { [C.CGrammar.Abs.Pointer] }
ListPointer
  : Pointer { (:[]) $1 } | Pointer ListPointer { (:) $1 $2 }

TypeQualifier :: { C.CGrammar.Abs.TypeQualifier }
TypeQualifier
  : 'const' { C.CGrammar.Abs.ConstKeyWord }
  | 'volatile' { C.CGrammar.Abs.VolatileKeyWord }

ListTypeQualifier :: { [C.CGrammar.Abs.TypeQualifier] }
ListTypeQualifier
  : {- empty -} { [] }
  | TypeQualifier ListTypeQualifier { (:) $1 $2 }

DirectDeclarator :: { C.CGrammar.Abs.DirectDeclarator }
DirectDeclarator
  : Ident { C.CGrammar.Abs.IdentDeclarator $1 }
  | '(' Declarator ')' { C.CGrammar.Abs.ParentDeclarator $2 }
  | DirectDeclarator '[' ConstantExpression ']' { C.CGrammar.Abs.ArrayDeclarator $1 $3 }
  | DirectDeclarator '[' ']' { C.CGrammar.Abs.ArrayEmptyDeclarator $1 }
  | DirectDeclarator '(' ParameterTypeList ')' { C.CGrammar.Abs.DeclaratorParameters $1 $3 }
  | DirectDeclarator '(' ListIdent ')' { C.CGrammar.Abs.DeclaratorIdentList $1 $3 }

ListIdent :: { [C.CGrammar.Abs.Ident] }
ListIdent : {- empty -} { [] } | Ident ListIdent { (:) $1 $2 }

ConstantExpression :: { C.CGrammar.Abs.ConstantExpression }
ConstantExpression
  : Expression2 { C.CGrammar.Abs.CondConstantExpr $1 }

Expression2 :: { C.CGrammar.Abs.Expression }
Expression2
  : Expression3 { $1 }
  | Expression3 '?' Expression ':' Expression2 { C.CGrammar.Abs.TernaryCondExpr $1 $3 $5 }

Expression3 :: { C.CGrammar.Abs.Expression }
Expression3
  : Expression4 { $1 }
  | Expression3 '||' Expression4 { C.CGrammar.Abs.LogicalOrExpr $1 $3 }

Expression4 :: { C.CGrammar.Abs.Expression }
Expression4
  : Expression5 { $1 }
  | Expression4 '&&' Expression5 { C.CGrammar.Abs.LogicalAndExpr $1 $3 }

Expression5 :: { C.CGrammar.Abs.Expression }
Expression5
  : Expression6 { $1 }
  | Expression5 '|' Expression6 { C.CGrammar.Abs.BitOrExpr $1 $3 }

Expression6 :: { C.CGrammar.Abs.Expression }
Expression6
  : Expression7 { $1 }
  | Expression6 '^' Expression7 { C.CGrammar.Abs.XorExpr $1 $3 }

Expression7 :: { C.CGrammar.Abs.Expression }
Expression7
  : Expression8 { $1 }
  | Expression7 '&' Expression8 { C.CGrammar.Abs.BitAndExpr $1 $3 }

Expression8 :: { C.CGrammar.Abs.Expression }
Expression8
  : Expression9 { $1 }
  | Expression8 '==' Expression9 { C.CGrammar.Abs.EqualExpr $1 $3 }
  | Expression8 '!=' Expression9 { C.CGrammar.Abs.NotEqualExpr $1 $3 }

Expression9 :: { C.CGrammar.Abs.Expression }
Expression9
  : Expression10 { $1 }
  | Expression9 '<' Expression10 { C.CGrammar.Abs.LessExpr $1 $3 }
  | Expression9 '>' Expression10 { C.CGrammar.Abs.GreaterExpr $1 $3 }
  | Expression9 '<=' Expression10 { C.CGrammar.Abs.LessOrEqualExpr $1 $3 }
  | Expression9 '>=' Expression10 { C.CGrammar.Abs.GreaterOrEqualExpr $1 $3 }

Expression10 :: { C.CGrammar.Abs.Expression }
Expression10
  : Expression11 { $1 }
  | Expression10 '<<' Expression11 { C.CGrammar.Abs.LeftShiftExpr $1 $3 }
  | Expression10 '>>' Expression11 { C.CGrammar.Abs.RightShiftExpr $1 $3 }

Expression11 :: { C.CGrammar.Abs.Expression }
Expression11
  : Expression12 { $1 }
  | Expression11 '+' Expression12 { C.CGrammar.Abs.PlusExpr $1 $3 }
  | Expression11 '-' Expression12 { C.CGrammar.Abs.MinusExpr $1 $3 }

Expression12 :: { C.CGrammar.Abs.Expression }
Expression12
  : Expression13 { $1 }
  | Expression12 '*' Expression13 { C.CGrammar.Abs.MultExpr $1 $3 }
  | Expression12 '/' Expression13 { C.CGrammar.Abs.DivExpr $1 $3 }
  | Expression12 '%' Expression13 { C.CGrammar.Abs.ModExpr $1 $3 }

Expression13 :: { C.CGrammar.Abs.Expression }
Expression13
  : Expression14 { $1 }
  | '(' TypeName ')' Expression13 { C.CGrammar.Abs.TypeCastExpr $2 $4 }

Expression14 :: { C.CGrammar.Abs.Expression }
Expression14
  : Expression15 { $1 }
  | '++' Expression14 { C.CGrammar.Abs.PrefixPlusPlusExpr $2 }
  | '--' Expression14 { C.CGrammar.Abs.PrefixMinusMinusExpr $2 }
  | UnaryOperator Expression13 { C.CGrammar.Abs.UnaryOpExpr $1 $2 }
  | 'sizeof' Expression14 { C.CGrammar.Abs.SizeOfExpr $2 }
  | 'sizeof' TypeName { C.CGrammar.Abs.SizeOfType $2 }

Expression15 :: { C.CGrammar.Abs.Expression }
Expression15
  : Expression16 { $1 }
  | Expression15 '[' Expression ']' { C.CGrammar.Abs.ArrayExpr $1 $3 }
  | Expression15 '(' ')' { C.CGrammar.Abs.PostfixParentExpr $1 }
  | Expression15 '(' ListExpression1 ')' { C.CGrammar.Abs.PostfixAssignExpr $1 $3 }
  | Expression15 '.' Ident { C.CGrammar.Abs.DotExpr $1 $3 }
  | Expression15 '->' Ident { C.CGrammar.Abs.ArrowExpr $1 $3 }
  | Expression15 '++' { C.CGrammar.Abs.PostfixPlusPlusExpr $1 }
  | Expression15 '--' { C.CGrammar.Abs.PostfixMinusMinusExpr $1 }

Expression16 :: { C.CGrammar.Abs.Expression }
Expression16
  : Ident { C.CGrammar.Abs.IdentifierExpr $1 }
  | Constant { C.CGrammar.Abs.ConstantExpr $1 }
  | String { C.CGrammar.Abs.StringExpr $1 }
  | '(' Expression ')' { $2 }

Constant :: { C.CGrammar.Abs.Constant }
Constant
  : Integer { C.CGrammar.Abs.IntegerExpr $1 }
  | Char { C.CGrammar.Abs.CharExpr $1 }
  | Double { C.CGrammar.Abs.DoubleExpr $1 }

Expression :: { C.CGrammar.Abs.Expression }
Expression : ListExpression1 { C.CGrammar.Abs.AnExpression $1 }

Expression1 :: { C.CGrammar.Abs.Expression }
Expression1
  : Expression2 { $1 }
  | Expression14 AssignmentOperator Expression1 { C.CGrammar.Abs.AssignmentExpr $1 $2 $3 }

ListExpression1 :: { [C.CGrammar.Abs.Expression] }
ListExpression1
  : Expression1 { (:[]) $1 }
  | Expression1 ',' ListExpression1 { (:) $1 $3 }

AssignmentOperator :: { C.CGrammar.Abs.AssignmentOperator }
AssignmentOperator
  : '=' { C.CGrammar.Abs.EqualOp }
  | '*=' { C.CGrammar.Abs.MultEqualOp }
  | '/=' { C.CGrammar.Abs.DivEqualOp }
  | '%=' { C.CGrammar.Abs.ModEqualOp }
  | '+=' { C.CGrammar.Abs.PlusEqualOp }
  | '-=' { C.CGrammar.Abs.MinusEqualOp }
  | '<<=' { C.CGrammar.Abs.LeftShiftEqualOp }
  | '>>=' { C.CGrammar.Abs.RoghtShiftEqualOp }
  | '&=' { C.CGrammar.Abs.AndEqualOp }
  | '^=' { C.CGrammar.Abs.XorEqualOp }
  | '|=' { C.CGrammar.Abs.OrEqualOp }

UnaryOperator :: { C.CGrammar.Abs.UnaryOperator }
UnaryOperator
  : '&' { C.CGrammar.Abs.UnaryAndOp }
  | '*' { C.CGrammar.Abs.UnaryMultOp }
  | '+' { C.CGrammar.Abs.UnaryPlusOp }
  | '-' { C.CGrammar.Abs.UnaryMinusOp }
  | '~' { C.CGrammar.Abs.UnaryTildeOp }
  | '!' { C.CGrammar.Abs.UnaryNotOp }

TypeName :: { C.CGrammar.Abs.TypeName }
TypeName
  : SpecifierQualifier ListSpecifierQualifier AbstractDeclarator { C.CGrammar.Abs.TypeNameAbstrDecl $1 $2 $3 }
  | SpecifierQualifier ListSpecifierQualifier { C.CGrammar.Abs.ATypeName $1 $2 }

ParameterTypeList :: { C.CGrammar.Abs.ParameterTypeList }
ParameterTypeList
  : ListParameterDeclaration { C.CGrammar.Abs.SimpleParameters $1 }
  | ListParameterDeclaration ',' '...' { C.CGrammar.Abs.ParametersDotDotDot $1 }

ParameterDeclaration :: { C.CGrammar.Abs.ParameterDeclaration }
ParameterDeclaration
  : DeclarationSpecifier ListDeclarationSpecifier Declarator { C.CGrammar.Abs.DeclaratorParameter $1 $2 $3 }
  | DeclarationSpecifier ListDeclarationSpecifier AbstractDeclarator { C.CGrammar.Abs.AbstractDeclaratorParameter $1 $2 $3 }
  | DeclarationSpecifier ListDeclarationSpecifier { C.CGrammar.Abs.SimpleDeclaratorParameter $1 $2 }

ListParameterDeclaration :: { [C.CGrammar.Abs.ParameterDeclaration] }
ListParameterDeclaration
  : ParameterDeclaration { (:[]) $1 }
  | ParameterDeclaration ',' ListParameterDeclaration { (:) $1 $3 }

AbstractDeclarator :: { C.CGrammar.Abs.AbstractDeclarator }
AbstractDeclarator
  : ListPointer { C.CGrammar.Abs.PointerAbstractDeclarator $1 }
  | ListPointer DirectAbstractDeclarator { C.CGrammar.Abs.PointerDirectAbstractDeclarator $1 $2 }
  | DirectAbstractDeclarator { C.CGrammar.Abs.ADirectAbstractDeclarator $1 }

DirectAbstractDeclarator :: { C.CGrammar.Abs.DirectAbstractDeclarator }
DirectAbstractDeclarator
  : '(' AbstractDeclarator ')' { C.CGrammar.Abs.SimpleDirectAbstractDeclarator $2 }
  | DirectAbstractDeclarator '[' ConstantExpression ']' { C.CGrammar.Abs.FullBracketsDirectAbstractDeclarator $1 $3 }
  | DirectAbstractDeclarator '[' ']' { C.CGrammar.Abs.BracketsDirectAbstractDeclarator $1 }
  | '[' ConstantExpression ']' { C.CGrammar.Abs.ConstExprDirectAbstractDeclarator $2 }
  | '[' ']' { C.CGrammar.Abs.SquareBracketsDirectAbstractDeclarator }
  | DirectAbstractDeclarator '(' ParameterTypeList ')' { C.CGrammar.Abs.FullParamDirectAbstractDeclarator $1 $3 }
  | DirectAbstractDeclarator '(' ')' { C.CGrammar.Abs.ParantNoParamDirectAbstractDeclarator $1 }
  | '(' ParameterTypeList ')' { C.CGrammar.Abs.ParamDirectAbstractDeclarator $2 }
  | '(' ')' { C.CGrammar.Abs.ParantDirectAbstractDeclarator }

EnumSpecifier :: { C.CGrammar.Abs.EnumSpecifier }
EnumSpecifier
  : 'enum' Ident '{' ListEnumerator '}' { C.CGrammar.Abs.NamedInitEnum $2 $4 }
  | 'enum' '{' ListEnumerator '}' { C.CGrammar.Abs.InitEnum $3 }
  | 'enum' Ident { C.CGrammar.Abs.NamedEnum $2 }

Enumerator :: { C.CGrammar.Abs.Enumerator }
Enumerator
  : Ident { C.CGrammar.Abs.DefaultEnumerator $1 }
  | Ident '=' ConstantExpression { C.CGrammar.Abs.DefinedEnumerator $1 $3 }

ListEnumerator :: { [C.CGrammar.Abs.Enumerator] }
ListEnumerator
  : Enumerator { (:[]) $1 }
  | Enumerator ',' ListEnumerator { (:) $1 $3 }

Declaration :: { C.CGrammar.Abs.Declaration }
Declaration
  : DeclarationSpecifier ListDeclarationSpecifier ListInitDeclarator ';' { C.CGrammar.Abs.ADeclaration $1 $2 $3 }

ListDeclaration :: { [C.CGrammar.Abs.Declaration] }
ListDeclaration
  : {- empty -} { [] } | Declaration ListDeclaration { (:) $1 $2 }

InitDeclarator :: { C.CGrammar.Abs.InitDeclarator }
InitDeclarator
  : Declarator { C.CGrammar.Abs.SimpleInitDeclarator $1 }
  | Declarator '=' Initializer { C.CGrammar.Abs.InitializedDeclarator $1 $3 }

ListInitDeclarator :: { [C.CGrammar.Abs.InitDeclarator] }
ListInitDeclarator
  : {- empty -} { [] }
  | InitDeclarator ListInitDeclarator { (:) $1 $2 }

Initializer :: { C.CGrammar.Abs.Initializer }
Initializer
  : Expression1 { C.CGrammar.Abs.AssignExprInitializer $1 }
  | '{' ListInitializer '}' { C.CGrammar.Abs.BlockInitializer $2 }
  | '{' ListInitializer ',' '}' { C.CGrammar.Abs.BlockCommaInitializer $2 }

ListInitializer :: { [C.CGrammar.Abs.Initializer] }
ListInitializer
  : Initializer { (:[]) $1 }
  | Initializer ',' ListInitializer { (:) $1 $3 }

Compound_Statement :: { C.CGrammar.Abs.Compound_Statement }
Compound_Statement
  : '{' ListDeclaration ListStatement '}' { C.CGrammar.Abs.CompoundStatement $2 $3 }

Statement :: { C.CGrammar.Abs.Statement }
Statement
  : LabeledStatement { C.CGrammar.Abs.ALabeledStatement $1 }
  | ExpressionStatement { C.CGrammar.Abs.AnExpressionStatement $1 }
  | Compound_Statement { C.CGrammar.Abs.ACompoundStatement $1 }
  | SelectionStatement { C.CGrammar.Abs.ASelectionStatement $1 }
  | IterationStatement { C.CGrammar.Abs.AnIterationStatement $1 }
  | JumpStatement { C.CGrammar.Abs.AJumpStatement $1 }

ListStatement :: { [C.CGrammar.Abs.Statement] }
ListStatement
  : {- empty -} { [] } | Statement ListStatement { (:) $1 $2 }

LabeledStatement :: { C.CGrammar.Abs.LabeledStatement }
LabeledStatement
  : Ident ':' Statement { C.CGrammar.Abs.LableStatement $1 $3 }
  | 'case' ConstantExpression ':' Statement { C.CGrammar.Abs.CaseStatement $2 $4 }
  | 'default' ':' Statement { C.CGrammar.Abs.DefaultStatement $3 }

ExpressionStatement :: { C.CGrammar.Abs.ExpressionStatement }
ExpressionStatement
  : MayBeExpression ';' { C.CGrammar.Abs.ExprStatement $1 }

SelectionStatement :: { C.CGrammar.Abs.SelectionStatement }
SelectionStatement
  : 'if' '(' Expression ')' Statement { C.CGrammar.Abs.IfStatement $3 $5 }
  | 'if' '(' Expression ')' Statement 'else' Statement { C.CGrammar.Abs.IfElseStatement $3 $5 $7 }
  | 'switch' '(' Expression ')' Statement { C.CGrammar.Abs.SwitchStatement $3 $5 }

IterationStatement :: { C.CGrammar.Abs.IterationStatement }
IterationStatement
  : 'while' '(' Expression ')' Statement { C.CGrammar.Abs.WhileStatement $3 $5 }
  | 'do' Statement 'while' '(' Expression ')' ';' { C.CGrammar.Abs.DoWhileStatement $2 $5 }
  | 'for' '(' MayBeExpression ';' MayBeExpression ';' MayBeExpression ')' Statement { C.CGrammar.Abs.ForStatement $3 $5 $7 $9 }

MayBeExpression :: { C.CGrammar.Abs.MayBeExpression }
MayBeExpression
  : Expression { C.CGrammar.Abs.YesExpr $1 }
  | {- empty -} { C.CGrammar.Abs.NoExpr }

JumpStatement :: { C.CGrammar.Abs.JumpStatement }
JumpStatement
  : 'goto' Ident ';' { C.CGrammar.Abs.GotoStatement $2 }
  | 'continue' ';' { C.CGrammar.Abs.ContinueStatement }
  | 'break' ';' { C.CGrammar.Abs.BreakStatement }
  | 'return' MayBeExpression ';' { C.CGrammar.Abs.ReturnStatement $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

