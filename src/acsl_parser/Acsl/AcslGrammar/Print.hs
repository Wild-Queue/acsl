-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Acsl.

module Acsl.AcslGrammar.Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified Acsl.AcslGrammar.Abs

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Acsl.AcslGrammar.Abs.Ident where
  prt _ (Acsl.AcslGrammar.Abs.Ident i) = doc $ showString i
instance Print Acsl.AcslGrammar.Abs.Program where
  prt i = \case
    Acsl.AcslGrammar.Abs.AnnotProgram annot -> prPrec i 0 (concatD [prt 0 annot])
    Acsl.AcslGrammar.Abs.AnnotationProgram logicptreeannot -> prPrec i 0 (concatD [prt 0 logicptreeannot])

instance Print Acsl.AcslGrammar.Abs.Annot where
  prt i = \case
    Acsl.AcslGrammar.Abs.CodeAnnot codeannot -> prPrec i 0 (concatD [prt 0 codeannot])

instance Print Acsl.AcslGrammar.Abs.Code_Annot where
  prt i = \case
    Acsl.AcslGrammar.Abs.CodeAnnotContract contract -> prPrec i 0 (concatD [prt 0 contract])

instance Print Acsl.AcslGrammar.Abs.Contract where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleContract requires terminates decreases simpleclauses behaviors completeordisjoint -> prPrec i 0 (concatD [prt 0 requires, prt 0 terminates, prt 0 decreases, prt 0 simpleclauses, prt 0 behaviors, prt 0 completeordisjoint])
    Acsl.AcslGrammar.Abs.ClausesRequiresContract requires terminates decreases nesimpleclauses -> prPrec i 0 (concatD [prt 0 requires, prt 0 terminates, prt 0 decreases, prt 0 nesimpleclauses, doc (showString "requires")])
    Acsl.AcslGrammar.Abs.ClausesTerminatesContract requires terminates decreases nesimpleclauses -> prPrec i 0 (concatD [prt 0 requires, prt 0 terminates, prt 0 decreases, prt 0 nesimpleclauses, doc (showString "terminates")])
    Acsl.AcslGrammar.Abs.ClausesDecreasesContract requires terminates decreases nesimpleclauses -> prPrec i 0 (concatD [prt 0 requires, prt 0 terminates, prt 0 decreases, prt 0 nesimpleclauses, doc (showString "decreases")])

instance Print Acsl.AcslGrammar.Abs.Requires where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoRequires -> prPrec i 0 (concatD [])
    Acsl.AcslGrammar.Abs.SomeRequires nerequires -> prPrec i 0 (concatD [prt 0 nerequires])

instance Print Acsl.AcslGrammar.Abs.NERequires where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleRequires lexpr requires -> prPrec i 0 (concatD [doc (showString "requires"), prt 0 lexpr, doc (showString ";"), prt 0 requires])
    Acsl.AcslGrammar.Abs.CheckRequires lexpr requires -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "requires"), prt 0 lexpr, doc (showString ";"), prt 0 requires])
    Acsl.AcslGrammar.Abs.AdimtRequires lexpr requires -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "requires"), prt 0 lexpr, doc (showString ";"), prt 0 requires])

instance Print Acsl.AcslGrammar.Abs.Terminates where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoTerminate -> prPrec i 0 (concatD [])

instance Print Acsl.AcslGrammar.Abs.Decreases where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoDecreases -> prPrec i 0 (concatD [])

instance Print Acsl.AcslGrammar.Abs.SimpleClauses where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoSimpleClauses -> prPrec i 0 (concatD [])
    Acsl.AcslGrammar.Abs.SomeSimpleClauses nesimpleclauses -> prPrec i 0 (concatD [prt 0 nesimpleclauses])

instance Print Acsl.AcslGrammar.Abs.NESimpleClauses where
  prt i = \case
    Acsl.AcslGrammar.Abs.PostCondSimpleClauses postcond lexpr simpleclauses -> prPrec i 0 (concatD [prt 0 postcond, prt 0 lexpr, doc (showString ";"), prt 0 simpleclauses])
    Acsl.AcslGrammar.Abs.AssignsSimpleClauses assigns simpleclauses -> prPrec i 0 (concatD [doc (showString "assigns"), prt 0 assigns, doc (showString ";"), prt 0 simpleclauses])

instance Print Acsl.AcslGrammar.Abs.Assigns where
  prt i = \case
    Acsl.AcslGrammar.Abs.AssignZone zones -> prPrec i 0 (concatD [prt 0 zones])
    Acsl.AcslGrammar.Abs.AssignZoneFromZone lexprs zones -> prPrec i 0 (concatD [prt 0 lexprs, doc (showString "\\from"), prt 0 zones])

instance Print Acsl.AcslGrammar.Abs.Zones where
  prt i = \case
    Acsl.AcslGrammar.Abs.SomeZone lexprs -> prPrec i 0 (concatD [prt 0 lexprs])
    Acsl.AcslGrammar.Abs.NoZone -> prPrec i 0 (concatD [doc (showString "\\nothing")])

instance Print Acsl.AcslGrammar.Abs.Behaviors where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoBehaviors -> prPrec i 0 (concatD [])

instance Print Acsl.AcslGrammar.Abs.CompleteOrDisjoint where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoComplDisj -> prPrec i 0 (concatD [])

instance Print Acsl.AcslGrammar.Abs.Lexpr where
  prt i = \case
    Acsl.AcslGrammar.Abs.ImplLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "==>"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.IffLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "<==>"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.OrLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "||"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.AndLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "&&"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.HatHatLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "^^"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.AmpLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "&"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.PipeLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "|"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.HatLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "^"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.BimpliesLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "-->"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.BiffLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "<-->"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.InLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 1 lexpr1, doc (showString "\\in"), prt 0 lexpr2])
    Acsl.AcslGrammar.Abs.TernaryLexpr lexpr1 lexpr2 lexpr3 -> prPrec i 0 (concatD [prt 0 lexpr1, doc (showString "?"), prt 0 lexpr2, doc (showString ":"), prt 0 lexpr3])
    Acsl.AcslGrammar.Abs.RelationLexpr lexpr1 lexprrelinners relation lexpr2 -> prPrec i 1 (concatD [prt 3 lexpr1, prt 0 lexprrelinners, prt 0 relation, prt 2 lexpr2])
    Acsl.AcslGrammar.Abs.BinderLexpr lexprbinder -> prPrec i 2 (concatD [prt 0 lexprbinder])
    Acsl.AcslGrammar.Abs.NotBinderLexpr lexprbinder -> prPrec i 2 (concatD [doc (showString "!"), prt 0 lexprbinder])
    Acsl.AcslGrammar.Abs.TrueLexpr -> prPrec i 3 (concatD [doc (showString "\\true")])
    Acsl.AcslGrammar.Abs.FalseLexpr -> prPrec i 3 (concatD [doc (showString "\\false")])
    Acsl.AcslGrammar.Abs.PointerLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\object_pointer"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.ValidLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\valid"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.ValidReadLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\valid_read"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.ValidFuncLexpr lexpr -> prPrec i 3 (concatD [doc (showString "\\valid_function"), doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.ValidIndxLexpr optlabel lexpr1 lexpr2 -> prPrec i 3 (concatD [doc (showString "\\valid_index"), prt 1 optlabel, doc (showString "("), prt 0 lexpr1, doc (showString ","), prt 0 lexpr2, doc (showString ")")])
    Acsl.AcslGrammar.Abs.ValidRangeLexpr optlabel lexpr1 lexpr2 lexpr3 -> prPrec i 3 (concatD [doc (showString "\\valid_range"), prt 1 optlabel, doc (showString "("), prt 0 lexpr1, doc (showString ","), prt 0 lexpr2, doc (showString ","), prt 0 lexpr3, doc (showString ")")])
    Acsl.AcslGrammar.Abs.InitializedLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\initialized"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.DanglingLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\dangling"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.FreshLexpr optlabel lexpr1 lexpr2 -> prPrec i 3 (concatD [doc (showString "\\fresh"), prt 2 optlabel, doc (showString "("), prt 0 lexpr1, doc (showString ","), prt 0 lexpr2, doc (showString ")")])
    Acsl.AcslGrammar.Abs.BaseAddrLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\base_addr"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.BlockLengthLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\block_length"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.OffsetLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\offset"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.AllocableLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\allocable"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.FreeableLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\freeable"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.AllocationLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\allocation"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.AutomaticLexpr -> prPrec i 3 (concatD [doc (showString "\\automatic")])
    Acsl.AcslGrammar.Abs.DynamicLexpr -> prPrec i 3 (concatD [doc (showString "\\dynamic")])
    Acsl.AcslGrammar.Abs.RegisterLexpr -> prPrec i 3 (concatD [doc (showString "\\register")])
    Acsl.AcslGrammar.Abs.StaticLexpr -> prPrec i 3 (concatD [doc (showString "\\static")])
    Acsl.AcslGrammar.Abs.UnallocatedLexpr -> prPrec i 3 (concatD [doc (showString "\\unallocated")])
    Acsl.AcslGrammar.Abs.NullLexpr -> prPrec i 3 (concatD [doc (showString "\\null")])
    Acsl.AcslGrammar.Abs.LexprIntConst n -> prPrec i 3 (concatD [prt 0 n])
    Acsl.AcslGrammar.Abs.LexprFloatConst d -> prPrec i 3 (concatD [prt 0 d])
    Acsl.AcslGrammar.Abs.LexprStringConst str -> prPrec i 3 (concatD [printString str])
    Acsl.AcslGrammar.Abs.AddLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "+"), prt 3 lexpr2])
    Acsl.AcslGrammar.Abs.SubtrLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "-"), prt 3 lexpr2])
    Acsl.AcslGrammar.Abs.MultLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "*"), prt 3 lexpr2])
    Acsl.AcslGrammar.Abs.DivLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "/"), prt 3 lexpr2])
    Acsl.AcslGrammar.Abs.ModLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "%"), prt 3 lexpr2])
    Acsl.AcslGrammar.Abs.SquaresRangeLexpr lexpr range -> prPrec i 3 (concatD [prt 3 lexpr, doc (showString "["), prt 0 range, doc (showString "]")])
    Acsl.AcslGrammar.Abs.SquaresLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "["), prt 0 lexpr2, doc (showString "]")])
    Acsl.AcslGrammar.Abs.MinusLexpr lexpr -> prPrec i 3 (concatD [doc (showString "-"), prt 3 lexpr])
    Acsl.AcslGrammar.Abs.PlusLexpr lexpr -> prPrec i 3 (concatD [doc (showString "+"), prt 3 lexpr])
    Acsl.AcslGrammar.Abs.TildeLexpr lexpr -> prPrec i 3 (concatD [doc (showString "~"), prt 3 lexpr])
    Acsl.AcslGrammar.Abs.StarLexpr lexpr -> prPrec i 3 (concatD [doc (showString "*"), prt 3 lexpr])
    Acsl.AcslGrammar.Abs.AmpUnaryLexpr lexpr -> prPrec i 3 (concatD [doc (showString "&"), prt 3 lexpr])
    Acsl.AcslGrammar.Abs.SizeOfLexpr lexpr -> prPrec i 3 (concatD [doc (showString "sizeof"), doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.OldLexpr lexpr -> prPrec i 3 (concatD [doc (showString "\\old"), doc (showString "("), prt 0 lexpr, doc (showString ")")])
    Acsl.AcslGrammar.Abs.AtLexpr lexpr labelname -> prPrec i 3 (concatD [doc (showString "\\at"), doc (showString "("), prt 0 lexpr, doc (showString ","), prt 0 labelname, doc (showString ")")])
    Acsl.AcslGrammar.Abs.ResultLexpr -> prPrec i 3 (concatD [doc (showString "\\result")])
    Acsl.AcslGrammar.Abs.SeparatedLexpr lexprs -> prPrec i 3 (concatD [doc (showString "\\separated"), doc (showString "("), prt 0 lexprs, doc (showString ")")])
    Acsl.AcslGrammar.Abs.FullIdParenLexpr fullidentifier lexprs -> prPrec i 3 (concatD [prt 0 fullidentifier, doc (showString "("), prt 0 lexprs, doc (showString ")")])
    Acsl.AcslGrammar.Abs.FullId fullidentifier -> prPrec i 3 (concatD [prt 0 fullidentifier])
    Acsl.AcslGrammar.Abs.PiLexpr -> prPrec i 3 (concatD [doc (showString "\\pi")])
    Acsl.AcslGrammar.Abs.ParenRangeLexpr range -> prPrec i 3 (concatD [doc (showString "("), prt 0 range, doc (showString ")")])

instance Print [Acsl.AcslGrammar.Abs.Lexpr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Acsl.AcslGrammar.Abs.LexprRelInner where
  prt i = \case
    Acsl.AcslGrammar.Abs.RelInnerLexpr relation lexpr -> prPrec i 0 (concatD [prt 0 relation, prt 3 lexpr])

instance Print [Acsl.AcslGrammar.Abs.LexprRelInner] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Acsl.AcslGrammar.Abs.Relation where
  prt i = \case
    Acsl.AcslGrammar.Abs.LessRel -> prPrec i 0 (concatD [doc (showString "<")])
    Acsl.AcslGrammar.Abs.GreaterRel -> prPrec i 0 (concatD [doc (showString ">")])
    Acsl.AcslGrammar.Abs.LessEqRel -> prPrec i 0 (concatD [doc (showString "<=")])
    Acsl.AcslGrammar.Abs.GreaterEqRel -> prPrec i 0 (concatD [doc (showString ">=")])
    Acsl.AcslGrammar.Abs.EqRel -> prPrec i 0 (concatD [doc (showString "==")])
    Acsl.AcslGrammar.Abs.NotEqRel -> prPrec i 0 (concatD [doc (showString "!=")])

instance Print Acsl.AcslGrammar.Abs.LexprBinder where
  prt i = \case
    Acsl.AcslGrammar.Abs.ForallBinderLexpr binders lexpr -> prPrec i 0 (concatD [doc (showString "\\forall"), prt 0 binders, doc (showString ";"), prt 0 lexpr])
    Acsl.AcslGrammar.Abs.ExistBinderLexpr binders lexpr -> prPrec i 0 (concatD [doc (showString "\\exists"), prt 0 binders, doc (showString ";"), prt 0 lexpr])
    Acsl.AcslGrammar.Abs.LambdaBinderLexpr binders lexpr -> prPrec i 0 (concatD [doc (showString "\\lambda"), prt 0 binders, doc (showString ";"), prt 0 lexpr])

instance Print Acsl.AcslGrammar.Abs.Binders where
  prt i = \case
    Acsl.AcslGrammar.Abs.TheBinders typespecoftypename varspec bindersreentrances -> prPrec i 0 (concatD [prt 0 typespecoftypename, prt 0 varspec, prt 0 bindersreentrances])

instance Print Acsl.AcslGrammar.Abs.TypeSpecOFTYPENAME where
  prt i = \case
    Acsl.AcslGrammar.Abs.TypeSpecTYPENAME id_ -> prPrec i 0 (concatD [prt 0 id_])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleFromTypenameTypeSpec typespecsimple -> prPrec i 0 (concatD [prt 0 typespecsimple])

instance Print Acsl.AcslGrammar.Abs.BindersReentrance where
  prt i = \case
    Acsl.AcslGrammar.Abs.BindersReentranceDeclSpec typespecoftypename varspec -> prPrec i 0 (concatD [doc (showString ","), prt 0 typespecoftypename, prt 0 varspec])
    Acsl.AcslGrammar.Abs.BindersReentranceVarSpec varspec -> prPrec i 0 (concatD [doc (showString ","), prt 0 varspec])

instance Print [Acsl.AcslGrammar.Abs.BindersReentrance] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Acsl.AcslGrammar.Abs.VarSpec where
  prt i = \case
    Acsl.AcslGrammar.Abs.StartVarSpec starss varspec -> prPrec i 0 (concatD [prt 0 starss, prt 1 varspec])
    Acsl.AcslGrammar.Abs.SimpleSpec fullidentifier -> prPrec i 1 (concatD [prt 0 fullidentifier])
    Acsl.AcslGrammar.Abs.ArraySpec varspec arraysize -> prPrec i 1 (concatD [prt 1 varspec, doc (showString "["), prt 0 arraysize, doc (showString "]")])

instance Print Acsl.AcslGrammar.Abs.Stars where
  prt i = \case
    Acsl.AcslGrammar.Abs.Star -> prPrec i 0 (concatD [doc (showString "*")])

instance Print [Acsl.AcslGrammar.Abs.Stars] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Acsl.AcslGrammar.Abs.ArraySize where
  prt i = \case
    Acsl.AcslGrammar.Abs.IntConstArraySize n -> prPrec i 0 (concatD [prt 0 n])
    Acsl.AcslGrammar.Abs.SomeArraySize fullidentifier -> prPrec i 0 (concatD [prt 0 fullidentifier])
    Acsl.AcslGrammar.Abs.NoSize -> prPrec i 0 (concatD [])

instance Print Acsl.AcslGrammar.Abs.OptLabel where
  prt i = \case
    Acsl.AcslGrammar.Abs.OptLabelOne optlabellist -> prPrec i 1 (concatD [prt 0 optlabellist])
    Acsl.AcslGrammar.Abs.OptLabelTwo optlabellist -> prPrec i 2 (concatD [prt 0 optlabellist])

instance Print Acsl.AcslGrammar.Abs.OptLabelList where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoLableList -> prPrec i 0 (concatD [])
    Acsl.AcslGrammar.Abs.LableList labelnames -> prPrec i 0 (concatD [doc (showString "{"), prt 0 labelnames, doc (showString "}")])

instance Print Acsl.AcslGrammar.Abs.LabelName where
  prt i = \case
    Acsl.AcslGrammar.Abs.LableName anyidentifier -> prPrec i 0 (concatD [prt 0 anyidentifier])

instance Print [Acsl.AcslGrammar.Abs.LabelName] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Acsl.AcslGrammar.Abs.Range where
  prt i = \case
    Acsl.AcslGrammar.Abs.LexprRange lexproption1 lexproption2 -> prPrec i 0 (concatD [prt 0 lexproption1, doc (showString ".."), prt 0 lexproption2])

instance Print Acsl.AcslGrammar.Abs.LexprOption where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoLexprOption -> prPrec i 0 (concatD [])
    Acsl.AcslGrammar.Abs.SomeLexprOption lexpr -> prPrec i 0 (concatD [prt 0 lexpr])

instance Print Acsl.AcslGrammar.Abs.AnyIdentifier where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleIdentifierAny identifier -> prPrec i 0 (concatD [prt 0 identifier])

instance Print Acsl.AcslGrammar.Abs.PostCond where
  prt i = \case
    Acsl.AcslGrammar.Abs.EnsuresKeyWord -> prPrec i 0 (concatD [doc (showString "ensures")])
    Acsl.AcslGrammar.Abs.ExitsKeyWord -> prPrec i 0 (concatD [doc (showString "exits")])
    Acsl.AcslGrammar.Abs.BreaksKeyWord -> prPrec i 0 (concatD [doc (showString "breaks")])
    Acsl.AcslGrammar.Abs.ContinuesKeyWord -> prPrec i 0 (concatD [doc (showString "continues")])
    Acsl.AcslGrammar.Abs.ReturnsKeyWord -> prPrec i 0 (concatD [doc (showString "returns")])
    Acsl.AcslGrammar.Abs.CheckEnsuresKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "ensures")])
    Acsl.AcslGrammar.Abs.CheckExitsKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "exits")])
    Acsl.AcslGrammar.Abs.CheckBreaksKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "breaks")])
    Acsl.AcslGrammar.Abs.CheckContinuesKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "continues")])
    Acsl.AcslGrammar.Abs.CheckReturnsKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "returns")])
    Acsl.AcslGrammar.Abs.AdmitEnsuresKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "ensures")])
    Acsl.AcslGrammar.Abs.AdmitExitsKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "exits")])
    Acsl.AcslGrammar.Abs.AdmitBreaksKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "breaks")])
    Acsl.AcslGrammar.Abs.AdmitContinuesKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "continues")])
    Acsl.AcslGrammar.Abs.AdmitReturnsKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "returns")])

instance Print Acsl.AcslGrammar.Abs.FullIdentifier where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleIdentifierFull identifier -> prPrec i 0 (concatD [prt 0 identifier])
    Acsl.AcslGrammar.Abs.AdmitKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "admit")])
    Acsl.AcslGrammar.Abs.AllocatesKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "allocates")])
    Acsl.AcslGrammar.Abs.AssertKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "assert")])
    Acsl.AcslGrammar.Abs.AssignsKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "assigns")])
    Acsl.AcslGrammar.Abs.AssumesKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "assumes")])
    Acsl.AcslGrammar.Abs.AtKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "at")])
    Acsl.AcslGrammar.Abs.AxiomKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "axiom")])
    Acsl.AcslGrammar.Abs.AxiomaticKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "axiomatic")])
    Acsl.AcslGrammar.Abs.BehaviorKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "behavior")])
    Acsl.AcslGrammar.Abs.BreaksKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "breaks")])
    Acsl.AcslGrammar.Abs.CheckKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "check")])
    Acsl.AcslGrammar.Abs.CompleteKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "complete")])
    Acsl.AcslGrammar.Abs.ContinuesKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "continues")])
    Acsl.AcslGrammar.Abs.ContractKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "contract")])
    Acsl.AcslGrammar.Abs.DecreasesKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "decreases")])
    Acsl.AcslGrammar.Abs.DisjointKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "disjoint")])
    Acsl.AcslGrammar.Abs.EnsuresKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "ensures")])
    Acsl.AcslGrammar.Abs.ExitsKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "exits")])
    Acsl.AcslGrammar.Abs.FreesKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "frees")])
    Acsl.AcslGrammar.Abs.FunctionKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "function")])
    Acsl.AcslGrammar.Abs.GlobalKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "global")])
    Acsl.AcslGrammar.Abs.ImpactKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "impact")])
    Acsl.AcslGrammar.Abs.InductiveKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "inductive")])
    Acsl.AcslGrammar.Abs.IncludeKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "include")])
    Acsl.AcslGrammar.Abs.InvariantKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "invariant")])
    Acsl.AcslGrammar.Abs.LemmaKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "lemma")])
    Acsl.AcslGrammar.Abs.LetKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "let")])
    Acsl.AcslGrammar.Abs.LogicKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "logic")])
    Acsl.AcslGrammar.Abs.LoopKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "loop")])
    Acsl.AcslGrammar.Abs.ModelKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "model")])
    Acsl.AcslGrammar.Abs.ModuleKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "module")])
    Acsl.AcslGrammar.Abs.PragmaKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "pragma")])
    Acsl.AcslGrammar.Abs.PredicateKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "predicate")])
    Acsl.AcslGrammar.Abs.RequiresKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "requires")])
    Acsl.AcslGrammar.Abs.ReturnsKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "returns")])
    Acsl.AcslGrammar.Abs.SliceKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "slice")])
    Acsl.AcslGrammar.Abs.TerminatesKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "terminates")])
    Acsl.AcslGrammar.Abs.TypeKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "type")])
    Acsl.AcslGrammar.Abs.VariantKeyWordFullIdent -> prPrec i 0 (concatD [doc (showString "variant")])

instance Print [Acsl.AcslGrammar.Abs.FullIdentifier] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Acsl.AcslGrammar.Abs.Identifier where
  prt i = \case
    Acsl.AcslGrammar.Abs.IdentifierIdent id_ -> prPrec i 0 (concatD [prt 0 id_])
    Acsl.AcslGrammar.Abs.BehaviorsKeyWord -> prPrec i 0 (concatD [doc (showString "behaviors")])
    Acsl.AcslGrammar.Abs.LabelKeyWord -> prPrec i 0 (concatD [doc (showString "label")])
    Acsl.AcslGrammar.Abs.ReadsKeyWord -> prPrec i 0 (concatD [doc (showString "reads")])
    Acsl.AcslGrammar.Abs.WritesKeyWord -> prPrec i 0 (concatD [doc (showString "writes")])

instance Print Acsl.AcslGrammar.Abs.TypeSpecSimple where
  prt i = \case
    Acsl.AcslGrammar.Abs.TypeSpecSimpleIntegerKeyWord -> prPrec i 0 (concatD [doc (showString "integer")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleRealKeyWord -> prPrec i 0 (concatD [doc (showString "real")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleBooleanKeyWord -> prPrec i 0 (concatD [doc (showString "boolean")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleVoidKeyWord -> prPrec i 0 (concatD [doc (showString "void")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleBoolKeyWord -> prPrec i 0 (concatD [doc (showString "_Bool")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleCharKeyWord -> prPrec i 0 (concatD [doc (showString "char")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedCharKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "char")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedCharKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "char")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleIntKeyWord -> prPrec i 0 (concatD [doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedIntKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedIntKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleShortKeyWord -> prPrec i 0 (concatD [doc (showString "short")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedShortKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "short")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedShortKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "short")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleShortIntKeyWord -> prPrec i 0 (concatD [doc (showString "short"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedShortIntKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "short"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedShortIntKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "short"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleLongKeyWord -> prPrec i 0 (concatD [doc (showString "long")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "long")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "long")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongIntKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "long"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleLongIntKeyWord -> prPrec i 0 (concatD [doc (showString "long"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongIntKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "long"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleLongLongKeyWord -> prPrec i 0 (concatD [doc (showString "long"), doc (showString "long")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongLongKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "long"), doc (showString "long")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongLongKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "long"), doc (showString "long")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleLongLongIntKeyWord -> prPrec i 0 (concatD [doc (showString "long"), doc (showString "long"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongLongIntKeyWord -> prPrec i 0 (concatD [doc (showString "signed"), doc (showString "long"), doc (showString "long"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongLongIntKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned"), doc (showString "long"), doc (showString "long"), doc (showString "int")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleFloatKeyWord -> prPrec i 0 (concatD [doc (showString "float")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleDoubleKeyWord -> prPrec i 0 (concatD [doc (showString "double")])
    Acsl.AcslGrammar.Abs.TypeSpecSimpleLongDoubleKeyWord -> prPrec i 0 (concatD [doc (showString "long"), doc (showString "double")])

instance Print Acsl.AcslGrammar.Abs.LogicPTreeAnnot where
  prt i = \case
    Acsl.AcslGrammar.Abs.AnAnnotation annotation -> prPrec i 0 (concatD [prt 0 annotation])

instance Print Acsl.AcslGrammar.Abs.Annotation where
  prt i = \case
    Acsl.AcslGrammar.Abs.LoopAnnotation loopannotstack -> prPrec i 0 (concatD [prt 0 loopannotstack])

instance Print Acsl.AcslGrammar.Abs.LoopAnnotStack where
  prt i = \case
    Acsl.AcslGrammar.Abs.LoopAnnotStackInvariant loopinvariant loopannotopt -> prPrec i 0 (concatD [prt 0 loopinvariant, prt 0 loopannotopt])
    Acsl.AcslGrammar.Abs.LoopAnnotStackEffects loopeffects loopannotopt -> prPrec i 0 (concatD [prt 0 loopeffects, prt 0 loopannotopt])
    Acsl.AcslGrammar.Abs.LoopAnnotStackAllocation loopallocation loopannotopt -> prPrec i 0 (concatD [prt 0 loopallocation, prt 0 loopannotopt])
    Acsl.AcslGrammar.Abs.LoopAnnotStackVariant loopvariant loopannotopt -> prPrec i 0 (concatD [prt 0 loopvariant, prt 0 loopannotopt])

instance Print Acsl.AcslGrammar.Abs.LoopAnnotOpt where
  prt i = \case
    Acsl.AcslGrammar.Abs.NoLoopAnnot -> prPrec i 0 (concatD [])
    Acsl.AcslGrammar.Abs.SomeLoopAnnot loopannotstack -> prPrec i 0 (concatD [prt 0 loopannotstack])

instance Print Acsl.AcslGrammar.Abs.LoopInvariant where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleLoopInvariant lexpr -> prPrec i 0 (concatD [doc (showString "loop"), doc (showString "invariant"), prt 0 lexpr, doc (showString ";")])
    Acsl.AcslGrammar.Abs.CheckLoopInvariant lexpr -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "loop"), doc (showString "invariant"), prt 0 lexpr, doc (showString ";")])
    Acsl.AcslGrammar.Abs.AdmitLoopInvariant lexpr -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "loop"), doc (showString "invariant"), prt 0 lexpr, doc (showString ";")])

instance Print Acsl.AcslGrammar.Abs.LoopAllocation where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleLoopAllocation allocation -> prPrec i 0 (concatD [doc (showString "loop"), prt 0 allocation, doc (showString ";")])

instance Print Acsl.AcslGrammar.Abs.Allocation where
  prt i = \case
    Acsl.AcslGrammar.Abs.AllocatesZones zones -> prPrec i 0 (concatD [doc (showString "allocates"), prt 0 zones])
    Acsl.AcslGrammar.Abs.FreesZones zones -> prPrec i 0 (concatD [doc (showString "frees"), prt 0 zones])

instance Print Acsl.AcslGrammar.Abs.LoopVariant where
  prt i = \case
    Acsl.AcslGrammar.Abs.SimpleLoopVariant variant -> prPrec i 0 (concatD [doc (showString "loop"), doc (showString "variant"), prt 0 variant, doc (showString ";")])

instance Print Acsl.AcslGrammar.Abs.LoopEffects where
  prt i = \case
    Acsl.AcslGrammar.Abs.LoopAssigns assigns -> prPrec i 0 (concatD [doc (showString "loop"), doc (showString "assigns"), prt 0 assigns, doc (showString ";")])

instance Print Acsl.AcslGrammar.Abs.Variant where
  prt i = \case
    Acsl.AcslGrammar.Abs.ForVariant lexpr anyidentifier -> prPrec i 0 (concatD [prt 0 lexpr, doc (showString "for"), prt 0 anyidentifier])
    Acsl.AcslGrammar.Abs.LexprVariant lexpr -> prPrec i 0 (concatD [prt 0 lexpr])
