-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Acsl.AcslGrammar.Par
  ( happyError
  , myLexer
  , pProgram
  , pAnnot
  , pCode_Annot
  , pContract
  , pRequires
  , pNERequires
  , pTerminates
  , pDecreases
  , pSimpleClauses
  , pNESimpleClauses
  , pAssigns
  , pZones
  , pBehaviors
  , pCompleteOrDisjoint
  , pLexpr
  , pListLexpr
  , pLexpr1
  , pLexprRelInner
  , pListLexprRelInner
  , pRelation
  , pLexpr2
  , pLexprBinder
  , pBinders
  , pTypeSpecOFTYPENAME
  , pBindersReentrance
  , pListBindersReentrance
  , pVarSpec
  , pStars
  , pListStars
  , pVarSpec1
  , pArraySize
  , pLexpr3
  , pOptLabel1
  , pOptLabel2
  , pOptLabelList
  , pLabelName
  , pListLabelName
  , pRange
  , pLexprOption
  , pAnyIdentifier
  , pPostCond
  , pFullIdentifier
  , pListFullIdentifier
  , pIdentifier
  , pTypeSpecSimple
  , pLogicPTreeAnnot
  , pAnnotation
  , pLoopAnnotStack
  , pLoopAnnotOpt
  , pLoopInvariant
  , pLoopAllocation
  , pAllocation
  , pLoopVariant
  , pLoopEffects
  , pVariant
  ) where

import Prelude

import qualified Acsl.AcslGrammar.Abs
import Acsl.AcslGrammar.Lex

}

%name pProgram Program
%name pAnnot Annot
%name pCode_Annot Code_Annot
%name pContract Contract
%name pRequires Requires
%name pNERequires NERequires
%name pTerminates Terminates
%name pDecreases Decreases
%name pSimpleClauses SimpleClauses
%name pNESimpleClauses NESimpleClauses
%name pAssigns Assigns
%name pZones Zones
%name pBehaviors Behaviors
%name pCompleteOrDisjoint CompleteOrDisjoint
%name pLexpr Lexpr
%name pListLexpr ListLexpr
%name pLexpr1 Lexpr1
%name pLexprRelInner LexprRelInner
%name pListLexprRelInner ListLexprRelInner
%name pRelation Relation
%name pLexpr2 Lexpr2
%name pLexprBinder LexprBinder
%name pBinders Binders
%name pTypeSpecOFTYPENAME TypeSpecOFTYPENAME
%name pBindersReentrance BindersReentrance
%name pListBindersReentrance ListBindersReentrance
%name pVarSpec VarSpec
%name pStars Stars
%name pListStars ListStars
%name pVarSpec1 VarSpec1
%name pArraySize ArraySize
%name pLexpr3 Lexpr3
%name pOptLabel1 OptLabel1
%name pOptLabel2 OptLabel2
%name pOptLabelList OptLabelList
%name pLabelName LabelName
%name pListLabelName ListLabelName
%name pRange Range
%name pLexprOption LexprOption
%name pAnyIdentifier AnyIdentifier
%name pPostCond PostCond
%name pFullIdentifier FullIdentifier
%name pListFullIdentifier ListFullIdentifier
%name pIdentifier Identifier
%name pTypeSpecSimple TypeSpecSimple
%name pLogicPTreeAnnot LogicPTreeAnnot
%name pAnnotation Annotation
%name pLoopAnnotStack LoopAnnotStack
%name pLoopAnnotOpt LoopAnnotOpt
%name pLoopInvariant LoopInvariant
%name pLoopAllocation LoopAllocation
%name pAllocation Allocation
%name pLoopVariant LoopVariant
%name pLoopEffects LoopEffects
%name pVariant Variant
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'                { PT _ (TS _ 1)   }
  '!='               { PT _ (TS _ 2)   }
  '%'                { PT _ (TS _ 3)   }
  '&'                { PT _ (TS _ 4)   }
  '&&'               { PT _ (TS _ 5)   }
  '('                { PT _ (TS _ 6)   }
  ')'                { PT _ (TS _ 7)   }
  '*'                { PT _ (TS _ 8)   }
  '+'                { PT _ (TS _ 9)   }
  ','                { PT _ (TS _ 10)  }
  '-'                { PT _ (TS _ 11)  }
  '-->'              { PT _ (TS _ 12)  }
  '..'               { PT _ (TS _ 13)  }
  '/'                { PT _ (TS _ 14)  }
  ':'                { PT _ (TS _ 15)  }
  ';'                { PT _ (TS _ 16)  }
  '<'                { PT _ (TS _ 17)  }
  '<-->'             { PT _ (TS _ 18)  }
  '<='               { PT _ (TS _ 19)  }
  '<==>'             { PT _ (TS _ 20)  }
  '=='               { PT _ (TS _ 21)  }
  '==>'              { PT _ (TS _ 22)  }
  '>'                { PT _ (TS _ 23)  }
  '>='               { PT _ (TS _ 24)  }
  '?'                { PT _ (TS _ 25)  }
  '['                { PT _ (TS _ 26)  }
  '\\allocable'      { PT _ (TS _ 27)  }
  '\\allocation'     { PT _ (TS _ 28)  }
  '\\at'             { PT _ (TS _ 29)  }
  '\\automatic'      { PT _ (TS _ 30)  }
  '\\base_addr'      { PT _ (TS _ 31)  }
  '\\block_length'   { PT _ (TS _ 32)  }
  '\\dangling'       { PT _ (TS _ 33)  }
  '\\dynamic'        { PT _ (TS _ 34)  }
  '\\exists'         { PT _ (TS _ 35)  }
  '\\false'          { PT _ (TS _ 36)  }
  '\\forall'         { PT _ (TS _ 37)  }
  '\\freeable'       { PT _ (TS _ 38)  }
  '\\fresh'          { PT _ (TS _ 39)  }
  '\\from'           { PT _ (TS _ 40)  }
  '\\in'             { PT _ (TS _ 41)  }
  '\\initialized'    { PT _ (TS _ 42)  }
  '\\lambda'         { PT _ (TS _ 43)  }
  '\\nothing'        { PT _ (TS _ 44)  }
  '\\null'           { PT _ (TS _ 45)  }
  '\\object_pointer' { PT _ (TS _ 46)  }
  '\\offset'         { PT _ (TS _ 47)  }
  '\\old'            { PT _ (TS _ 48)  }
  '\\pi'             { PT _ (TS _ 49)  }
  '\\register'       { PT _ (TS _ 50)  }
  '\\result'         { PT _ (TS _ 51)  }
  '\\separated'      { PT _ (TS _ 52)  }
  '\\static'         { PT _ (TS _ 53)  }
  '\\true'           { PT _ (TS _ 54)  }
  '\\unallocated'    { PT _ (TS _ 55)  }
  '\\valid'          { PT _ (TS _ 56)  }
  '\\valid_function' { PT _ (TS _ 57)  }
  '\\valid_index'    { PT _ (TS _ 58)  }
  '\\valid_range'    { PT _ (TS _ 59)  }
  '\\valid_read'     { PT _ (TS _ 60)  }
  ']'                { PT _ (TS _ 61)  }
  '^'                { PT _ (TS _ 62)  }
  '^^'               { PT _ (TS _ 63)  }
  '_Bool'            { PT _ (TS _ 64)  }
  'admit'            { PT _ (TS _ 65)  }
  'allocates'        { PT _ (TS _ 66)  }
  'assert'           { PT _ (TS _ 67)  }
  'assigns'          { PT _ (TS _ 68)  }
  'assumes'          { PT _ (TS _ 69)  }
  'at'               { PT _ (TS _ 70)  }
  'axiom'            { PT _ (TS _ 71)  }
  'axiomatic'        { PT _ (TS _ 72)  }
  'behavior'         { PT _ (TS _ 73)  }
  'behaviors'        { PT _ (TS _ 74)  }
  'boolean'          { PT _ (TS _ 75)  }
  'breaks'           { PT _ (TS _ 76)  }
  'char'             { PT _ (TS _ 77)  }
  'check'            { PT _ (TS _ 78)  }
  'complete'         { PT _ (TS _ 79)  }
  'continues'        { PT _ (TS _ 80)  }
  'contract'         { PT _ (TS _ 81)  }
  'decreases'        { PT _ (TS _ 82)  }
  'disjoint'         { PT _ (TS _ 83)  }
  'double'           { PT _ (TS _ 84)  }
  'ensures'          { PT _ (TS _ 85)  }
  'exits'            { PT _ (TS _ 86)  }
  'float'            { PT _ (TS _ 87)  }
  'for'              { PT _ (TS _ 88)  }
  'frees'            { PT _ (TS _ 89)  }
  'function'         { PT _ (TS _ 90)  }
  'global'           { PT _ (TS _ 91)  }
  'impact'           { PT _ (TS _ 92)  }
  'include'          { PT _ (TS _ 93)  }
  'inductive'        { PT _ (TS _ 94)  }
  'int'              { PT _ (TS _ 95)  }
  'integer'          { PT _ (TS _ 96)  }
  'invariant'        { PT _ (TS _ 97)  }
  'label'            { PT _ (TS _ 98)  }
  'lemma'            { PT _ (TS _ 99)  }
  'let'              { PT _ (TS _ 100) }
  'logic'            { PT _ (TS _ 101) }
  'long'             { PT _ (TS _ 102) }
  'loop'             { PT _ (TS _ 103) }
  'model'            { PT _ (TS _ 104) }
  'module'           { PT _ (TS _ 105) }
  'pragma'           { PT _ (TS _ 106) }
  'predicate'        { PT _ (TS _ 107) }
  'reads'            { PT _ (TS _ 108) }
  'real'             { PT _ (TS _ 109) }
  'requires'         { PT _ (TS _ 110) }
  'returns'          { PT _ (TS _ 111) }
  'short'            { PT _ (TS _ 112) }
  'signed'           { PT _ (TS _ 113) }
  'sizeof'           { PT _ (TS _ 114) }
  'slice'            { PT _ (TS _ 115) }
  'terminates'       { PT _ (TS _ 116) }
  'type'             { PT _ (TS _ 117) }
  'unsigned'         { PT _ (TS _ 118) }
  'variant'          { PT _ (TS _ 119) }
  'void'             { PT _ (TS _ 120) }
  'writes'           { PT _ (TS _ 121) }
  '{'                { PT _ (TS _ 122) }
  '|'                { PT _ (TS _ 123) }
  '||'               { PT _ (TS _ 124) }
  '}'                { PT _ (TS _ 125) }
  '~'                { PT _ (TS _ 126) }
  L_Ident            { PT _ (TV $$)    }
  L_doubl            { PT _ (TD $$)    }
  L_integ            { PT _ (TI $$)    }
  L_quoted           { PT _ (TL $$)    }

%%

Ident :: { Acsl.AcslGrammar.Abs.Ident }
Ident  : L_Ident { Acsl.AcslGrammar.Abs.Ident $1 }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Program :: { Acsl.AcslGrammar.Abs.Program }
Program
  : Annot { Acsl.AcslGrammar.Abs.AnnotProgram $1 }
  | LogicPTreeAnnot { Acsl.AcslGrammar.Abs.AnnotationProgram $1 }

Annot :: { Acsl.AcslGrammar.Abs.Annot }
Annot : Code_Annot { Acsl.AcslGrammar.Abs.CodeAnnot $1 }

Code_Annot :: { Acsl.AcslGrammar.Abs.Code_Annot }
Code_Annot : Contract { Acsl.AcslGrammar.Abs.CodeAnnotContract $1 }

Contract :: { Acsl.AcslGrammar.Abs.Contract }
Contract
  : Requires Terminates Decreases SimpleClauses Behaviors CompleteOrDisjoint { Acsl.AcslGrammar.Abs.SimpleContract $1 $2 $3 $4 $5 $6 }
  | Requires Terminates Decreases NESimpleClauses 'requires' { Acsl.AcslGrammar.Abs.ClausesRequiresContract $1 $2 $3 $4 }
  | Requires Terminates Decreases NESimpleClauses 'terminates' { Acsl.AcslGrammar.Abs.ClausesTerminatesContract $1 $2 $3 $4 }
  | Requires Terminates Decreases NESimpleClauses 'decreases' { Acsl.AcslGrammar.Abs.ClausesDecreasesContract $1 $2 $3 $4 }

Requires :: { Acsl.AcslGrammar.Abs.Requires }
Requires
  : {- empty -} { Acsl.AcslGrammar.Abs.NoRequires }
  | NERequires { Acsl.AcslGrammar.Abs.SomeRequires $1 }

NERequires :: { Acsl.AcslGrammar.Abs.NERequires }
NERequires
  : 'requires' Lexpr ';' Requires { Acsl.AcslGrammar.Abs.SimpleRequires $2 $4 }
  | 'check' 'requires' Lexpr ';' Requires { Acsl.AcslGrammar.Abs.CheckRequires $3 $5 }
  | 'admit' 'requires' Lexpr ';' Requires { Acsl.AcslGrammar.Abs.AdimtRequires $3 $5 }

Terminates :: { Acsl.AcslGrammar.Abs.Terminates }
Terminates : {- empty -} { Acsl.AcslGrammar.Abs.NoTerminate }

Decreases :: { Acsl.AcslGrammar.Abs.Decreases }
Decreases : {- empty -} { Acsl.AcslGrammar.Abs.NoDecreases }

SimpleClauses :: { Acsl.AcslGrammar.Abs.SimpleClauses }
SimpleClauses
  : {- empty -} { Acsl.AcslGrammar.Abs.NoSimpleClauses }
  | NESimpleClauses { Acsl.AcslGrammar.Abs.SomeSimpleClauses $1 }

NESimpleClauses :: { Acsl.AcslGrammar.Abs.NESimpleClauses }
NESimpleClauses
  : PostCond Lexpr ';' SimpleClauses { Acsl.AcslGrammar.Abs.PostCondSimpleClauses $1 $2 $4 }
  | 'assigns' Assigns ';' SimpleClauses { Acsl.AcslGrammar.Abs.AssignsSimpleClauses $2 $4 }

Assigns :: { Acsl.AcslGrammar.Abs.Assigns }
Assigns
  : Zones { Acsl.AcslGrammar.Abs.AssignZone $1 }
  | ListLexpr '\\from' Zones { Acsl.AcslGrammar.Abs.AssignZoneFromZone $1 $3 }

Zones :: { Acsl.AcslGrammar.Abs.Zones }
Zones
  : ListLexpr { Acsl.AcslGrammar.Abs.SomeZone $1 }
  | '\\nothing' { Acsl.AcslGrammar.Abs.NoZone }

Behaviors :: { Acsl.AcslGrammar.Abs.Behaviors }
Behaviors : {- empty -} { Acsl.AcslGrammar.Abs.NoBehaviors }

CompleteOrDisjoint :: { Acsl.AcslGrammar.Abs.CompleteOrDisjoint }
CompleteOrDisjoint
  : {- empty -} { Acsl.AcslGrammar.Abs.NoComplDisj }

Lexpr :: { Acsl.AcslGrammar.Abs.Lexpr }
Lexpr
  : Lexpr1 '==>' Lexpr { Acsl.AcslGrammar.Abs.ImplLexpr $1 $3 }
  | Lexpr1 '<==>' Lexpr { Acsl.AcslGrammar.Abs.IffLexpr $1 $3 }
  | Lexpr1 '||' Lexpr { Acsl.AcslGrammar.Abs.OrLexpr $1 $3 }
  | Lexpr1 '&&' Lexpr { Acsl.AcslGrammar.Abs.AndLexpr $1 $3 }
  | Lexpr1 '^^' Lexpr { Acsl.AcslGrammar.Abs.HatHatLexpr $1 $3 }
  | Lexpr1 '&' Lexpr { Acsl.AcslGrammar.Abs.AmpLexpr $1 $3 }
  | Lexpr1 '|' Lexpr { Acsl.AcslGrammar.Abs.PipeLexpr $1 $3 }
  | Lexpr1 '^' Lexpr { Acsl.AcslGrammar.Abs.HatLexpr $1 $3 }
  | Lexpr1 '-->' Lexpr { Acsl.AcslGrammar.Abs.BimpliesLexpr $1 $3 }
  | Lexpr1 '<-->' Lexpr { Acsl.AcslGrammar.Abs.BiffLexpr $1 $3 }
  | Lexpr1 '\\in' Lexpr { Acsl.AcslGrammar.Abs.InLexpr $1 $3 }
  | Lexpr '?' Lexpr ':' Lexpr { Acsl.AcslGrammar.Abs.TernaryLexpr $1 $3 $5 }
  | Lexpr1 { $1 }

ListLexpr :: { [Acsl.AcslGrammar.Abs.Lexpr] }
ListLexpr : Lexpr { (:[]) $1 } | Lexpr ',' ListLexpr { (:) $1 $3 }

Lexpr1 :: { Acsl.AcslGrammar.Abs.Lexpr }
Lexpr1
  : Lexpr2 { $1 }
  | Lexpr3 ListLexprRelInner Relation Lexpr2 { Acsl.AcslGrammar.Abs.RelationLexpr $1 $2 $3 $4 }

LexprRelInner :: { Acsl.AcslGrammar.Abs.LexprRelInner }
LexprRelInner
  : Relation Lexpr3 { Acsl.AcslGrammar.Abs.RelInnerLexpr $1 $2 }

ListLexprRelInner :: { [Acsl.AcslGrammar.Abs.LexprRelInner] }
ListLexprRelInner
  : {- empty -} { [] }
  | LexprRelInner ListLexprRelInner { (:) $1 $2 }

Relation :: { Acsl.AcslGrammar.Abs.Relation }
Relation
  : '<' { Acsl.AcslGrammar.Abs.LessRel }
  | '>' { Acsl.AcslGrammar.Abs.GreaterRel }
  | '<=' { Acsl.AcslGrammar.Abs.LessEqRel }
  | '>=' { Acsl.AcslGrammar.Abs.GreaterEqRel }
  | '==' { Acsl.AcslGrammar.Abs.EqRel }
  | '!=' { Acsl.AcslGrammar.Abs.NotEqRel }

Lexpr2 :: { Acsl.AcslGrammar.Abs.Lexpr }
Lexpr2
  : Lexpr3 { $1 }
  | LexprBinder { Acsl.AcslGrammar.Abs.BinderLexpr $1 }
  | '!' LexprBinder { Acsl.AcslGrammar.Abs.NotBinderLexpr $2 }

LexprBinder :: { Acsl.AcslGrammar.Abs.LexprBinder }
LexprBinder
  : '\\forall' Binders ';' Lexpr { Acsl.AcslGrammar.Abs.ForallBinderLexpr $2 $4 }
  | '\\exists' Binders ';' Lexpr { Acsl.AcslGrammar.Abs.ExistBinderLexpr $2 $4 }
  | '\\lambda' Binders ';' Lexpr { Acsl.AcslGrammar.Abs.LambdaBinderLexpr $2 $4 }

Binders :: { Acsl.AcslGrammar.Abs.Binders }
Binders
  : TypeSpecOFTYPENAME VarSpec ListBindersReentrance { Acsl.AcslGrammar.Abs.TheBinders $1 $2 $3 }

TypeSpecOFTYPENAME :: { Acsl.AcslGrammar.Abs.TypeSpecOFTYPENAME }
TypeSpecOFTYPENAME
  : Ident { Acsl.AcslGrammar.Abs.TypeSpecTYPENAME $1 }
  | TypeSpecSimple { Acsl.AcslGrammar.Abs.TypeSpecSimpleFromTypenameTypeSpec $1 }

BindersReentrance :: { Acsl.AcslGrammar.Abs.BindersReentrance }
BindersReentrance
  : ',' TypeSpecOFTYPENAME VarSpec { Acsl.AcslGrammar.Abs.BindersReentranceDeclSpec $2 $3 }
  | ',' VarSpec { Acsl.AcslGrammar.Abs.BindersReentranceVarSpec $2 }

ListBindersReentrance :: { [Acsl.AcslGrammar.Abs.BindersReentrance] }
ListBindersReentrance
  : {- empty -} { [] }
  | BindersReentrance ListBindersReentrance { (:) $1 $2 }

VarSpec :: { Acsl.AcslGrammar.Abs.VarSpec }
VarSpec
  : VarSpec1 { $1 }
  | ListStars VarSpec1 { Acsl.AcslGrammar.Abs.StartVarSpec $1 $2 }

Stars :: { Acsl.AcslGrammar.Abs.Stars }
Stars : '*' { Acsl.AcslGrammar.Abs.Star }

ListStars :: { [Acsl.AcslGrammar.Abs.Stars] }
ListStars : Stars { (:[]) $1 } | Stars ListStars { (:) $1 $2 }

VarSpec1 :: { Acsl.AcslGrammar.Abs.VarSpec }
VarSpec1
  : FullIdentifier { Acsl.AcslGrammar.Abs.SimpleSpec $1 }
  | VarSpec1 '[' ArraySize ']' { Acsl.AcslGrammar.Abs.ArraySpec $1 $3 }
  | '(' VarSpec ')' { $2 }

ArraySize :: { Acsl.AcslGrammar.Abs.ArraySize }
ArraySize
  : Integer { Acsl.AcslGrammar.Abs.IntConstArraySize $1 }
  | FullIdentifier { Acsl.AcslGrammar.Abs.SomeArraySize $1 }
  | {- empty -} { Acsl.AcslGrammar.Abs.NoSize }

Lexpr3 :: { Acsl.AcslGrammar.Abs.Lexpr }
Lexpr3
  : '\\true' { Acsl.AcslGrammar.Abs.TrueLexpr }
  | '\\false' { Acsl.AcslGrammar.Abs.FalseLexpr }
  | '\\object_pointer' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.PointerLexpr $2 $4 }
  | '\\valid' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.ValidLexpr $2 $4 }
  | '\\valid_read' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.ValidReadLexpr $2 $4 }
  | '\\valid_function' '(' Lexpr ')' { Acsl.AcslGrammar.Abs.ValidFuncLexpr $3 }
  | '\\valid_index' OptLabel1 '(' Lexpr ',' Lexpr ')' { Acsl.AcslGrammar.Abs.ValidIndxLexpr $2 $4 $6 }
  | '\\valid_range' OptLabel1 '(' Lexpr ',' Lexpr ',' Lexpr ')' { Acsl.AcslGrammar.Abs.ValidRangeLexpr $2 $4 $6 $8 }
  | '\\initialized' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.InitializedLexpr $2 $4 }
  | '\\dangling' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.DanglingLexpr $2 $4 }
  | '\\fresh' OptLabel2 '(' Lexpr ',' Lexpr ')' { Acsl.AcslGrammar.Abs.FreshLexpr $2 $4 $6 }
  | '\\base_addr' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.BaseAddrLexpr $2 $4 }
  | '\\block_length' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.BlockLengthLexpr $2 $4 }
  | '\\offset' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.OffsetLexpr $2 $4 }
  | '\\allocable' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.AllocableLexpr $2 $4 }
  | '\\freeable' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.FreeableLexpr $2 $4 }
  | '\\allocation' OptLabel1 '(' Lexpr ')' { Acsl.AcslGrammar.Abs.AllocationLexpr $2 $4 }
  | '\\automatic' { Acsl.AcslGrammar.Abs.AutomaticLexpr }
  | '\\dynamic' { Acsl.AcslGrammar.Abs.DynamicLexpr }
  | '\\register' { Acsl.AcslGrammar.Abs.RegisterLexpr }
  | '\\static' { Acsl.AcslGrammar.Abs.StaticLexpr }
  | '\\unallocated' { Acsl.AcslGrammar.Abs.UnallocatedLexpr }
  | '\\null' { Acsl.AcslGrammar.Abs.NullLexpr }
  | Integer { Acsl.AcslGrammar.Abs.LexprIntConst $1 }
  | Double { Acsl.AcslGrammar.Abs.LexprFloatConst $1 }
  | String { Acsl.AcslGrammar.Abs.LexprStringConst $1 }
  | Lexpr3 '+' Lexpr3 { Acsl.AcslGrammar.Abs.AddLexpr $1 $3 }
  | Lexpr3 '-' Lexpr3 { Acsl.AcslGrammar.Abs.SubtrLexpr $1 $3 }
  | Lexpr3 '*' Lexpr3 { Acsl.AcslGrammar.Abs.MultLexpr $1 $3 }
  | Lexpr3 '/' Lexpr3 { Acsl.AcslGrammar.Abs.DivLexpr $1 $3 }
  | Lexpr3 '%' Lexpr3 { Acsl.AcslGrammar.Abs.ModLexpr $1 $3 }
  | Lexpr3 '[' Range ']' { Acsl.AcslGrammar.Abs.SquaresRangeLexpr $1 $3 }
  | Lexpr3 '[' Lexpr ']' { Acsl.AcslGrammar.Abs.SquaresLexpr $1 $3 }
  | '-' Lexpr3 { Acsl.AcslGrammar.Abs.MinusLexpr $2 }
  | '+' Lexpr3 { Acsl.AcslGrammar.Abs.PlusLexpr $2 }
  | '~' Lexpr3 { Acsl.AcslGrammar.Abs.TildeLexpr $2 }
  | '*' Lexpr3 { Acsl.AcslGrammar.Abs.StarLexpr $2 }
  | '&' Lexpr3 { Acsl.AcslGrammar.Abs.AmpUnaryLexpr $2 }
  | 'sizeof' '(' Lexpr ')' { Acsl.AcslGrammar.Abs.SizeOfLexpr $3 }
  | '\\old' '(' Lexpr ')' { Acsl.AcslGrammar.Abs.OldLexpr $3 }
  | '\\at' '(' Lexpr ',' LabelName ')' { Acsl.AcslGrammar.Abs.AtLexpr $3 $5 }
  | '\\result' { Acsl.AcslGrammar.Abs.ResultLexpr }
  | '\\separated' '(' ListLexpr ')' { Acsl.AcslGrammar.Abs.SeparatedLexpr $3 }
  | FullIdentifier '(' ListLexpr ')' { Acsl.AcslGrammar.Abs.FullIdParenLexpr $1 $3 }
  | FullIdentifier { Acsl.AcslGrammar.Abs.FullId $1 }
  | '\\pi' { Acsl.AcslGrammar.Abs.PiLexpr }
  | '(' Lexpr ')' { $2 }
  | '(' Range ')' { Acsl.AcslGrammar.Abs.ParenRangeLexpr $2 }

OptLabel1 :: { Acsl.AcslGrammar.Abs.OptLabel }
OptLabel1 : OptLabelList { Acsl.AcslGrammar.Abs.OptLabelOne $1 }

OptLabel2 :: { Acsl.AcslGrammar.Abs.OptLabel }
OptLabel2 : OptLabelList { Acsl.AcslGrammar.Abs.OptLabelTwo $1 }

OptLabelList :: { Acsl.AcslGrammar.Abs.OptLabelList }
OptLabelList
  : {- empty -} { Acsl.AcslGrammar.Abs.NoLableList }
  | '{' ListLabelName '}' { Acsl.AcslGrammar.Abs.LableList $2 }

LabelName :: { Acsl.AcslGrammar.Abs.LabelName }
LabelName : AnyIdentifier { Acsl.AcslGrammar.Abs.LableName $1 }

ListLabelName :: { [Acsl.AcslGrammar.Abs.LabelName] }
ListLabelName
  : LabelName { (:[]) $1 }
  | LabelName ',' ListLabelName { (:) $1 $3 }

Range :: { Acsl.AcslGrammar.Abs.Range }
Range
  : LexprOption '..' LexprOption { Acsl.AcslGrammar.Abs.LexprRange $1 $3 }

LexprOption :: { Acsl.AcslGrammar.Abs.LexprOption }
LexprOption
  : {- empty -} { Acsl.AcslGrammar.Abs.NoLexprOption }
  | Lexpr { Acsl.AcslGrammar.Abs.SomeLexprOption $1 }

AnyIdentifier :: { Acsl.AcslGrammar.Abs.AnyIdentifier }
AnyIdentifier
  : Identifier { Acsl.AcslGrammar.Abs.SimpleIdentifierAny $1 }

PostCond :: { Acsl.AcslGrammar.Abs.PostCond }
PostCond
  : 'ensures' { Acsl.AcslGrammar.Abs.EnsuresKeyWord }
  | 'exits' { Acsl.AcslGrammar.Abs.ExitsKeyWord }
  | 'breaks' { Acsl.AcslGrammar.Abs.BreaksKeyWord }
  | 'continues' { Acsl.AcslGrammar.Abs.ContinuesKeyWord }
  | 'returns' { Acsl.AcslGrammar.Abs.ReturnsKeyWord }
  | 'check' 'ensures' { Acsl.AcslGrammar.Abs.CheckEnsuresKeyWord }
  | 'check' 'exits' { Acsl.AcslGrammar.Abs.CheckExitsKeyWord }
  | 'check' 'breaks' { Acsl.AcslGrammar.Abs.CheckBreaksKeyWord }
  | 'check' 'continues' { Acsl.AcslGrammar.Abs.CheckContinuesKeyWord }
  | 'check' 'returns' { Acsl.AcslGrammar.Abs.CheckReturnsKeyWord }
  | 'admit' 'ensures' { Acsl.AcslGrammar.Abs.AdmitEnsuresKeyWord }
  | 'admit' 'exits' { Acsl.AcslGrammar.Abs.AdmitExitsKeyWord }
  | 'admit' 'breaks' { Acsl.AcslGrammar.Abs.AdmitBreaksKeyWord }
  | 'admit' 'continues' { Acsl.AcslGrammar.Abs.AdmitContinuesKeyWord }
  | 'admit' 'returns' { Acsl.AcslGrammar.Abs.AdmitReturnsKeyWord }

FullIdentifier :: { Acsl.AcslGrammar.Abs.FullIdentifier }
FullIdentifier
  : Identifier { Acsl.AcslGrammar.Abs.SimpleIdentifierFull $1 }
  | 'admit' { Acsl.AcslGrammar.Abs.AdmitKeyWordFullIdent }
  | 'allocates' { Acsl.AcslGrammar.Abs.AllocatesKeyWordFullIdent }
  | 'assert' { Acsl.AcslGrammar.Abs.AssertKeyWordFullIdent }
  | 'assigns' { Acsl.AcslGrammar.Abs.AssignsKeyWordFullIdent }
  | 'assumes' { Acsl.AcslGrammar.Abs.AssumesKeyWordFullIdent }
  | 'at' { Acsl.AcslGrammar.Abs.AtKeyWordFullIdent }
  | 'axiom' { Acsl.AcslGrammar.Abs.AxiomKeyWordFullIdent }
  | 'axiomatic' { Acsl.AcslGrammar.Abs.AxiomaticKeyWordFullIdent }
  | 'behavior' { Acsl.AcslGrammar.Abs.BehaviorKeyWordFullIdent }
  | 'breaks' { Acsl.AcslGrammar.Abs.BreaksKeyWordFullIdent }
  | 'check' { Acsl.AcslGrammar.Abs.CheckKeyWordFullIdent }
  | 'complete' { Acsl.AcslGrammar.Abs.CompleteKeyWordFullIdent }
  | 'continues' { Acsl.AcslGrammar.Abs.ContinuesKeyWordFullIdent }
  | 'contract' { Acsl.AcslGrammar.Abs.ContractKeyWordFullIdent }
  | 'decreases' { Acsl.AcslGrammar.Abs.DecreasesKeyWordFullIdent }
  | 'disjoint' { Acsl.AcslGrammar.Abs.DisjointKeyWordFullIdent }
  | 'ensures' { Acsl.AcslGrammar.Abs.EnsuresKeyWordFullIdent }
  | 'exits' { Acsl.AcslGrammar.Abs.ExitsKeyWordFullIdent }
  | 'frees' { Acsl.AcslGrammar.Abs.FreesKeyWordFullIdent }
  | 'function' { Acsl.AcslGrammar.Abs.FunctionKeyWordFullIdent }
  | 'global' { Acsl.AcslGrammar.Abs.GlobalKeyWordFullIdent }
  | 'impact' { Acsl.AcslGrammar.Abs.ImpactKeyWordFullIdent }
  | 'inductive' { Acsl.AcslGrammar.Abs.InductiveKeyWordFullIdent }
  | 'include' { Acsl.AcslGrammar.Abs.IncludeKeyWordFullIdent }
  | 'invariant' { Acsl.AcslGrammar.Abs.InvariantKeyWordFullIdent }
  | 'lemma' { Acsl.AcslGrammar.Abs.LemmaKeyWordFullIdent }
  | 'let' { Acsl.AcslGrammar.Abs.LetKeyWordFullIdent }
  | 'logic' { Acsl.AcslGrammar.Abs.LogicKeyWordFullIdent }
  | 'loop' { Acsl.AcslGrammar.Abs.LoopKeyWordFullIdent }
  | 'model' { Acsl.AcslGrammar.Abs.ModelKeyWordFullIdent }
  | 'module' { Acsl.AcslGrammar.Abs.ModuleKeyWordFullIdent }
  | 'pragma' { Acsl.AcslGrammar.Abs.PragmaKeyWordFullIdent }
  | 'predicate' { Acsl.AcslGrammar.Abs.PredicateKeyWordFullIdent }
  | 'requires' { Acsl.AcslGrammar.Abs.RequiresKeyWordFullIdent }
  | 'returns' { Acsl.AcslGrammar.Abs.ReturnsKeyWordFullIdent }
  | 'slice' { Acsl.AcslGrammar.Abs.SliceKeyWordFullIdent }
  | 'terminates' { Acsl.AcslGrammar.Abs.TerminatesKeyWordFullIdent }
  | 'type' { Acsl.AcslGrammar.Abs.TypeKeyWordFullIdent }
  | 'variant' { Acsl.AcslGrammar.Abs.VariantKeyWordFullIdent }

ListFullIdentifier :: { [Acsl.AcslGrammar.Abs.FullIdentifier] }
ListFullIdentifier
  : FullIdentifier { (:[]) $1 }
  | FullIdentifier ',' ListFullIdentifier { (:) $1 $3 }

Identifier :: { Acsl.AcslGrammar.Abs.Identifier }
Identifier
  : Ident { Acsl.AcslGrammar.Abs.IdentifierIdent $1 }
  | 'behaviors' { Acsl.AcslGrammar.Abs.BehaviorsKeyWord }
  | 'label' { Acsl.AcslGrammar.Abs.LabelKeyWord }
  | 'reads' { Acsl.AcslGrammar.Abs.ReadsKeyWord }
  | 'writes' { Acsl.AcslGrammar.Abs.WritesKeyWord }

TypeSpecSimple :: { Acsl.AcslGrammar.Abs.TypeSpecSimple }
TypeSpecSimple
  : 'integer' { Acsl.AcslGrammar.Abs.TypeSpecSimpleIntegerKeyWord }
  | 'real' { Acsl.AcslGrammar.Abs.TypeSpecSimpleRealKeyWord }
  | 'boolean' { Acsl.AcslGrammar.Abs.TypeSpecSimpleBooleanKeyWord }
  | 'void' { Acsl.AcslGrammar.Abs.TypeSpecSimpleVoidKeyWord }
  | '_Bool' { Acsl.AcslGrammar.Abs.TypeSpecSimpleBoolKeyWord }
  | 'char' { Acsl.AcslGrammar.Abs.TypeSpecSimpleCharKeyWord }
  | 'signed' 'char' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedCharKeyWord }
  | 'unsigned' 'char' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedCharKeyWord }
  | 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleIntKeyWord }
  | 'signed' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedIntKeyWord }
  | 'unsigned' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedIntKeyWord }
  | 'unsigned' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedKeyWord }
  | 'short' { Acsl.AcslGrammar.Abs.TypeSpecSimpleShortKeyWord }
  | 'signed' 'short' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedShortKeyWord }
  | 'unsigned' 'short' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedShortKeyWord }
  | 'short' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleShortIntKeyWord }
  | 'signed' 'short' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedShortIntKeyWord }
  | 'unsigned' 'short' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedShortIntKeyWord }
  | 'long' { Acsl.AcslGrammar.Abs.TypeSpecSimpleLongKeyWord }
  | 'signed' 'long' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongKeyWord }
  | 'unsigned' 'long' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongKeyWord }
  | 'signed' 'long' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongIntKeyWord }
  | 'long' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleLongIntKeyWord }
  | 'unsigned' 'long' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongIntKeyWord }
  | 'long' 'long' { Acsl.AcslGrammar.Abs.TypeSpecSimpleLongLongKeyWord }
  | 'signed' 'long' 'long' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongLongKeyWord }
  | 'unsigned' 'long' 'long' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongLongKeyWord }
  | 'long' 'long' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleLongLongIntKeyWord }
  | 'signed' 'long' 'long' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleSignedLongLongIntKeyWord }
  | 'unsigned' 'long' 'long' 'int' { Acsl.AcslGrammar.Abs.TypeSpecSimpleUnsignedLongLongIntKeyWord }
  | 'float' { Acsl.AcslGrammar.Abs.TypeSpecSimpleFloatKeyWord }
  | 'double' { Acsl.AcslGrammar.Abs.TypeSpecSimpleDoubleKeyWord }
  | 'long' 'double' { Acsl.AcslGrammar.Abs.TypeSpecSimpleLongDoubleKeyWord }

LogicPTreeAnnot :: { Acsl.AcslGrammar.Abs.LogicPTreeAnnot }
LogicPTreeAnnot
  : Annotation { Acsl.AcslGrammar.Abs.AnAnnotation $1 }

Annotation :: { Acsl.AcslGrammar.Abs.Annotation }
Annotation
  : LoopAnnotStack { Acsl.AcslGrammar.Abs.LoopAnnotation $1 }

LoopAnnotStack :: { Acsl.AcslGrammar.Abs.LoopAnnotStack }
LoopAnnotStack
  : LoopInvariant LoopAnnotOpt { Acsl.AcslGrammar.Abs.LoopAnnotStackInvariant $1 $2 }
  | LoopEffects LoopAnnotOpt { Acsl.AcslGrammar.Abs.LoopAnnotStackEffects $1 $2 }
  | LoopAllocation LoopAnnotOpt { Acsl.AcslGrammar.Abs.LoopAnnotStackAllocation $1 $2 }
  | LoopVariant LoopAnnotOpt { Acsl.AcslGrammar.Abs.LoopAnnotStackVariant $1 $2 }

LoopAnnotOpt :: { Acsl.AcslGrammar.Abs.LoopAnnotOpt }
LoopAnnotOpt
  : {- empty -} { Acsl.AcslGrammar.Abs.NoLoopAnnot }
  | LoopAnnotStack { Acsl.AcslGrammar.Abs.SomeLoopAnnot $1 }

LoopInvariant :: { Acsl.AcslGrammar.Abs.LoopInvariant }
LoopInvariant
  : 'loop' 'invariant' Lexpr ';' { Acsl.AcslGrammar.Abs.SimpleLoopInvariant $3 }
  | 'check' 'loop' 'invariant' Lexpr ';' { Acsl.AcslGrammar.Abs.CheckLoopInvariant $4 }
  | 'admit' 'loop' 'invariant' Lexpr ';' { Acsl.AcslGrammar.Abs.AdmitLoopInvariant $4 }

LoopAllocation :: { Acsl.AcslGrammar.Abs.LoopAllocation }
LoopAllocation
  : 'loop' Allocation ';' { Acsl.AcslGrammar.Abs.SimpleLoopAllocation $2 }

Allocation :: { Acsl.AcslGrammar.Abs.Allocation }
Allocation
  : 'allocates' Zones { Acsl.AcslGrammar.Abs.AllocatesZones $2 }
  | 'frees' Zones { Acsl.AcslGrammar.Abs.FreesZones $2 }

LoopVariant :: { Acsl.AcslGrammar.Abs.LoopVariant }
LoopVariant
  : 'loop' 'variant' Variant ';' { Acsl.AcslGrammar.Abs.SimpleLoopVariant $3 }

LoopEffects :: { Acsl.AcslGrammar.Abs.LoopEffects }
LoopEffects
  : 'loop' 'assigns' Assigns ';' { Acsl.AcslGrammar.Abs.LoopAssigns $3 }

Variant :: { Acsl.AcslGrammar.Abs.Variant }
Variant
  : Lexpr 'for' AnyIdentifier { Acsl.AcslGrammar.Abs.ForVariant $1 $3 }
  | Lexpr { Acsl.AcslGrammar.Abs.LexprVariant $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

