/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"
%name-prefix = "acsl"
  /* From Bison 2.6: %define api.prefix {acsl} */

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the acsllloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE acsl_scan_string(const char *str, yyscan_t scanner);
extern void acsl_delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void acsllex_destroy(yyscan_t scanner);
extern char* acslget_text(yyscan_t scanner);

extern yyscan_t acsl_initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  acsl::Program* program_;
  acsl::Globals* globals_;
  acsl::GhostGlobals* ghostglobals_;
  acsl::Global* global_;
  acsl::IdOrTypenameAsId* idortypenameasid_;
  acsl::IdOrTypename* idortypename_;
  acsl::MaybeComma* maybecomma_;
  acsl::AssignExpr* assignexpr_;
  acsl::OffsetofMemberDesignator* offsetofmemberdesignator_;
  acsl::Expression* expression_;
  acsl::Constant* constant_;
  acsl::StringConstant* stringconstant_;
  acsl::WStringList* wstringlist_;
  acsl::OneString* onestring_;
  acsl::ListOneString* listonestring_;
  acsl::InitExpression* initexpression_;
  acsl::InitializerListOpt* initializerlistopt_;
  acsl::InitializerSingle* initializersingle_;
  acsl::ListInitializerSingle* listinitializersingle_;
  acsl::EqOpt* eqopt_;
  acsl::InitDesignators* initdesignators_;
  acsl::InitDesignatorsOpt* initdesignatorsopt_;
  acsl::GhostArgumentsOpt* ghostargumentsopt_;
  acsl::Arguments* arguments_;
  acsl::OptExpression* optexpression_;
  acsl::ListExpression* listexpression_;
  acsl::CommaExpressionOpt* commaexpressionopt_;
  acsl::Block* block_;
  acsl::BlockAttrs* blockattrs_;
  acsl::BlockElement* blockelement_;
  acsl::ListBlockElement* listblockelement_;
  acsl::Annot* annot_;
  acsl::ListAnnot* listannot_;
  acsl::Code_Annot* code_annot_;
  acsl::LocalLabel* locallabel_;
  acsl::ListLocalLabel* listlocallabel_;
  acsl::LocalLabelName* locallabelname_;
  acsl::ListLocalLabelName* listlocallabelname_;
  acsl::AnnotatedStmt* annotatedstmt_;
  acsl::ElsePart* elsepart_;
  acsl::Statement* statement_;
  acsl::OptLoopAnnotations* optloopannotations_;
  acsl::ForClause* forclause_;
  acsl::GhostParameterOpt* ghostparameteropt_;
  acsl::Declaration* declaration_;
  acsl::GenericAssociation* genericassociation_;
  acsl::ListGenericAssociation* listgenericassociation_;
  acsl::DeclAndInitDeclAttrList* declandinitdeclattrlist_;
  acsl::InitDeclaratorAttr* initdeclaratorattr_;
  acsl::ListInitDeclaratorAttr* listinitdeclaratorattr_;
  acsl::InitDeclarator* initdeclarator_;
  acsl::DeclSpecWOType* declspecwotype_;
  acsl::DeclSpecList* declspeclist_;
  acsl::DeclSpecListNoNamed* declspeclistnonamed_;
  acsl::TypeSpec* typespec_;
  acsl::StructDeclList* structdecllist_;
  acsl::StaticAssertDeclaration* staticassertdeclaration_;
  acsl::FieldDecl* fielddecl_;
  acsl::ListFieldDecl* listfielddecl_;
  acsl::Enumerator* enumerator_;
  acsl::ListEnumerator* listenumerator_;
  acsl::Declarator* declarator_;
  acsl::ListDeclarator* listdeclarator_;
  acsl::AttributesOrStatic* attributesorstatic_;
  acsl::DirectDecl* directdecl_;
  acsl::RestParList* restparlist_;
  acsl::ParameterDecl* parameterdecl_;
  acsl::ListParameterDecl* listparameterdecl_;
  acsl::DirectOldProtoDecl* directoldprotodecl_;
  acsl::ListIdent* listident_;
  acsl::OldPardefList* oldpardeflist_;
  acsl::OldPardef* oldpardef_;
  acsl::ListOldPardef* listoldpardef_;
  acsl::PointerOpt* pointeropt_;
  acsl::TypeName* typename_;
  acsl::AbstractDecl* abstractdecl_;
  acsl::AbsDirectDecl* absdirectdecl_;
  acsl::AbsDirectDeclOpt* absdirectdeclopt_;
  acsl::FunctionDef* functiondef_;
  acsl::FunctionDefStart* functiondefstart_;
  acsl::CVSpec* cvspec_;
  acsl::AttributesWithAsm* attributeswithasm_;
  acsl::AttributeNocv* attributenocv_;
  acsl::ListAttributeNocv* listattributenocv_;
  acsl::Attribute* attribute_;
  acsl::ListAttribute* listattribute_;
  acsl::JustAttribute* justattribute_;
  acsl::ListJustAttribute* listjustattribute_;
  acsl::Pragma* pragma_;
  acsl::VarAttr* varattr_;
  acsl::BasicAttribute* basicattribute_;
  acsl::ListBasicAttribute* listbasicattribute_;
  acsl::ParameterAttrListNE* parameterattrlistne_;
  acsl::ParamAttrListNE* paramattrlistne_;
  acsl::Attr* attr_;
  acsl::ListAttr* listattr_;
  acsl::AttrTest* attrtest_;
  acsl::AttrList* attrlist_;
  acsl::Asmattr* asmattr_;
  acsl::ListAsmattr* listasmattr_;
  acsl::Asmoutputs* asmoutputs_;
  acsl::Asmoperands* asmoperands_;
  acsl::Asmoperand* asmoperand_;
  acsl::ListAsmoperand* listasmoperand_;
  acsl::Asminputs* asminputs_;
  acsl::Asmopname* asmopname_;
  acsl::Asmclobber* asmclobber_;
  acsl::ListStringConstant* liststringconstant_;
  acsl::Asmlabels* asmlabels_;
  acsl::LexprEOF* lexpreof_;
  acsl::LexprList* lexprlist_;
  acsl::ListLexpr* listlexpr_;
  acsl::LexprOption* lexproption_;
  acsl::Lexpr* lexpr_;
  acsl::LexprBinder* lexprbinder_;
  acsl::LexprRelInner* lexprrelinner_;
  acsl::ListLexprRelInner* listlexprrelinner_;
  acsl::Relation* relation_;
  acsl::ListSTRING_LITERAL* liststring_literal_;
  acsl::Range* range_;
  acsl::FieldInitElt* fieldinitelt_;
  acsl::ListFieldInitElt* listfieldinitelt_;
  acsl::ArrayInitElt* arrayinitelt_;
  acsl::ListArrayInitElt* listarrayinitelt_;
  acsl::UpdateElt* updateelt_;
  acsl::ListUpdateElt* listupdateelt_;
  acsl::PathElt* pathelt_;
  acsl::ListPathElt* listpathelt_;
  acsl::Binders* binders_;
  acsl::BindersReentrance* bindersreentrance_;
  acsl::ListBindersReentrance* listbindersreentrance_;
  acsl::VarSpec* varspec_;
  acsl::ArraySize* arraysize_;
  acsl::AbsParamTypeList* absparamtypelist_;
  acsl::AbsParam* absparam_;
  acsl::ListAbsParam* listabsparam_;
  acsl::Parameter* parameter_;
  acsl::ListParameter* listparameter_;
  acsl::LogicTypeGenOFTYPENAME* logictypegenoftypename_;
  acsl::ListLogicTypeGenOFTYPENAME* listlogictypegenoftypename_;
  acsl::LogicTypeGenOFIdentifierOrTypename* logictypegenofidentifierortypename_;
  acsl::ListLogicTypeGenOFIdentifierOrTypename* listlogictypegenofidentifierortypename_;
  acsl::CV* cv_;
  acsl::ListCV* listcv_;
  acsl::TypeSpecCVOFTYPENAME* typespeccvoftypename_;
  acsl::CastLogicType* castlogictype_;
  acsl::LogicRtType* logicrttype_;
  acsl::AbsSpecOption* absspecoption_;
  acsl::AbsSpecCVOption* absspeccvoption_;
  acsl::AbsSpec* absspec_;
  acsl::AbsSpecCV* absspeccv_;
  acsl::Stars* stars_;
  acsl::ListStars* liststars_;
  acsl::StarsCV* starscv_;
  acsl::ListStarsCV* liststarscv_;
  acsl::Tabs* tabs_;
  acsl::ListTabs* listtabs_;
  acsl::TypeSpecSimple* typespecsimple_;
  acsl::TypeSpecOFTYPENAME* typespecoftypename_;
  acsl::TypeSpecOFIdentifierOrTypename* typespecofidentifierortypename_;
  acsl::FullIdentifier* fullidentifier_;
  acsl::ListFullIdentifier* listfullidentifier_;
  acsl::ExtSpec* extspec_;
  acsl::ExtGlobalClausesOpt* extglobalclausesopt_;
  acsl::ExtGlobalClause* extglobalclause_;
  acsl::ListExtGlobalClause* listextglobalclause_;
  acsl::ExtGlobalSpecsOpt* extglobalspecsopt_;
  acsl::ExtGlobalSpec* extglobalspec_;
  acsl::ListExtGlobalSpec* listextglobalspec_;
  acsl::ExtModuleSpecsOpt* extmodulespecsopt_;
  acsl::ExtModuleSpec* extmodulespec_;
  acsl::ListExtModuleSpec* listextmodulespec_;
  acsl::ExtFunctionSpecsOpt* extfunctionspecsopt_;
  acsl::ExtFunctionSpecs* extfunctionspecs_;
  acsl::ExtFunctionSpec* extfunctionspec_;
  acsl::ListExtFunctionSpec* listextfunctionspec_;
  acsl::ExtFunSpec* extfunspec_;
  acsl::ListExtFunSpec* listextfunspec_;
  acsl::ExtIdentifierOpt* extidentifieropt_;
  acsl::StmtMarkup* stmtmarkup_;
  acsl::ListStmtMarkup* liststmtmarkup_;
  acsl::Spec* spec_;
  acsl::Contract* contract_;
  acsl::ClauseKW* clausekw_;
  acsl::Requires* requires_;
  acsl::NERequires* nerequires_;
  acsl::Terminates* terminates_;
  acsl::NETerminates* neterminates_;
  acsl::Decreases* decreases_;
  acsl::NEDecreases* nedecreases_;
  acsl::Variant* variant_;
  acsl::SimpleClauses* simpleclauses_;
  acsl::Allocation* allocation_;
  acsl::NESimpleClauses* nesimpleclauses_;
  acsl::ExtensionContent* extensioncontent_;
  acsl::Behaviors* behaviors_;
  acsl::NEBehaviors* nebehaviors_;
  acsl::BehaviorBody* behaviorbody_;
  acsl::Assumes* assumes_;
  acsl::CompleteOrDisjoint* completeordisjoint_;
  acsl::NECompleteOrDisjoint* necompleteordisjoint_;
  acsl::Assigns* assigns_;
  acsl::Zones* zones_;
  acsl::LogicPTreeAnnot* logicptreeannot_;
  acsl::ListLogicPTreeAnnot* listlogicptreeannot_;
  acsl::Annotation* annotation_;
  acsl::LoopAnnotStack* loopannotstack_;
  acsl::LoopAnnotOpt* loopannotopt_;
  acsl::LoopEffects* loopeffects_;
  acsl::LoopAllocation* loopallocation_;
  acsl::LoopInvariant* loopinvariant_;
  acsl::LoopVariant* loopvariant_;
  acsl::LoopGrammarExtension* loopgrammarextension_;
  acsl::LoopPragma* looppragma_;
  acsl::BegPragmaOrCodeAnnotation* begpragmaorcodeannotation_;
  acsl::PragmaOrCodeAnnotation* pragmaorcodeannotation_;
  acsl::CodeAnnotation* codeannotation_;
  acsl::SlicePragma* slicepragma_;
  acsl::ImpactPragma* impactpragma_;
  acsl::Decl* decl_;
  acsl::ListDecl* listdecl_;
  acsl::ExtDecl* extdecl_;
  acsl::ListExtDecl* listextdecl_;
  acsl::VolatileOpt* volatileopt_;
  acsl::ListVolatileOpt* listvolatileopt_;
  acsl::TypeAnnot* typeannot_;
  acsl::OptSemicolon* optsemicolon_;
  acsl::ModelAnnot* modelannot_;
  acsl::PolyIdType* polyidtype_;
  acsl::PolyId* polyid_;
  acsl::OptParameters* optparameters_;
  acsl::Parameters* parameters_;
  acsl::LogicDef* logicdef_;
  acsl::DeprecatedLogicDecl* deprecatedlogicdecl_;
  acsl::LogicDecl* logicdecl_;
  acsl::ListLogicDecl* listlogicdecl_;
  acsl::ReadsClause* readsclause_;
  acsl::Typedef* typedef_;
  acsl::DataconsWithSeparator* dataconswithseparator_;
  acsl::ListDataconsWithSeparator* listdataconswithseparator_;
  acsl::Datacons* datacons_;
  acsl::Indcase* indcase_;
  acsl::ListIndcase* listindcase_;
  acsl::OptLabel* optlabel_;
  acsl::OptLabelList* optlabellist_;
  acsl::LabelName* labelname_;
  acsl::ListLabelName* listlabelname_;
  acsl::BehaviorNameList* behaviornamelist_;
  acsl::BehaviorName* behaviorname_;
  acsl::ListBehaviorName* listbehaviorname_;
  acsl::AnyIdentifier* anyidentifier_;
  acsl::IdentifierOrTypename* identifierortypename_;
  acsl::IdentifierOrTypenameFull* identifierortypenamefull_;
  acsl::ListIdentifierOrTypenameFull* listidentifierortypenamefull_;
  acsl::Identifier* identifier_;
  acsl::BoundedVar* boundedvar_;
  acsl::CKeyword* ckeyword_;
  acsl::ACSLCKeyword* acslckeyword_;
  acsl::PostCond* postcond_;
  acsl::IsACSLSpec* isacslspec_;
  acsl::IsACSLDeclOrCodeAnnot* isacsldeclorcodeannot_;
  acsl::IsACSLTypename* isacsltypename_;
  acsl::IsExtSpec* isextspec_;
  acsl::Keyword* keyword_;
  acsl::BSKeyword* bskeyword_;
  acsl::Wildcard* wildcard_;
  acsl::ListWildcard* listwildcard_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, acslget_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG               /* ! */
%token          _BANGEQ             /* != */
%token          _DOLLAR             /* $ */
%token          _PERCENT            /* % */
%token          _PERCENTEQ          /* %= */
%token          _AMP                /* & */
%token          _DAMP               /* && */
%token          _AMPEQ              /* &= */
%token          _LPAREN             /* ( */
%token          _RPAREN             /* ) */
%token          _STAR               /* * */
%token          _STAREQ             /* *= */
%token          _SYMB_93            /* *^ */
%token          _PLUS               /* + */
%token          _DPLUS              /* ++ */
%token          _PLUSEQ             /* += */
%token          _COMMA              /* , */
%token          _MINUS              /* - */
%token          _DMINUS             /* -- */
%token          _SYMB_63            /* --> */
%token          _MINUSEQ            /* -= */
%token          _RARROW             /* -> */
%token          _DOT                /* . */
%token          _DDOT               /* .. */
%token          _ELLIPSIS           /* ... */
%token          _SLASH              /* / */
%token          _SLASHEQ            /* /= */
%token          _COLON              /* : */
%token          _DCOLON             /* :: */
%token          _SEMI               /* ; */
%token          _LT                 /* < */
%token          _SYMB_64            /* <--> */
%token          _DLT                /* << */
%token          _DLTEQ              /* <<= */
%token          _LDARROW            /* <= */
%token          _SYMB_61            /* <==> */
%token          _EQ                 /* = */
%token          _DEQ                /* == */
%token          _SYMB_60            /* ==> */
%token          _GT                 /* > */
%token          _GTEQ               /* >= */
%token          _DGT                /* >> */
%token          _DGTEQ              /* >>= */
%token          _QUESTION           /* ? */
%token          _KW_Assigns         /* Assigns */
%token          _KW_Assumes         /* Assumes */
%token          _KW_Behaviors       /* Behaviors */
%token          _KW_Contract        /* Contract */
%token          _KW_Decreases       /* Decreases */
%token          _KW_Requires        /* Requires */
%token          _KW_Terminates      /* Terminates */
%token          _KW_Variant         /* Variant */
%token          _LBRACK             /* [ */
%token          _SYMB_96            /* [| */
%token          _SYMB_86            /* \\Allocation */
%token          _SYMB_84            /* \\allocable */
%token          _SYMB_99            /* \\at */
%token          _SYMB_87            /* \\automatic */
%token          _SYMB_81            /* \\base_addr */
%token          _SYMB_82            /* \\block_length */
%token          _SYMB_79            /* \\dangling */
%token          _SYMB_88            /* \\dynamic */
%token          _SYMB_107           /* \\empty */
%token          _SYMB_68            /* \\exists */
%token          _SYMB_71            /* \\false */
%token          _SYMB_67            /* \\forall */
%token          _SYMB_85            /* \\freeable */
%token          _SYMB_80            /* \\fresh */
%token          _SYMB_112           /* \\from */
%token          _SYMB_56            /* \\ghost */
%token          _SYMB_65            /* \\in */
%token          _SYMB_78            /* \\initialized */
%token          _SYMB_109           /* \\inter */
%token          _SYMB_69            /* \\lambda */
%token          _SYMB_66            /* \\let */
%token          _SYMB_113           /* \\nothing */
%token          _SYMB_92            /* \\null */
%token          _SYMB_72            /* \\object_pointer */
%token          _SYMB_83            /* \\offset */
%token          _SYMB_98            /* \\old */
%token          _SYMB_104           /* \\pi */
%token          _SYMB_89            /* \\register */
%token          _SYMB_100           /* \\result */
%token          _SYMB_101           /* \\separated */
%token          _SYMB_90            /* \\static */
%token          _SYMB_70            /* \\true */
%token          _SYMB_106           /* \\type */
%token          _SYMB_105           /* \\typeof */
%token          _SYMB_91            /* \\unallocated */
%token          _SYMB_108           /* \\union */
%token          _SYMB_73            /* \\valid */
%token          _SYMB_75            /* \\valid_function */
%token          _SYMB_76            /* \\valid_index */
%token          _SYMB_77            /* \\valid_range */
%token          _SYMB_74            /* \\valid_read */
%token          _SYMB_110           /* \\with */
%token          _RBRACK             /* ] */
%token          _CARET              /* ^ */
%token          _CARETEQ            /* ^= */
%token          _DCARET             /* ^^ */
%token          _SYMB_53            /* _Bool */
%token          _SYMB_4             /* _Generic */
%token          _SYMB_52            /* _Noreturn */
%token          _SYMB_51            /* _Static_assert */
%token          _SYMB_59            /* _Thread_local */
%token          _SYMB_45            /* __PRETTY_FUNCTION__ */
%token          _SYMB_7             /* __builtin_offsetof */
%token          _SYMB_6             /* __builtin_types_compatible_p */
%token          _SYMB_5             /* __builtin_va_arg */
%token          _SYMB_57            /* __declspec */
%token          _SYMB_49            /* __except */
%token          _SYMB_50            /* __finally */
%token          _SYMB_54            /* __int32 */
%token          _SYMB_55            /* __int64 */
%token          _SYMB_47            /* __label__ */
%token          _SYMB_58            /* __thread */
%token          _SYMB_48            /* __try */
%token          _KW_admit           /* admit */
%token          _KW_allocates       /* allocates */
%token          _KW_assert          /* assert */
%token          _KW_at              /* at */
%token          _KW_auto            /* auto */
%token          _KW_axiom           /* axiom */
%token          _KW_axiomatic       /* axiomatic */
%token          _KW_behavior        /* behavior */
%token          _KW_boolean         /* boolean */
%token          _KW_break           /* break */
%token          _KW_breaks          /* breaks */
%token          _KW_case            /* case */
%token          _KW_char            /* char */
%token          _KW_check           /* check */
%token          _KW_complete        /* complete */
%token          _KW_const           /* const */
%token          _KW_continue        /* continue */
%token          _KW_continues       /* continues */
%token          _KW_default         /* default */
%token          _KW_disjoint        /* disjoint */
%token          _KW_do              /* do */
%token          _KW_double          /* double */
%token          _KW_else            /* else */
%token          _KW_ensures         /* ensures */
%token          _KW_enum            /* enum */
%token          _KW_exits           /* exits */
%token          _KW_extern          /* extern */
%token          _KW_float           /* float */
%token          _KW_for             /* for */
%token          _KW_frees           /* frees */
%token          _KW_function        /* function */
%token          _KW_ghost           /* ghost */
%token          _KW_global          /* global */
%token          _KW_goto            /* goto */
%token          _KW_if              /* if */
%token          _KW_impact          /* impact */
%token          _KW_include         /* include */
%token          _KW_inductive       /* inductive */
%token          _KW_int             /* int */
%token          _KW_integer         /* integer */
%token          _KW_invariant       /* invariant */
%token          _KW_label           /* label */
%token          _KW_lemma           /* lemma */
%token          _KW_let             /* let */
%token          _KW_logic           /* logic */
%token          _KW_long            /* long */
%token          _KW_loop            /* loop */
%token          _KW_model           /* model */
%token          _KW_module          /* module */
%token          _KW_pragma          /* pragma */
%token          _KW_predicate       /* predicate */
%token          _KW_reads           /* reads */
%token          _KW_real            /* real */
%token          _KW_register        /* register */
%token          _KW_requires        /* requires */
%token          _KW_return          /* return */
%token          _KW_returns         /* returns */
%token          _KW_short           /* short */
%token          _KW_signed          /* signed */
%token          _KW_sizeof          /* sizeof */
%token          _KW_slice           /* slice */
%token          _KW_static          /* static */
%token          _KW_struct          /* struct */
%token          _KW_switch          /* switch */
%token          _KW_type            /* type */
%token          _KW_typedef         /* typedef */
%token          _KW_union           /* union */
%token          _KW_unsigned        /* unsigned */
%token          _KW_void            /* void */
%token          _KW_volatile        /* volatile */
%token          _KW_while           /* while */
%token          _KW_writes          /* writes */
%token          _LBRACE             /* { */
%token          _BAR                /* | */
%token          _BAREQ              /* |= */
%token          _SYMB_97            /* |] */
%token          _DBAR               /* || */
%token          _RBRACE             /* } */
%token          _TILDE              /* ~ */
%token<_string> T_ALIGNOF           /* ALIGNOF */
%token<_string> T_ASM               /* ASM */
%token<_string> T_ATTRIBUTE         /* ATTRIBUTE */
%token<_string> T_BLOCKATTRIBUTE    /* BLOCKATTRIBUTE */
%token<_string> T_CONST             /* CONST */
%token<_string> T_CST_WCHAR         /* CST_WCHAR */
%token<_string> T_CST_WSTRING       /* CST_WSTRING */
%token<_string> T_EXT_CODE_ANNOT    /* EXT_CODE_ANNOT */
%token<_string> T_EXT_CONTRACT      /* EXT_CONTRACT */
%token<_string> T_EXT_GLOBAL        /* EXT_GLOBAL */
%token<_string> T_EXT_GLOBAL_BLOCK  /* EXT_GLOBAL_BLOCK */
%token<_string> T_FUNCTION__        /* FUNCTION__ */
%token<_string> T_INLINE            /* INLINE */
%token<_string> T_LBRACE            /* LBRACE */
%token<_string> T_LBRACKET          /* LBRACKET */
%token<_string> T_MSATTR            /* MSATTR */
%token<_string> T_NAMEDTYPE         /* NAMEDTYPE */
%token<_string> T_RBRACE            /* RBRACE */
%token<_string> T_RBRACKET          /* RBRACKET */
%token<_string> T_RESTRICT          /* RESTRICT */
%token<_string> T_RGHOST            /* RGHOST */
%token<_string> T_SIGNED            /* SIGNED */
%token<_string> T_STRING_LITERAL    /* STRING_LITERAL */
%token<_string> T_TYPENAME          /* TYPENAME */
%token<_string> T_TYPEOF            /* TYPEOF */
%token<_string> T_VOLATILE          /* VOLATILE */
%token<_string> T_WSTRING_CONSTANT  /* WSTRING_CONSTANT */
%token<_string> _STRING_
%token<_char>   _CHAR_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <program_> Program
%type <globals_> Globals
%type <ghostglobals_> GhostGlobals
%type <global_> Global
%type <idortypenameasid_> IdOrTypenameAsId
%type <idortypename_> IdOrTypename
%type <maybecomma_> MaybeComma
%type <assignexpr_> AssignExpr15
%type <assignexpr_> AssignExpr14
%type <offsetofmemberdesignator_> OffsetofMemberDesignator
%type <assignexpr_> AssignExpr13
%type <assignexpr_> AssignExpr12
%type <assignexpr_> AssignExpr11
%type <assignexpr_> AssignExpr10
%type <assignexpr_> AssignExpr9
%type <assignexpr_> AssignExpr8
%type <assignexpr_> AssignExpr7
%type <assignexpr_> AssignExpr6
%type <assignexpr_> AssignExpr5
%type <assignexpr_> AssignExpr4
%type <assignexpr_> AssignExpr3
%type <assignexpr_> AssignExpr2
%type <assignexpr_> AssignExpr1
%type <assignexpr_> AssignExpr
%type <expression_> Expression
%type <constant_> Constant
%type <stringconstant_> StringConstant
%type <wstringlist_> WStringList
%type <onestring_> OneString
%type <listonestring_> ListOneString
%type <initexpression_> InitExpression
%type <initializerlistopt_> InitializerListOpt
%type <initializersingle_> InitializerSingle
%type <listinitializersingle_> ListInitializerSingle
%type <eqopt_> EqOpt
%type <initdesignators_> InitDesignators
%type <initdesignatorsopt_> InitDesignatorsOpt
%type <ghostargumentsopt_> GhostArgumentsOpt
%type <arguments_> Arguments
%type <optexpression_> OptExpression
%type <listexpression_> ListExpression
%type <commaexpressionopt_> CommaExpressionOpt
%type <block_> Block
%type <blockattrs_> BlockAttrs
%type <blockelement_> BlockElement
%type <listblockelement_> ListBlockElement
%type <annot_> Annot
%type <listannot_> ListAnnot
%type <code_annot_> Code_Annot
%type <locallabel_> LocalLabel
%type <listlocallabel_> ListLocalLabel
%type <locallabelname_> LocalLabelName
%type <listlocallabelname_> ListLocalLabelName
%type <annotatedstmt_> AnnotatedStmt
%type <elsepart_> ElsePart
%type <statement_> Statement
%type <optloopannotations_> OptLoopAnnotations
%type <forclause_> ForClause
%type <ghostparameteropt_> GhostParameterOpt
%type <declaration_> Declaration
%type <genericassociation_> GenericAssociation
%type <listgenericassociation_> ListGenericAssociation
%type <declandinitdeclattrlist_> DeclAndInitDeclAttrList
%type <initdeclaratorattr_> InitDeclaratorAttr
%type <listinitdeclaratorattr_> ListInitDeclaratorAttr
%type <initdeclarator_> InitDeclarator
%type <declspecwotype_> DeclSpecWOType
%type <declspeclist_> DeclSpecList
%type <declspeclistnonamed_> DeclSpecListNoNamed
%type <typespec_> TypeSpec
%type <structdecllist_> StructDeclList
%type <staticassertdeclaration_> StaticAssertDeclaration
%type <fielddecl_> FieldDecl
%type <listfielddecl_> ListFieldDecl
%type <enumerator_> Enumerator
%type <listenumerator_> ListEnumerator
%type <declarator_> Declarator
%type <listdeclarator_> ListDeclarator
%type <attributesorstatic_> AttributesOrStatic
%type <directdecl_> DirectDecl
%type <restparlist_> RestParList
%type <parameterdecl_> ParameterDecl
%type <listparameterdecl_> ListParameterDecl
%type <directoldprotodecl_> DirectOldProtoDecl
%type <listident_> ListIdent
%type <oldpardeflist_> OldPardefList
%type <oldpardef_> OldPardef
%type <listoldpardef_> ListOldPardef
%type <pointeropt_> PointerOpt
%type <typename_> TypeName
%type <abstractdecl_> AbstractDecl
%type <absdirectdecl_> AbsDirectDecl
%type <absdirectdeclopt_> AbsDirectDeclOpt
%type <functiondef_> FunctionDef
%type <functiondefstart_> FunctionDefStart
%type <cvspec_> CVSpec
%type <attributeswithasm_> AttributesWithAsm
%type <attributenocv_> AttributeNocv
%type <listattributenocv_> ListAttributeNocv
%type <attribute_> Attribute
%type <listattribute_> ListAttribute
%type <justattribute_> JustAttribute
%type <listjustattribute_> ListJustAttribute
%type <pragma_> Pragma
%type <varattr_> VarAttr
%type <basicattribute_> BasicAttribute
%type <listbasicattribute_> ListBasicAttribute
%type <parameterattrlistne_> ParameterAttrListNE
%type <paramattrlistne_> ParamAttrListNE
%type <attr_> Attr14
%type <attr_> Attr13
%type <attr_> Attr12
%type <attr_> Attr11
%type <attr_> Attr10
%type <attr_> Attr9
%type <attr_> Attr8
%type <attr_> Attr7
%type <attr_> Attr6
%type <attr_> Attr5
%type <attr_> Attr4
%type <attr_> Attr3
%type <attr_> Attr2
%type <attr_> Attr1
%type <attr_> Attr
%type <listattr_> ListAttr
%type <attrtest_> AttrTest
%type <attrlist_> AttrList
%type <asmattr_> Asmattr
%type <listasmattr_> ListAsmattr
%type <asmoutputs_> Asmoutputs
%type <asmoperands_> Asmoperands
%type <asmoperand_> Asmoperand
%type <listasmoperand_> ListAsmoperand
%type <asminputs_> Asminputs
%type <asmopname_> Asmopname
%type <asmclobber_> Asmclobber
%type <liststringconstant_> ListStringConstant
%type <asmlabels_> Asmlabels
%type <lexpreof_> LexprEOF
%type <lexprlist_> LexprList
%type <listlexpr_> ListLexpr
%type <lexproption_> LexprOption
%type <lexpr_> Lexpr
%type <lexpr_> Lexpr1
%type <lexpr_> Lexpr2
%type <lexprbinder_> LexprBinder
%type <lexprrelinner_> LexprRelInner
%type <listlexprrelinner_> ListLexprRelInner
%type <relation_> Relation
%type <lexpr_> Lexpr3
%type <liststring_literal_> ListSTRING_LITERAL
%type <range_> Range
%type <fieldinitelt_> FieldInitElt
%type <listfieldinitelt_> ListFieldInitElt
%type <arrayinitelt_> ArrayInitElt
%type <listarrayinitelt_> ListArrayInitElt
%type <updateelt_> UpdateElt
%type <listupdateelt_> ListUpdateElt
%type <pathelt_> PathElt
%type <listpathelt_> ListPathElt
%type <binders_> Binders
%type <bindersreentrance_> BindersReentrance
%type <listbindersreentrance_> ListBindersReentrance
%type <varspec_> VarSpec
%type <arraysize_> ArraySize
%type <varspec_> VarSpec1
%type <absparamtypelist_> AbsParamTypeList
%type <absparam_> AbsParam
%type <listabsparam_> ListAbsParam
%type <parameter_> Parameter
%type <listparameter_> ListParameter
%type <logictypegenoftypename_> LogicTypeGenOFTYPENAME
%type <listlogictypegenoftypename_> ListLogicTypeGenOFTYPENAME
%type <logictypegenofidentifierortypename_> LogicTypeGenOFIdentifierOrTypename
%type <listlogictypegenofidentifierortypename_> ListLogicTypeGenOFIdentifierOrTypename
%type <cv_> CV
%type <listcv_> ListCV
%type <typespeccvoftypename_> TypeSpecCVOFTYPENAME
%type <castlogictype_> CastLogicType
%type <logicrttype_> LogicRtType
%type <absspecoption_> AbsSpecOption
%type <absspeccvoption_> AbsSpecCVOption
%type <absspec_> AbsSpec
%type <absspeccv_> AbsSpecCV
%type <absspec_> AbsSpec1
%type <absspeccv_> AbsSpecCV1
%type <stars_> Stars
%type <liststars_> ListStars
%type <starscv_> StarsCV
%type <liststarscv_> ListStarsCV
%type <tabs_> Tabs
%type <listtabs_> ListTabs
%type <typespecsimple_> TypeSpecSimple
%type <typespecoftypename_> TypeSpecOFTYPENAME
%type <typespecofidentifierortypename_> TypeSpecOFIdentifierOrTypename
%type <fullidentifier_> FullIdentifier
%type <listfullidentifier_> ListFullIdentifier
%type <extspec_> ExtSpec
%type <extglobalclausesopt_> ExtGlobalClausesOpt
%type <extglobalclause_> ExtGlobalClause
%type <listextglobalclause_> ListExtGlobalClause
%type <extglobalspecsopt_> ExtGlobalSpecsOpt
%type <extglobalspec_> ExtGlobalSpec
%type <listextglobalspec_> ListExtGlobalSpec
%type <extmodulespecsopt_> ExtModuleSpecsOpt
%type <extmodulespec_> ExtModuleSpec
%type <listextmodulespec_> ListExtModuleSpec
%type <extfunctionspecsopt_> ExtFunctionSpecsOpt
%type <extfunctionspecs_> ExtFunctionSpecs
%type <extfunctionspec_> ExtFunctionSpec
%type <listextfunctionspec_> ListExtFunctionSpec
%type <extfunspec_> ExtFunSpec
%type <listextfunspec_> ListExtFunSpec
%type <extidentifieropt_> ExtIdentifierOpt
%type <stmtmarkup_> StmtMarkup
%type <liststmtmarkup_> ListStmtMarkup
%type <spec_> Spec
%type <contract_> Contract
%type <clausekw_> ClauseKW
%type <requires_> Requires
%type <nerequires_> NERequires
%type <terminates_> Terminates
%type <neterminates_> NETerminates
%type <decreases_> Decreases
%type <nedecreases_> NEDecreases
%type <variant_> Variant
%type <simpleclauses_> SimpleClauses
%type <allocation_> Allocation
%type <nesimpleclauses_> NESimpleClauses
%type <extensioncontent_> ExtensionContent
%type <behaviors_> Behaviors
%type <nebehaviors_> NEBehaviors
%type <behaviorbody_> BehaviorBody
%type <assumes_> Assumes
%type <completeordisjoint_> CompleteOrDisjoint
%type <necompleteordisjoint_> NECompleteOrDisjoint
%type <assigns_> Assigns
%type <zones_> Zones
%type <logicptreeannot_> LogicPTreeAnnot
%type <listlogicptreeannot_> ListLogicPTreeAnnot
%type <annotation_> Annotation
%type <loopannotstack_> LoopAnnotStack
%type <loopannotopt_> LoopAnnotOpt
%type <loopeffects_> LoopEffects
%type <loopallocation_> LoopAllocation
%type <loopinvariant_> LoopInvariant
%type <loopvariant_> LoopVariant
%type <loopgrammarextension_> LoopGrammarExtension
%type <looppragma_> LoopPragma
%type <begpragmaorcodeannotation_> BegPragmaOrCodeAnnotation
%type <pragmaorcodeannotation_> PragmaOrCodeAnnotation
%type <codeannotation_> CodeAnnotation
%type <slicepragma_> SlicePragma
%type <impactpragma_> ImpactPragma
%type <decl_> Decl
%type <listdecl_> ListDecl
%type <extdecl_> ExtDecl
%type <listextdecl_> ListExtDecl
%type <volatileopt_> VolatileOpt
%type <listvolatileopt_> ListVolatileOpt
%type <typeannot_> TypeAnnot
%type <optsemicolon_> OptSemicolon
%type <modelannot_> ModelAnnot
%type <polyidtype_> PolyIdType
%type <polyid_> PolyId
%type <optparameters_> OptParameters
%type <parameters_> Parameters
%type <logicdef_> LogicDef
%type <deprecatedlogicdecl_> DeprecatedLogicDecl
%type <logicdecl_> LogicDecl
%type <listlogicdecl_> ListLogicDecl
%type <readsclause_> ReadsClause
%type <typedef_> Typedef
%type <dataconswithseparator_> DataconsWithSeparator
%type <listdataconswithseparator_> ListDataconsWithSeparator
%type <datacons_> Datacons
%type <indcase_> Indcase
%type <listindcase_> ListIndcase
%type <optlabel_> OptLabel1
%type <optlabel_> OptLabel2
%type <optlabellist_> OptLabelList
%type <labelname_> LabelName
%type <listlabelname_> ListLabelName
%type <behaviornamelist_> BehaviorNameList
%type <behaviorname_> BehaviorName
%type <listbehaviorname_> ListBehaviorName
%type <anyidentifier_> AnyIdentifier
%type <identifierortypename_> IdentifierOrTypename
%type <identifierortypenamefull_> IdentifierOrTypenameFull
%type <listidentifierortypenamefull_> ListIdentifierOrTypenameFull
%type <identifier_> Identifier
%type <boundedvar_> BoundedVar
%type <ckeyword_> CKeyword
%type <acslckeyword_> ACSLCKeyword
%type <postcond_> PostCond
%type <isacslspec_> IsACSLSpec
%type <isacsldeclorcodeannot_> IsACSLDeclOrCodeAnnot
%type <isacsltypename_> IsACSLTypename
%type <isextspec_> IsExtSpec
%type <keyword_> Keyword
%type <bskeyword_> BSKeyword
%type <wildcard_> Wildcard
%type <listwildcard_> ListWildcard

%start Program

%%

Program : Globals { $$ = new acsl::AProgram($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->program_ = $$; }
;
Globals : /* empty */ { $$ = new acsl::NoGlobals(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
  | Global Globals { $$ = new acsl::SimpleGlobals($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
  | _KW_ghost GhostGlobals Globals { $$ = new acsl::AGhostGlobals($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
  | _SEMI Globals { $$ = new acsl::SemiColonGlobals($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
;
GhostGlobals : Declaration GhostGlobals { $$ = new acsl::GhostGlobalsDeclataion($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostglobals_ = $$; }
  | FunctionDef GhostGlobals { $$ = new acsl::GhostGlobalsFunctionDef($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostglobals_ = $$; }
  | T_RGHOST { $$ = new acsl::GhostGlobalsRGhost($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostglobals_ = $$; }
;
Global : Decl { $$ = new acsl::GlobalDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | Declaration { $$ = new acsl::GlobalsDeclataion($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | FunctionDef { $$ = new acsl::GlobalsFunctionDef($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | _KW_extern StringConstant Declaration { $$ = new acsl::ExternGlobalDeclataion($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | _KW_extern StringConstant T_LBRACE Globals T_RBRACE { $$ = new acsl::ExternGlobalPar($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | T_ASM _LPAREN StringConstant _RPAREN _SEMI { $$ = new acsl::AsmGlobal($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | Pragma { $$ = new acsl::PragmaGlobal($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | _IDENT_ _LPAREN ListIdent _RPAREN OldPardefList _SEMI { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::GlobalOldStyle($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | _IDENT_ _LPAREN _RPAREN _SEMI { $$ = new acsl::GlobalEmptyOldStyle($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
;
IdOrTypenameAsId : _IDENT_ { $$ = new acsl::IdOrTypenameAsIdIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->idortypenameasid_ = $$; }
  | T_NAMEDTYPE { $$ = new acsl::IdOrTypenameAsIdNamedType($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->idortypenameasid_ = $$; }
;
IdOrTypename : IdOrTypenameAsId { $$ = new acsl::IdTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->idortypename_ = $$; }
;
MaybeComma : /* empty */ { $$ = new acsl::NoComa(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->maybecomma_ = $$; }
  | _COMMA { $$ = new acsl::Coma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->maybecomma_ = $$; }
;
AssignExpr15 : _IDENT_ { $$ = new acsl::IdentifierPrimaryExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | Constant { $$ = new acsl::ConstantPrimaryExpressin($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN ListExpression _RPAREN { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::CommaExpressionPrimaryExpressin($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN Block _RPAREN { $$ = new acsl::BlockPrimaryExpressin($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _SYMB_4 _LPAREN AssignExpr _COMMA ListGenericAssociation _RPAREN { std::reverse($5->begin(),$5->end()) ;$$ = new acsl::GenericAssociationPrimaryExpressin($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _SYMB_4 _LPAREN AssignExpr _RPAREN { $$ = new acsl::GenericPrimaryExpressin($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr14 : AssignExpr15 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 T_LBRACKET ListExpression T_RBRACKET { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::BracketsPostfixExpression($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _LPAREN Arguments _RPAREN GhostArgumentsOpt { $$ = new acsl::ArgumentsPostfixExpression($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _SYMB_5 _LPAREN Expression _COMMA TypeName _RPAREN { $$ = new acsl::BuiltinVaArgPostfixExpression($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _SYMB_6 _LPAREN TypeName _COMMA TypeName _RPAREN { $$ = new acsl::BuiltinTypesCompatPostfixExpression($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _SYMB_7 _LPAREN TypeName _COMMA OffsetofMemberDesignator _RPAREN { $$ = new acsl::BuiltinOffsetOfPostfixExpression($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _DOT IdOrTypename { $$ = new acsl::DotPostfixExpression($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _RARROW IdOrTypename { $$ = new acsl::ArrowPostfixExpression($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _DPLUS { $$ = new acsl::PlusPlusPostfixExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _DMINUS { $$ = new acsl::MinusMinusPostfixExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN TypeName _RPAREN T_LBRACE InitializerListOpt T_RBRACE { $$ = new acsl::ConstructorPostfixExpression($2, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
OffsetofMemberDesignator : IdOrTypename { $$ = new acsl::IdTypenameOffsetMembetDesignator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->offsetofmemberdesignator_ = $$; }
  | OffsetofMemberDesignator _DOT _IDENT_ { $$ = new acsl::DotOffsetMembetDesignator($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->offsetofmemberdesignator_ = $$; }
  | OffsetofMemberDesignator T_LBRACKET ListExpression T_RBRACKET { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::BracketsOffsetMembetDesignator($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->offsetofmemberdesignator_ = $$; }
;
AssignExpr13 : AssignExpr14 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _DPLUS AssignExpr13 { $$ = new acsl::UnaryExprPlusPlus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _DMINUS AssignExpr13 { $$ = new acsl::UnaryExprMinusMinus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _KW_sizeof AssignExpr13 { $$ = new acsl::UnaryExprSizeOf($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _KW_sizeof _LPAREN TypeName _RPAREN { $$ = new acsl::UnaryExprSizeOfTypeName($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | T_ALIGNOF AssignExpr13 { $$ = new acsl::UnaryExprAlignOfUnaryExpr($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | T_ALIGNOF _LPAREN TypeName _RPAREN { $$ = new acsl::UnaryExprAlignOfTypeName($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _PLUS AssignExpr12 { $$ = new acsl::UnaryExprPlus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _MINUS AssignExpr12 { $$ = new acsl::UnaryExprMinus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _STAR AssignExpr12 { $$ = new acsl::UnaryExprMult($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _AMP AssignExpr12 { $$ = new acsl::UnaryExprAmp($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _BANG AssignExpr12 { $$ = new acsl::UnaryExprNot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _TILDE AssignExpr12 { $$ = new acsl::UnaryExprTilde($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _DAMP IdOrTypenameAsId { $$ = new acsl::UnaryExprAddress($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr12 : AssignExpr13 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN TypeName _RPAREN AssignExpr12 { $$ = new acsl::CastExpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr11 : AssignExpr12 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr11 _STAR AssignExpr12 { $$ = new acsl::MulsExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr11 _SLASH AssignExpr12 { $$ = new acsl::DivExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr11 _PERCENT AssignExpr12 { $$ = new acsl::ModExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr10 : AssignExpr11 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr10 _PLUS AssignExpr11 { $$ = new acsl::PlusExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr10 _MINUS AssignExpr11 { $$ = new acsl::MinusExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr9 : AssignExpr10 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr9 _DLT AssignExpr10 { $$ = new acsl::LeftShiftExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr9 _DGT AssignExpr10 { $$ = new acsl::RightShiftExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr8 : AssignExpr9 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _LT AssignExpr9 { $$ = new acsl::LessExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _GT AssignExpr9 { $$ = new acsl::GreaterExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _LDARROW AssignExpr9 { $$ = new acsl::LessEqualExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _GTEQ AssignExpr9 { $$ = new acsl::GreaterEqualExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr7 : AssignExpr8 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr7 _DEQ AssignExpr8 { $$ = new acsl::EqExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr7 _BANGEQ AssignExpr8 { $$ = new acsl::NotEqExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr6 : AssignExpr7 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr6 _AMP AssignExpr7 { $$ = new acsl::BitAndExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr5 : AssignExpr6 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr5 _CARET AssignExpr6 { $$ = new acsl::BitXorExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr4 : AssignExpr5 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr4 _BAR AssignExpr5 { $$ = new acsl::BitOrExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr3 : AssignExpr4 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr3 _DAMP AssignExpr4 { $$ = new acsl::AndExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr2 : AssignExpr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr2 _DBAR AssignExpr3 { $$ = new acsl::OrExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr1 : AssignExpr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr2 _QUESTION OptExpression _COLON AssignExpr1 { $$ = new acsl::TernaryCondExpr($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr : AssignExpr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _EQ AssignExpr { $$ = new acsl::EqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _PLUSEQ AssignExpr { $$ = new acsl::PlusEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _MINUSEQ AssignExpr { $$ = new acsl::MinusEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _STAREQ AssignExpr { $$ = new acsl::MultEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _SLASHEQ AssignExpr { $$ = new acsl::DivEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _PERCENTEQ AssignExpr { $$ = new acsl::ModEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _AMPEQ AssignExpr { $$ = new acsl::AndEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _BAREQ AssignExpr { $$ = new acsl::OrEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _CARETEQ AssignExpr { $$ = new acsl::XorEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _DLTEQ AssignExpr { $$ = new acsl::LeftShiftEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _DGTEQ AssignExpr { $$ = new acsl::RightShiftEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
Expression : AssignExpr { $$ = new acsl::AssignmentExpr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expression_ = $$; }
;
Constant : _INTEGER_ { $$ = new acsl::ConstantInt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | _DOUBLE_ { $$ = new acsl::ConstantFloat($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | _CHAR_ { $$ = new acsl::ConstantChar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | T_CST_WCHAR { $$ = new acsl::ConstantWChar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | StringConstant { $$ = new acsl::ConstantString($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | WStringList { $$ = new acsl::ConstantWString($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
;
StringConstant : ListOneString { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::StringConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->stringconstant_ = $$; }
;
WStringList : T_CST_WSTRING { $$ = new acsl::LastConstantWString($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wstringlist_ = $$; }
  | OneString WStringList { $$ = new acsl::OneStringWithList($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wstringlist_ = $$; }
  | T_CST_WSTRING WStringList { $$ = new acsl::WStringWithList($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wstringlist_ = $$; }
  | T_CST_WSTRING ListOneString { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::LatersConstantWString($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wstringlist_ = $$; }
;
OneString : _STRING_ { $$ = new acsl::SimpleConstantString($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->onestring_ = $$; }
  | T_FUNCTION__ { $$ = new acsl::FunctionConstantString($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->onestring_ = $$; }
  | _SYMB_45 { $$ = new acsl::PrettyFunctionConstantString(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->onestring_ = $$; }
;
ListOneString : OneString { $$ = new acsl::ListOneString(); $$->push_back($1); result->listonestring_ = $$; }
  | OneString ListOneString { $2->push_back($1); $$ = $2; result->listonestring_ = $$; }
;
InitExpression : Expression { $$ = new acsl::SimpleExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initexpression_ = $$; }
  | T_LBRACE InitializerListOpt T_RBRACE { $$ = new acsl::BracesExpression($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initexpression_ = $$; }
;
InitializerListOpt : /* empty */ { $$ = new acsl::EmptyInitializerList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initializerlistopt_ = $$; }
  | ListInitializerSingle { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::InitializerList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initializerlistopt_ = $$; }
  | ListInitializerSingle _COMMA { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::InitializerListComma($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initializerlistopt_ = $$; }
;
InitializerSingle : InitDesignators EqOpt InitExpression { $$ = new acsl::InitializerDesignator($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initializersingle_ = $$; }
  | IdOrTypename _COLON InitExpression { $$ = new acsl::InitializerGCCDesignator($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initializersingle_ = $$; }
  | InitExpression { $$ = new acsl::EmptyInitializer($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initializersingle_ = $$; }
;
ListInitializerSingle : InitializerSingle { $$ = new acsl::ListInitializerSingle(); $$->push_back($1); result->listinitializersingle_ = $$; }
  | InitializerSingle _COMMA ListInitializerSingle { $3->push_back($1); $$ = $3; result->listinitializersingle_ = $$; }
;
EqOpt : _EQ { $$ = new acsl::EquationSign(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->eqopt_ = $$; }
  | /* empty */ { $$ = new acsl::NoEquationSign(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->eqopt_ = $$; }
;
InitDesignators : _DOT IdOrTypename InitDesignatorsOpt { $$ = new acsl::DotInitDesignator($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdesignators_ = $$; }
  | T_LBRACKET Expression T_RBRACKET InitDesignatorsOpt { $$ = new acsl::BracketsInitDesignator($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdesignators_ = $$; }
  | T_LBRACKET Expression _ELLIPSIS Expression T_RBRACKET { $$ = new acsl::BracketsSliceInitDesignator($1, $2, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdesignators_ = $$; }
;
InitDesignatorsOpt : /* empty */ { $$ = new acsl::NoInitDesignator(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdesignatorsopt_ = $$; }
  | InitDesignators { $$ = new acsl::SomeInitDesignator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdesignatorsopt_ = $$; }
;
GhostArgumentsOpt : /* empty */ { $$ = new acsl::NoGhostArguments(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostargumentsopt_ = $$; }
  | _KW_ghost _LPAREN Arguments _RPAREN T_RGHOST { $$ = new acsl::SomeGhostArguments($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostargumentsopt_ = $$; }
;
Arguments : /* empty */ { $$ = new acsl::NoArguments(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arguments_ = $$; }
  | ListExpression { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeArguments($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arguments_ = $$; }
;
OptExpression : /* empty */ { $$ = new acsl::NoExpression(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optexpression_ = $$; }
  | ListExpression { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optexpression_ = $$; }
;
ListExpression : Expression { $$ = new acsl::ListExpression(); $$->push_back($1); result->listexpression_ = $$; }
  | Expression _COMMA ListExpression { $3->push_back($1); $$ = $3; result->listexpression_ = $$; }
;
CommaExpressionOpt : /* empty */ { $$ = new acsl::NoCommaExpression(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->commaexpressionopt_ = $$; }
  | ListExpression { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeCommaExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->commaexpressionopt_ = $$; }
;
Block : T_LBRACE ListLocalLabel BlockAttrs ListBlockElement ListAnnot T_RBRACE { $$ = new acsl::ABlock($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->block_ = $$; }
;
BlockAttrs : /* empty */ { $$ = new acsl::NoBlockAttrs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockattrs_ = $$; }
  | T_BLOCKATTRIBUTE _LPAREN ListAttr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::SomeBlockAttrs($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockattrs_ = $$; }
;
BlockElement : ListAnnot Declaration { $$ = new acsl::DeclarationElement($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockelement_ = $$; }
  | ListAnnot Statement { $$ = new acsl::StatementElement($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockelement_ = $$; }
  | ListAnnot Pragma { $$ = new acsl::PragmaElement($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockelement_ = $$; }
;
ListBlockElement : /* empty */ { $$ = new acsl::ListBlockElement(); result->listblockelement_ = $$; }
  | ListBlockElement BlockElement { $1->push_back($2); $$ = $1; result->listblockelement_ = $$; }
;
Annot : Code_Annot { $$ = new acsl::CodeAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annot_ = $$; }
  | _KW_ghost ListBlockElement ListAnnot T_RGHOST { $$ = new acsl::GhostAnnot($2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annot_ = $$; }
;
ListAnnot : /* empty */ { $$ = new acsl::ListAnnot(); result->listannot_ = $$; }
  | ListAnnot Annot { $1->push_back($2); $$ = $1; result->listannot_ = $$; }
;
Code_Annot : _KW_Contract ExtIdentifierOpt _COLON Contract { $$ = new acsl::CodeAnnotExtContract($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->code_annot_ = $$; }
  | PragmaOrCodeAnnotation { $$ = new acsl::CodeAnnotPragmaOrCodeAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->code_annot_ = $$; }
  | Contract { $$ = new acsl::CodeAnnotContract($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->code_annot_ = $$; }
  | CodeAnnotation { $$ = new acsl::CodeAnnotCodeAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->code_annot_ = $$; }
;
LocalLabel : _SYMB_47 ListLocalLabelName _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::LocalLable($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->locallabel_ = $$; }
;
ListLocalLabel : /* empty */ { $$ = new acsl::ListLocalLabel(); result->listlocallabel_ = $$; }
  | ListLocalLabel LocalLabel { $1->push_back($2); $$ = $1; result->listlocallabel_ = $$; }
;
LocalLabelName : IdOrTypenameAsId { $$ = new acsl::ALocalLabelName($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->locallabelname_ = $$; }
;
ListLocalLabelName : LocalLabelName { $$ = new acsl::ListLocalLabelName(); $$->push_back($1); result->listlocallabelname_ = $$; }
  | LocalLabelName _COMMA ListLocalLabelName { $3->push_back($1); $$ = $3; result->listlocallabelname_ = $$; }
;
AnnotatedStmt : ListAnnot Statement { $$ = new acsl::AnnotatedStatement($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotatedstmt_ = $$; }
;
ElsePart : /* empty */ { $$ = new acsl::NoElsePart(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->elsepart_ = $$; }
  | _KW_else AnnotatedStmt { $$ = new acsl::SimpleElsePart($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->elsepart_ = $$; }
  | _KW_ghost AnnotatedStmt T_RGHOST { $$ = new acsl::SimpleGhostElsePart($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->elsepart_ = $$; }
  | _KW_ghost AnnotatedStmt T_RGHOST _KW_else AnnotatedStmt { $$ = new acsl::GhostElsePart($2, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->elsepart_ = $$; }
;
Statement : _SEMI { $$ = new acsl::SemicolonStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | IsACSLSpec ListWildcard AnnotatedStmt { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::SpecStatement($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | ListExpression _SEMI { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ExprsStatement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | Block { $$ = new acsl::BlockStatement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_if _LPAREN ListExpression _RPAREN AnnotatedStmt ElsePart { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::IfStatement($3, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_switch _LPAREN ListExpression _RPAREN AnnotatedStmt { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::SwitchStatement($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | OptLoopAnnotations _KW_while _LPAREN ListExpression _RPAREN AnnotatedStmt { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::WhileStatement($1, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | OptLoopAnnotations _KW_do AnnotatedStmt _KW_while _LPAREN ListExpression _RPAREN _SEMI { std::reverse($6->begin(),$6->end()) ;$$ = new acsl::DoWhileStatement($1, $3, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | OptLoopAnnotations _KW_for _LPAREN ForClause OptExpression _SEMI OptExpression _RPAREN AnnotatedStmt { $$ = new acsl::ForStatement($1, $4, $5, $7, $9); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | IdOrTypenameAsId _COLON ListAttributeNocv AnnotatedStmt { $$ = new acsl::ColonStatement($1, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_case Expression _COLON AnnotatedStmt { $$ = new acsl::CaseStatement($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_case Expression _ELLIPSIS Expression _COLON AnnotatedStmt { $$ = new acsl::CaseSliceStatement($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_default _COLON AnnotatedStmt { $$ = new acsl::DefaultStatement($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_return _SEMI { $$ = new acsl::EmptyReturnStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_return ListExpression _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ReturnStatement($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_break _SEMI { $$ = new acsl::BreakStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_continue _SEMI { $$ = new acsl::ContinueStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_goto IdOrTypenameAsId _SEMI { $$ = new acsl::GotoStatement($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_goto _STAR ListExpression _SEMI { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::StarGotoStatement($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | T_ASM _KW_goto ListAsmattr _LPAREN ListOneString Asmoutputs _RPAREN _SEMI { std::reverse($5->begin(),$5->end()) ;$$ = new acsl::AsmGotoAsmattrStatement($1, $3, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | T_ASM ListAsmattr _LPAREN ListOneString Asmoutputs _RPAREN _SEMI { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::AsmAsmattrStatement($1, $2, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | T_ASM { $$ = new acsl::AsmStatement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _SYMB_48 Block _SYMB_49 _LPAREN ListExpression _RPAREN Block { std::reverse($5->begin(),$5->end()) ;$$ = new acsl::TryExceptStatement($2, $5, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _SYMB_48 Block _SYMB_50 Block { $$ = new acsl::TryFinallyStatement($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
;
OptLoopAnnotations : /* empty */ { $$ = new acsl::NoLoopAnnotations(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optloopannotations_ = $$; }
  | LoopAnnotStack { $$ = new acsl::SomeLoopAnnotations($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optloopannotations_ = $$; }
;
ForClause : OptExpression _SEMI { $$ = new acsl::ForClauseExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->forclause_ = $$; }
  | Declaration { $$ = new acsl::ForClauseDeclaration($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->forclause_ = $$; }
;
GhostParameterOpt : /* empty */ { $$ = new acsl::NoGhostParameter(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostparameteropt_ = $$; }
  | _KW_ghost _LPAREN RestParList _RPAREN T_RGHOST { $$ = new acsl::SomeGhostParameter($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostparameteropt_ = $$; }
;
Declaration : DeclSpecList DeclAndInitDeclAttrList _SEMI { $$ = new acsl::DeclSpecInitDecl($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | DeclSpecList _SEMI { $$ = new acsl::DeclSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | IsACSLSpec ListWildcard DeclSpecList DeclAndInitDeclAttrList _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::SpecDeclSpecInitDecl($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | IsACSLSpec ListWildcard DeclSpecList _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::SpecDeclSpec($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | _SYMB_51 _LPAREN Expression _RPAREN { $$ = new acsl::StaticAssertDecl($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | _SYMB_51 _LPAREN Expression _COMMA StringConstant _RPAREN { $$ = new acsl::StaticAssertDeclStringConst($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
;
GenericAssociation : TypeName _COLON AssignExpr { $$ = new acsl::ColonGenericAssociation($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->genericassociation_ = $$; }
  | _KW_default _COLON AssignExpr { $$ = new acsl::DefaultGenericAssociation($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->genericassociation_ = $$; }
;
ListGenericAssociation : GenericAssociation { $$ = new acsl::ListGenericAssociation(); $$->push_back($1); result->listgenericassociation_ = $$; }
  | GenericAssociation _COMMA ListGenericAssociation { $3->push_back($1); $$ = $3; result->listgenericassociation_ = $$; }
;
DeclAndInitDeclAttrList : InitDeclarator { $$ = new acsl::InitDeclaration($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declandinitdeclattrlist_ = $$; }
  | InitDeclarator _COMMA ListInitDeclaratorAttr { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::InitDeclarationWithAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declandinitdeclattrlist_ = $$; }
;
InitDeclaratorAttr : ListAttributeNocv InitDeclarator { $$ = new acsl::InitDeclaratorAttribute($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdeclaratorattr_ = $$; }
;
ListInitDeclaratorAttr : InitDeclaratorAttr { $$ = new acsl::ListInitDeclaratorAttr(); $$->push_back($1); result->listinitdeclaratorattr_ = $$; }
  | InitDeclaratorAttr _COMMA ListInitDeclaratorAttr { $3->push_back($1); $$ = $3; result->listinitdeclaratorattr_ = $$; }
;
InitDeclarator : Declarator { $$ = new acsl::SimpleInitDeclarator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdeclarator_ = $$; }
  | Declarator _EQ InitExpression { $$ = new acsl::InitDeclaratorExpression($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdeclarator_ = $$; }
;
DeclSpecWOType : _KW_typedef { $$ = new acsl::DeclSpecWOTypeTypedefKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | _KW_extern { $$ = new acsl::DeclSpecWOTypeExternKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | _KW_static { $$ = new acsl::DeclSpecWOTypeStaticKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | _KW_auto { $$ = new acsl::DeclSpecWOTypeAutoKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | _KW_register { $$ = new acsl::DeclSpecWOTypeRegisterKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | T_INLINE { $$ = new acsl::DeclSpecWOTypeInlineKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | _SYMB_52 { $$ = new acsl::DeclSpecWOTypeNoReturnKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | CVSpec { $$ = new acsl::DeclSpecWOTypeDeclSpecCVSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
  | AttributeNocv { $$ = new acsl::DeclSpecWOTypeDeclSpecAtribNOCV($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspecwotype_ = $$; }
;
DeclSpecList : DeclSpecWOType { $$ = new acsl::DeclSpecWoType($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclist_ = $$; }
  | DeclSpecWOType DeclSpecList { $$ = new acsl::DeclSpecWoTypeNext($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclist_ = $$; }
  | TypeSpec { $$ = new acsl::DeclSpecTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclist_ = $$; }
  | TypeSpec DeclSpecListNoNamed { $$ = new acsl::DeclSpecTypeSpecNext($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclist_ = $$; }
;
DeclSpecListNoNamed : DeclSpecWOType { $$ = new acsl::DeclSpecNoNamedWOType($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclistnonamed_ = $$; }
  | DeclSpecWOType DeclSpecListNoNamed { $$ = new acsl::DeclSpecNoNamedWOTypeNext($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclistnonamed_ = $$; }
  | TypeSpec { $$ = new acsl::DeclSpecNoNamedTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclistnonamed_ = $$; }
  | TypeSpec DeclSpecListNoNamed { $$ = new acsl::DeclSpecNoNamedTypeSpecNext($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclistnonamed_ = $$; }
;
TypeSpec : _KW_void { $$ = new acsl::TypeSpecVoidKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_char { $$ = new acsl::TypeSpecCharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _SYMB_53 { $$ = new acsl::TypeSpecBoolKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_short { $$ = new acsl::TypeSpecShortKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _SYMB_54 { $$ = new acsl::TypeSpecInt32KeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_int { $$ = new acsl::TypeSpecIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_long { $$ = new acsl::TypeSpecLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _SYMB_55 { $$ = new acsl::TypeSpecInt64KeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_float { $$ = new acsl::TypeSpecFloatKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_double { $$ = new acsl::TypeSpecDoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | T_SIGNED { $$ = new acsl::TypeSpecSignedKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_unsigned { $$ = new acsl::TypeSpecUnsignedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct IdOrTypename { $$ = new acsl::StructId($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct ListJustAttribute IdOrTypename { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::StructJustAttr($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct IdOrTypename T_LBRACE StructDeclList T_RBRACE { $$ = new acsl::StructIdBraces($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct T_LBRACE StructDeclList T_RBRACE { $$ = new acsl::StructBraces($2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct ListJustAttribute IdOrTypename T_LBRACE StructDeclList T_RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::StructJustAttrIdBraces($2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct ListJustAttribute T_LBRACE StructDeclList T_RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::StructJustAttrBraces($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_union IdOrTypename { $$ = new acsl::UnionId($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_union IdOrTypename T_LBRACE StructDeclList T_RBRACE { $$ = new acsl::UnionIdBraces($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_union T_LBRACE StructDeclList T_RBRACE { $$ = new acsl::UnionBraces($2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_union ListJustAttribute IdOrTypename T_LBRACE StructDeclList T_RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::UnionJustAttrIdBraces($2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_union ListJustAttribute T_LBRACE StructDeclList T_RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::UnionJustAttrBraces($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_enum IdOrTypename { $$ = new acsl::EnumId($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_enum IdOrTypename T_LBRACE ListEnumerator MaybeComma T_RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::EnumIdBraces($2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_enum T_LBRACE ListEnumerator MaybeComma T_RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::EnumBraces($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_enum ListJustAttribute IdOrTypename T_LBRACE ListEnumerator MaybeComma T_RBRACE { std::reverse($2->begin(),$2->end()) ; std::reverse($5->begin(),$5->end()) ;$$ = new acsl::EnumJustAttrIdBraces($2, $3, $4, $5, $6, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_enum ListJustAttribute T_LBRACE ListEnumerator MaybeComma T_RBRACE { std::reverse($2->begin(),$2->end()) ; std::reverse($4->begin(),$4->end()) ;$$ = new acsl::EnumJustAttrBraces($2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | T_NAMEDTYPE { $$ = new acsl::NamedTypeTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | T_TYPEOF _LPAREN Expression _RPAREN { $$ = new acsl::TypeOfExpression($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | T_TYPEOF _LPAREN TypeName _RPAREN { $$ = new acsl::TypeOfTypeName($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
;
StructDeclList : /* empty */ { $$ = new acsl::EmptyStructDecl(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | DeclSpecList _SEMI StructDeclList { $$ = new acsl::DeclSpecStructDecl($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | _SEMI StructDeclList { $$ = new acsl::SemicolonStructDecl($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | DeclSpecList ListFieldDecl _SEMI StructDeclList { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::SpecFieldDeclStructDecl($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | Pragma StructDeclList { $$ = new acsl::PragmaStructDecl($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | StaticAssertDeclaration { $$ = new acsl::StaticAssertStructDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | StaticAssertDeclaration _SEMI StructDeclList { $$ = new acsl::StaticAssertStructDeclNext($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
;
StaticAssertDeclaration : _SYMB_51 _LPAREN Expression _RPAREN { $$ = new acsl::StaticAssert($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->staticassertdeclaration_ = $$; }
  | _SYMB_51 _LPAREN Expression _COMMA StringConstant _RPAREN { $$ = new acsl::StaticAssertStringConst($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->staticassertdeclaration_ = $$; }
;
FieldDecl : Declarator { $$ = new acsl::FieldDeclDeclarator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fielddecl_ = $$; }
  | Declarator _COLON Expression ListAttribute { $$ = new acsl::FieldDeclDeclaratorColon($1, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fielddecl_ = $$; }
  | _COLON Expression { $$ = new acsl::FieldDeclColonExpression($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fielddecl_ = $$; }
;
ListFieldDecl : FieldDecl { $$ = new acsl::ListFieldDecl(); $$->push_back($1); result->listfielddecl_ = $$; }
  | FieldDecl _COMMA ListFieldDecl { $3->push_back($1); $$ = $3; result->listfielddecl_ = $$; }
;
Enumerator : _IDENT_ { $$ = new acsl::IdentEnumerator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->enumerator_ = $$; }
  | _IDENT_ _EQ Expression { $$ = new acsl::IdentAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->enumerator_ = $$; }
;
ListEnumerator : Enumerator { $$ = new acsl::ListEnumerator(); $$->push_back($1); result->listenumerator_ = $$; }
  | Enumerator _COMMA ListEnumerator { $3->push_back($1); $$ = $3; result->listenumerator_ = $$; }
;
Declarator : PointerOpt DirectDecl AttributesWithAsm { $$ = new acsl::ADeclarator($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declarator_ = $$; }
;
ListDeclarator : Declarator { $$ = new acsl::ListDeclarator(); $$->push_back($1); result->listdeclarator_ = $$; }
  | Declarator _COMMA ListDeclarator { $3->push_back($1); $$ = $3; result->listdeclarator_ = $$; }
;
AttributesOrStatic : ListAttribute CommaExpressionOpt { $$ = new acsl::AttributesCommaExpression($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributesorstatic_ = $$; }
  | Attribute ListAttribute _KW_static ListExpression { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::AttributesStaticExpression($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributesorstatic_ = $$; }
  | _KW_static ListAttribute ListExpression { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::StaticAttributesExpression($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributesorstatic_ = $$; }
;
DirectDecl : IdOrTypename { $$ = new acsl::DirectDeclIdTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
  | _LPAREN ListAttribute Declarator _RPAREN { $$ = new acsl::DirectDeclAttrDecl($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
  | DirectDecl T_LBRACKET AttributesOrStatic T_RBRACKET { $$ = new acsl::DirectDeclAttrStatic($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
  | DirectDecl _LPAREN _RPAREN GhostParameterOpt { $$ = new acsl::DirectDeclGhostParam($1, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
  | DirectDecl _LPAREN RestParList _RPAREN GhostParameterOpt { $$ = new acsl::DirectDeclGhostRestParParam($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
;
RestParList : ListParameterDecl { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SimpleParameterDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->restparlist_ = $$; }
  | ListParameterDecl _COMMA _ELLIPSIS { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::DotDotDotParameterDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->restparlist_ = $$; }
;
ParameterDecl : DeclSpecList Declarator { $$ = new acsl::ParameterDeclSpecDeclarator($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
  | DeclSpecList AbstractDecl { $$ = new acsl::ParameterDeclSpecAbstract($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
  | DeclSpecList { $$ = new acsl::ParameterDeclSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
  | _LPAREN ParameterDecl _RPAREN { $$ = new acsl::ParameterDeclPar($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
;
ListParameterDecl : ParameterDecl { $$ = new acsl::ListParameterDecl(); $$->push_back($1); result->listparameterdecl_ = $$; }
  | ParameterDecl _COMMA ListParameterDecl { $3->push_back($1); $$ = $3; result->listparameterdecl_ = $$; }
;
DirectOldProtoDecl : DirectDecl _LPAREN ListIdent _RPAREN OldPardefList { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::OldDirectProtoDecl($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directoldprotodecl_ = $$; }
;
ListIdent : _IDENT_ { $$ = new acsl::ListIdent(); $$->push_back($1); result->listident_ = $$; }
  | _IDENT_ _COMMA ListIdent { $3->push_back($1); $$ = $3; result->listident_ = $$; }
;
OldPardefList : /* empty */ { $$ = new acsl::EmptyOldPardefList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->oldpardeflist_ = $$; }
  | ListOldPardef _ELLIPSIS { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::DotDotDotOldPardefList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->oldpardeflist_ = $$; }
  | ListOldPardef { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SimpleOldPardefList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->oldpardeflist_ = $$; }
;
OldPardef : DeclSpecList ListDeclarator { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::OldParDef($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->oldpardef_ = $$; }
;
ListOldPardef : OldPardef { $$ = new acsl::ListOldPardef(); $$->push_back($1); result->listoldpardef_ = $$; }
  | OldPardef _SEMI ListOldPardef { $3->push_back($1); $$ = $3; result->listoldpardef_ = $$; }
;
PointerOpt : /* empty */ { $$ = new acsl::NoPointer(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pointeropt_ = $$; }
  | _STAR ListAttribute PointerOpt { $$ = new acsl::SomePointer($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pointeropt_ = $$; }
;
TypeName : DeclSpecList AbstractDecl { $$ = new acsl::TypeNameAbstractDecl($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typename_ = $$; }
  | DeclSpecList { $$ = new acsl::TypeNameDeclSpecList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typename_ = $$; }
;
AbstractDecl : PointerOpt AbsDirectDecl ListAttribute { $$ = new acsl::AbstractDeclAttr($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->abstractdecl_ = $$; }
  | _STAR ListAttribute PointerOpt { $$ = new acsl::AbstractDeclPointer($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->abstractdecl_ = $$; }
;
AbsDirectDecl : _LPAREN ListAttribute AbstractDecl _RPAREN { $$ = new acsl::AbsDirectDeclPar($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absdirectdecl_ = $$; }
  | AbsDirectDeclOpt T_LBRACKET CommaExpressionOpt T_RBRACKET { $$ = new acsl::AbsDirectDeclBreckets($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absdirectdecl_ = $$; }
  | AbsDirectDecl _LPAREN RestParList _RPAREN { $$ = new acsl::AbsDirectDeclRestPar($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absdirectdecl_ = $$; }
  | AbsDirectDecl _LPAREN _RPAREN { $$ = new acsl::AbsDirectDeclNoRestPar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absdirectdecl_ = $$; }
;
AbsDirectDeclOpt : AbsDirectDecl { $$ = new acsl::SomeAbsDirectDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absdirectdeclopt_ = $$; }
  | /* empty */ { $$ = new acsl::NoAbsDirectDecl(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absdirectdeclopt_ = $$; }
;
FunctionDef : IsACSLSpec ListWildcard FunctionDefStart Block { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::FunctionDefSpec($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondef_ = $$; }
  | FunctionDefStart Block { $$ = new acsl::SimpleFunctionDef($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondef_ = $$; }
;
FunctionDefStart : DeclSpecList Declarator { $$ = new acsl::FunctionDefStartDeclarator($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondefstart_ = $$; }
  | DeclSpecList PointerOpt DirectOldProtoDecl { $$ = new acsl::FunctionDefStartOldProtoDecl($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondefstart_ = $$; }
  | _IDENT_ _LPAREN RestParList _RPAREN GhostParameterOpt { $$ = new acsl::FunctionDefStartReatParGhostParameter($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondefstart_ = $$; }
  | _IDENT_ _LPAREN ListIdent _RPAREN OldPardefList { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::FunctionDefStartOldPardef($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondefstart_ = $$; }
  | _IDENT_ _LPAREN _RPAREN GhostParameterOpt { $$ = new acsl::FunctionDefStartGhostParameter($1, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondefstart_ = $$; }
;
CVSpec : T_CONST { $$ = new acsl::CVSpecConstKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cvspec_ = $$; }
  | T_VOLATILE { $$ = new acsl::CVSpecVolatileKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cvspec_ = $$; }
  | T_RESTRICT { $$ = new acsl::CVSpecRestrictKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cvspec_ = $$; }
  | _SYMB_56 { $$ = new acsl::CVSpecGhostKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cvspec_ = $$; }
  | Identifier { $$ = new acsl::CVSpecAttribute_annotKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cvspec_ = $$; }
;
AttributesWithAsm : /* empty */ { $$ = new acsl::EmptyAttrWithASM(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributeswithasm_ = $$; }
  | Attribute ListAttribute { $$ = new acsl::ListAttrWithASM($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributeswithasm_ = $$; }
  | Attribute ListAttribute T_ASM _LPAREN StringConstant _RPAREN ListAttribute { $$ = new acsl::ListASMAttrWithASM($1, $2, $3, $5, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributeswithasm_ = $$; }
  | T_ASM _LPAREN StringConstant _RPAREN ListAttribute { $$ = new acsl::ASMAttrWithASM($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributeswithasm_ = $$; }
;
AttributeNocv : T_ATTRIBUTE _LPAREN _LPAREN AttrList _RPAREN _RPAREN { $$ = new acsl::AttributeAttrNocv($1, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributenocv_ = $$; }
  | _SYMB_57 _LPAREN ListAttr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::DeclspecAttrNocv($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributenocv_ = $$; }
  | T_MSATTR { $$ = new acsl::MsattrAttrNocv($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributenocv_ = $$; }
  | _SYMB_58 { $$ = new acsl::ThreadAttrNocv(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributenocv_ = $$; }
  | _SYMB_59 { $$ = new acsl::ThreadLocalAttrNocv(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributenocv_ = $$; }
;
ListAttributeNocv : /* empty */ { $$ = new acsl::ListAttributeNocv(); result->listattributenocv_ = $$; }
  | ListAttributeNocv AttributeNocv { $1->push_back($2); $$ = $1; result->listattributenocv_ = $$; }
;
Attribute : AttributeNocv { $$ = new acsl::AttributeNoCV($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
  | T_CONST { $$ = new acsl::AttributeConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
  | T_RESTRICT { $$ = new acsl::AttributeRestrict($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
  | T_VOLATILE { $$ = new acsl::AttributeVolatile($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
  | _SYMB_56 { $$ = new acsl::AttributeGhost(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
  | Identifier { $$ = new acsl::AttributeAttributeAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
;
ListAttribute : /* empty */ { $$ = new acsl::ListAttribute(); result->listattribute_ = $$; }
  | ListAttribute Attribute { $1->push_back($2); $$ = $1; result->listattribute_ = $$; }
;
JustAttribute : T_ATTRIBUTE _LPAREN _LPAREN AttrList _RPAREN _RPAREN { $$ = new acsl::AttributeJustAttribute($1, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->justattribute_ = $$; }
  | _SYMB_57 _LPAREN ListAttr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::DeclspecJustAttribute($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->justattribute_ = $$; }
;
ListJustAttribute : JustAttribute { $$ = new acsl::ListJustAttribute(); $$->push_back($1); result->listjustattribute_ = $$; }
  | JustAttribute ListJustAttribute { $2->push_back($1); $$ = $2; result->listjustattribute_ = $$; }
;
Pragma : _KW_pragma { $$ = new acsl::SimplePragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragma_ = $$; }
  | _KW_pragma Attr { $$ = new acsl::AttrPragma($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragma_ = $$; }
  | _KW_pragma Attr _SEMI { $$ = new acsl::AttrPragmaSeparated($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragma_ = $$; }
  | _KW_pragma { $$ = new acsl::PragmaKeyrod(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragma_ = $$; }
;
VarAttr : _IDENT_ { $$ = new acsl::IdentifierVarAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varattr_ = $$; }
  | T_NAMEDTYPE { $$ = new acsl::NamedTypeVarAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varattr_ = $$; }
  | _KW_default _COLON _INTEGER_ { $$ = new acsl::DefaultVarAttr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varattr_ = $$; }
  | T_CONST { $$ = new acsl::ConstVarAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varattr_ = $$; }
  | T_VOLATILE { $$ = new acsl::VolatileVarAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varattr_ = $$; }
  | _INTEGER_ _COLON _INTEGER_ { $$ = new acsl::ContIntVarAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varattr_ = $$; }
;
BasicAttribute : _INTEGER_ { $$ = new acsl::BasicAttrConsInt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->basicattribute_ = $$; }
  | _DOUBLE_ { $$ = new acsl::BasicAttrConsFloat($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->basicattribute_ = $$; }
  | VarAttr { $$ = new acsl::BasicAttrVar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->basicattribute_ = $$; }
;
ListBasicAttribute : BasicAttribute { $$ = new acsl::ListBasicAttribute(); $$->push_back($1); result->listbasicattribute_ = $$; }
  | BasicAttribute ListBasicAttribute { $2->push_back($1); $$ = $2; result->listbasicattribute_ = $$; }
;
ParameterAttrListNE : ListBasicAttribute { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ParameterBasicAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterattrlistne_ = $$; }
  | ListBasicAttribute StringConstant { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ParameterBasicAttrStringConst($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterattrlistne_ = $$; }
  | ListBasicAttribute StringConstant ParameterAttrListNE { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ParameterBasicAttrStringConstNext($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterattrlistne_ = $$; }
;
ParamAttrListNE : ParameterAttrListNE { $$ = new acsl::ParamAttrList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->paramattrlistne_ = $$; }
  | StringConstant { $$ = new acsl::ParamStringConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->paramattrlistne_ = $$; }
;
Attr14 : BasicAttribute { $$ = new acsl::BasicAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _LPAREN Attr _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | StringConstant { $$ = new acsl::AttrStringConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr13 : Attr14 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | IdOrTypenameAsId _LPAREN ListAttr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::FuncationCall($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | IdOrTypenameAsId _LPAREN _RPAREN { $$ = new acsl::ProcedureCall($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | BasicAttribute ParamAttrListNE { $$ = new acsl::BasicPostfix($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr13 _RARROW IdOrTypename { $$ = new acsl::ArrowAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr13 _DOT IdOrTypename { $$ = new acsl::DotAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr13 T_LBRACKET Attr T_RBRACKET { $$ = new acsl::ArrayAttr($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr12 : Attr13 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _KW_sizeof AssignExpr13 { $$ = new acsl::SizeOfAttrUnary($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _KW_sizeof _LPAREN TypeName _RPAREN { $$ = new acsl::SizeOfAttrTypeName($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | T_ALIGNOF AssignExpr13 { $$ = new acsl::AlignOfAttrUnary($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | T_ALIGNOF _LPAREN TypeName _RPAREN { $$ = new acsl::AlignOfAttrTypeName($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _PLUS Attr12 { $$ = new acsl::PlusUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _MINUS Attr12 { $$ = new acsl::MinusUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _STAR Attr12 { $$ = new acsl::MultUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _AMP Attr12 { $$ = new acsl::AmpUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _BANG Attr12 { $$ = new acsl::NotUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _TILDE Attr12 { $$ = new acsl::TildeUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr11 : Attr12 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr11 _STAR Attr12 { $$ = new acsl::MultOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr11 _SLASH Attr12 { $$ = new acsl::DivOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr11 _PERCENT Attr12 { $$ = new acsl::ModOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr10 : Attr11 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr10 _PLUS Attr11 { $$ = new acsl::AddOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr10 _MINUS Attr11 { $$ = new acsl::SubOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr9 : Attr10 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr9 _DLT Attr10 { $$ = new acsl::LeftShiftOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr9 _DGT Attr10 { $$ = new acsl::RightShiftOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr8 : Attr9 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _LT Attr9 { $$ = new acsl::Less($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _GT Attr9 { $$ = new acsl::Greater($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _LDARROW Attr9 { $$ = new acsl::LessEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _GTEQ Attr9 { $$ = new acsl::GreaterEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr7 : Attr8 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr7 _DEQ Attr8 { $$ = new acsl::EqualEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr7 _BANGEQ Attr8 { $$ = new acsl::NotEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr6 : Attr7 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr6 _AMP Attr7 { $$ = new acsl::BitAnd($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr5 : Attr6 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr5 _CARET Attr6 { $$ = new acsl::Xor($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr4 : Attr5 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr4 _BAR Attr5 { $$ = new acsl::BitOr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr3 : Attr4 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr3 _DAMP Attr4 { $$ = new acsl::And($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr2 : Attr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr2 _DBAR Attr3 { $$ = new acsl::Or($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr1 : Attr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr2 _QUESTION AttrTest Attr1 _COLON Attr1 { $$ = new acsl::TernaryCond($1, $3, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr : Attr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr1 _EQ Attr1 { $$ = new acsl::AnAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
ListAttr : Attr { $$ = new acsl::ListAttr(); $$->push_back($1); result->listattr_ = $$; }
  | Attr _COMMA ListAttr { $3->push_back($1); $$ = $3; result->listattr_ = $$; }
;
AttrTest : /* empty */ { $$ = new acsl::AvoidShiftReduce(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attrtest_ = $$; }
;
AttrList : /* empty */ { $$ = new acsl::EmptyAtrList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attrlist_ = $$; }
  | ListAttr { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AtrList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attrlist_ = $$; }
;
Asmattr : T_VOLATILE { $$ = new acsl::VolatileKeyWrod($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmattr_ = $$; }
  | T_CONST { $$ = new acsl::ConstKeyWrod($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmattr_ = $$; }
;
ListAsmattr : /* empty */ { $$ = new acsl::ListAsmattr(); result->listasmattr_ = $$; }
  | ListAsmattr Asmattr { $1->push_back($2); $$ = $1; result->listasmattr_ = $$; }
;
Asmoutputs : /* empty */ { $$ = new acsl::NoAsmoutputs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmoutputs_ = $$; }
  | _COLON Asmoperands Asminputs { $$ = new acsl::SomeAsmoutputs($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmoutputs_ = $$; }
;
Asmoperands : /* empty */ { $$ = new acsl::NoAsmoperands(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmoperands_ = $$; }
  | ListAsmoperand { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeAsmoperands($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmoperands_ = $$; }
;
Asmoperand : Asmopname StringConstant _LPAREN Expression _RPAREN { $$ = new acsl::AsmOperand($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmoperand_ = $$; }
;
ListAsmoperand : Asmoperand { $$ = new acsl::ListAsmoperand(); $$->push_back($1); result->listasmoperand_ = $$; }
  | Asmoperand _COMMA ListAsmoperand { $3->push_back($1); $$ = $3; result->listasmoperand_ = $$; }
;
Asminputs : /* empty */ { $$ = new acsl::NoAsminputs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asminputs_ = $$; }
  | _COLON Asmoperands Asmclobber { $$ = new acsl::SomeAsminputs($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asminputs_ = $$; }
;
Asmopname : /* empty */ { $$ = new acsl::NoAsmopname(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmopname_ = $$; }
  | T_LBRACKET _IDENT_ T_RBRACKET { $$ = new acsl::SomeAsmopname($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmopname_ = $$; }
;
Asmclobber : /* empty */ { $$ = new acsl::NoAsmclobber(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmclobber_ = $$; }
  | _COLON Asmlabels { $$ = new acsl::ColonAsmclobber($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmclobber_ = $$; }
  | _COLON ListStringConstant Asmlabels { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ColonStringAsmclobber($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmclobber_ = $$; }
;
ListStringConstant : StringConstant { $$ = new acsl::ListStringConstant(); $$->push_back($1); result->liststringconstant_ = $$; }
  | StringConstant _COMMA ListStringConstant { $3->push_back($1); $$ = $3; result->liststringconstant_ = $$; }
;
Asmlabels : /* empty */ { $$ = new acsl::NoAsmlabels(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmlabels_ = $$; }
  | _COLON ListLocalLabelName { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::SomeAsmlabels($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->asmlabels_ = $$; }
;
LexprEOF : Lexpr { $$ = new acsl::LexprEof($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpreof_ = $$; }
;
LexprList : /* empty */ { $$ = new acsl::EmptyLexprList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprlist_ = $$; }
  | ListLexpr { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::NonEmptyLexprList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprlist_ = $$; }
;
ListLexpr : Lexpr { $$ = new acsl::ListLexpr(); $$->push_back($1); result->listlexpr_ = $$; }
  | Lexpr _COMMA ListLexpr { $3->push_back($1); $$ = $3; result->listlexpr_ = $$; }
;
LexprOption : /* empty */ { $$ = new acsl::NoLexprOption(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexproption_ = $$; }
  | Lexpr { $$ = new acsl::SomeLexprOption($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexproption_ = $$; }
;
Lexpr : /* empty */ { $$ = new acsl::NoLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _SYMB_60 Lexpr { $$ = new acsl::ImplLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _SYMB_61 Lexpr { $$ = new acsl::IffLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _DBAR Lexpr { $$ = new acsl::OrLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _DAMP Lexpr { $$ = new acsl::AndLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _DCARET Lexpr { $$ = new acsl::HatHatLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _AMP Lexpr { $$ = new acsl::AmpLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _BAR Lexpr { $$ = new acsl::PipeLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _CARET Lexpr { $$ = new acsl::HatLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _SYMB_63 Lexpr { $$ = new acsl::BimpliesLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _SYMB_64 Lexpr { $$ = new acsl::BiffLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _SYMB_65 Lexpr { $$ = new acsl::InLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _QUESTION Lexpr _COLON Lexpr { $$ = new acsl::TernaryLexpr($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | AnyIdentifier _COLON Lexpr { $$ = new acsl::IdAssignLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | ListSTRING_LITERAL _COLON Lexpr { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::StrAssignLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
Lexpr1 : Lexpr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 ListLexprRelInner Relation Lexpr2 { $$ = new acsl::RelationLexpr($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
Lexpr2 : Lexpr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | LexprBinder { $$ = new acsl::BinderLexpr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _BANG LexprBinder { $$ = new acsl::NotBinderLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
LexprBinder : _SYMB_66 BoundedVar _EQ Lexpr _SEMI Lexpr { $$ = new acsl::LetBinderLexpr($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
  | _SYMB_67 Binders _SEMI Lexpr { $$ = new acsl::ForallBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
  | _SYMB_68 Binders _SEMI Lexpr { $$ = new acsl::ExistBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
  | _SYMB_69 Binders _SEMI Lexpr { $$ = new acsl::LambdaBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
;
LexprRelInner : Relation Lexpr3 { $$ = new acsl::RelInnerLexpr($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprrelinner_ = $$; }
;
ListLexprRelInner : /* empty */ { $$ = new acsl::ListLexprRelInner(); result->listlexprrelinner_ = $$; }
  | ListLexprRelInner LexprRelInner { $1->push_back($2); $$ = $1; result->listlexprrelinner_ = $$; }
;
Relation : _LT { $$ = new acsl::LessRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _GT { $$ = new acsl::GreaterRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _LDARROW { $$ = new acsl::LessEqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _GTEQ { $$ = new acsl::GreaterEqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _DEQ { $$ = new acsl::EqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _BANGEQ { $$ = new acsl::NotEqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _EQ { $$ = new acsl::EQUALRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
;
Lexpr3 : ListSTRING_LITERAL { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::StringLexpr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _BANG Lexpr3 { $$ = new acsl::NotLexprInner($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_70 { $$ = new acsl::TrueLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_71 { $$ = new acsl::FalseLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_72 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::PointerLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_73 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::ValidLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_74 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::ValidReadLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_75 _LPAREN Lexpr _RPAREN { $$ = new acsl::ValidFuncLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_76 OptLabel1 _LPAREN Lexpr _COMMA Lexpr _RPAREN { $$ = new acsl::ValidIndxLexpr($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_77 OptLabel1 _LPAREN Lexpr _COMMA Lexpr _COMMA Lexpr _RPAREN { $$ = new acsl::ValidRangeLexpr($2, $4, $6, $8); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_78 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::InitializedLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_79 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::DanglingLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_80 OptLabel2 _LPAREN Lexpr _COMMA Lexpr _RPAREN { $$ = new acsl::FreshLexpr($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_81 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::BaseAddrLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_82 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::BlockLengthLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_83 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::OffsetLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_84 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::AllocableLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_85 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::FreeableLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_86 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::AllocationLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_87 { $$ = new acsl::AutomaticLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_88 { $$ = new acsl::DynamicLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_89 { $$ = new acsl::RegisterLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_90 { $$ = new acsl::StaticLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_91 { $$ = new acsl::UnallocatedLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_92 { $$ = new acsl::NullLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _INTEGER_ { $$ = new acsl::LexprIntConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _DOUBLE_ { $$ = new acsl::LexprFloatConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _STRING_ { $$ = new acsl::LexprStringConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | T_WSTRING_CONSTANT { $$ = new acsl::LexprWStringConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _PLUS Lexpr3 { $$ = new acsl::AddLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _MINUS Lexpr3 { $$ = new acsl::SubtrLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _STAR Lexpr3 { $$ = new acsl::MultLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _SLASH Lexpr3 { $$ = new acsl::DivLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _PERCENT Lexpr3 { $$ = new acsl::ModLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _SYMB_93 Lexpr3 { $$ = new acsl::StarHatLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _RARROW IdentifierOrTypenameFull { $$ = new acsl::ArrowLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _DOT IdentifierOrTypenameFull { $$ = new acsl::DotLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _LBRACK Range _RBRACK { $$ = new acsl::SquaresRangeLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _LBRACK Lexpr _RBRACK { $$ = new acsl::SquaresLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_96 LexprList _SYMB_97 { $$ = new acsl::SquaresPipeLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _MINUS Lexpr3 { $$ = new acsl::MinusLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _PLUS Lexpr3 { $$ = new acsl::PlusLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _TILDE Lexpr3 { $$ = new acsl::TildeLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _STAR Lexpr3 { $$ = new acsl::StarLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _AMP Lexpr3 { $$ = new acsl::AmpUnaryLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _KW_sizeof _LPAREN Lexpr _RPAREN { $$ = new acsl::SizeOfLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _KW_sizeof _LPAREN CastLogicType _RPAREN { $$ = new acsl::SizeOfLogicTypeLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_98 _LPAREN Lexpr _RPAREN { $$ = new acsl::OldLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_99 _LPAREN Lexpr _COMMA LabelName _RPAREN { $$ = new acsl::AtLexpr($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_100 { $$ = new acsl::ResultLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_101 _LPAREN ListLexpr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::SeparatedLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | FullIdentifier _LPAREN ListLexpr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::FullIdParenLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | FullIdentifier _LBRACE ListIdentifierOrTypenameFull _RBRACE _LPAREN ListLexpr _RPAREN { std::reverse($3->begin(),$3->end()) ; std::reverse($6->begin(),$6->end()) ;$$ = new acsl::FullIdBraceParenLexpr($1, $3, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | FullIdentifier _LBRACE ListIdentifierOrTypenameFull _RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::FullIdBracesLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | FullIdentifier { $$ = new acsl::FullId($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_104 { $$ = new acsl::PiLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _DGT Lexpr3 { $$ = new acsl::LessLessLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _DLT Lexpr3 { $$ = new acsl::GreaterGreaterLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LPAREN Lexpr _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LPAREN Range _RPAREN { $$ = new acsl::ParenRangeLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LPAREN CastLogicType _RPAREN Lexpr3 { $$ = new acsl::CastLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_105 _LPAREN Lexpr _RPAREN { $$ = new acsl::TypeOfLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_106 _LPAREN TypeSpecOFTYPENAME _RPAREN { $$ = new acsl::TypeLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_106 _LPAREN TypeSpecOFTYPENAME ListStars _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::TypeWithStarsLexpr($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_107 { $$ = new acsl::EmptyLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_108 _LPAREN LexprList _RPAREN { $$ = new acsl::UnionLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_109 _LPAREN LexprList _RPAREN { $$ = new acsl::InterLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LBRACE LexprList _RBRACE { $$ = new acsl::BraceLexprList($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LBRACE Lexpr _BAR Binders _RBRACE { $$ = new acsl::BraceBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LBRACE Lexpr _BAR Binders _SEMI Lexpr _RBRACE { $$ = new acsl::BraceBinderLexprLexpr($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LBRACE ListFieldInitElt _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::FieldInitLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LBRACE ListArrayInitElt _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ArrayInitLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LBRACE Lexpr _SYMB_110 ListUpdateElt _RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::UpdateBraceLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
ListSTRING_LITERAL : T_STRING_LITERAL { $$ = new acsl::ListSTRING_LITERAL(); $$->push_back($1); result->liststring_literal_ = $$; }
  | T_STRING_LITERAL ListSTRING_LITERAL { $2->push_back($1); $$ = $2; result->liststring_literal_ = $$; }
;
Range : LexprOption _DDOT LexprOption { $$ = new acsl::LexprRange($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->range_ = $$; }
;
FieldInitElt : _DOT IdentifierOrTypenameFull _EQ Lexpr { $$ = new acsl::AFieldInitElt($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fieldinitelt_ = $$; }
;
ListFieldInitElt : FieldInitElt { $$ = new acsl::ListFieldInitElt(); $$->push_back($1); result->listfieldinitelt_ = $$; }
  | FieldInitElt _COMMA ListFieldInitElt { $3->push_back($1); $$ = $3; result->listfieldinitelt_ = $$; }
;
ArrayInitElt : _LBRACK Lexpr _RBRACK _EQ Lexpr { $$ = new acsl::AnArrayInitElt($2, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arrayinitelt_ = $$; }
  | _LBRACK Range _RBRACK _EQ Lexpr { $$ = new acsl::ArrayInitRangeElt($2, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arrayinitelt_ = $$; }
;
ListArrayInitElt : ArrayInitElt { $$ = new acsl::ListArrayInitElt(); $$->push_back($1); result->listarrayinitelt_ = $$; }
  | ArrayInitElt _COMMA ListArrayInitElt { $3->push_back($1); $$ = $3; result->listarrayinitelt_ = $$; }
;
UpdateElt : ListPathElt _EQ Lexpr { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AnUpdateElt($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->updateelt_ = $$; }
  | ListPathElt _EQ _LBRACE _SYMB_110 ListUpdateElt _RBRACE { std::reverse($1->begin(),$1->end()) ; std::reverse($5->begin(),$5->end()) ;$$ = new acsl::UpdateEltWith($1, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->updateelt_ = $$; }
;
ListUpdateElt : UpdateElt { $$ = new acsl::ListUpdateElt(); $$->push_back($1); result->listupdateelt_ = $$; }
  | UpdateElt _COMMA ListUpdateElt { $3->push_back($1); $$ = $3; result->listupdateelt_ = $$; }
;
PathElt : _DOT IdentifierOrTypenameFull { $$ = new acsl::FieldElt($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pathelt_ = $$; }
  | _LBRACK Lexpr _RBRACK { $$ = new acsl::ArrayElt($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pathelt_ = $$; }
  | _LBRACK Range _RBRACK { $$ = new acsl::ArrayRangeElt($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pathelt_ = $$; }
;
ListPathElt : PathElt { $$ = new acsl::ListPathElt(); $$->push_back($1); result->listpathelt_ = $$; }
  | PathElt ListPathElt { $2->push_back($1); $$ = $2; result->listpathelt_ = $$; }
;
Binders : TypeSpecOFTYPENAME VarSpec _COMMA ListBindersReentrance { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::TheBinders($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->binders_ = $$; }
;
BindersReentrance : TypeSpecOFTYPENAME VarSpec { $$ = new acsl::BindersReentranceDeclSpec($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bindersreentrance_ = $$; }
  | VarSpec { $$ = new acsl::BindersReentranceVarSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bindersreentrance_ = $$; }
;
ListBindersReentrance : BindersReentrance { $$ = new acsl::ListBindersReentrance(); $$->push_back($1); result->listbindersreentrance_ = $$; }
  | BindersReentrance _COMMA ListBindersReentrance { $3->push_back($1); $$ = $3; result->listbindersreentrance_ = $$; }
;
VarSpec : VarSpec1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | ListStars VarSpec1 { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::StartVarSpec($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
;
ArraySize : _INTEGER_ { $$ = new acsl::IntConstArraySize($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arraysize_ = $$; }
  | FullIdentifier { $$ = new acsl::SomeArraySize($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arraysize_ = $$; }
  | /* empty */ { $$ = new acsl::NoSize(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arraysize_ = $$; }
;
VarSpec1 : FullIdentifier { $$ = new acsl::SimpleSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | VarSpec1 _LBRACK ArraySize _RBRACK { $$ = new acsl::ArraySpec($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | _LPAREN VarSpec _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | VarSpec1 _LPAREN AbsParamTypeList _RPAREN { $$ = new acsl::FunctionSpec($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
;
AbsParamTypeList : /* empty */ { $$ = new acsl::EmptyTypeParam(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absparamtypelist_ = $$; }
  | ListAbsParam { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeTypeParam($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absparamtypelist_ = $$; }
  | ListAbsParam _COMMA _ELLIPSIS { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::InfTypeParam($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absparamtypelist_ = $$; }
;
AbsParam : LogicTypeGenOFTYPENAME { $$ = new acsl::AbsParamsElement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absparam_ = $$; }
;
ListAbsParam : AbsParam { $$ = new acsl::ListAbsParam(); $$->push_back($1); result->listabsparam_ = $$; }
  | AbsParam _COMMA ListAbsParam { $3->push_back($1); $$ = $3; result->listabsparam_ = $$; }
;
Parameter : TypeSpecOFIdentifierOrTypename VarSpec { $$ = new acsl::Prartemer($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameter_ = $$; }
;
ListParameter : Parameter { $$ = new acsl::ListParameter(); $$->push_back($1); result->listparameter_ = $$; }
  | Parameter _COMMA ListParameter { $3->push_back($1); $$ = $3; result->listparameter_ = $$; }
;
LogicTypeGenOFTYPENAME : TypeSpecOFTYPENAME AbsSpecOption { $$ = new acsl::LogicTypeGenTypemane($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logictypegenoftypename_ = $$; }
;
ListLogicTypeGenOFTYPENAME : LogicTypeGenOFTYPENAME { $$ = new acsl::ListLogicTypeGenOFTYPENAME(); $$->push_back($1); result->listlogictypegenoftypename_ = $$; }
  | LogicTypeGenOFTYPENAME _COMMA ListLogicTypeGenOFTYPENAME { $3->push_back($1); $$ = $3; result->listlogictypegenoftypename_ = $$; }
;
LogicTypeGenOFIdentifierOrTypename : TypeSpecOFIdentifierOrTypename AbsSpecOption { $$ = new acsl::LogicTypeGenIdOrTypename($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logictypegenofidentifierortypename_ = $$; }
;
ListLogicTypeGenOFIdentifierOrTypename : LogicTypeGenOFIdentifierOrTypename { $$ = new acsl::ListLogicTypeGenOFIdentifierOrTypename(); $$->push_back($1); result->listlogictypegenofidentifierortypename_ = $$; }
  | LogicTypeGenOFIdentifierOrTypename _COMMA ListLogicTypeGenOFIdentifierOrTypename { $3->push_back($1); $$ = $3; result->listlogictypegenofidentifierortypename_ = $$; }
;
CV : _KW_const { $$ = new acsl::ConstCV(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cv_ = $$; }
  | _KW_volatile { $$ = new acsl::VolatileCV(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cv_ = $$; }
  | _SYMB_56 { $$ = new acsl::GhostCV(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cv_ = $$; }
;
ListCV : /* empty */ { $$ = new acsl::ListCV(); result->listcv_ = $$; }
  | ListCV CV { $1->push_back($2); $$ = $1; result->listcv_ = $$; }
;
TypeSpecCVOFTYPENAME : ListCV TypeSpecOFTYPENAME ListCV { $$ = new acsl::TypeSpecCVTypename($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespeccvoftypename_ = $$; }
;
CastLogicType : TypeSpecCVOFTYPENAME AbsSpecCVOption { $$ = new acsl::AnCastLogicType($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->castlogictype_ = $$; }
;
LogicRtType : LogicTypeGenOFIdentifierOrTypename { $$ = new acsl::LogicRTType($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrttype_ = $$; }
;
AbsSpecOption : /* empty */ { $$ = new acsl::NoAbsSpec(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspecoption_ = $$; }
  | AbsSpec { $$ = new acsl::SomeAbsSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspecoption_ = $$; }
;
AbsSpecCVOption : /* empty */ { $$ = new acsl::NoAbsSpecCV(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccvoption_ = $$; }
  | AbsSpecCV { $$ = new acsl::SomeAbsSpecCV($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccvoption_ = $$; }
;
AbsSpec : ListTabs { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AbsSpecTabs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | ListStars { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AbsSpecStars($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | ListStars ListTabs { std::reverse($1->begin(),$1->end()) ; std::reverse($2->begin(),$2->end()) ;$$ = new acsl::AbsSpecStarsTabs($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | ListStars AbsSpec1 { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AbsSpecBitsStars($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | ListStars AbsSpec1 ListTabs { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new acsl::AbsSpecBitsStarsTabs($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | AbsSpec1 ListTabs { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::AbsSpecBitsTabs($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | AbsSpec1 { $$ = new acsl::AbsSpecBits($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
;
AbsSpecCV : ListTabs { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AbsSpecCVTabs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | ListStarsCV { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AbsSpecCVStars($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | ListStarsCV ListTabs { std::reverse($1->begin(),$1->end()) ; std::reverse($2->begin(),$2->end()) ;$$ = new acsl::AbsSpecCVStarsTabs($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | ListStarsCV AbsSpecCV1 { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AbsSpecCVBitsStars($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | ListStarsCV AbsSpecCV1 ListTabs { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new acsl::AbsSpecCVBitsStarsTabs($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | AbsSpecCV1 ListTabs { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::AbsSpecCVBitsTabs($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | AbsSpecCV1 { $$ = new acsl::AbsSpecCVBits($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
;
AbsSpec1 : _LPAREN AbsSpec _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
  | AbsSpec1 _LPAREN AbsParamTypeList _RPAREN { $$ = new acsl::AbsSpecBitsParams($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspec_ = $$; }
;
AbsSpecCV1 : _LPAREN AbsSpecCV _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
  | AbsSpecCV1 _LPAREN AbsParamTypeList _RPAREN { $$ = new acsl::AbsSpecBitsCVParams($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->absspeccv_ = $$; }
;
Stars : _STAR { $$ = new acsl::Star(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->stars_ = $$; }
;
ListStars : Stars { $$ = new acsl::ListStars(); $$->push_back($1); result->liststars_ = $$; }
  | Stars ListStars { $2->push_back($1); $$ = $2; result->liststars_ = $$; }
;
StarsCV : _STAR { $$ = new acsl::StarCV(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->starscv_ = $$; }
  | _STAR CV { $$ = new acsl::StarCVWithCV($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->starscv_ = $$; }
;
ListStarsCV : StarsCV { $$ = new acsl::ListStarsCV(); $$->push_back($1); result->liststarscv_ = $$; }
  | StarsCV ListStarsCV { $2->push_back($1); $$ = $2; result->liststarscv_ = $$; }
;
Tabs : _LBRACK ArraySize _RBRACK { $$ = new acsl::Tab($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->tabs_ = $$; }
;
ListTabs : Tabs { $$ = new acsl::ListTabs(); $$->push_back($1); result->listtabs_ = $$; }
  | Tabs ListTabs { $2->push_back($1); $$ = $2; result->listtabs_ = $$; }
;
TypeSpecSimple : _KW_integer { $$ = new acsl::TypeSpecSimpleIntegerKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_real { $$ = new acsl::TypeSpecSimpleRealKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_boolean { $$ = new acsl::TypeSpecSimpleBooleanKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_void { $$ = new acsl::TypeSpecSimpleVoidKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _SYMB_53 { $$ = new acsl::TypeSpecSimpleBoolKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_char { $$ = new acsl::TypeSpecSimpleCharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_char { $$ = new acsl::TypeSpecSimpleSignedCharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_char { $$ = new acsl::TypeSpecSimpleUnsignedCharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_int { $$ = new acsl::TypeSpecSimpleIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_int { $$ = new acsl::TypeSpecSimpleSignedIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_int { $$ = new acsl::TypeSpecSimpleUnsignedIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned { $$ = new acsl::TypeSpecSimpleUnsignedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_short { $$ = new acsl::TypeSpecSimpleShortKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_short { $$ = new acsl::TypeSpecSimpleSignedShortKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_short { $$ = new acsl::TypeSpecSimpleUnsignedShortKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_short _KW_int { $$ = new acsl::TypeSpecSimpleShortIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_short _KW_int { $$ = new acsl::TypeSpecSimpleSignedShortIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_short _KW_int { $$ = new acsl::TypeSpecSimpleUnsignedShortIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_long { $$ = new acsl::TypeSpecSimpleLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_long { $$ = new acsl::TypeSpecSimpleSignedLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_long { $$ = new acsl::TypeSpecSimpleUnsignedLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_long _KW_int { $$ = new acsl::TypeSpecSimpleSignedLongIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_long _KW_int { $$ = new acsl::TypeSpecSimpleLongIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_long _KW_int { $$ = new acsl::TypeSpecSimpleUnsignedLongIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_long _KW_long { $$ = new acsl::TypeSpecSimpleLongLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_long _KW_long { $$ = new acsl::TypeSpecSimpleSignedLongLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_long _KW_long { $$ = new acsl::TypeSpecSimpleUnsignedLongLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_long _KW_long _KW_int { $$ = new acsl::TypeSpecSimpleLongLongIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_signed _KW_long _KW_long _KW_int { $$ = new acsl::TypeSpecSimpleSignedLongLongIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_unsigned _KW_long _KW_long _KW_int { $$ = new acsl::TypeSpecSimpleUnsignedLongLongIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_float { $$ = new acsl::TypeSpecSimpleFloatKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_double { $$ = new acsl::TypeSpecSimpleDoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_long _KW_double { $$ = new acsl::TypeSpecSimpleLongDoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_struct IdentifierOrTypenameFull { $$ = new acsl::TypeSpecSimpleStruct($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_enum IdentifierOrTypenameFull { $$ = new acsl::TypeSpecSimpleEnum($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_union IdentifierOrTypenameFull { $$ = new acsl::TypeSpecSimpleUnion($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
;
TypeSpecOFTYPENAME : T_TYPENAME { $$ = new acsl::TypeSpecTYPENAME($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecoftypename_ = $$; }
  | T_TYPENAME _LT ListLogicTypeGenOFTYPENAME _GT { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::TypeSpecTYPENAMELogicTypeGen($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecoftypename_ = $$; }
  | TypeSpecSimple { $$ = new acsl::TypeSpecSimpleFromTypenameTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecoftypename_ = $$; }
;
TypeSpecOFIdentifierOrTypename : IdentifierOrTypename { $$ = new acsl::TypeSpecIdentifierOrTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecofidentifierortypename_ = $$; }
  | IdentifierOrTypename _LT ListLogicTypeGenOFIdentifierOrTypename _GT { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::TypeSpecIdentifierOrTypenameAngles($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecofidentifierortypename_ = $$; }
  | TypeSpecSimple { $$ = new acsl::TypeSpecSimpleFromIdTypenameTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecofidentifierortypename_ = $$; }
;
FullIdentifier : Identifier { $$ = new acsl::SimpleIdentifierFull($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_admit { $$ = new acsl::AdmitKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_allocates { $$ = new acsl::AllocatesKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_assert { $$ = new acsl::AssertKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Assigns { $$ = new acsl::AssignsKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Assumes { $$ = new acsl::AssumesKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_at { $$ = new acsl::AtKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_axiom { $$ = new acsl::AxiomKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_axiomatic { $$ = new acsl::AxiomaticKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_behavior { $$ = new acsl::BehaviorKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_breaks { $$ = new acsl::BreaksKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_check { $$ = new acsl::CheckKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_complete { $$ = new acsl::CompleteKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_continues { $$ = new acsl::ContinuesKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Contract { $$ = new acsl::ContractKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Decreases { $$ = new acsl::DecreasesKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_disjoint { $$ = new acsl::DisjointKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_ensures { $$ = new acsl::EnsuresKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_exits { $$ = new acsl::ExitsKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_frees { $$ = new acsl::FreesKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_function { $$ = new acsl::FunctionKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_global { $$ = new acsl::GlobalKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_impact { $$ = new acsl::ImpactKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_inductive { $$ = new acsl::InductiveKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_include { $$ = new acsl::IncludeKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_invariant { $$ = new acsl::InvariantKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_lemma { $$ = new acsl::LemmaKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_let { $$ = new acsl::LetKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_logic { $$ = new acsl::LogicKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_loop { $$ = new acsl::LoopKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_model { $$ = new acsl::ModelKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_module { $$ = new acsl::ModuleKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_pragma { $$ = new acsl::PragmaKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_predicate { $$ = new acsl::PredicateKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Requires { $$ = new acsl::RequiresKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_returns { $$ = new acsl::ReturnsKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_slice { $$ = new acsl::SliceKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Terminates { $$ = new acsl::TerminatesKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_type { $$ = new acsl::TypeKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | _KW_Variant { $$ = new acsl::VariantKeyWordFullIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | T_EXT_CODE_ANNOT { $$ = new acsl::IdentExtCodeAnnotFullIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | T_EXT_CONTRACT { $$ = new acsl::IdentExtContractFullIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | T_EXT_GLOBAL { $$ = new acsl::IdentExtGlobalFullIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
  | T_EXT_GLOBAL_BLOCK { $$ = new acsl::IdentExtGlobalBlockFullIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
;
ListFullIdentifier : FullIdentifier { $$ = new acsl::ListFullIdentifier(); $$->push_back($1); result->listfullidentifier_ = $$; }
  | FullIdentifier _COMMA ListFullIdentifier { $3->push_back($1); $$ = $3; result->listfullidentifier_ = $$; }
;
ExtSpec : ExtGlobalClausesOpt ExtModuleSpecsOpt ExtGlobalSpecsOpt { $$ = new acsl::ExrSpec($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extspec_ = $$; }
;
ExtGlobalClausesOpt : /* empty */ { $$ = new acsl::EmptyExtGlobalClauses(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalclausesopt_ = $$; }
  | ListExtGlobalClause { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeExtGlobalClauses($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalclausesopt_ = $$; }
;
ExtGlobalClause : Decl { $$ = new acsl::DeclClause($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalclause_ = $$; }
  | _KW_let AnyIdentifier _EQ Lexpr _SEMI { $$ = new acsl::LetClause($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalclause_ = $$; }
  | _KW_global _KW_let AnyIdentifier _EQ Lexpr _SEMI { $$ = new acsl::GlobalLetClause($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalclause_ = $$; }
  | _KW_include ListSTRING_LITERAL _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::IncludeClause($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalclause_ = $$; }
;
ListExtGlobalClause : ExtGlobalClause { $$ = new acsl::ListExtGlobalClause(); $$->push_back($1); result->listextglobalclause_ = $$; }
  | ExtGlobalClause ListExtGlobalClause { $2->push_back($1); $$ = $2; result->listextglobalclause_ = $$; }
;
ExtGlobalSpecsOpt : /* empty */ { $$ = new acsl::EmptyExtGlobalSpecs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalspecsopt_ = $$; }
  | ListExtGlobalSpec { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeExtGlobalSpecs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalspecsopt_ = $$; }
;
ExtGlobalSpec : _KW_module AnyIdentifier _COLON ListExtGlobalClause ListExtModuleSpec { std::reverse($4->begin(),$4->end()) ; std::reverse($5->begin(),$5->end()) ;$$ = new acsl::ExtGlobalSpecClauseModule($2, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalspec_ = $$; }
  | _KW_module AnyIdentifier _COLON ListExtModuleSpec { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::ExtGlobalSpecModule($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalspec_ = $$; }
  | _KW_module AnyIdentifier _COLON ListExtGlobalClause { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::ExtGlobalSpecClause($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalspec_ = $$; }
  | _KW_module AnyIdentifier _COLON { $$ = new acsl::ExtGlobalSpecSimple($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extglobalspec_ = $$; }
;
ListExtGlobalSpec : ExtGlobalSpec { $$ = new acsl::ListExtGlobalSpec(); $$->push_back($1); result->listextglobalspec_ = $$; }
  | ExtGlobalSpec ListExtGlobalSpec { $2->push_back($1); $$ = $2; result->listextglobalspec_ = $$; }
;
ExtModuleSpecsOpt : /* empty */ { $$ = new acsl::EmptyExtModuleSpecs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extmodulespecsopt_ = $$; }
  | ListExtModuleSpec { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ListExtModuleSpecs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extmodulespecsopt_ = $$; }
  | ListExtFunSpec { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::FunSpecExtModuleSpecs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extmodulespecsopt_ = $$; }
  | ListExtFunSpec ListExtModuleSpec { std::reverse($1->begin(),$1->end()) ; std::reverse($2->begin(),$2->end()) ;$$ = new acsl::FunSpecWithListModules($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extmodulespecsopt_ = $$; }
;
ExtModuleSpec : _KW_function AnyIdentifier _COLON ExtFunctionSpecsOpt { $$ = new acsl::AnExtModuleSpec($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extmodulespec_ = $$; }
;
ListExtModuleSpec : ExtModuleSpec { $$ = new acsl::ListExtModuleSpec(); $$->push_back($1); result->listextmodulespec_ = $$; }
  | ExtModuleSpec ListExtModuleSpec { $2->push_back($1); $$ = $2; result->listextmodulespec_ = $$; }
;
ExtFunctionSpecsOpt : /* empty */ { $$ = new acsl::NoExtFunctionSpecs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspecsopt_ = $$; }
  | ExtFunctionSpecs { $$ = new acsl::SomeExtFunctionSpecs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspecsopt_ = $$; }
;
ExtFunctionSpecs : _KW_at ListStmtMarkup _COLON { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::AtMarkup($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspecs_ = $$; }
  | ListExtFunctionSpec { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ListFunctionSpecs($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspecs_ = $$; }
  | ListExtFunctionSpec _KW_at ListStmtMarkup _COLON { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new acsl::ListFunctionSpecsAtMarkup($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspecs_ = $$; }
;
ExtFunctionSpec : ExtGlobalClause { $$ = new acsl::AnExtGlobalClause($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspec_ = $$; }
  | ExtFunSpec { $$ = new acsl::AnExtFunSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunctionspec_ = $$; }
;
ListExtFunctionSpec : ExtFunctionSpec { $$ = new acsl::ListExtFunctionSpec(); $$->push_back($1); result->listextfunctionspec_ = $$; }
  | ExtFunctionSpec ListExtFunctionSpec { $2->push_back($1); $$ = $2; result->listextfunctionspec_ = $$; }
;
ExtFunSpec : _KW_at ListStmtMarkup _COLON Annotation { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::FunSpecAtAnnotation($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunspec_ = $$; }
  | _KW_at ListStmtMarkup _COLON _KW_Contract ExtIdentifierOpt _COLON Contract { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::FunSpecAtContract($2, $5, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunspec_ = $$; }
  | _KW_Contract ExtIdentifierOpt _COLON Contract { $$ = new acsl::FunSpecContract($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extfunspec_ = $$; }
;
ListExtFunSpec : ExtFunSpec { $$ = new acsl::ListExtFunSpec(); $$->push_back($1); result->listextfunspec_ = $$; }
  | ExtFunSpec ListExtFunSpec { $2->push_back($1); $$ = $2; result->listextfunspec_ = $$; }
;
ExtIdentifierOpt : /* empty */ { $$ = new acsl::ExtIdentifierEmpty(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extidentifieropt_ = $$; }
  | AnyIdentifier { $$ = new acsl::ExtIdentifierSome($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extidentifieropt_ = $$; }
;
StmtMarkup : AnyIdentifier { $$ = new acsl::MarkupStmtIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->stmtmarkup_ = $$; }
  | _INTEGER_ { $$ = new acsl::MarkupIntConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->stmtmarkup_ = $$; }
;
ListStmtMarkup : StmtMarkup { $$ = new acsl::ListStmtMarkup(); $$->push_back($1); result->liststmtmarkup_ = $$; }
  | StmtMarkup ListStmtMarkup { $2->push_back($1); $$ = $2; result->liststmtmarkup_ = $$; }
;
Spec : Contract { $$ = new acsl::SpecConstract($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->spec_ = $$; }
;
Contract : Requires Terminates Decreases SimpleClauses Behaviors CompleteOrDisjoint { $$ = new acsl::SimpleContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires NETerminates _KW_Requires { $$ = new acsl::TerminatesRequiresContract($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates NEDecreases _KW_Requires { $$ = new acsl::DecreasesRequiresContract($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates NEDecreases _KW_Terminates { $$ = new acsl::DecreasesTerminatesContract($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases NESimpleClauses _KW_Requires { $$ = new acsl::ClausesRequiresContract($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases NESimpleClauses _KW_Terminates { $$ = new acsl::ClausesTerminatesContract($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases NESimpleClauses _KW_Decreases { $$ = new acsl::ClausesDecreasesContract($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses NEBehaviors _KW_Terminates { $$ = new acsl::BehaviorsTerminatesContract($1, $2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses NEBehaviors _KW_Decreases { $$ = new acsl::BehaviorsDecreasesContract($1, $2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_Requires { $$ = new acsl::ComplDisjRequiresContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_Terminates { $$ = new acsl::ComplDisjTerminatesContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_Decreases { $$ = new acsl::ComplDisjDecreasesContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_behavior { $$ = new acsl::ComplDisjBehaviorContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_Assigns { $$ = new acsl::ComplDisjAssignsContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_allocates { $$ = new acsl::ComplDisjAllocatesContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint _KW_frees { $$ = new acsl::ComplDisjFreesContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
  | Requires Terminates Decreases SimpleClauses Behaviors NECompleteOrDisjoint PostCond { $$ = new acsl::ComplDisjPostCondContract($1, $2, $3, $4, $5, $6, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
;
ClauseKW : _KW_admit _KW_requires { $$ = new acsl::AdmitRequiresClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_admit _KW_invariant { $$ = new acsl::AdmitInvariantClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_admit _KW_lemma { $$ = new acsl::AdmitLemmaClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_admit _KW_loop { $$ = new acsl::AdmitLoopClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_check _KW_requires { $$ = new acsl::CheckRequiresClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_check _KW_invariant { $$ = new acsl::CheckInvariantClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_check _KW_lemma { $$ = new acsl::CheckLemmaClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_check _KW_loop { $$ = new acsl::CheckLoopClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_Requires { $$ = new acsl::RequiresClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_Assumes { $$ = new acsl::AssumesClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_Assigns { $$ = new acsl::AssignsClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | PostCond { $$ = new acsl::PostCondClause($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_Decreases { $$ = new acsl::DecreasesClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_behavior { $$ = new acsl::BehaviorClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_allocates { $$ = new acsl::AllocatesClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_frees { $$ = new acsl::FreesClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_complete { $$ = new acsl::CompleteClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | _KW_disjoint { $$ = new acsl::DisjointClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | T_EXT_CONTRACT { $$ = new acsl::ClauseExtConstract($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
  | /* empty */ { $$ = new acsl::EmptyClauseKW(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->clausekw_ = $$; }
;
Requires : /* empty */ { $$ = new acsl::NoRequires(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->requires_ = $$; }
  | NERequires { $$ = new acsl::SomeRequires($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->requires_ = $$; }
;
NERequires : _KW_Requires Lexpr _SEMI Requires { $$ = new acsl::SimpleRequires($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_check _KW_requires Lexpr _SEMI Requires { $$ = new acsl::CheckRequires($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_admit _KW_requires Lexpr _SEMI Requires { $$ = new acsl::AdimtRequires($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_Requires Lexpr ClauseKW { $$ = new acsl::ClauseSimpleRequires($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_check _KW_requires Lexpr ClauseKW { $$ = new acsl::ClauseCheckRequires($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_admit _KW_requires Lexpr ClauseKW { $$ = new acsl::ClauseAdimtRequires($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
;
Terminates : /* empty */ { $$ = new acsl::NoTerminate(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->terminates_ = $$; }
  | NETerminates { $$ = new acsl::SomeTerminate($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->terminates_ = $$; }
;
NETerminates : _KW_Terminates Lexpr _SEMI { $$ = new acsl::SimpleTerminates($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->neterminates_ = $$; }
  | _KW_Terminates Lexpr ClauseKW { $$ = new acsl::ClauseTerminates($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->neterminates_ = $$; }
;
Decreases : /* empty */ { $$ = new acsl::NoDecreases(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decreases_ = $$; }
  | NEDecreases { $$ = new acsl::SomeDecreases($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decreases_ = $$; }
;
NEDecreases : _KW_Decreases Variant _SEMI { $$ = new acsl::SimpleDecreases($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nedecreases_ = $$; }
  | _KW_Decreases Variant ClauseKW { $$ = new acsl::ClauseDecreases($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nedecreases_ = $$; }
;
Variant : Lexpr _KW_for AnyIdentifier { $$ = new acsl::ForVariant($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->variant_ = $$; }
  | Lexpr { $$ = new acsl::LexprVariant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->variant_ = $$; }
;
SimpleClauses : /* empty */ { $$ = new acsl::NoSimpleClauses(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->simpleclauses_ = $$; }
  | NESimpleClauses { $$ = new acsl::SomeSimpleClauses($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->simpleclauses_ = $$; }
;
Allocation : _KW_allocates Zones { $$ = new acsl::AllocatesZones($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->allocation_ = $$; }
  | _KW_frees Zones { $$ = new acsl::FreesZones($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->allocation_ = $$; }
;
NESimpleClauses : PostCond Lexpr _SEMI SimpleClauses { $$ = new acsl::PostCondSimpleClauses($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | Allocation _SEMI SimpleClauses { $$ = new acsl::AllocationSimpleClauses($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | _KW_Assigns Assigns _SEMI SimpleClauses { $$ = new acsl::AssignsSimpleClauses($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | T_EXT_CONTRACT ExtensionContent _SEMI SimpleClauses { $$ = new acsl::ExtContractSimpleClauses($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | PostCond Lexpr ClauseKW { $$ = new acsl::ClausesPostCondSimpleClauses($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | Allocation ClauseKW { $$ = new acsl::ClausesAllocationSimpleClauses($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | _KW_Assigns Assigns ClauseKW { $$ = new acsl::ClausesAssignsSimpleClauses($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | T_EXT_CONTRACT Zones ClauseKW { $$ = new acsl::ExtConClausestractSimpleClauses($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
;
ExtensionContent : /* empty */ { $$ = new acsl::NoExtensionContent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extensioncontent_ = $$; }
  | Zones { $$ = new acsl::SomeExtensionContent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extensioncontent_ = $$; }
;
Behaviors : /* empty */ { $$ = new acsl::NoBehaviors(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviors_ = $$; }
  | NEBehaviors { $$ = new acsl::SomeBehaviors($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviors_ = $$; }
;
NEBehaviors : _KW_behavior BehaviorName _COLON BehaviorBody Behaviors { $$ = new acsl::TheBehaviors($2, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nebehaviors_ = $$; }
;
BehaviorBody : Assumes Requires SimpleClauses { $$ = new acsl::SimpleClausesBehavior($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviorbody_ = $$; }
  | Assumes NERequires _KW_Assumes { $$ = new acsl::RequiresAssumes($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviorbody_ = $$; }
  | Assumes Requires NESimpleClauses _KW_Assumes { $$ = new acsl::SimpleClausesAssumes($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviorbody_ = $$; }
  | Assumes Requires NESimpleClauses _KW_Requires { $$ = new acsl::RequiresRequires($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviorbody_ = $$; }
;
Assumes : /* empty */ { $$ = new acsl::NoAssumes(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assumes_ = $$; }
  | _KW_Assumes Lexpr _SEMI Assumes { $$ = new acsl::SimpleAssumes($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assumes_ = $$; }
  | _KW_Assumes Lexpr ClauseKW { $$ = new acsl::ClauseAssumes($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assumes_ = $$; }
;
CompleteOrDisjoint : /* empty */ { $$ = new acsl::NoComplDisj(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->completeordisjoint_ = $$; }
  | NECompleteOrDisjoint { $$ = new acsl::SomeComplDisj($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->completeordisjoint_ = $$; }
;
NECompleteOrDisjoint : _KW_complete _KW_Behaviors BehaviorNameList _SEMI CompleteOrDisjoint { $$ = new acsl::CompleteBehavior($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->necompleteordisjoint_ = $$; }
  | _KW_disjoint _KW_Behaviors BehaviorNameList _SEMI CompleteOrDisjoint { $$ = new acsl::DisjointBehavior($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->necompleteordisjoint_ = $$; }
  | _KW_complete _KW_Behaviors ListBehaviorName ClauseKW { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::CompleteBehaviorClause($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->necompleteordisjoint_ = $$; }
  | _KW_disjoint _KW_Behaviors ListBehaviorName ClauseKW { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::DisjointBehaviorClause($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->necompleteordisjoint_ = $$; }
;
Assigns : Zones { $$ = new acsl::AssignZone($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assigns_ = $$; }
  | ListLexpr _SYMB_112 Zones { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AssignZoneFromZone($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assigns_ = $$; }
;
Zones : ListLexpr { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeZone($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->zones_ = $$; }
  | _SYMB_113 { $$ = new acsl::NoZone(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->zones_ = $$; }
;
LogicPTreeAnnot : Annotation { $$ = new acsl::AnAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicptreeannot_ = $$; }
  | IsACSLSpec ListWildcard { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ACSLSpec($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicptreeannot_ = $$; }
  | ListDecl { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AnnotDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicptreeannot_ = $$; }
;
ListLogicPTreeAnnot : /* empty */ { $$ = new acsl::ListLogicPTreeAnnot(); result->listlogicptreeannot_ = $$; }
  | ListLogicPTreeAnnot LogicPTreeAnnot { $1->push_back($2); $$ = $1; result->listlogicptreeannot_ = $$; }
;
Annotation : LoopAnnotStack { $$ = new acsl::LoopAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
  | _KW_for ListBehaviorName _COLON Contract { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ForContractAnnotation($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
  | _KW_for ListBehaviorName _COLON CodeAnnotation { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ForCodeAnnotation($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
  | PragmaOrCodeAnnotation { $$ = new acsl::SimplePragmaOrCodeAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
  | PragmaOrCodeAnnotation BegPragmaOrCodeAnnotation { $$ = new acsl::PragmaOrCodeAnnotationBeg($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
  | Identifier { $$ = new acsl::IdentifierAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
  | _SYMB_56 { $$ = new acsl::GhostAnnotation(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
;
LoopAnnotStack : LoopInvariant LoopAnnotOpt { $$ = new acsl::LoopAnnotStackInvariant($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopEffects LoopAnnotOpt { $$ = new acsl::LoopAnnotStackEffects($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopAllocation LoopAnnotOpt { $$ = new acsl::LoopAnnotStackAllocation($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | _KW_for ListBehaviorName _COLON LoopAnnotStack { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::LoopAnnotStackForBehavior($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopVariant LoopAnnotOpt { $$ = new acsl::LoopAnnotStackVariant($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopPragma LoopAnnotOpt { $$ = new acsl::LoopAnnotStackPragma($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopGrammarExtension LoopAnnotOpt { $$ = new acsl::LoopAnnotStackGrammarExten($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
;
LoopAnnotOpt : /* empty */ { $$ = new acsl::NoLoopAnnot(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotopt_ = $$; }
  | LoopAnnotStack { $$ = new acsl::SomeLoopAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotopt_ = $$; }
;
LoopEffects : _KW_loop _KW_Assigns Assigns _SEMI { $$ = new acsl::LoopAssigns($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopeffects_ = $$; }
;
LoopAllocation : _KW_loop Allocation _SEMI { $$ = new acsl::SimpleLoopAllocation($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopallocation_ = $$; }
;
LoopInvariant : _KW_loop _KW_invariant Lexpr _SEMI { $$ = new acsl::SimpleLoopInvariant($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopinvariant_ = $$; }
  | _KW_check _KW_loop _KW_invariant Lexpr _SEMI { $$ = new acsl::CheckLoopInvariant($4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopinvariant_ = $$; }
  | _KW_admit _KW_loop _KW_invariant Lexpr _SEMI { $$ = new acsl::AdmitLoopInvariant($4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopinvariant_ = $$; }
;
LoopVariant : _KW_loop _KW_Variant Variant _SEMI { $$ = new acsl::SimpleLoopVariant($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopvariant_ = $$; }
;
LoopGrammarExtension : _KW_loop T_EXT_CODE_ANNOT ExtensionContent _SEMI { $$ = new acsl::SimpleLoopGrammarExten($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopgrammarextension_ = $$; }
;
LoopPragma : _KW_loop _KW_pragma AnyIdentifier ListLexpr _SEMI { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::PragmaLoop($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->looppragma_ = $$; }
;
BegPragmaOrCodeAnnotation : _KW_impact { $$ = new acsl::ImpactKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_slice { $$ = new acsl::SliceKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_for { $$ = new acsl::ForKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_assert { $$ = new acsl::AssertKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_check { $$ = new acsl::CheckKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_admit { $$ = new acsl::AdmitKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_invariant { $$ = new acsl::InvariantKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_check _KW_invariant { $$ = new acsl::CheckInvariantKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_admit _KW_invariant { $$ = new acsl::AdmitInvariantKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_check _KW_loop { $$ = new acsl::CheckLoopKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | _KW_admit _KW_loop { $$ = new acsl::AdmitLoopKeyWordBegPragma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
  | T_EXT_CODE_ANNOT { $$ = new acsl::BegExtCodeAnnotBegPragma($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->begpragmaorcodeannotation_ = $$; }
;
PragmaOrCodeAnnotation : SlicePragma { $$ = new acsl::PragmaCodeAnnotSlice($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragmaorcodeannotation_ = $$; }
  | ImpactPragma { $$ = new acsl::PragmaCodeAnnotImpact($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragmaorcodeannotation_ = $$; }
  | CodeAnnotation { $$ = new acsl::PragmaOrCodeAnnotCodeAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pragmaorcodeannotation_ = $$; }
;
CodeAnnotation : _KW_assert Lexpr _SEMI { $$ = new acsl::AssertCodeAnnot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
  | _KW_check Lexpr _SEMI { $$ = new acsl::CheckCodeAnnot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
  | _KW_admit Lexpr _SEMI { $$ = new acsl::AdmitCodeAnnot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
  | _KW_invariant Lexpr _SEMI { $$ = new acsl::InvariantCodeAnnot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
  | _KW_check _KW_invariant Lexpr _SEMI { $$ = new acsl::CheckInvariantCodeAnnot($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
  | _KW_admit _KW_invariant Lexpr _SEMI { $$ = new acsl::AdmitInvariantCodeAnnot($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
  | T_EXT_CODE_ANNOT ExtensionContent _SEMI { $$ = new acsl::ExtCodeAnnotCodeAnnot($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->codeannotation_ = $$; }
;
SlicePragma : _KW_slice _KW_pragma AnyIdentifier Lexpr _SEMI { $$ = new acsl::PragmaSliceLexpr($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->slicepragma_ = $$; }
  | _KW_slice _KW_pragma AnyIdentifier _SEMI { $$ = new acsl::PragmaSlice($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->slicepragma_ = $$; }
;
ImpactPragma : _KW_impact _KW_pragma AnyIdentifier Lexpr _SEMI { $$ = new acsl::ImpactPragmaLexpr($3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->impactpragma_ = $$; }
  | _KW_impact _KW_pragma AnyIdentifier _SEMI { $$ = new acsl::AnImpactPragma($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->impactpragma_ = $$; }
;
Decl : _KW_global _KW_invariant AnyIdentifier _COLON Lexpr _SEMI { $$ = new acsl::DeclGlobalInvariant($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
  | _KW_volatile ListLexpr ListVolatileOpt _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::DeclVolatile($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
  | TypeAnnot { $$ = new acsl::DeclTypeAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
  | ModelAnnot { $$ = new acsl::DeclModelAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
  | LogicDef { $$ = new acsl::DeclLogicDef($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
  | ExtDecl { $$ = new acsl::DeclExt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
  | DeprecatedLogicDecl { $$ = new acsl::DeclDeprecatedLogic($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
;
ListDecl : Decl { $$ = new acsl::ListDecl(); $$->push_back($1); result->listdecl_ = $$; }
  | Decl ListDecl { $2->push_back($1); $$ = $2; result->listdecl_ = $$; }
;
ExtDecl : T_EXT_GLOBAL ExtensionContent _SEMI { $$ = new acsl::ExtGlobalDecl($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extdecl_ = $$; }
  | T_EXT_GLOBAL_BLOCK AnyIdentifier _LBRACE ListExtDecl _RBRACE { $$ = new acsl::ExtGlobalBlockDecl($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->extdecl_ = $$; }
;
ListExtDecl : /* empty */ { $$ = new acsl::ListExtDecl(); result->listextdecl_ = $$; }
  | ListExtDecl ExtDecl { $1->push_back($2); $$ = $1; result->listextdecl_ = $$; }
;
VolatileOpt : _KW_reads AnyIdentifier { $$ = new acsl::ReadVolotile($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->volatileopt_ = $$; }
  | _KW_writes AnyIdentifier { $$ = new acsl::WriteVolotile($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->volatileopt_ = $$; }
;
ListVolatileOpt : /* empty */ { $$ = new acsl::ListVolatileOpt(); result->listvolatileopt_ = $$; }
  | ListVolatileOpt VolatileOpt { $1->push_back($2); $$ = $1; result->listvolatileopt_ = $$; }
;
TypeAnnot : _KW_type _KW_invariant AnyIdentifier _LPAREN Parameter _RPAREN _EQ Lexpr _SEMI { $$ = new acsl::TypeInvariant($3, $5, $8); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typeannot_ = $$; }
;
OptSemicolon : /* empty */ { $$ = new acsl::NoSemicolon(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optsemicolon_ = $$; }
  | _SEMI { $$ = new acsl::Semicolon(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optsemicolon_ = $$; }
;
ModelAnnot : _KW_model TypeSpecOFTYPENAME _LBRACE Parameter OptSemicolon _RBRACE _SEMI { $$ = new acsl::ModelAnnotation($2, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->modelannot_ = $$; }
;
PolyIdType : FullIdentifier { $$ = new acsl::SimplePolyIdType($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->polyidtype_ = $$; }
  | FullIdentifier _LT ListFullIdentifier _GT { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::PolyIdTypeAngles($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->polyidtype_ = $$; }
;
PolyId : PolyIdType { $$ = new acsl::PolyTypeId($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->polyid_ = $$; }
  | FullIdentifier _LBRACE ListLabelName _RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::PolyIdTypeSquares($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->polyid_ = $$; }
  | FullIdentifier _LBRACE ListLabelName _RBRACE _LT ListFullIdentifier _GT { std::reverse($3->begin(),$3->end()) ; std::reverse($6->begin(),$6->end()) ;$$ = new acsl::PolyIdTypeSquaresAngles($1, $3, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->polyid_ = $$; }
;
OptParameters : /* empty */ { $$ = new acsl::NoParameters(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optparameters_ = $$; }
  | Parameters { $$ = new acsl::SomeParameters($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optparameters_ = $$; }
;
Parameters : _LPAREN ListParameter _RPAREN { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::AParameters($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameters_ = $$; }
;
LogicDef : _KW_logic LogicRtType PolyId OptParameters _EQ Lexpr _SEMI { $$ = new acsl::SimpleLogicDef($2, $3, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_predicate PolyId OptParameters _EQ Lexpr _SEMI { $$ = new acsl::PredicateLogicDef($2, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_inductive PolyId Parameters _LBRACE ListIndcase _RBRACE { $$ = new acsl::InductiveLogicDef($2, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_lemma PolyId _COLON Lexpr _SEMI { $$ = new acsl::LemmaLogicDef($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_check _KW_lemma PolyId _COLON Lexpr _SEMI { $$ = new acsl::CheckLemmaLogicDef($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_admit _KW_lemma PolyId _COLON Lexpr _SEMI { $$ = new acsl::AdmitLemmaLogicDef($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_axiomatic AnyIdentifier _LBRACE ListLogicDecl _RBRACE { $$ = new acsl::AxiomaticLogicDef($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
  | _KW_type PolyIdType _EQ Typedef _SEMI { $$ = new acsl::TypeLogicDef($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdef_ = $$; }
;
DeprecatedLogicDecl : _KW_logic LogicRtType PolyId OptParameters _SEMI { $$ = new acsl::SimpleDeprecatedLogicDecl($2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->deprecatedlogicdecl_ = $$; }
  | _KW_predicate PolyId OptParameters _SEMI { $$ = new acsl::PredicateDeprecatedLogicDecl($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->deprecatedlogicdecl_ = $$; }
  | _KW_type PolyIdType _SEMI { $$ = new acsl::TypeDeprecatedLogicDecl($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->deprecatedlogicdecl_ = $$; }
  | _KW_axiom PolyId _COLON Lexpr _SEMI { $$ = new acsl::AxiomDeprecatedLogicDecl($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->deprecatedlogicdecl_ = $$; }
;
LogicDecl : LogicDef { $$ = new acsl::LocidDeclDef($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdecl_ = $$; }
  | _KW_logic LogicRtType PolyId OptParameters ReadsClause _SEMI { $$ = new acsl::SimpleLogicDecl($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdecl_ = $$; }
  | _KW_predicate PolyId OptParameters ReadsClause _SEMI { $$ = new acsl::PredicateLogicDecl($2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdecl_ = $$; }
  | _KW_type PolyIdType _SEMI { $$ = new acsl::TypeLogicDecl($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdecl_ = $$; }
  | _KW_axiom PolyId _COLON Lexpr _SEMI { $$ = new acsl::AxiomLogicDecl($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicdecl_ = $$; }
;
ListLogicDecl : /* empty */ { $$ = new acsl::ListLogicDecl(); result->listlogicdecl_ = $$; }
  | ListLogicDecl LogicDecl { $1->push_back($2); $$ = $1; result->listlogicdecl_ = $$; }
;
ReadsClause : /* empty */ { $$ = new acsl::NoReadsClause(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->readsclause_ = $$; }
  | _KW_reads Zones { $$ = new acsl::SomeReadsClause($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->readsclause_ = $$; }
;
Typedef : ListDataconsWithSeparator { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ListOfDatacons($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typedef_ = $$; }
  | LogicTypeGenOFTYPENAME { $$ = new acsl::TypedefLogicTypeGen($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typedef_ = $$; }
;
DataconsWithSeparator : Datacons { $$ = new acsl::SimpleDataCons($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->dataconswithseparator_ = $$; }
  | _BAR Datacons { $$ = new acsl::DataConsWithPipe($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->dataconswithseparator_ = $$; }
;
ListDataconsWithSeparator : DataconsWithSeparator { $$ = new acsl::ListDataconsWithSeparator(); $$->push_back($1); result->listdataconswithseparator_ = $$; }
  | DataconsWithSeparator ListDataconsWithSeparator { $2->push_back($1); $$ = $2; result->listdataconswithseparator_ = $$; }
;
Datacons : FullIdentifier { $$ = new acsl::DataConsFullIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->datacons_ = $$; }
  | FullIdentifier _LPAREN ListLogicTypeGenOFTYPENAME _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::DataConsFullIdentifierFun($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->datacons_ = $$; }
;
Indcase : _KW_case PolyId _COLON Lexpr _SEMI { $$ = new acsl::IndCase($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->indcase_ = $$; }
;
ListIndcase : /* empty */ { $$ = new acsl::ListIndcase(); result->listindcase_ = $$; }
  | ListIndcase Indcase { $1->push_back($2); $$ = $1; result->listindcase_ = $$; }
;
OptLabel1 : OptLabelList { $$ = new acsl::OptLabelOne($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabel_ = $$; }
;
OptLabel2 : OptLabelList { $$ = new acsl::OptLabelTwo($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabel_ = $$; }
;
OptLabelList : /* empty */ { $$ = new acsl::NoLableList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabellist_ = $$; }
  | _LBRACE ListLabelName _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::LableList($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabellist_ = $$; }
;
LabelName : AnyIdentifier { $$ = new acsl::LableName($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->labelname_ = $$; }
;
ListLabelName : LabelName { $$ = new acsl::ListLabelName(); $$->push_back($1); result->listlabelname_ = $$; }
  | LabelName _COMMA ListLabelName { $3->push_back($1); $$ = $3; result->listlabelname_ = $$; }
;
BehaviorNameList : /* empty */ { $$ = new acsl::EmptyBehaviorNameList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviornamelist_ = $$; }
  | ListBehaviorName { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AnBehaviorNameList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviornamelist_ = $$; }
;
BehaviorName : AnyIdentifier { $$ = new acsl::BehaviorNameAnyIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviorname_ = $$; }
;
ListBehaviorName : BehaviorName { $$ = new acsl::ListBehaviorName(); $$->push_back($1); result->listbehaviorname_ = $$; }
  | BehaviorName _COMMA ListBehaviorName { $3->push_back($1); $$ = $3; result->listbehaviorname_ = $$; }
;
AnyIdentifier : Identifier { $$ = new acsl::SimpleIdentifierAny($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->anyidentifier_ = $$; }
  | IsACSLTypename { $$ = new acsl::ACSLTypenameIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->anyidentifier_ = $$; }
  | T_TYPENAME { $$ = new acsl::TypenameIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->anyidentifier_ = $$; }
  | Keyword { $$ = new acsl::KeywordIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->anyidentifier_ = $$; }
;
IdentifierOrTypename : T_TYPENAME { $$ = new acsl::Typename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifierortypename_ = $$; }
  | FullIdentifier { $$ = new acsl::AnFullIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifierortypename_ = $$; }
;
IdentifierOrTypenameFull : IsACSLTypename { $$ = new acsl::ACSLTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifierortypenamefull_ = $$; }
  | IdentifierOrTypename { $$ = new acsl::AnIdentifierOrTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifierortypenamefull_ = $$; }
;
ListIdentifierOrTypenameFull : IdentifierOrTypenameFull { $$ = new acsl::ListIdentifierOrTypenameFull(); $$->push_back($1); result->listidentifierortypenamefull_ = $$; }
  | IdentifierOrTypenameFull _COMMA ListIdentifierOrTypenameFull { $3->push_back($1); $$ = $3; result->listidentifierortypenamefull_ = $$; }
;
Identifier : _IDENT_ { $$ = new acsl::IdentifierIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifier_ = $$; }
  | _KW_Behaviors { $$ = new acsl::BehaviorsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifier_ = $$; }
  | _KW_label { $$ = new acsl::LabelKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifier_ = $$; }
  | _KW_reads { $$ = new acsl::ReadsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifier_ = $$; }
  | _KW_writes { $$ = new acsl::WritesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifier_ = $$; }
;
BoundedVar : FullIdentifier { $$ = new acsl::BoendedVarFullIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->boundedvar_ = $$; }
  | IsACSLTypename { $$ = new acsl::BoendedVarACSLTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->boundedvar_ = $$; }
  | T_TYPENAME { $$ = new acsl::BoendedVarTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->boundedvar_ = $$; }
;
CKeyword : _KW_char { $$ = new acsl::CharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_boolean { $$ = new acsl::BooleanKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _SYMB_53 { $$ = new acsl::BoolKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_const { $$ = new acsl::ConstKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_double { $$ = new acsl::DoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_enum { $$ = new acsl::EnumKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_else { $$ = new acsl::ElseKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_float { $$ = new acsl::FloatKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_if { $$ = new acsl::IfKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_int { $$ = new acsl::IntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_long { $$ = new acsl::LongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_short { $$ = new acsl::ShortKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_signed { $$ = new acsl::SignedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_sizeof { $$ = new acsl::SizeofKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _SYMB_90 { $$ = new acsl::StaticKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_struct { $$ = new acsl::StructKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_union { $$ = new acsl::UnionKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_unsigned { $$ = new acsl::UnsignedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
  | _KW_void { $$ = new acsl::VoidKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ckeyword_ = $$; }
;
ACSLCKeyword : _KW_case { $$ = new acsl::CaseKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->acslckeyword_ = $$; }
  | _KW_for { $$ = new acsl::ForKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->acslckeyword_ = $$; }
  | _KW_volatile { $$ = new acsl::VolatileKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->acslckeyword_ = $$; }
;
PostCond : _KW_ensures { $$ = new acsl::EnsuresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_exits { $$ = new acsl::ExitsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_breaks { $$ = new acsl::BreaksKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_continues { $$ = new acsl::ContinuesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_returns { $$ = new acsl::ReturnsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_ensures { $$ = new acsl::CheckEnsuresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_exits { $$ = new acsl::CheckExitsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_breaks { $$ = new acsl::CheckBreaksKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_continues { $$ = new acsl::CheckContinuesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_returns { $$ = new acsl::CheckReturnsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_ensures { $$ = new acsl::AdmitEnsuresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_exits { $$ = new acsl::AdmitExitsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_breaks { $$ = new acsl::AdmitBreaksKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_continues { $$ = new acsl::AdmitContinuesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_returns { $$ = new acsl::AdmitReturnsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
;
IsACSLSpec : PostCond { $$ = new acsl::PostCondKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | T_EXT_CONTRACT { $$ = new acsl::ExtContractKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_Assigns { $$ = new acsl::AssignsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_allocates { $$ = new acsl::AllocatesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_frees { $$ = new acsl::FreesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_behavior { $$ = new acsl::BehaviorKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_Requires { $$ = new acsl::RequiresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_check _KW_requires { $$ = new acsl::CheckRequiresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_admit _KW_requires { $$ = new acsl::AdmitRequiresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_Terminates { $$ = new acsl::TerminatesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_complete { $$ = new acsl::CompleteKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_Decreases { $$ = new acsl::DecreasesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
  | _KW_disjoint { $$ = new acsl::DisjointKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacslspec_ = $$; }
;
IsACSLDeclOrCodeAnnot : T_EXT_CODE_ANNOT { $$ = new acsl::ExtCodeAnnotKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | T_EXT_GLOBAL { $$ = new acsl::ExtGlobalKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | T_EXT_GLOBAL_BLOCK { $$ = new acsl::ExtGlobalBlockKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_Assumes { $$ = new acsl::AssumesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_assert { $$ = new acsl::AssertKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_check { $$ = new acsl::CheckKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_admit { $$ = new acsl::AdmitKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_global { $$ = new acsl::GlobalKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_impact { $$ = new acsl::ImpactKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_inductive { $$ = new acsl::InductiveKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_invariant { $$ = new acsl::InvariantKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_admit _KW_invariant { $$ = new acsl::AdmitInvariantKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_check _KW_invariant { $$ = new acsl::CheckInvariantKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_lemma { $$ = new acsl::LemmaKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_admit _KW_lemma { $$ = new acsl::AdmitLemmaKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_check _KW_lemma { $$ = new acsl::CheckLemmaKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_loop { $$ = new acsl::LoopKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_admit _KW_loop { $$ = new acsl::AdmitLoopKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_check _KW_loop { $$ = new acsl::CheckLoopKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_pragma { $$ = new acsl::PragmaKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_predicate { $$ = new acsl::PredicateKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_slice { $$ = new acsl::SliceKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_type { $$ = new acsl::TypeKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_model { $$ = new acsl::ModelKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_axiom { $$ = new acsl::AxiomKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_Variant { $$ = new acsl::VariantKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
  | _KW_axiomatic { $$ = new acsl::AxiomaticKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsldeclorcodeannot_ = $$; }
;
IsACSLTypename : _KW_integer { $$ = new acsl::IntegerKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsltypename_ = $$; }
  | _KW_real { $$ = new acsl::RealKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isacsltypename_ = $$; }
;
IsExtSpec : _KW_Contract { $$ = new acsl::ContractKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isextspec_ = $$; }
  | _KW_function { $$ = new acsl::FunctionKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isextspec_ = $$; }
  | _KW_module { $$ = new acsl::ModuleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isextspec_ = $$; }
  | _KW_include { $$ = new acsl::IncludeKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isextspec_ = $$; }
  | _KW_at { $$ = new acsl::AtKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isextspec_ = $$; }
  | _KW_let { $$ = new acsl::LetKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->isextspec_ = $$; }
;
Keyword : _KW_logic { $$ = new acsl::LogicKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->keyword_ = $$; }
  | CKeyword { $$ = new acsl::CKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->keyword_ = $$; }
  | ACSLCKeyword { $$ = new acsl::ACSLCKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->keyword_ = $$; }
  | IsExtSpec { $$ = new acsl::ExtSpecKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->keyword_ = $$; }
  | IsACSLSpec { $$ = new acsl::ACSLSpecKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->keyword_ = $$; }
  | IsACSLDeclOrCodeAnnot { $$ = new acsl::ACSLDeclCodeAnnotKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->keyword_ = $$; }
;
BSKeyword : _SYMB_84 { $$ = new acsl::SlashAllocableKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_86 { $$ = new acsl::SlashAllocationKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_87 { $$ = new acsl::SlashAutomaticKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_99 { $$ = new acsl::SlashAtKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_81 { $$ = new acsl::SlashBaseAddrKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_82 { $$ = new acsl::SlashBlockLengthKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_56 { $$ = new acsl::SlashGhostKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_88 { $$ = new acsl::SlashDynamicKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_107 { $$ = new acsl::SlashEmptyKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_71 { $$ = new acsl::SlashFalseKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_67 { $$ = new acsl::SlashForallKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_85 { $$ = new acsl::SlashFreeableKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_80 { $$ = new acsl::SlashFreshKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_112 { $$ = new acsl::SlashFromKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_109 { $$ = new acsl::SlashInterKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_69 { $$ = new acsl::SlashLambdaKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_66 { $$ = new acsl::SlashLetKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_113 { $$ = new acsl::SlashNothingKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_92 { $$ = new acsl::SlashNullKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_98 { $$ = new acsl::SlashOldKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_83 { $$ = new acsl::SlashOffsetKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_89 { $$ = new acsl::SlashRegisterKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_100 { $$ = new acsl::SlashResultKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_101 { $$ = new acsl::SlashSeparatedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_70 { $$ = new acsl::SlashTrueKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_106 { $$ = new acsl::SlashTypeKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_105 { $$ = new acsl::SlashTypeofKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_108 { $$ = new acsl::SlashUnionKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_91 { $$ = new acsl::SlashUnallocatedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_72 { $$ = new acsl::SlashObjectPointerKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_73 { $$ = new acsl::SlashValidKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_76 { $$ = new acsl::SlashValidIndexKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_77 { $$ = new acsl::SlashValidRangeKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_74 { $$ = new acsl::SlashValidReadKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_75 { $$ = new acsl::SlashValidFunctionKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_78 { $$ = new acsl::SlashInitializedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_79 { $$ = new acsl::SlashDanglingKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
  | _SYMB_110 { $$ = new acsl::SlashWithKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bskeyword_ = $$; }
;
Wildcard : AnyIdentifier { $$ = new acsl::WildCardAnyIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | BSKeyword { $$ = new acsl::WildCardBSKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _AMP { $$ = new acsl::WildcardAmp(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DAMP { $$ = new acsl::WildcardAnd(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _RARROW { $$ = new acsl::WildcardArrow(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_64 { $$ = new acsl::WildcardBIff(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_63 { $$ = new acsl::WildcardBImplicate(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _COLON { $$ = new acsl::WildcardColon(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DCOLON { $$ = new acsl::WildcardColonColon(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _COMMA { $$ = new acsl::WildcardComma(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _INTEGER_ { $$ = new acsl::WildcardIntConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DOUBLE_ { $$ = new acsl::WildcardFloatConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _STRING_ { $$ = new acsl::WildcardStringConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | T_WSTRING_CONSTANT { $$ = new acsl::WildcardWstringConstant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DOLLAR { $$ = new acsl::WildcardDollar(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DOT { $$ = new acsl::WildcardDot(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DDOT { $$ = new acsl::WildcardDotDot(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _ELLIPSIS { $$ = new acsl::WildcardDotDotDot(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DEQ { $$ = new acsl::WildcardEQ(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _EQ { $$ = new acsl::WildcardEqual(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_68 { $$ = new acsl::WildcardExistsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _GTEQ { $$ = new acsl::WildcardGreaterEq(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_56 { $$ = new acsl::WildcardGhostKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _GT { $$ = new acsl::WildcardGreater(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DGT { $$ = new acsl::WildcardGreaterGreater(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _CARET { $$ = new acsl::WildcardHat(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DCARET { $$ = new acsl::WildcardHatHat(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_61 { $$ = new acsl::WildcardIff(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_60 { $$ = new acsl::WildcardImplicate(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _LBRACE { $$ = new acsl::WildcardLeftBrace(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _LDARROW { $$ = new acsl::WildcardLessEq(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _LPAREN { $$ = new acsl::WildcardLeftPar(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _LBRACK { $$ = new acsl::WildcardLeftSquare(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_96 { $$ = new acsl::WildcardLeftSquarePipe(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _LT { $$ = new acsl::WildcardLess(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DLT { $$ = new acsl::WildcardLessLess(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _MINUS { $$ = new acsl::WildcardMinus(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _BANGEQ { $$ = new acsl::WildcardNotEq(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _BANG { $$ = new acsl::WildcardNot(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _DBAR { $$ = new acsl::WildcardPipePipe(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _PERCENT { $$ = new acsl::WildcardMod(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_104 { $$ = new acsl::WildcardPiKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _BAR { $$ = new acsl::WildcardPipe(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _PLUS { $$ = new acsl::WildcardPlus(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _QUESTION { $$ = new acsl::WildcardQuestion(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _RBRACE { $$ = new acsl::WildcardRightBrace(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _RPAREN { $$ = new acsl::WildcardRightPar(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _RBRACK { $$ = new acsl::WildcardRightSquare(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_97 { $$ = new acsl::WildcardRightSquarePipe(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SEMI { $$ = new acsl::WildcardSemiColon(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SLASH { $$ = new acsl::WildcardDivide(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _STAR { $$ = new acsl::WildcardMult(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_93 { $$ = new acsl::WildcardMultHat(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | T_STRING_LITERAL { $$ = new acsl::WildcardStringLiteral($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _TILDE { $$ = new acsl::WildcardTildeKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
  | _SYMB_65 { $$ = new acsl::WildcardInKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->wildcard_ = $$; }
;
ListWildcard : Wildcard { $$ = new acsl::ListWildcard(); $$->push_back($1); result->listwildcard_ = $$; }
  | Wildcard ListWildcard { $2->push_back($1); $$ = $2; result->listwildcard_ = $$; }
;

%%

namespace acsl
{
/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Globals* from file. */
Globals* pGlobals(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.globals_;
  }
}

/* Entrypoint: parse Globals* from string. */
Globals* psGlobals(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.globals_;
  }
}

/* Entrypoint: parse GhostGlobals* from file. */
GhostGlobals* pGhostGlobals(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostglobals_;
  }
}

/* Entrypoint: parse GhostGlobals* from string. */
GhostGlobals* psGhostGlobals(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostglobals_;
  }
}

/* Entrypoint: parse Global* from file. */
Global* pGlobal(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.global_;
  }
}

/* Entrypoint: parse Global* from string. */
Global* psGlobal(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.global_;
  }
}

/* Entrypoint: parse IdOrTypenameAsId* from file. */
IdOrTypenameAsId* pIdOrTypenameAsId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypenameasid_;
  }
}

/* Entrypoint: parse IdOrTypenameAsId* from string. */
IdOrTypenameAsId* psIdOrTypenameAsId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypenameasid_;
  }
}

/* Entrypoint: parse IdOrTypename* from file. */
IdOrTypename* pIdOrTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypename_;
  }
}

/* Entrypoint: parse IdOrTypename* from string. */
IdOrTypename* psIdOrTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypename_;
  }
}

/* Entrypoint: parse MaybeComma* from file. */
MaybeComma* pMaybeComma(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maybecomma_;
  }
}

/* Entrypoint: parse MaybeComma* from string. */
MaybeComma* psMaybeComma(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.maybecomma_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr15(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr15(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse OffsetofMemberDesignator* from file. */
OffsetofMemberDesignator* pOffsetofMemberDesignator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.offsetofmemberdesignator_;
  }
}

/* Entrypoint: parse OffsetofMemberDesignator* from string. */
OffsetofMemberDesignator* psOffsetofMemberDesignator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.offsetofmemberdesignator_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Constant* from file. */
Constant* pConstant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse Constant* from string. */
Constant* psConstant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse StringConstant* from file. */
StringConstant* pStringConstant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stringconstant_;
  }
}

/* Entrypoint: parse StringConstant* from string. */
StringConstant* psStringConstant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stringconstant_;
  }
}

/* Entrypoint: parse WStringList* from file. */
WStringList* pWStringList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.wstringlist_;
  }
}

/* Entrypoint: parse WStringList* from string. */
WStringList* psWStringList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.wstringlist_;
  }
}

/* Entrypoint: parse OneString* from file. */
OneString* pOneString(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.onestring_;
  }
}

/* Entrypoint: parse OneString* from string. */
OneString* psOneString(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.onestring_;
  }
}

/* Entrypoint: parse ListOneString* from file. */
ListOneString* pListOneString(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listonestring_->begin(), result.listonestring_->end());
    return result.listonestring_;
  }
}

/* Entrypoint: parse ListOneString* from string. */
ListOneString* psListOneString(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listonestring_->begin(), result.listonestring_->end());
    return result.listonestring_;
  }
}

/* Entrypoint: parse InitExpression* from file. */
InitExpression* pInitExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initexpression_;
  }
}

/* Entrypoint: parse InitExpression* from string. */
InitExpression* psInitExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initexpression_;
  }
}

/* Entrypoint: parse InitializerListOpt* from file. */
InitializerListOpt* pInitializerListOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initializerlistopt_;
  }
}

/* Entrypoint: parse InitializerListOpt* from string. */
InitializerListOpt* psInitializerListOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initializerlistopt_;
  }
}

/* Entrypoint: parse InitializerSingle* from file. */
InitializerSingle* pInitializerSingle(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initializersingle_;
  }
}

/* Entrypoint: parse InitializerSingle* from string. */
InitializerSingle* psInitializerSingle(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initializersingle_;
  }
}

/* Entrypoint: parse ListInitializerSingle* from file. */
ListInitializerSingle* pListInitializerSingle(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listinitializersingle_->begin(), result.listinitializersingle_->end());
    return result.listinitializersingle_;
  }
}

/* Entrypoint: parse ListInitializerSingle* from string. */
ListInitializerSingle* psListInitializerSingle(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listinitializersingle_->begin(), result.listinitializersingle_->end());
    return result.listinitializersingle_;
  }
}

/* Entrypoint: parse EqOpt* from file. */
EqOpt* pEqOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.eqopt_;
  }
}

/* Entrypoint: parse EqOpt* from string. */
EqOpt* psEqOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.eqopt_;
  }
}

/* Entrypoint: parse InitDesignators* from file. */
InitDesignators* pInitDesignators(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdesignators_;
  }
}

/* Entrypoint: parse InitDesignators* from string. */
InitDesignators* psInitDesignators(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdesignators_;
  }
}

/* Entrypoint: parse InitDesignatorsOpt* from file. */
InitDesignatorsOpt* pInitDesignatorsOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdesignatorsopt_;
  }
}

/* Entrypoint: parse InitDesignatorsOpt* from string. */
InitDesignatorsOpt* psInitDesignatorsOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdesignatorsopt_;
  }
}

/* Entrypoint: parse GhostArgumentsOpt* from file. */
GhostArgumentsOpt* pGhostArgumentsOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostargumentsopt_;
  }
}

/* Entrypoint: parse GhostArgumentsOpt* from string. */
GhostArgumentsOpt* psGhostArgumentsOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostargumentsopt_;
  }
}

/* Entrypoint: parse Arguments* from file. */
Arguments* pArguments(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arguments_;
  }
}

/* Entrypoint: parse Arguments* from string. */
Arguments* psArguments(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arguments_;
  }
}

/* Entrypoint: parse OptExpression* from file. */
OptExpression* pOptExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optexpression_;
  }
}

/* Entrypoint: parse OptExpression* from string. */
OptExpression* psOptExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optexpression_;
  }
}

/* Entrypoint: parse ListExpression* from file. */
ListExpression* pListExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse ListExpression* from string. */
ListExpression* psListExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse CommaExpressionOpt* from file. */
CommaExpressionOpt* pCommaExpressionOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.commaexpressionopt_;
  }
}

/* Entrypoint: parse CommaExpressionOpt* from string. */
CommaExpressionOpt* psCommaExpressionOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.commaexpressionopt_;
  }
}

/* Entrypoint: parse Block* from file. */
Block* pBlock(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse Block* from string. */
Block* psBlock(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse BlockAttrs* from file. */
BlockAttrs* pBlockAttrs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockattrs_;
  }
}

/* Entrypoint: parse BlockAttrs* from string. */
BlockAttrs* psBlockAttrs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockattrs_;
  }
}

/* Entrypoint: parse BlockElement* from file. */
BlockElement* pBlockElement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockelement_;
  }
}

/* Entrypoint: parse BlockElement* from string. */
BlockElement* psBlockElement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockelement_;
  }
}

/* Entrypoint: parse ListBlockElement* from file. */
ListBlockElement* pListBlockElement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listblockelement_;
  }
}

/* Entrypoint: parse ListBlockElement* from string. */
ListBlockElement* psListBlockElement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listblockelement_;
  }
}

/* Entrypoint: parse Annot* from file. */
Annot* pAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annot_;
  }
}

/* Entrypoint: parse Annot* from string. */
Annot* psAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annot_;
  }
}

/* Entrypoint: parse ListAnnot* from file. */
ListAnnot* pListAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listannot_;
  }
}

/* Entrypoint: parse ListAnnot* from string. */
ListAnnot* psListAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listannot_;
  }
}

/* Entrypoint: parse Code_Annot* from file. */
Code_Annot* pCode_Annot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.code_annot_;
  }
}

/* Entrypoint: parse Code_Annot* from string. */
Code_Annot* psCode_Annot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.code_annot_;
  }
}

/* Entrypoint: parse LocalLabel* from file. */
LocalLabel* pLocalLabel(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.locallabel_;
  }
}

/* Entrypoint: parse LocalLabel* from string. */
LocalLabel* psLocalLabel(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.locallabel_;
  }
}

/* Entrypoint: parse ListLocalLabel* from file. */
ListLocalLabel* pListLocalLabel(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlocallabel_;
  }
}

/* Entrypoint: parse ListLocalLabel* from string. */
ListLocalLabel* psListLocalLabel(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlocallabel_;
  }
}

/* Entrypoint: parse LocalLabelName* from file. */
LocalLabelName* pLocalLabelName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.locallabelname_;
  }
}

/* Entrypoint: parse LocalLabelName* from string. */
LocalLabelName* psLocalLabelName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.locallabelname_;
  }
}

/* Entrypoint: parse ListLocalLabelName* from file. */
ListLocalLabelName* pListLocalLabelName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlocallabelname_->begin(), result.listlocallabelname_->end());
    return result.listlocallabelname_;
  }
}

/* Entrypoint: parse ListLocalLabelName* from string. */
ListLocalLabelName* psListLocalLabelName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlocallabelname_->begin(), result.listlocallabelname_->end());
    return result.listlocallabelname_;
  }
}

/* Entrypoint: parse AnnotatedStmt* from file. */
AnnotatedStmt* pAnnotatedStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotatedstmt_;
  }
}

/* Entrypoint: parse AnnotatedStmt* from string. */
AnnotatedStmt* psAnnotatedStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotatedstmt_;
  }
}

/* Entrypoint: parse ElsePart* from file. */
ElsePart* pElsePart(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsepart_;
  }
}

/* Entrypoint: parse ElsePart* from string. */
ElsePart* psElsePart(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsepart_;
  }
}

/* Entrypoint: parse Statement* from file. */
Statement* pStatement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse Statement* from string. */
Statement* psStatement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse OptLoopAnnotations* from file. */
OptLoopAnnotations* pOptLoopAnnotations(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optloopannotations_;
  }
}

/* Entrypoint: parse OptLoopAnnotations* from string. */
OptLoopAnnotations* psOptLoopAnnotations(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optloopannotations_;
  }
}

/* Entrypoint: parse ForClause* from file. */
ForClause* pForClause(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.forclause_;
  }
}

/* Entrypoint: parse ForClause* from string. */
ForClause* psForClause(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.forclause_;
  }
}

/* Entrypoint: parse GhostParameterOpt* from file. */
GhostParameterOpt* pGhostParameterOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostparameteropt_;
  }
}

/* Entrypoint: parse GhostParameterOpt* from string. */
GhostParameterOpt* psGhostParameterOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostparameteropt_;
  }
}

/* Entrypoint: parse Declaration* from file. */
Declaration* pDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declaration_;
  }
}

/* Entrypoint: parse Declaration* from string. */
Declaration* psDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declaration_;
  }
}

/* Entrypoint: parse GenericAssociation* from file. */
GenericAssociation* pGenericAssociation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.genericassociation_;
  }
}

/* Entrypoint: parse GenericAssociation* from string. */
GenericAssociation* psGenericAssociation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.genericassociation_;
  }
}

/* Entrypoint: parse ListGenericAssociation* from file. */
ListGenericAssociation* pListGenericAssociation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listgenericassociation_->begin(), result.listgenericassociation_->end());
    return result.listgenericassociation_;
  }
}

/* Entrypoint: parse ListGenericAssociation* from string. */
ListGenericAssociation* psListGenericAssociation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listgenericassociation_->begin(), result.listgenericassociation_->end());
    return result.listgenericassociation_;
  }
}

/* Entrypoint: parse DeclAndInitDeclAttrList* from file. */
DeclAndInitDeclAttrList* pDeclAndInitDeclAttrList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declandinitdeclattrlist_;
  }
}

/* Entrypoint: parse DeclAndInitDeclAttrList* from string. */
DeclAndInitDeclAttrList* psDeclAndInitDeclAttrList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declandinitdeclattrlist_;
  }
}

/* Entrypoint: parse InitDeclaratorAttr* from file. */
InitDeclaratorAttr* pInitDeclaratorAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclaratorattr_;
  }
}

/* Entrypoint: parse InitDeclaratorAttr* from string. */
InitDeclaratorAttr* psInitDeclaratorAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclaratorattr_;
  }
}

/* Entrypoint: parse ListInitDeclaratorAttr* from file. */
ListInitDeclaratorAttr* pListInitDeclaratorAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listinitdeclaratorattr_->begin(), result.listinitdeclaratorattr_->end());
    return result.listinitdeclaratorattr_;
  }
}

/* Entrypoint: parse ListInitDeclaratorAttr* from string. */
ListInitDeclaratorAttr* psListInitDeclaratorAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listinitdeclaratorattr_->begin(), result.listinitdeclaratorattr_->end());
    return result.listinitdeclaratorattr_;
  }
}

/* Entrypoint: parse InitDeclarator* from file. */
InitDeclarator* pInitDeclarator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclarator_;
  }
}

/* Entrypoint: parse InitDeclarator* from string. */
InitDeclarator* psInitDeclarator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclarator_;
  }
}

/* Entrypoint: parse DeclSpecWOType* from file. */
DeclSpecWOType* pDeclSpecWOType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspecwotype_;
  }
}

/* Entrypoint: parse DeclSpecWOType* from string. */
DeclSpecWOType* psDeclSpecWOType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspecwotype_;
  }
}

/* Entrypoint: parse DeclSpecList* from file. */
DeclSpecList* pDeclSpecList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclist_;
  }
}

/* Entrypoint: parse DeclSpecList* from string. */
DeclSpecList* psDeclSpecList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclist_;
  }
}

/* Entrypoint: parse DeclSpecListNoNamed* from file. */
DeclSpecListNoNamed* pDeclSpecListNoNamed(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclistnonamed_;
  }
}

/* Entrypoint: parse DeclSpecListNoNamed* from string. */
DeclSpecListNoNamed* psDeclSpecListNoNamed(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclistnonamed_;
  }
}

/* Entrypoint: parse TypeSpec* from file. */
TypeSpec* pTypeSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespec_;
  }
}

/* Entrypoint: parse TypeSpec* from string. */
TypeSpec* psTypeSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespec_;
  }
}

/* Entrypoint: parse StructDeclList* from file. */
StructDeclList* pStructDeclList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.structdecllist_;
  }
}

/* Entrypoint: parse StructDeclList* from string. */
StructDeclList* psStructDeclList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.structdecllist_;
  }
}

/* Entrypoint: parse StaticAssertDeclaration* from file. */
StaticAssertDeclaration* pStaticAssertDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.staticassertdeclaration_;
  }
}

/* Entrypoint: parse StaticAssertDeclaration* from string. */
StaticAssertDeclaration* psStaticAssertDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.staticassertdeclaration_;
  }
}

/* Entrypoint: parse FieldDecl* from file. */
FieldDecl* pFieldDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fielddecl_;
  }
}

/* Entrypoint: parse FieldDecl* from string. */
FieldDecl* psFieldDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fielddecl_;
  }
}

/* Entrypoint: parse ListFieldDecl* from file. */
ListFieldDecl* pListFieldDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfielddecl_->begin(), result.listfielddecl_->end());
    return result.listfielddecl_;
  }
}

/* Entrypoint: parse ListFieldDecl* from string. */
ListFieldDecl* psListFieldDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfielddecl_->begin(), result.listfielddecl_->end());
    return result.listfielddecl_;
  }
}

/* Entrypoint: parse Enumerator* from file. */
Enumerator* pEnumerator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.enumerator_;
  }
}

/* Entrypoint: parse Enumerator* from string. */
Enumerator* psEnumerator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.enumerator_;
  }
}

/* Entrypoint: parse ListEnumerator* from file. */
ListEnumerator* pListEnumerator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listenumerator_->begin(), result.listenumerator_->end());
    return result.listenumerator_;
  }
}

/* Entrypoint: parse ListEnumerator* from string. */
ListEnumerator* psListEnumerator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listenumerator_->begin(), result.listenumerator_->end());
    return result.listenumerator_;
  }
}

/* Entrypoint: parse Declarator* from file. */
Declarator* pDeclarator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declarator_;
  }
}

/* Entrypoint: parse Declarator* from string. */
Declarator* psDeclarator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declarator_;
  }
}

/* Entrypoint: parse ListDeclarator* from file. */
ListDeclarator* pListDeclarator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listdeclarator_->begin(), result.listdeclarator_->end());
    return result.listdeclarator_;
  }
}

/* Entrypoint: parse ListDeclarator* from string. */
ListDeclarator* psListDeclarator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listdeclarator_->begin(), result.listdeclarator_->end());
    return result.listdeclarator_;
  }
}

/* Entrypoint: parse AttributesOrStatic* from file. */
AttributesOrStatic* pAttributesOrStatic(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributesorstatic_;
  }
}

/* Entrypoint: parse AttributesOrStatic* from string. */
AttributesOrStatic* psAttributesOrStatic(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributesorstatic_;
  }
}

/* Entrypoint: parse DirectDecl* from file. */
DirectDecl* pDirectDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.directdecl_;
  }
}

/* Entrypoint: parse DirectDecl* from string. */
DirectDecl* psDirectDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.directdecl_;
  }
}

/* Entrypoint: parse RestParList* from file. */
RestParList* pRestParList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.restparlist_;
  }
}

/* Entrypoint: parse RestParList* from string. */
RestParList* psRestParList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.restparlist_;
  }
}

/* Entrypoint: parse ParameterDecl* from file. */
ParameterDecl* pParameterDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameterdecl_;
  }
}

/* Entrypoint: parse ParameterDecl* from string. */
ParameterDecl* psParameterDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameterdecl_;
  }
}

/* Entrypoint: parse ListParameterDecl* from file. */
ListParameterDecl* pListParameterDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparameterdecl_->begin(), result.listparameterdecl_->end());
    return result.listparameterdecl_;
  }
}

/* Entrypoint: parse ListParameterDecl* from string. */
ListParameterDecl* psListParameterDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparameterdecl_->begin(), result.listparameterdecl_->end());
    return result.listparameterdecl_;
  }
}

/* Entrypoint: parse DirectOldProtoDecl* from file. */
DirectOldProtoDecl* pDirectOldProtoDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.directoldprotodecl_;
  }
}

/* Entrypoint: parse DirectOldProtoDecl* from string. */
DirectOldProtoDecl* psDirectOldProtoDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.directoldprotodecl_;
  }
}

/* Entrypoint: parse ListIdent* from file. */
ListIdent* pListIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listident_->begin(), result.listident_->end());
    return result.listident_;
  }
}

/* Entrypoint: parse ListIdent* from string. */
ListIdent* psListIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listident_->begin(), result.listident_->end());
    return result.listident_;
  }
}

/* Entrypoint: parse OldPardefList* from file. */
OldPardefList* pOldPardefList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.oldpardeflist_;
  }
}

/* Entrypoint: parse OldPardefList* from string. */
OldPardefList* psOldPardefList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.oldpardeflist_;
  }
}

/* Entrypoint: parse OldPardef* from file. */
OldPardef* pOldPardef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.oldpardef_;
  }
}

/* Entrypoint: parse OldPardef* from string. */
OldPardef* psOldPardef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.oldpardef_;
  }
}

/* Entrypoint: parse ListOldPardef* from file. */
ListOldPardef* pListOldPardef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listoldpardef_->begin(), result.listoldpardef_->end());
    return result.listoldpardef_;
  }
}

/* Entrypoint: parse ListOldPardef* from string. */
ListOldPardef* psListOldPardef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listoldpardef_->begin(), result.listoldpardef_->end());
    return result.listoldpardef_;
  }
}

/* Entrypoint: parse PointerOpt* from file. */
PointerOpt* pPointerOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pointeropt_;
  }
}

/* Entrypoint: parse PointerOpt* from string. */
PointerOpt* psPointerOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pointeropt_;
  }
}

/* Entrypoint: parse TypeName* from file. */
TypeName* pTypeName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typename_;
  }
}

/* Entrypoint: parse TypeName* from string. */
TypeName* psTypeName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typename_;
  }
}

/* Entrypoint: parse AbstractDecl* from file. */
AbstractDecl* pAbstractDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.abstractdecl_;
  }
}

/* Entrypoint: parse AbstractDecl* from string. */
AbstractDecl* psAbstractDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.abstractdecl_;
  }
}

/* Entrypoint: parse AbsDirectDecl* from file. */
AbsDirectDecl* pAbsDirectDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absdirectdecl_;
  }
}

/* Entrypoint: parse AbsDirectDecl* from string. */
AbsDirectDecl* psAbsDirectDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absdirectdecl_;
  }
}

/* Entrypoint: parse AbsDirectDeclOpt* from file. */
AbsDirectDeclOpt* pAbsDirectDeclOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absdirectdeclopt_;
  }
}

/* Entrypoint: parse AbsDirectDeclOpt* from string. */
AbsDirectDeclOpt* psAbsDirectDeclOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absdirectdeclopt_;
  }
}

/* Entrypoint: parse FunctionDef* from file. */
FunctionDef* pFunctionDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondef_;
  }
}

/* Entrypoint: parse FunctionDef* from string. */
FunctionDef* psFunctionDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondef_;
  }
}

/* Entrypoint: parse FunctionDefStart* from file. */
FunctionDefStart* pFunctionDefStart(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondefstart_;
  }
}

/* Entrypoint: parse FunctionDefStart* from string. */
FunctionDefStart* psFunctionDefStart(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondefstart_;
  }
}

/* Entrypoint: parse CVSpec* from file. */
CVSpec* pCVSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cvspec_;
  }
}

/* Entrypoint: parse CVSpec* from string. */
CVSpec* psCVSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cvspec_;
  }
}

/* Entrypoint: parse AttributesWithAsm* from file. */
AttributesWithAsm* pAttributesWithAsm(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributeswithasm_;
  }
}

/* Entrypoint: parse AttributesWithAsm* from string. */
AttributesWithAsm* psAttributesWithAsm(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributeswithasm_;
  }
}

/* Entrypoint: parse AttributeNocv* from file. */
AttributeNocv* pAttributeNocv(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributenocv_;
  }
}

/* Entrypoint: parse AttributeNocv* from string. */
AttributeNocv* psAttributeNocv(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributenocv_;
  }
}

/* Entrypoint: parse ListAttributeNocv* from file. */
ListAttributeNocv* pListAttributeNocv(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listattributenocv_;
  }
}

/* Entrypoint: parse ListAttributeNocv* from string. */
ListAttributeNocv* psListAttributeNocv(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listattributenocv_;
  }
}

/* Entrypoint: parse Attribute* from file. */
Attribute* pAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attribute_;
  }
}

/* Entrypoint: parse Attribute* from string. */
Attribute* psAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attribute_;
  }
}

/* Entrypoint: parse ListAttribute* from file. */
ListAttribute* pListAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listattribute_;
  }
}

/* Entrypoint: parse ListAttribute* from string. */
ListAttribute* psListAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listattribute_;
  }
}

/* Entrypoint: parse JustAttribute* from file. */
JustAttribute* pJustAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.justattribute_;
  }
}

/* Entrypoint: parse JustAttribute* from string. */
JustAttribute* psJustAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.justattribute_;
  }
}

/* Entrypoint: parse ListJustAttribute* from file. */
ListJustAttribute* pListJustAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listjustattribute_->begin(), result.listjustattribute_->end());
    return result.listjustattribute_;
  }
}

/* Entrypoint: parse ListJustAttribute* from string. */
ListJustAttribute* psListJustAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listjustattribute_->begin(), result.listjustattribute_->end());
    return result.listjustattribute_;
  }
}

/* Entrypoint: parse Pragma* from file. */
Pragma* pPragma(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pragma_;
  }
}

/* Entrypoint: parse Pragma* from string. */
Pragma* psPragma(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pragma_;
  }
}

/* Entrypoint: parse VarAttr* from file. */
VarAttr* pVarAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varattr_;
  }
}

/* Entrypoint: parse VarAttr* from string. */
VarAttr* psVarAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varattr_;
  }
}

/* Entrypoint: parse BasicAttribute* from file. */
BasicAttribute* pBasicAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.basicattribute_;
  }
}

/* Entrypoint: parse BasicAttribute* from string. */
BasicAttribute* psBasicAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.basicattribute_;
  }
}

/* Entrypoint: parse ListBasicAttribute* from file. */
ListBasicAttribute* pListBasicAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbasicattribute_->begin(), result.listbasicattribute_->end());
    return result.listbasicattribute_;
  }
}

/* Entrypoint: parse ListBasicAttribute* from string. */
ListBasicAttribute* psListBasicAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbasicattribute_->begin(), result.listbasicattribute_->end());
    return result.listbasicattribute_;
  }
}

/* Entrypoint: parse ParameterAttrListNE* from file. */
ParameterAttrListNE* pParameterAttrListNE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameterattrlistne_;
  }
}

/* Entrypoint: parse ParameterAttrListNE* from string. */
ParameterAttrListNE* psParameterAttrListNE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameterattrlistne_;
  }
}

/* Entrypoint: parse ParamAttrListNE* from file. */
ParamAttrListNE* pParamAttrListNE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.paramattrlistne_;
  }
}

/* Entrypoint: parse ParamAttrListNE* from string. */
ParamAttrListNE* psParamAttrListNE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.paramattrlistne_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse ListAttr* from file. */
ListAttr* pListAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listattr_->begin(), result.listattr_->end());
    return result.listattr_;
  }
}

/* Entrypoint: parse ListAttr* from string. */
ListAttr* psListAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listattr_->begin(), result.listattr_->end());
    return result.listattr_;
  }
}

/* Entrypoint: parse AttrTest* from file. */
AttrTest* pAttrTest(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attrtest_;
  }
}

/* Entrypoint: parse AttrTest* from string. */
AttrTest* psAttrTest(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attrtest_;
  }
}

/* Entrypoint: parse AttrList* from file. */
AttrList* pAttrList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attrlist_;
  }
}

/* Entrypoint: parse AttrList* from string. */
AttrList* psAttrList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attrlist_;
  }
}

/* Entrypoint: parse Asmattr* from file. */
Asmattr* pAsmattr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmattr_;
  }
}

/* Entrypoint: parse Asmattr* from string. */
Asmattr* psAsmattr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmattr_;
  }
}

/* Entrypoint: parse ListAsmattr* from file. */
ListAsmattr* pListAsmattr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listasmattr_;
  }
}

/* Entrypoint: parse ListAsmattr* from string. */
ListAsmattr* psListAsmattr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listasmattr_;
  }
}

/* Entrypoint: parse Asmoutputs* from file. */
Asmoutputs* pAsmoutputs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmoutputs_;
  }
}

/* Entrypoint: parse Asmoutputs* from string. */
Asmoutputs* psAsmoutputs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmoutputs_;
  }
}

/* Entrypoint: parse Asmoperands* from file. */
Asmoperands* pAsmoperands(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmoperands_;
  }
}

/* Entrypoint: parse Asmoperands* from string. */
Asmoperands* psAsmoperands(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmoperands_;
  }
}

/* Entrypoint: parse Asmoperand* from file. */
Asmoperand* pAsmoperand(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmoperand_;
  }
}

/* Entrypoint: parse Asmoperand* from string. */
Asmoperand* psAsmoperand(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmoperand_;
  }
}

/* Entrypoint: parse ListAsmoperand* from file. */
ListAsmoperand* pListAsmoperand(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listasmoperand_->begin(), result.listasmoperand_->end());
    return result.listasmoperand_;
  }
}

/* Entrypoint: parse ListAsmoperand* from string. */
ListAsmoperand* psListAsmoperand(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listasmoperand_->begin(), result.listasmoperand_->end());
    return result.listasmoperand_;
  }
}

/* Entrypoint: parse Asminputs* from file. */
Asminputs* pAsminputs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asminputs_;
  }
}

/* Entrypoint: parse Asminputs* from string. */
Asminputs* psAsminputs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asminputs_;
  }
}

/* Entrypoint: parse Asmopname* from file. */
Asmopname* pAsmopname(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmopname_;
  }
}

/* Entrypoint: parse Asmopname* from string. */
Asmopname* psAsmopname(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmopname_;
  }
}

/* Entrypoint: parse Asmclobber* from file. */
Asmclobber* pAsmclobber(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmclobber_;
  }
}

/* Entrypoint: parse Asmclobber* from string. */
Asmclobber* psAsmclobber(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmclobber_;
  }
}

/* Entrypoint: parse ListStringConstant* from file. */
ListStringConstant* pListStringConstant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststringconstant_->begin(), result.liststringconstant_->end());
    return result.liststringconstant_;
  }
}

/* Entrypoint: parse ListStringConstant* from string. */
ListStringConstant* psListStringConstant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststringconstant_->begin(), result.liststringconstant_->end());
    return result.liststringconstant_;
  }
}

/* Entrypoint: parse Asmlabels* from file. */
Asmlabels* pAsmlabels(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmlabels_;
  }
}

/* Entrypoint: parse Asmlabels* from string. */
Asmlabels* psAsmlabels(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.asmlabels_;
  }
}

/* Entrypoint: parse LexprEOF* from file. */
LexprEOF* pLexprEOF(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpreof_;
  }
}

/* Entrypoint: parse LexprEOF* from string. */
LexprEOF* psLexprEOF(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpreof_;
  }
}

/* Entrypoint: parse LexprList* from file. */
LexprList* pLexprList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprlist_;
  }
}

/* Entrypoint: parse LexprList* from string. */
LexprList* psLexprList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprlist_;
  }
}

/* Entrypoint: parse ListLexpr* from file. */
ListLexpr* pListLexpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlexpr_->begin(), result.listlexpr_->end());
    return result.listlexpr_;
  }
}

/* Entrypoint: parse ListLexpr* from string. */
ListLexpr* psListLexpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlexpr_->begin(), result.listlexpr_->end());
    return result.listlexpr_;
  }
}

/* Entrypoint: parse LexprOption* from file. */
LexprOption* pLexprOption(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexproption_;
  }
}

/* Entrypoint: parse LexprOption* from string. */
LexprOption* psLexprOption(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexproption_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse LexprBinder* from file. */
LexprBinder* pLexprBinder(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprbinder_;
  }
}

/* Entrypoint: parse LexprBinder* from string. */
LexprBinder* psLexprBinder(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprbinder_;
  }
}

/* Entrypoint: parse LexprRelInner* from file. */
LexprRelInner* pLexprRelInner(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprrelinner_;
  }
}

/* Entrypoint: parse LexprRelInner* from string. */
LexprRelInner* psLexprRelInner(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprrelinner_;
  }
}

/* Entrypoint: parse ListLexprRelInner* from file. */
ListLexprRelInner* pListLexprRelInner(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlexprrelinner_;
  }
}

/* Entrypoint: parse ListLexprRelInner* from string. */
ListLexprRelInner* psListLexprRelInner(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlexprrelinner_;
  }
}

/* Entrypoint: parse Relation* from file. */
Relation* pRelation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.relation_;
  }
}

/* Entrypoint: parse Relation* from string. */
Relation* psRelation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.relation_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse ListSTRING_LITERAL* from file. */
ListSTRING_LITERAL* pListSTRING_LITERAL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststring_literal_->begin(), result.liststring_literal_->end());
    return result.liststring_literal_;
  }
}

/* Entrypoint: parse ListSTRING_LITERAL* from string. */
ListSTRING_LITERAL* psListSTRING_LITERAL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststring_literal_->begin(), result.liststring_literal_->end());
    return result.liststring_literal_;
  }
}

/* Entrypoint: parse Range* from file. */
Range* pRange(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.range_;
  }
}

/* Entrypoint: parse Range* from string. */
Range* psRange(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.range_;
  }
}

/* Entrypoint: parse FieldInitElt* from file. */
FieldInitElt* pFieldInitElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fieldinitelt_;
  }
}

/* Entrypoint: parse FieldInitElt* from string. */
FieldInitElt* psFieldInitElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fieldinitelt_;
  }
}

/* Entrypoint: parse ListFieldInitElt* from file. */
ListFieldInitElt* pListFieldInitElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfieldinitelt_->begin(), result.listfieldinitelt_->end());
    return result.listfieldinitelt_;
  }
}

/* Entrypoint: parse ListFieldInitElt* from string. */
ListFieldInitElt* psListFieldInitElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfieldinitelt_->begin(), result.listfieldinitelt_->end());
    return result.listfieldinitelt_;
  }
}

/* Entrypoint: parse ArrayInitElt* from file. */
ArrayInitElt* pArrayInitElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arrayinitelt_;
  }
}

/* Entrypoint: parse ArrayInitElt* from string. */
ArrayInitElt* psArrayInitElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arrayinitelt_;
  }
}

/* Entrypoint: parse ListArrayInitElt* from file. */
ListArrayInitElt* pListArrayInitElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listarrayinitelt_->begin(), result.listarrayinitelt_->end());
    return result.listarrayinitelt_;
  }
}

/* Entrypoint: parse ListArrayInitElt* from string. */
ListArrayInitElt* psListArrayInitElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listarrayinitelt_->begin(), result.listarrayinitelt_->end());
    return result.listarrayinitelt_;
  }
}

/* Entrypoint: parse UpdateElt* from file. */
UpdateElt* pUpdateElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.updateelt_;
  }
}

/* Entrypoint: parse UpdateElt* from string. */
UpdateElt* psUpdateElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.updateelt_;
  }
}

/* Entrypoint: parse ListUpdateElt* from file. */
ListUpdateElt* pListUpdateElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listupdateelt_->begin(), result.listupdateelt_->end());
    return result.listupdateelt_;
  }
}

/* Entrypoint: parse ListUpdateElt* from string. */
ListUpdateElt* psListUpdateElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listupdateelt_->begin(), result.listupdateelt_->end());
    return result.listupdateelt_;
  }
}

/* Entrypoint: parse PathElt* from file. */
PathElt* pPathElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pathelt_;
  }
}

/* Entrypoint: parse PathElt* from string. */
PathElt* psPathElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pathelt_;
  }
}

/* Entrypoint: parse ListPathElt* from file. */
ListPathElt* pListPathElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listpathelt_->begin(), result.listpathelt_->end());
    return result.listpathelt_;
  }
}

/* Entrypoint: parse ListPathElt* from string. */
ListPathElt* psListPathElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listpathelt_->begin(), result.listpathelt_->end());
    return result.listpathelt_;
  }
}

/* Entrypoint: parse Binders* from file. */
Binders* pBinders(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.binders_;
  }
}

/* Entrypoint: parse Binders* from string. */
Binders* psBinders(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.binders_;
  }
}

/* Entrypoint: parse BindersReentrance* from file. */
BindersReentrance* pBindersReentrance(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bindersreentrance_;
  }
}

/* Entrypoint: parse BindersReentrance* from string. */
BindersReentrance* psBindersReentrance(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bindersreentrance_;
  }
}

/* Entrypoint: parse ListBindersReentrance* from file. */
ListBindersReentrance* pListBindersReentrance(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbindersreentrance_->begin(), result.listbindersreentrance_->end());
    return result.listbindersreentrance_;
  }
}

/* Entrypoint: parse ListBindersReentrance* from string. */
ListBindersReentrance* psListBindersReentrance(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbindersreentrance_->begin(), result.listbindersreentrance_->end());
    return result.listbindersreentrance_;
  }
}

/* Entrypoint: parse VarSpec* from file. */
VarSpec* pVarSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse VarSpec* from string. */
VarSpec* psVarSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse ArraySize* from file. */
ArraySize* pArraySize(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arraysize_;
  }
}

/* Entrypoint: parse ArraySize* from string. */
ArraySize* psArraySize(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arraysize_;
  }
}

/* Entrypoint: parse VarSpec* from file. */
VarSpec* pVarSpec1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse VarSpec* from string. */
VarSpec* psVarSpec1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse AbsParamTypeList* from file. */
AbsParamTypeList* pAbsParamTypeList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absparamtypelist_;
  }
}

/* Entrypoint: parse AbsParamTypeList* from string. */
AbsParamTypeList* psAbsParamTypeList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absparamtypelist_;
  }
}

/* Entrypoint: parse AbsParam* from file. */
AbsParam* pAbsParam(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absparam_;
  }
}

/* Entrypoint: parse AbsParam* from string. */
AbsParam* psAbsParam(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absparam_;
  }
}

/* Entrypoint: parse ListAbsParam* from file. */
ListAbsParam* pListAbsParam(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listabsparam_->begin(), result.listabsparam_->end());
    return result.listabsparam_;
  }
}

/* Entrypoint: parse ListAbsParam* from string. */
ListAbsParam* psListAbsParam(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listabsparam_->begin(), result.listabsparam_->end());
    return result.listabsparam_;
  }
}

/* Entrypoint: parse Parameter* from file. */
Parameter* pParameter(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameter_;
  }
}

/* Entrypoint: parse Parameter* from string. */
Parameter* psParameter(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameter_;
  }
}

/* Entrypoint: parse ListParameter* from file. */
ListParameter* pListParameter(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparameter_->begin(), result.listparameter_->end());
    return result.listparameter_;
  }
}

/* Entrypoint: parse ListParameter* from string. */
ListParameter* psListParameter(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparameter_->begin(), result.listparameter_->end());
    return result.listparameter_;
  }
}

/* Entrypoint: parse LogicTypeGenOFTYPENAME* from file. */
LogicTypeGenOFTYPENAME* pLogicTypeGenOFTYPENAME(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logictypegenoftypename_;
  }
}

/* Entrypoint: parse LogicTypeGenOFTYPENAME* from string. */
LogicTypeGenOFTYPENAME* psLogicTypeGenOFTYPENAME(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logictypegenoftypename_;
  }
}

/* Entrypoint: parse ListLogicTypeGenOFTYPENAME* from file. */
ListLogicTypeGenOFTYPENAME* pListLogicTypeGenOFTYPENAME(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlogictypegenoftypename_->begin(), result.listlogictypegenoftypename_->end());
    return result.listlogictypegenoftypename_;
  }
}

/* Entrypoint: parse ListLogicTypeGenOFTYPENAME* from string. */
ListLogicTypeGenOFTYPENAME* psListLogicTypeGenOFTYPENAME(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlogictypegenoftypename_->begin(), result.listlogictypegenoftypename_->end());
    return result.listlogictypegenoftypename_;
  }
}

/* Entrypoint: parse LogicTypeGenOFIdentifierOrTypename* from file. */
LogicTypeGenOFIdentifierOrTypename* pLogicTypeGenOFIdentifierOrTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logictypegenofidentifierortypename_;
  }
}

/* Entrypoint: parse LogicTypeGenOFIdentifierOrTypename* from string. */
LogicTypeGenOFIdentifierOrTypename* psLogicTypeGenOFIdentifierOrTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logictypegenofidentifierortypename_;
  }
}

/* Entrypoint: parse ListLogicTypeGenOFIdentifierOrTypename* from file. */
ListLogicTypeGenOFIdentifierOrTypename* pListLogicTypeGenOFIdentifierOrTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlogictypegenofidentifierortypename_->begin(), result.listlogictypegenofidentifierortypename_->end());
    return result.listlogictypegenofidentifierortypename_;
  }
}

/* Entrypoint: parse ListLogicTypeGenOFIdentifierOrTypename* from string. */
ListLogicTypeGenOFIdentifierOrTypename* psListLogicTypeGenOFIdentifierOrTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlogictypegenofidentifierortypename_->begin(), result.listlogictypegenofidentifierortypename_->end());
    return result.listlogictypegenofidentifierortypename_;
  }
}

/* Entrypoint: parse CV* from file. */
CV* pCV(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cv_;
  }
}

/* Entrypoint: parse CV* from string. */
CV* psCV(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cv_;
  }
}

/* Entrypoint: parse ListCV* from file. */
ListCV* pListCV(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listcv_;
  }
}

/* Entrypoint: parse ListCV* from string. */
ListCV* psListCV(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listcv_;
  }
}

/* Entrypoint: parse TypeSpecCVOFTYPENAME* from file. */
TypeSpecCVOFTYPENAME* pTypeSpecCVOFTYPENAME(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespeccvoftypename_;
  }
}

/* Entrypoint: parse TypeSpecCVOFTYPENAME* from string. */
TypeSpecCVOFTYPENAME* psTypeSpecCVOFTYPENAME(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespeccvoftypename_;
  }
}

/* Entrypoint: parse CastLogicType* from file. */
CastLogicType* pCastLogicType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.castlogictype_;
  }
}

/* Entrypoint: parse CastLogicType* from string. */
CastLogicType* psCastLogicType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.castlogictype_;
  }
}

/* Entrypoint: parse LogicRtType* from file. */
LogicRtType* pLogicRtType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicrttype_;
  }
}

/* Entrypoint: parse LogicRtType* from string. */
LogicRtType* psLogicRtType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicrttype_;
  }
}

/* Entrypoint: parse AbsSpecOption* from file. */
AbsSpecOption* pAbsSpecOption(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspecoption_;
  }
}

/* Entrypoint: parse AbsSpecOption* from string. */
AbsSpecOption* psAbsSpecOption(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspecoption_;
  }
}

/* Entrypoint: parse AbsSpecCVOption* from file. */
AbsSpecCVOption* pAbsSpecCVOption(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspeccvoption_;
  }
}

/* Entrypoint: parse AbsSpecCVOption* from string. */
AbsSpecCVOption* psAbsSpecCVOption(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspeccvoption_;
  }
}

/* Entrypoint: parse AbsSpec* from file. */
AbsSpec* pAbsSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspec_;
  }
}

/* Entrypoint: parse AbsSpec* from string. */
AbsSpec* psAbsSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspec_;
  }
}

/* Entrypoint: parse AbsSpecCV* from file. */
AbsSpecCV* pAbsSpecCV(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspeccv_;
  }
}

/* Entrypoint: parse AbsSpecCV* from string. */
AbsSpecCV* psAbsSpecCV(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspeccv_;
  }
}

/* Entrypoint: parse AbsSpec* from file. */
AbsSpec* pAbsSpec1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspec_;
  }
}

/* Entrypoint: parse AbsSpec* from string. */
AbsSpec* psAbsSpec1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspec_;
  }
}

/* Entrypoint: parse AbsSpecCV* from file. */
AbsSpecCV* pAbsSpecCV1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspeccv_;
  }
}

/* Entrypoint: parse AbsSpecCV* from string. */
AbsSpecCV* psAbsSpecCV1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.absspeccv_;
  }
}

/* Entrypoint: parse Stars* from file. */
Stars* pStars(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stars_;
  }
}

/* Entrypoint: parse Stars* from string. */
Stars* psStars(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stars_;
  }
}

/* Entrypoint: parse ListStars* from file. */
ListStars* pListStars(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststars_->begin(), result.liststars_->end());
    return result.liststars_;
  }
}

/* Entrypoint: parse ListStars* from string. */
ListStars* psListStars(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststars_->begin(), result.liststars_->end());
    return result.liststars_;
  }
}

/* Entrypoint: parse StarsCV* from file. */
StarsCV* pStarsCV(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.starscv_;
  }
}

/* Entrypoint: parse StarsCV* from string. */
StarsCV* psStarsCV(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.starscv_;
  }
}

/* Entrypoint: parse ListStarsCV* from file. */
ListStarsCV* pListStarsCV(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststarscv_->begin(), result.liststarscv_->end());
    return result.liststarscv_;
  }
}

/* Entrypoint: parse ListStarsCV* from string. */
ListStarsCV* psListStarsCV(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststarscv_->begin(), result.liststarscv_->end());
    return result.liststarscv_;
  }
}

/* Entrypoint: parse Tabs* from file. */
Tabs* pTabs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tabs_;
  }
}

/* Entrypoint: parse Tabs* from string. */
Tabs* psTabs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tabs_;
  }
}

/* Entrypoint: parse ListTabs* from file. */
ListTabs* pListTabs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtabs_->begin(), result.listtabs_->end());
    return result.listtabs_;
  }
}

/* Entrypoint: parse ListTabs* from string. */
ListTabs* psListTabs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtabs_->begin(), result.listtabs_->end());
    return result.listtabs_;
  }
}

/* Entrypoint: parse TypeSpecSimple* from file. */
TypeSpecSimple* pTypeSpecSimple(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecsimple_;
  }
}

/* Entrypoint: parse TypeSpecSimple* from string. */
TypeSpecSimple* psTypeSpecSimple(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecsimple_;
  }
}

/* Entrypoint: parse TypeSpecOFTYPENAME* from file. */
TypeSpecOFTYPENAME* pTypeSpecOFTYPENAME(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecoftypename_;
  }
}

/* Entrypoint: parse TypeSpecOFTYPENAME* from string. */
TypeSpecOFTYPENAME* psTypeSpecOFTYPENAME(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecoftypename_;
  }
}

/* Entrypoint: parse TypeSpecOFIdentifierOrTypename* from file. */
TypeSpecOFIdentifierOrTypename* pTypeSpecOFIdentifierOrTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecofidentifierortypename_;
  }
}

/* Entrypoint: parse TypeSpecOFIdentifierOrTypename* from string. */
TypeSpecOFIdentifierOrTypename* psTypeSpecOFIdentifierOrTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecofidentifierortypename_;
  }
}

/* Entrypoint: parse FullIdentifier* from file. */
FullIdentifier* pFullIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fullidentifier_;
  }
}

/* Entrypoint: parse FullIdentifier* from string. */
FullIdentifier* psFullIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fullidentifier_;
  }
}

/* Entrypoint: parse ListFullIdentifier* from file. */
ListFullIdentifier* pListFullIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfullidentifier_->begin(), result.listfullidentifier_->end());
    return result.listfullidentifier_;
  }
}

/* Entrypoint: parse ListFullIdentifier* from string. */
ListFullIdentifier* psListFullIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfullidentifier_->begin(), result.listfullidentifier_->end());
    return result.listfullidentifier_;
  }
}

/* Entrypoint: parse ExtSpec* from file. */
ExtSpec* pExtSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extspec_;
  }
}

/* Entrypoint: parse ExtSpec* from string. */
ExtSpec* psExtSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extspec_;
  }
}

/* Entrypoint: parse ExtGlobalClausesOpt* from file. */
ExtGlobalClausesOpt* pExtGlobalClausesOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalclausesopt_;
  }
}

/* Entrypoint: parse ExtGlobalClausesOpt* from string. */
ExtGlobalClausesOpt* psExtGlobalClausesOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalclausesopt_;
  }
}

/* Entrypoint: parse ExtGlobalClause* from file. */
ExtGlobalClause* pExtGlobalClause(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalclause_;
  }
}

/* Entrypoint: parse ExtGlobalClause* from string. */
ExtGlobalClause* psExtGlobalClause(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalclause_;
  }
}

/* Entrypoint: parse ListExtGlobalClause* from file. */
ListExtGlobalClause* pListExtGlobalClause(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextglobalclause_->begin(), result.listextglobalclause_->end());
    return result.listextglobalclause_;
  }
}

/* Entrypoint: parse ListExtGlobalClause* from string. */
ListExtGlobalClause* psListExtGlobalClause(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextglobalclause_->begin(), result.listextglobalclause_->end());
    return result.listextglobalclause_;
  }
}

/* Entrypoint: parse ExtGlobalSpecsOpt* from file. */
ExtGlobalSpecsOpt* pExtGlobalSpecsOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalspecsopt_;
  }
}

/* Entrypoint: parse ExtGlobalSpecsOpt* from string. */
ExtGlobalSpecsOpt* psExtGlobalSpecsOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalspecsopt_;
  }
}

/* Entrypoint: parse ExtGlobalSpec* from file. */
ExtGlobalSpec* pExtGlobalSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalspec_;
  }
}

/* Entrypoint: parse ExtGlobalSpec* from string. */
ExtGlobalSpec* psExtGlobalSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extglobalspec_;
  }
}

/* Entrypoint: parse ListExtGlobalSpec* from file. */
ListExtGlobalSpec* pListExtGlobalSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextglobalspec_->begin(), result.listextglobalspec_->end());
    return result.listextglobalspec_;
  }
}

/* Entrypoint: parse ListExtGlobalSpec* from string. */
ListExtGlobalSpec* psListExtGlobalSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextglobalspec_->begin(), result.listextglobalspec_->end());
    return result.listextglobalspec_;
  }
}

/* Entrypoint: parse ExtModuleSpecsOpt* from file. */
ExtModuleSpecsOpt* pExtModuleSpecsOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extmodulespecsopt_;
  }
}

/* Entrypoint: parse ExtModuleSpecsOpt* from string. */
ExtModuleSpecsOpt* psExtModuleSpecsOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extmodulespecsopt_;
  }
}

/* Entrypoint: parse ExtModuleSpec* from file. */
ExtModuleSpec* pExtModuleSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extmodulespec_;
  }
}

/* Entrypoint: parse ExtModuleSpec* from string. */
ExtModuleSpec* psExtModuleSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extmodulespec_;
  }
}

/* Entrypoint: parse ListExtModuleSpec* from file. */
ListExtModuleSpec* pListExtModuleSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextmodulespec_->begin(), result.listextmodulespec_->end());
    return result.listextmodulespec_;
  }
}

/* Entrypoint: parse ListExtModuleSpec* from string. */
ListExtModuleSpec* psListExtModuleSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextmodulespec_->begin(), result.listextmodulespec_->end());
    return result.listextmodulespec_;
  }
}

/* Entrypoint: parse ExtFunctionSpecsOpt* from file. */
ExtFunctionSpecsOpt* pExtFunctionSpecsOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunctionspecsopt_;
  }
}

/* Entrypoint: parse ExtFunctionSpecsOpt* from string. */
ExtFunctionSpecsOpt* psExtFunctionSpecsOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunctionspecsopt_;
  }
}

/* Entrypoint: parse ExtFunctionSpecs* from file. */
ExtFunctionSpecs* pExtFunctionSpecs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunctionspecs_;
  }
}

/* Entrypoint: parse ExtFunctionSpecs* from string. */
ExtFunctionSpecs* psExtFunctionSpecs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunctionspecs_;
  }
}

/* Entrypoint: parse ExtFunctionSpec* from file. */
ExtFunctionSpec* pExtFunctionSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunctionspec_;
  }
}

/* Entrypoint: parse ExtFunctionSpec* from string. */
ExtFunctionSpec* psExtFunctionSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunctionspec_;
  }
}

/* Entrypoint: parse ListExtFunctionSpec* from file. */
ListExtFunctionSpec* pListExtFunctionSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextfunctionspec_->begin(), result.listextfunctionspec_->end());
    return result.listextfunctionspec_;
  }
}

/* Entrypoint: parse ListExtFunctionSpec* from string. */
ListExtFunctionSpec* psListExtFunctionSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextfunctionspec_->begin(), result.listextfunctionspec_->end());
    return result.listextfunctionspec_;
  }
}

/* Entrypoint: parse ExtFunSpec* from file. */
ExtFunSpec* pExtFunSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunspec_;
  }
}

/* Entrypoint: parse ExtFunSpec* from string. */
ExtFunSpec* psExtFunSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extfunspec_;
  }
}

/* Entrypoint: parse ListExtFunSpec* from file. */
ListExtFunSpec* pListExtFunSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextfunspec_->begin(), result.listextfunspec_->end());
    return result.listextfunspec_;
  }
}

/* Entrypoint: parse ListExtFunSpec* from string. */
ListExtFunSpec* psListExtFunSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listextfunspec_->begin(), result.listextfunspec_->end());
    return result.listextfunspec_;
  }
}

/* Entrypoint: parse ExtIdentifierOpt* from file. */
ExtIdentifierOpt* pExtIdentifierOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extidentifieropt_;
  }
}

/* Entrypoint: parse ExtIdentifierOpt* from string. */
ExtIdentifierOpt* psExtIdentifierOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extidentifieropt_;
  }
}

/* Entrypoint: parse StmtMarkup* from file. */
StmtMarkup* pStmtMarkup(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stmtmarkup_;
  }
}

/* Entrypoint: parse StmtMarkup* from string. */
StmtMarkup* psStmtMarkup(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stmtmarkup_;
  }
}

/* Entrypoint: parse ListStmtMarkup* from file. */
ListStmtMarkup* pListStmtMarkup(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststmtmarkup_->begin(), result.liststmtmarkup_->end());
    return result.liststmtmarkup_;
  }
}

/* Entrypoint: parse ListStmtMarkup* from string. */
ListStmtMarkup* psListStmtMarkup(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststmtmarkup_->begin(), result.liststmtmarkup_->end());
    return result.liststmtmarkup_;
  }
}

/* Entrypoint: parse Spec* from file. */
Spec* pSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.spec_;
  }
}

/* Entrypoint: parse Spec* from string. */
Spec* psSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.spec_;
  }
}

/* Entrypoint: parse Contract* from file. */
Contract* pContract(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.contract_;
  }
}

/* Entrypoint: parse Contract* from string. */
Contract* psContract(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.contract_;
  }
}

/* Entrypoint: parse ClauseKW* from file. */
ClauseKW* pClauseKW(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.clausekw_;
  }
}

/* Entrypoint: parse ClauseKW* from string. */
ClauseKW* psClauseKW(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.clausekw_;
  }
}

/* Entrypoint: parse Requires* from file. */
Requires* pRequires(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.requires_;
  }
}

/* Entrypoint: parse Requires* from string. */
Requires* psRequires(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.requires_;
  }
}

/* Entrypoint: parse NERequires* from file. */
NERequires* pNERequires(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nerequires_;
  }
}

/* Entrypoint: parse NERequires* from string. */
NERequires* psNERequires(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nerequires_;
  }
}

/* Entrypoint: parse Terminates* from file. */
Terminates* pTerminates(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.terminates_;
  }
}

/* Entrypoint: parse Terminates* from string. */
Terminates* psTerminates(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.terminates_;
  }
}

/* Entrypoint: parse NETerminates* from file. */
NETerminates* pNETerminates(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.neterminates_;
  }
}

/* Entrypoint: parse NETerminates* from string. */
NETerminates* psNETerminates(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.neterminates_;
  }
}

/* Entrypoint: parse Decreases* from file. */
Decreases* pDecreases(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decreases_;
  }
}

/* Entrypoint: parse Decreases* from string. */
Decreases* psDecreases(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decreases_;
  }
}

/* Entrypoint: parse NEDecreases* from file. */
NEDecreases* pNEDecreases(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nedecreases_;
  }
}

/* Entrypoint: parse NEDecreases* from string. */
NEDecreases* psNEDecreases(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nedecreases_;
  }
}

/* Entrypoint: parse Variant* from file. */
Variant* pVariant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variant_;
  }
}

/* Entrypoint: parse Variant* from string. */
Variant* psVariant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variant_;
  }
}

/* Entrypoint: parse SimpleClauses* from file. */
SimpleClauses* pSimpleClauses(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.simpleclauses_;
  }
}

/* Entrypoint: parse SimpleClauses* from string. */
SimpleClauses* psSimpleClauses(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.simpleclauses_;
  }
}

/* Entrypoint: parse Allocation* from file. */
Allocation* pAllocation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.allocation_;
  }
}

/* Entrypoint: parse Allocation* from string. */
Allocation* psAllocation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.allocation_;
  }
}

/* Entrypoint: parse NESimpleClauses* from file. */
NESimpleClauses* pNESimpleClauses(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nesimpleclauses_;
  }
}

/* Entrypoint: parse NESimpleClauses* from string. */
NESimpleClauses* psNESimpleClauses(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nesimpleclauses_;
  }
}

/* Entrypoint: parse ExtensionContent* from file. */
ExtensionContent* pExtensionContent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extensioncontent_;
  }
}

/* Entrypoint: parse ExtensionContent* from string. */
ExtensionContent* psExtensionContent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extensioncontent_;
  }
}

/* Entrypoint: parse Behaviors* from file. */
Behaviors* pBehaviors(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviors_;
  }
}

/* Entrypoint: parse Behaviors* from string. */
Behaviors* psBehaviors(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviors_;
  }
}

/* Entrypoint: parse NEBehaviors* from file. */
NEBehaviors* pNEBehaviors(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nebehaviors_;
  }
}

/* Entrypoint: parse NEBehaviors* from string. */
NEBehaviors* psNEBehaviors(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nebehaviors_;
  }
}

/* Entrypoint: parse BehaviorBody* from file. */
BehaviorBody* pBehaviorBody(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviorbody_;
  }
}

/* Entrypoint: parse BehaviorBody* from string. */
BehaviorBody* psBehaviorBody(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviorbody_;
  }
}

/* Entrypoint: parse Assumes* from file. */
Assumes* pAssumes(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assumes_;
  }
}

/* Entrypoint: parse Assumes* from string. */
Assumes* psAssumes(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assumes_;
  }
}

/* Entrypoint: parse CompleteOrDisjoint* from file. */
CompleteOrDisjoint* pCompleteOrDisjoint(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.completeordisjoint_;
  }
}

/* Entrypoint: parse CompleteOrDisjoint* from string. */
CompleteOrDisjoint* psCompleteOrDisjoint(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.completeordisjoint_;
  }
}

/* Entrypoint: parse NECompleteOrDisjoint* from file. */
NECompleteOrDisjoint* pNECompleteOrDisjoint(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.necompleteordisjoint_;
  }
}

/* Entrypoint: parse NECompleteOrDisjoint* from string. */
NECompleteOrDisjoint* psNECompleteOrDisjoint(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.necompleteordisjoint_;
  }
}

/* Entrypoint: parse Assigns* from file. */
Assigns* pAssigns(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assigns_;
  }
}

/* Entrypoint: parse Assigns* from string. */
Assigns* psAssigns(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assigns_;
  }
}

/* Entrypoint: parse Zones* from file. */
Zones* pZones(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.zones_;
  }
}

/* Entrypoint: parse Zones* from string. */
Zones* psZones(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.zones_;
  }
}

/* Entrypoint: parse LogicPTreeAnnot* from file. */
LogicPTreeAnnot* pLogicPTreeAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicptreeannot_;
  }
}

/* Entrypoint: parse LogicPTreeAnnot* from string. */
LogicPTreeAnnot* psLogicPTreeAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicptreeannot_;
  }
}

/* Entrypoint: parse ListLogicPTreeAnnot* from file. */
ListLogicPTreeAnnot* pListLogicPTreeAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlogicptreeannot_;
  }
}

/* Entrypoint: parse ListLogicPTreeAnnot* from string. */
ListLogicPTreeAnnot* psListLogicPTreeAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlogicptreeannot_;
  }
}

/* Entrypoint: parse Annotation* from file. */
Annotation* pAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotation_;
  }
}

/* Entrypoint: parse Annotation* from string. */
Annotation* psAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotation_;
  }
}

/* Entrypoint: parse LoopAnnotStack* from file. */
LoopAnnotStack* pLoopAnnotStack(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotstack_;
  }
}

/* Entrypoint: parse LoopAnnotStack* from string. */
LoopAnnotStack* psLoopAnnotStack(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotstack_;
  }
}

/* Entrypoint: parse LoopAnnotOpt* from file. */
LoopAnnotOpt* pLoopAnnotOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotopt_;
  }
}

/* Entrypoint: parse LoopAnnotOpt* from string. */
LoopAnnotOpt* psLoopAnnotOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotopt_;
  }
}

/* Entrypoint: parse LoopEffects* from file. */
LoopEffects* pLoopEffects(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopeffects_;
  }
}

/* Entrypoint: parse LoopEffects* from string. */
LoopEffects* psLoopEffects(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopeffects_;
  }
}

/* Entrypoint: parse LoopAllocation* from file. */
LoopAllocation* pLoopAllocation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopallocation_;
  }
}

/* Entrypoint: parse LoopAllocation* from string. */
LoopAllocation* psLoopAllocation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopallocation_;
  }
}

/* Entrypoint: parse LoopInvariant* from file. */
LoopInvariant* pLoopInvariant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopinvariant_;
  }
}

/* Entrypoint: parse LoopInvariant* from string. */
LoopInvariant* psLoopInvariant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopinvariant_;
  }
}

/* Entrypoint: parse LoopVariant* from file. */
LoopVariant* pLoopVariant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopvariant_;
  }
}

/* Entrypoint: parse LoopVariant* from string. */
LoopVariant* psLoopVariant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopvariant_;
  }
}

/* Entrypoint: parse LoopGrammarExtension* from file. */
LoopGrammarExtension* pLoopGrammarExtension(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopgrammarextension_;
  }
}

/* Entrypoint: parse LoopGrammarExtension* from string. */
LoopGrammarExtension* psLoopGrammarExtension(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopgrammarextension_;
  }
}

/* Entrypoint: parse LoopPragma* from file. */
LoopPragma* pLoopPragma(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.looppragma_;
  }
}

/* Entrypoint: parse LoopPragma* from string. */
LoopPragma* psLoopPragma(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.looppragma_;
  }
}

/* Entrypoint: parse BegPragmaOrCodeAnnotation* from file. */
BegPragmaOrCodeAnnotation* pBegPragmaOrCodeAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.begpragmaorcodeannotation_;
  }
}

/* Entrypoint: parse BegPragmaOrCodeAnnotation* from string. */
BegPragmaOrCodeAnnotation* psBegPragmaOrCodeAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.begpragmaorcodeannotation_;
  }
}

/* Entrypoint: parse PragmaOrCodeAnnotation* from file. */
PragmaOrCodeAnnotation* pPragmaOrCodeAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pragmaorcodeannotation_;
  }
}

/* Entrypoint: parse PragmaOrCodeAnnotation* from string. */
PragmaOrCodeAnnotation* psPragmaOrCodeAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pragmaorcodeannotation_;
  }
}

/* Entrypoint: parse CodeAnnotation* from file. */
CodeAnnotation* pCodeAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.codeannotation_;
  }
}

/* Entrypoint: parse CodeAnnotation* from string. */
CodeAnnotation* psCodeAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.codeannotation_;
  }
}

/* Entrypoint: parse SlicePragma* from file. */
SlicePragma* pSlicePragma(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.slicepragma_;
  }
}

/* Entrypoint: parse SlicePragma* from string. */
SlicePragma* psSlicePragma(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.slicepragma_;
  }
}

/* Entrypoint: parse ImpactPragma* from file. */
ImpactPragma* pImpactPragma(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.impactpragma_;
  }
}

/* Entrypoint: parse ImpactPragma* from string. */
ImpactPragma* psImpactPragma(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.impactpragma_;
  }
}

/* Entrypoint: parse Decl* from file. */
Decl* pDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decl_;
  }
}

/* Entrypoint: parse Decl* from string. */
Decl* psDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decl_;
  }
}

/* Entrypoint: parse ListDecl* from file. */
ListDecl* pListDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listdecl_->begin(), result.listdecl_->end());
    return result.listdecl_;
  }
}

/* Entrypoint: parse ListDecl* from string. */
ListDecl* psListDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listdecl_->begin(), result.listdecl_->end());
    return result.listdecl_;
  }
}

/* Entrypoint: parse ExtDecl* from file. */
ExtDecl* pExtDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extdecl_;
  }
}

/* Entrypoint: parse ExtDecl* from string. */
ExtDecl* psExtDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extdecl_;
  }
}

/* Entrypoint: parse ListExtDecl* from file. */
ListExtDecl* pListExtDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listextdecl_;
  }
}

/* Entrypoint: parse ListExtDecl* from string. */
ListExtDecl* psListExtDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listextdecl_;
  }
}

/* Entrypoint: parse VolatileOpt* from file. */
VolatileOpt* pVolatileOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.volatileopt_;
  }
}

/* Entrypoint: parse VolatileOpt* from string. */
VolatileOpt* psVolatileOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.volatileopt_;
  }
}

/* Entrypoint: parse ListVolatileOpt* from file. */
ListVolatileOpt* pListVolatileOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listvolatileopt_;
  }
}

/* Entrypoint: parse ListVolatileOpt* from string. */
ListVolatileOpt* psListVolatileOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listvolatileopt_;
  }
}

/* Entrypoint: parse TypeAnnot* from file. */
TypeAnnot* pTypeAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typeannot_;
  }
}

/* Entrypoint: parse TypeAnnot* from string. */
TypeAnnot* psTypeAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typeannot_;
  }
}

/* Entrypoint: parse OptSemicolon* from file. */
OptSemicolon* pOptSemicolon(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optsemicolon_;
  }
}

/* Entrypoint: parse OptSemicolon* from string. */
OptSemicolon* psOptSemicolon(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optsemicolon_;
  }
}

/* Entrypoint: parse ModelAnnot* from file. */
ModelAnnot* pModelAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.modelannot_;
  }
}

/* Entrypoint: parse ModelAnnot* from string. */
ModelAnnot* psModelAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.modelannot_;
  }
}

/* Entrypoint: parse PolyIdType* from file. */
PolyIdType* pPolyIdType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.polyidtype_;
  }
}

/* Entrypoint: parse PolyIdType* from string. */
PolyIdType* psPolyIdType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.polyidtype_;
  }
}

/* Entrypoint: parse PolyId* from file. */
PolyId* pPolyId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.polyid_;
  }
}

/* Entrypoint: parse PolyId* from string. */
PolyId* psPolyId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.polyid_;
  }
}

/* Entrypoint: parse OptParameters* from file. */
OptParameters* pOptParameters(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optparameters_;
  }
}

/* Entrypoint: parse OptParameters* from string. */
OptParameters* psOptParameters(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optparameters_;
  }
}

/* Entrypoint: parse Parameters* from file. */
Parameters* pParameters(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameters_;
  }
}

/* Entrypoint: parse Parameters* from string. */
Parameters* psParameters(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameters_;
  }
}

/* Entrypoint: parse LogicDef* from file. */
LogicDef* pLogicDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicdef_;
  }
}

/* Entrypoint: parse LogicDef* from string. */
LogicDef* psLogicDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicdef_;
  }
}

/* Entrypoint: parse DeprecatedLogicDecl* from file. */
DeprecatedLogicDecl* pDeprecatedLogicDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.deprecatedlogicdecl_;
  }
}

/* Entrypoint: parse DeprecatedLogicDecl* from string. */
DeprecatedLogicDecl* psDeprecatedLogicDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.deprecatedlogicdecl_;
  }
}

/* Entrypoint: parse LogicDecl* from file. */
LogicDecl* pLogicDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicdecl_;
  }
}

/* Entrypoint: parse LogicDecl* from string. */
LogicDecl* psLogicDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicdecl_;
  }
}

/* Entrypoint: parse ListLogicDecl* from file. */
ListLogicDecl* pListLogicDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlogicdecl_;
  }
}

/* Entrypoint: parse ListLogicDecl* from string. */
ListLogicDecl* psListLogicDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlogicdecl_;
  }
}

/* Entrypoint: parse ReadsClause* from file. */
ReadsClause* pReadsClause(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.readsclause_;
  }
}

/* Entrypoint: parse ReadsClause* from string. */
ReadsClause* psReadsClause(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.readsclause_;
  }
}

/* Entrypoint: parse Typedef* from file. */
Typedef* pTypedef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typedef_;
  }
}

/* Entrypoint: parse Typedef* from string. */
Typedef* psTypedef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typedef_;
  }
}

/* Entrypoint: parse DataconsWithSeparator* from file. */
DataconsWithSeparator* pDataconsWithSeparator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.dataconswithseparator_;
  }
}

/* Entrypoint: parse DataconsWithSeparator* from string. */
DataconsWithSeparator* psDataconsWithSeparator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.dataconswithseparator_;
  }
}

/* Entrypoint: parse ListDataconsWithSeparator* from file. */
ListDataconsWithSeparator* pListDataconsWithSeparator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listdataconswithseparator_->begin(), result.listdataconswithseparator_->end());
    return result.listdataconswithseparator_;
  }
}

/* Entrypoint: parse ListDataconsWithSeparator* from string. */
ListDataconsWithSeparator* psListDataconsWithSeparator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listdataconswithseparator_->begin(), result.listdataconswithseparator_->end());
    return result.listdataconswithseparator_;
  }
}

/* Entrypoint: parse Datacons* from file. */
Datacons* pDatacons(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.datacons_;
  }
}

/* Entrypoint: parse Datacons* from string. */
Datacons* psDatacons(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.datacons_;
  }
}

/* Entrypoint: parse Indcase* from file. */
Indcase* pIndcase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.indcase_;
  }
}

/* Entrypoint: parse Indcase* from string. */
Indcase* psIndcase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.indcase_;
  }
}

/* Entrypoint: parse ListIndcase* from file. */
ListIndcase* pListIndcase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listindcase_;
  }
}

/* Entrypoint: parse ListIndcase* from string. */
ListIndcase* psListIndcase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listindcase_;
  }
}

/* Entrypoint: parse OptLabel* from file. */
OptLabel* pOptLabel1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabel* from string. */
OptLabel* psOptLabel1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabel* from file. */
OptLabel* pOptLabel2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabel* from string. */
OptLabel* psOptLabel2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabelList* from file. */
OptLabelList* pOptLabelList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabellist_;
  }
}

/* Entrypoint: parse OptLabelList* from string. */
OptLabelList* psOptLabelList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabellist_;
  }
}

/* Entrypoint: parse LabelName* from file. */
LabelName* pLabelName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.labelname_;
  }
}

/* Entrypoint: parse LabelName* from string. */
LabelName* psLabelName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.labelname_;
  }
}

/* Entrypoint: parse ListLabelName* from file. */
ListLabelName* pListLabelName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlabelname_->begin(), result.listlabelname_->end());
    return result.listlabelname_;
  }
}

/* Entrypoint: parse ListLabelName* from string. */
ListLabelName* psListLabelName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlabelname_->begin(), result.listlabelname_->end());
    return result.listlabelname_;
  }
}

/* Entrypoint: parse BehaviorNameList* from file. */
BehaviorNameList* pBehaviorNameList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviornamelist_;
  }
}

/* Entrypoint: parse BehaviorNameList* from string. */
BehaviorNameList* psBehaviorNameList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviornamelist_;
  }
}

/* Entrypoint: parse BehaviorName* from file. */
BehaviorName* pBehaviorName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviorname_;
  }
}

/* Entrypoint: parse BehaviorName* from string. */
BehaviorName* psBehaviorName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviorname_;
  }
}

/* Entrypoint: parse ListBehaviorName* from file. */
ListBehaviorName* pListBehaviorName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbehaviorname_->begin(), result.listbehaviorname_->end());
    return result.listbehaviorname_;
  }
}

/* Entrypoint: parse ListBehaviorName* from string. */
ListBehaviorName* psListBehaviorName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbehaviorname_->begin(), result.listbehaviorname_->end());
    return result.listbehaviorname_;
  }
}

/* Entrypoint: parse AnyIdentifier* from file. */
AnyIdentifier* pAnyIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.anyidentifier_;
  }
}

/* Entrypoint: parse AnyIdentifier* from string. */
AnyIdentifier* psAnyIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.anyidentifier_;
  }
}

/* Entrypoint: parse IdentifierOrTypename* from file. */
IdentifierOrTypename* pIdentifierOrTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifierortypename_;
  }
}

/* Entrypoint: parse IdentifierOrTypename* from string. */
IdentifierOrTypename* psIdentifierOrTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifierortypename_;
  }
}

/* Entrypoint: parse IdentifierOrTypenameFull* from file. */
IdentifierOrTypenameFull* pIdentifierOrTypenameFull(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifierortypenamefull_;
  }
}

/* Entrypoint: parse IdentifierOrTypenameFull* from string. */
IdentifierOrTypenameFull* psIdentifierOrTypenameFull(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifierortypenamefull_;
  }
}

/* Entrypoint: parse ListIdentifierOrTypenameFull* from file. */
ListIdentifierOrTypenameFull* pListIdentifierOrTypenameFull(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listidentifierortypenamefull_->begin(), result.listidentifierortypenamefull_->end());
    return result.listidentifierortypenamefull_;
  }
}

/* Entrypoint: parse ListIdentifierOrTypenameFull* from string. */
ListIdentifierOrTypenameFull* psListIdentifierOrTypenameFull(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listidentifierortypenamefull_->begin(), result.listidentifierortypenamefull_->end());
    return result.listidentifierortypenamefull_;
  }
}

/* Entrypoint: parse Identifier* from file. */
Identifier* pIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifier_;
  }
}

/* Entrypoint: parse Identifier* from string. */
Identifier* psIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifier_;
  }
}

/* Entrypoint: parse BoundedVar* from file. */
BoundedVar* pBoundedVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.boundedvar_;
  }
}

/* Entrypoint: parse BoundedVar* from string. */
BoundedVar* psBoundedVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.boundedvar_;
  }
}

/* Entrypoint: parse CKeyword* from file. */
CKeyword* pCKeyword(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ckeyword_;
  }
}

/* Entrypoint: parse CKeyword* from string. */
CKeyword* psCKeyword(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ckeyword_;
  }
}

/* Entrypoint: parse ACSLCKeyword* from file. */
ACSLCKeyword* pACSLCKeyword(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.acslckeyword_;
  }
}

/* Entrypoint: parse ACSLCKeyword* from string. */
ACSLCKeyword* psACSLCKeyword(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.acslckeyword_;
  }
}

/* Entrypoint: parse PostCond* from file. */
PostCond* pPostCond(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.postcond_;
  }
}

/* Entrypoint: parse PostCond* from string. */
PostCond* psPostCond(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.postcond_;
  }
}

/* Entrypoint: parse IsACSLSpec* from file. */
IsACSLSpec* pIsACSLSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isacslspec_;
  }
}

/* Entrypoint: parse IsACSLSpec* from string. */
IsACSLSpec* psIsACSLSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isacslspec_;
  }
}

/* Entrypoint: parse IsACSLDeclOrCodeAnnot* from file. */
IsACSLDeclOrCodeAnnot* pIsACSLDeclOrCodeAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isacsldeclorcodeannot_;
  }
}

/* Entrypoint: parse IsACSLDeclOrCodeAnnot* from string. */
IsACSLDeclOrCodeAnnot* psIsACSLDeclOrCodeAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isacsldeclorcodeannot_;
  }
}

/* Entrypoint: parse IsACSLTypename* from file. */
IsACSLTypename* pIsACSLTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isacsltypename_;
  }
}

/* Entrypoint: parse IsACSLTypename* from string. */
IsACSLTypename* psIsACSLTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isacsltypename_;
  }
}

/* Entrypoint: parse IsExtSpec* from file. */
IsExtSpec* pIsExtSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isextspec_;
  }
}

/* Entrypoint: parse IsExtSpec* from string. */
IsExtSpec* psIsExtSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.isextspec_;
  }
}

/* Entrypoint: parse Keyword* from file. */
Keyword* pKeyword(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.keyword_;
  }
}

/* Entrypoint: parse Keyword* from string. */
Keyword* psKeyword(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.keyword_;
  }
}

/* Entrypoint: parse BSKeyword* from file. */
BSKeyword* pBSKeyword(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bskeyword_;
  }
}

/* Entrypoint: parse BSKeyword* from string. */
BSKeyword* psBSKeyword(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bskeyword_;
  }
}

/* Entrypoint: parse Wildcard* from file. */
Wildcard* pWildcard(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.wildcard_;
  }
}

/* Entrypoint: parse Wildcard* from string. */
Wildcard* psWildcard(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.wildcard_;
  }
}

/* Entrypoint: parse ListWildcard* from file. */
ListWildcard* pListWildcard(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listwildcard_->begin(), result.listwildcard_->end());
    return result.listwildcard_;
  }
}

/* Entrypoint: parse ListWildcard* from string. */
ListWildcard* psListWildcard(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listwildcard_->begin(), result.listwildcard_->end());
    return result.listwildcard_;
  }
}


}
