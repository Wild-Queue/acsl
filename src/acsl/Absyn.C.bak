/* File generated by the BNF Converter (bnfc 2.9.4.1). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace acsl
{
/********************   AProgram    ********************/
AProgram::AProgram(Globals *p1)
{
  globals_ = p1;

}

AProgram::AProgram(const AProgram & other)
{
  globals_ = other.globals_->clone();

}

AProgram &AProgram::operator=(const AProgram & other)
{
  AProgram tmp(other);
  swap(tmp);
  return *this;
}

void AProgram::swap(AProgram & other)
{
  std::swap(globals_, other.globals_);

}

AProgram::~AProgram()
{
  delete(globals_);

}

void AProgram::accept(Visitor *v)
{
  v->visitAProgram(this);
}

AProgram *AProgram::clone() const
{
  return new AProgram(*this);
}



/********************   NoGlobals    ********************/
NoGlobals::NoGlobals()
{

}

NoGlobals::NoGlobals(const NoGlobals & other)
{

}

NoGlobals &NoGlobals::operator=(const NoGlobals & other)
{
  NoGlobals tmp(other);
  swap(tmp);
  return *this;
}

void NoGlobals::swap(NoGlobals & other)
{

}

NoGlobals::~NoGlobals()
{

}

void NoGlobals::accept(Visitor *v)
{
  v->visitNoGlobals(this);
}

NoGlobals *NoGlobals::clone() const
{
  return new NoGlobals(*this);
}



/********************   SimpleGlobals    ********************/
SimpleGlobals::SimpleGlobals(Global *p1, Globals *p2)
{
  global_ = p1;
  globals_ = p2;

}

SimpleGlobals::SimpleGlobals(const SimpleGlobals & other)
{
  global_ = other.global_->clone();
  globals_ = other.globals_->clone();

}

SimpleGlobals &SimpleGlobals::operator=(const SimpleGlobals & other)
{
  SimpleGlobals tmp(other);
  swap(tmp);
  return *this;
}

void SimpleGlobals::swap(SimpleGlobals & other)
{
  std::swap(global_, other.global_);
  std::swap(globals_, other.globals_);

}

SimpleGlobals::~SimpleGlobals()
{
  delete(global_);
  delete(globals_);

}

void SimpleGlobals::accept(Visitor *v)
{
  v->visitSimpleGlobals(this);
}

SimpleGlobals *SimpleGlobals::clone() const
{
  return new SimpleGlobals(*this);
}



/********************   AGhostGlobals    ********************/
AGhostGlobals::AGhostGlobals(GhostGlobals *p1, Globals *p2)
{
  ghostglobals_ = p1;
  globals_ = p2;

}

AGhostGlobals::AGhostGlobals(const AGhostGlobals & other)
{
  ghostglobals_ = other.ghostglobals_->clone();
  globals_ = other.globals_->clone();

}

AGhostGlobals &AGhostGlobals::operator=(const AGhostGlobals & other)
{
  AGhostGlobals tmp(other);
  swap(tmp);
  return *this;
}

void AGhostGlobals::swap(AGhostGlobals & other)
{
  std::swap(ghostglobals_, other.ghostglobals_);
  std::swap(globals_, other.globals_);

}

AGhostGlobals::~AGhostGlobals()
{
  delete(ghostglobals_);
  delete(globals_);

}

void AGhostGlobals::accept(Visitor *v)
{
  v->visitAGhostGlobals(this);
}

AGhostGlobals *AGhostGlobals::clone() const
{
  return new AGhostGlobals(*this);
}



/********************   SemiColonGlobals    ********************/
SemiColonGlobals::SemiColonGlobals(Globals *p1)
{
  globals_ = p1;

}

SemiColonGlobals::SemiColonGlobals(const SemiColonGlobals & other)
{
  globals_ = other.globals_->clone();

}

SemiColonGlobals &SemiColonGlobals::operator=(const SemiColonGlobals & other)
{
  SemiColonGlobals tmp(other);
  swap(tmp);
  return *this;
}

void SemiColonGlobals::swap(SemiColonGlobals & other)
{
  std::swap(globals_, other.globals_);

}

SemiColonGlobals::~SemiColonGlobals()
{
  delete(globals_);

}

void SemiColonGlobals::accept(Visitor *v)
{
  v->visitSemiColonGlobals(this);
}

SemiColonGlobals *SemiColonGlobals::clone() const
{
  return new SemiColonGlobals(*this);
}



/********************   GhostGlobalsDeclataion    ********************/
GhostGlobalsDeclataion::GhostGlobalsDeclataion(Declaration *p1, GhostGlobals *p2)
{
  declaration_ = p1;
  ghostglobals_ = p2;

}

GhostGlobalsDeclataion::GhostGlobalsDeclataion(const GhostGlobalsDeclataion & other)
{
  declaration_ = other.declaration_->clone();
  ghostglobals_ = other.ghostglobals_->clone();

}

GhostGlobalsDeclataion &GhostGlobalsDeclataion::operator=(const GhostGlobalsDeclataion & other)
{
  GhostGlobalsDeclataion tmp(other);
  swap(tmp);
  return *this;
}

void GhostGlobalsDeclataion::swap(GhostGlobalsDeclataion & other)
{
  std::swap(declaration_, other.declaration_);
  std::swap(ghostglobals_, other.ghostglobals_);

}

GhostGlobalsDeclataion::~GhostGlobalsDeclataion()
{
  delete(declaration_);
  delete(ghostglobals_);

}

void GhostGlobalsDeclataion::accept(Visitor *v)
{
  v->visitGhostGlobalsDeclataion(this);
}

GhostGlobalsDeclataion *GhostGlobalsDeclataion::clone() const
{
  return new GhostGlobalsDeclataion(*this);
}



/********************   GhostGlobalsFunctionDef    ********************/
GhostGlobalsFunctionDef::GhostGlobalsFunctionDef(FunctionDef *p1, GhostGlobals *p2)
{
  functiondef_ = p1;
  ghostglobals_ = p2;

}

GhostGlobalsFunctionDef::GhostGlobalsFunctionDef(const GhostGlobalsFunctionDef & other)
{
  functiondef_ = other.functiondef_->clone();
  ghostglobals_ = other.ghostglobals_->clone();

}

GhostGlobalsFunctionDef &GhostGlobalsFunctionDef::operator=(const GhostGlobalsFunctionDef & other)
{
  GhostGlobalsFunctionDef tmp(other);
  swap(tmp);
  return *this;
}

void GhostGlobalsFunctionDef::swap(GhostGlobalsFunctionDef & other)
{
  std::swap(functiondef_, other.functiondef_);
  std::swap(ghostglobals_, other.ghostglobals_);

}

GhostGlobalsFunctionDef::~GhostGlobalsFunctionDef()
{
  delete(functiondef_);
  delete(ghostglobals_);

}

void GhostGlobalsFunctionDef::accept(Visitor *v)
{
  v->visitGhostGlobalsFunctionDef(this);
}

GhostGlobalsFunctionDef *GhostGlobalsFunctionDef::clone() const
{
  return new GhostGlobalsFunctionDef(*this);
}



/********************   GhostGlobalsRGhost    ********************/
GhostGlobalsRGhost::GhostGlobalsRGhost(RGHOST p1)
{
  rghost_ = p1;

}

GhostGlobalsRGhost::GhostGlobalsRGhost(const GhostGlobalsRGhost & other)
{
  rghost_ = other.rghost_;

}

GhostGlobalsRGhost &GhostGlobalsRGhost::operator=(const GhostGlobalsRGhost & other)
{
  GhostGlobalsRGhost tmp(other);
  swap(tmp);
  return *this;
}

void GhostGlobalsRGhost::swap(GhostGlobalsRGhost & other)
{
  std::swap(rghost_, other.rghost_);

}

GhostGlobalsRGhost::~GhostGlobalsRGhost()
{

}

void GhostGlobalsRGhost::accept(Visitor *v)
{
  v->visitGhostGlobalsRGhost(this);
}

GhostGlobalsRGhost *GhostGlobalsRGhost::clone() const
{
  return new GhostGlobalsRGhost(*this);
}



/********************   GlobalsFunctionDef    ********************/
GlobalsFunctionDef::GlobalsFunctionDef(FunctionDef *p1)
{
  functiondef_ = p1;

}

GlobalsFunctionDef::GlobalsFunctionDef(const GlobalsFunctionDef & other)
{
  functiondef_ = other.functiondef_->clone();

}

GlobalsFunctionDef &GlobalsFunctionDef::operator=(const GlobalsFunctionDef & other)
{
  GlobalsFunctionDef tmp(other);
  swap(tmp);
  return *this;
}

void GlobalsFunctionDef::swap(GlobalsFunctionDef & other)
{
  std::swap(functiondef_, other.functiondef_);

}

GlobalsFunctionDef::~GlobalsFunctionDef()
{
  delete(functiondef_);

}

void GlobalsFunctionDef::accept(Visitor *v)
{
  v->visitGlobalsFunctionDef(this);
}

GlobalsFunctionDef *GlobalsFunctionDef::clone() const
{
  return new GlobalsFunctionDef(*this);
}



/********************   GlobalDecl    ********************/
GlobalDecl::GlobalDecl(Decl *p1)
{
  decl_ = p1;

}

GlobalDecl::GlobalDecl(const GlobalDecl & other)
{
  decl_ = other.decl_->clone();

}

GlobalDecl &GlobalDecl::operator=(const GlobalDecl & other)
{
  GlobalDecl tmp(other);
  swap(tmp);
  return *this;
}

void GlobalDecl::swap(GlobalDecl & other)
{
  std::swap(decl_, other.decl_);

}

GlobalDecl::~GlobalDecl()
{
  delete(decl_);

}

void GlobalDecl::accept(Visitor *v)
{
  v->visitGlobalDecl(this);
}

GlobalDecl *GlobalDecl::clone() const
{
  return new GlobalDecl(*this);
}



/********************   GlobalsDeclataion    ********************/
GlobalsDeclataion::GlobalsDeclataion(Declaration *p1)
{
  declaration_ = p1;

}

GlobalsDeclataion::GlobalsDeclataion(const GlobalsDeclataion & other)
{
  declaration_ = other.declaration_->clone();

}

GlobalsDeclataion &GlobalsDeclataion::operator=(const GlobalsDeclataion & other)
{
  GlobalsDeclataion tmp(other);
  swap(tmp);
  return *this;
}

void GlobalsDeclataion::swap(GlobalsDeclataion & other)
{
  std::swap(declaration_, other.declaration_);

}

GlobalsDeclataion::~GlobalsDeclataion()
{
  delete(declaration_);

}

void GlobalsDeclataion::accept(Visitor *v)
{
  v->visitGlobalsDeclataion(this);
}

GlobalsDeclataion *GlobalsDeclataion::clone() const
{
  return new GlobalsDeclataion(*this);
}



/********************   ExternGlobalDeclataion    ********************/
ExternGlobalDeclataion::ExternGlobalDeclataion(StringConstant *p1, Declaration *p2)
{
  stringconstant_ = p1;
  declaration_ = p2;

}

ExternGlobalDeclataion::ExternGlobalDeclataion(const ExternGlobalDeclataion & other)
{
  stringconstant_ = other.stringconstant_->clone();
  declaration_ = other.declaration_->clone();

}

ExternGlobalDeclataion &ExternGlobalDeclataion::operator=(const ExternGlobalDeclataion & other)
{
  ExternGlobalDeclataion tmp(other);
  swap(tmp);
  return *this;
}

void ExternGlobalDeclataion::swap(ExternGlobalDeclataion & other)
{
  std::swap(stringconstant_, other.stringconstant_);
  std::swap(declaration_, other.declaration_);

}

ExternGlobalDeclataion::~ExternGlobalDeclataion()
{
  delete(stringconstant_);
  delete(declaration_);

}

void ExternGlobalDeclataion::accept(Visitor *v)
{
  v->visitExternGlobalDeclataion(this);
}

ExternGlobalDeclataion *ExternGlobalDeclataion::clone() const
{
  return new ExternGlobalDeclataion(*this);
}



/********************   ExternGlobalPar    ********************/
ExternGlobalPar::ExternGlobalPar(StringConstant *p1, LBRACE p2, Globals *p3, RBRACE p4)
{
  stringconstant_ = p1;
  lbrace_ = p2;
  globals_ = p3;
  rbrace_ = p4;

}

ExternGlobalPar::ExternGlobalPar(const ExternGlobalPar & other)
{
  stringconstant_ = other.stringconstant_->clone();
  lbrace_ = other.lbrace_;
  globals_ = other.globals_->clone();
  rbrace_ = other.rbrace_;

}

ExternGlobalPar &ExternGlobalPar::operator=(const ExternGlobalPar & other)
{
  ExternGlobalPar tmp(other);
  swap(tmp);
  return *this;
}

void ExternGlobalPar::swap(ExternGlobalPar & other)
{
  std::swap(stringconstant_, other.stringconstant_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(globals_, other.globals_);
  std::swap(rbrace_, other.rbrace_);

}

ExternGlobalPar::~ExternGlobalPar()
{
  delete(stringconstant_);
  delete(globals_);

}

void ExternGlobalPar::accept(Visitor *v)
{
  v->visitExternGlobalPar(this);
}

ExternGlobalPar *ExternGlobalPar::clone() const
{
  return new ExternGlobalPar(*this);
}



/********************   AsmGlobal    ********************/
AsmGlobal::AsmGlobal(ASM p1, StringConstant *p2)
{
  asm_ = p1;
  stringconstant_ = p2;

}

AsmGlobal::AsmGlobal(const AsmGlobal & other)
{
  asm_ = other.asm_;
  stringconstant_ = other.stringconstant_->clone();

}

AsmGlobal &AsmGlobal::operator=(const AsmGlobal & other)
{
  AsmGlobal tmp(other);
  swap(tmp);
  return *this;
}

void AsmGlobal::swap(AsmGlobal & other)
{
  std::swap(asm_, other.asm_);
  std::swap(stringconstant_, other.stringconstant_);

}

AsmGlobal::~AsmGlobal()
{
  delete(stringconstant_);

}

void AsmGlobal::accept(Visitor *v)
{
  v->visitAsmGlobal(this);
}

AsmGlobal *AsmGlobal::clone() const
{
  return new AsmGlobal(*this);
}



/********************   PragmaGlobal    ********************/
PragmaGlobal::PragmaGlobal(Pragma *p1)
{
  pragma_ = p1;

}

PragmaGlobal::PragmaGlobal(const PragmaGlobal & other)
{
  pragma_ = other.pragma_->clone();

}

PragmaGlobal &PragmaGlobal::operator=(const PragmaGlobal & other)
{
  PragmaGlobal tmp(other);
  swap(tmp);
  return *this;
}

void PragmaGlobal::swap(PragmaGlobal & other)
{
  std::swap(pragma_, other.pragma_);

}

PragmaGlobal::~PragmaGlobal()
{
  delete(pragma_);

}

void PragmaGlobal::accept(Visitor *v)
{
  v->visitPragmaGlobal(this);
}

PragmaGlobal *PragmaGlobal::clone() const
{
  return new PragmaGlobal(*this);
}



/********************   GlobalOldStyle    ********************/
GlobalOldStyle::GlobalOldStyle(Ident p1, ListIdent *p2, OldPardefList *p3)
{
  ident_ = p1;
  listident_ = p2;
  oldpardeflist_ = p3;

}

GlobalOldStyle::GlobalOldStyle(const GlobalOldStyle & other)
{
  ident_ = other.ident_;
  listident_ = other.listident_->clone();
  oldpardeflist_ = other.oldpardeflist_->clone();

}

GlobalOldStyle &GlobalOldStyle::operator=(const GlobalOldStyle & other)
{
  GlobalOldStyle tmp(other);
  swap(tmp);
  return *this;
}

void GlobalOldStyle::swap(GlobalOldStyle & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listident_, other.listident_);
  std::swap(oldpardeflist_, other.oldpardeflist_);

}

GlobalOldStyle::~GlobalOldStyle()
{
  delete(listident_);
  delete(oldpardeflist_);

}

void GlobalOldStyle::accept(Visitor *v)
{
  v->visitGlobalOldStyle(this);
}

GlobalOldStyle *GlobalOldStyle::clone() const
{
  return new GlobalOldStyle(*this);
}



/********************   GlobalEmptyOldStyle    ********************/
GlobalEmptyOldStyle::GlobalEmptyOldStyle(Ident p1)
{
  ident_ = p1;

}

GlobalEmptyOldStyle::GlobalEmptyOldStyle(const GlobalEmptyOldStyle & other)
{
  ident_ = other.ident_;

}

GlobalEmptyOldStyle &GlobalEmptyOldStyle::operator=(const GlobalEmptyOldStyle & other)
{
  GlobalEmptyOldStyle tmp(other);
  swap(tmp);
  return *this;
}

void GlobalEmptyOldStyle::swap(GlobalEmptyOldStyle & other)
{
  std::swap(ident_, other.ident_);

}

GlobalEmptyOldStyle::~GlobalEmptyOldStyle()
{

}

void GlobalEmptyOldStyle::accept(Visitor *v)
{
  v->visitGlobalEmptyOldStyle(this);
}

GlobalEmptyOldStyle *GlobalEmptyOldStyle::clone() const
{
  return new GlobalEmptyOldStyle(*this);
}



/********************   IdOrTypenameAsIdIdentifier    ********************/
IdOrTypenameAsIdIdentifier::IdOrTypenameAsIdIdentifier(Ident p1)
{
  ident_ = p1;

}

IdOrTypenameAsIdIdentifier::IdOrTypenameAsIdIdentifier(const IdOrTypenameAsIdIdentifier & other)
{
  ident_ = other.ident_;

}

IdOrTypenameAsIdIdentifier &IdOrTypenameAsIdIdentifier::operator=(const IdOrTypenameAsIdIdentifier & other)
{
  IdOrTypenameAsIdIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void IdOrTypenameAsIdIdentifier::swap(IdOrTypenameAsIdIdentifier & other)
{
  std::swap(ident_, other.ident_);

}

IdOrTypenameAsIdIdentifier::~IdOrTypenameAsIdIdentifier()
{

}

void IdOrTypenameAsIdIdentifier::accept(Visitor *v)
{
  v->visitIdOrTypenameAsIdIdentifier(this);
}

IdOrTypenameAsIdIdentifier *IdOrTypenameAsIdIdentifier::clone() const
{
  return new IdOrTypenameAsIdIdentifier(*this);
}



/********************   IdOrTypenameAsIdNamedType    ********************/
IdOrTypenameAsIdNamedType::IdOrTypenameAsIdNamedType(NAMEDTYPE p1)
{
  namedtype_ = p1;

}

IdOrTypenameAsIdNamedType::IdOrTypenameAsIdNamedType(const IdOrTypenameAsIdNamedType & other)
{
  namedtype_ = other.namedtype_;

}

IdOrTypenameAsIdNamedType &IdOrTypenameAsIdNamedType::operator=(const IdOrTypenameAsIdNamedType & other)
{
  IdOrTypenameAsIdNamedType tmp(other);
  swap(tmp);
  return *this;
}

void IdOrTypenameAsIdNamedType::swap(IdOrTypenameAsIdNamedType & other)
{
  std::swap(namedtype_, other.namedtype_);

}

IdOrTypenameAsIdNamedType::~IdOrTypenameAsIdNamedType()
{

}

void IdOrTypenameAsIdNamedType::accept(Visitor *v)
{
  v->visitIdOrTypenameAsIdNamedType(this);
}

IdOrTypenameAsIdNamedType *IdOrTypenameAsIdNamedType::clone() const
{
  return new IdOrTypenameAsIdNamedType(*this);
}



/********************   IdTypename    ********************/
IdTypename::IdTypename(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

IdTypename::IdTypename(const IdTypename & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

IdTypename &IdTypename::operator=(const IdTypename & other)
{
  IdTypename tmp(other);
  swap(tmp);
  return *this;
}

void IdTypename::swap(IdTypename & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

IdTypename::~IdTypename()
{
  delete(idortypenameasid_);

}

void IdTypename::accept(Visitor *v)
{
  v->visitIdTypename(this);
}

IdTypename *IdTypename::clone() const
{
  return new IdTypename(*this);
}



/********************   NoComa    ********************/
NoComa::NoComa()
{

}

NoComa::NoComa(const NoComa & other)
{

}

NoComa &NoComa::operator=(const NoComa & other)
{
  NoComa tmp(other);
  swap(tmp);
  return *this;
}

void NoComa::swap(NoComa & other)
{

}

NoComa::~NoComa()
{

}

void NoComa::accept(Visitor *v)
{
  v->visitNoComa(this);
}

NoComa *NoComa::clone() const
{
  return new NoComa(*this);
}



/********************   Coma    ********************/
Coma::Coma()
{

}

Coma::Coma(const Coma & other)
{

}

Coma &Coma::operator=(const Coma & other)
{
  Coma tmp(other);
  swap(tmp);
  return *this;
}

void Coma::swap(Coma & other)
{

}

Coma::~Coma()
{

}

void Coma::accept(Visitor *v)
{
  v->visitComa(this);
}

Coma *Coma::clone() const
{
  return new Coma(*this);
}



/********************   IdentifierPrimaryExpression    ********************/
IdentifierPrimaryExpression::IdentifierPrimaryExpression(Ident p1)
{
  ident_ = p1;

}

IdentifierPrimaryExpression::IdentifierPrimaryExpression(const IdentifierPrimaryExpression & other)
{
  ident_ = other.ident_;

}

IdentifierPrimaryExpression &IdentifierPrimaryExpression::operator=(const IdentifierPrimaryExpression & other)
{
  IdentifierPrimaryExpression tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierPrimaryExpression::swap(IdentifierPrimaryExpression & other)
{
  std::swap(ident_, other.ident_);

}

IdentifierPrimaryExpression::~IdentifierPrimaryExpression()
{

}

void IdentifierPrimaryExpression::accept(Visitor *v)
{
  v->visitIdentifierPrimaryExpression(this);
}

IdentifierPrimaryExpression *IdentifierPrimaryExpression::clone() const
{
  return new IdentifierPrimaryExpression(*this);
}



/********************   ConstantPrimaryExpressin    ********************/
ConstantPrimaryExpressin::ConstantPrimaryExpressin(Constant *p1)
{
  constant_ = p1;

}

ConstantPrimaryExpressin::ConstantPrimaryExpressin(const ConstantPrimaryExpressin & other)
{
  constant_ = other.constant_->clone();

}

ConstantPrimaryExpressin &ConstantPrimaryExpressin::operator=(const ConstantPrimaryExpressin & other)
{
  ConstantPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void ConstantPrimaryExpressin::swap(ConstantPrimaryExpressin & other)
{
  std::swap(constant_, other.constant_);

}

ConstantPrimaryExpressin::~ConstantPrimaryExpressin()
{
  delete(constant_);

}

void ConstantPrimaryExpressin::accept(Visitor *v)
{
  v->visitConstantPrimaryExpressin(this);
}

ConstantPrimaryExpressin *ConstantPrimaryExpressin::clone() const
{
  return new ConstantPrimaryExpressin(*this);
}



/********************   CommaExpressionPrimaryExpressin    ********************/
CommaExpressionPrimaryExpressin::CommaExpressionPrimaryExpressin(ListExpression *p1)
{
  listexpression_ = p1;

}

CommaExpressionPrimaryExpressin::CommaExpressionPrimaryExpressin(const CommaExpressionPrimaryExpressin & other)
{
  listexpression_ = other.listexpression_->clone();

}

CommaExpressionPrimaryExpressin &CommaExpressionPrimaryExpressin::operator=(const CommaExpressionPrimaryExpressin & other)
{
  CommaExpressionPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void CommaExpressionPrimaryExpressin::swap(CommaExpressionPrimaryExpressin & other)
{
  std::swap(listexpression_, other.listexpression_);

}

CommaExpressionPrimaryExpressin::~CommaExpressionPrimaryExpressin()
{
  delete(listexpression_);

}

void CommaExpressionPrimaryExpressin::accept(Visitor *v)
{
  v->visitCommaExpressionPrimaryExpressin(this);
}

CommaExpressionPrimaryExpressin *CommaExpressionPrimaryExpressin::clone() const
{
  return new CommaExpressionPrimaryExpressin(*this);
}



/********************   BlockPrimaryExpressin    ********************/
BlockPrimaryExpressin::BlockPrimaryExpressin(Block *p1)
{
  block_ = p1;

}

BlockPrimaryExpressin::BlockPrimaryExpressin(const BlockPrimaryExpressin & other)
{
  block_ = other.block_->clone();

}

BlockPrimaryExpressin &BlockPrimaryExpressin::operator=(const BlockPrimaryExpressin & other)
{
  BlockPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void BlockPrimaryExpressin::swap(BlockPrimaryExpressin & other)
{
  std::swap(block_, other.block_);

}

BlockPrimaryExpressin::~BlockPrimaryExpressin()
{
  delete(block_);

}

void BlockPrimaryExpressin::accept(Visitor *v)
{
  v->visitBlockPrimaryExpressin(this);
}

BlockPrimaryExpressin *BlockPrimaryExpressin::clone() const
{
  return new BlockPrimaryExpressin(*this);
}



/********************   GenericAssociationPrimaryExpressin    ********************/
GenericAssociationPrimaryExpressin::GenericAssociationPrimaryExpressin(AssignExpr *p1, ListGenericAssociation *p2)
{
  assignexpr_ = p1;
  listgenericassociation_ = p2;

}

GenericAssociationPrimaryExpressin::GenericAssociationPrimaryExpressin(const GenericAssociationPrimaryExpressin & other)
{
  assignexpr_ = other.assignexpr_->clone();
  listgenericassociation_ = other.listgenericassociation_->clone();

}

GenericAssociationPrimaryExpressin &GenericAssociationPrimaryExpressin::operator=(const GenericAssociationPrimaryExpressin & other)
{
  GenericAssociationPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void GenericAssociationPrimaryExpressin::swap(GenericAssociationPrimaryExpressin & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(listgenericassociation_, other.listgenericassociation_);

}

GenericAssociationPrimaryExpressin::~GenericAssociationPrimaryExpressin()
{
  delete(assignexpr_);
  delete(listgenericassociation_);

}

void GenericAssociationPrimaryExpressin::accept(Visitor *v)
{
  v->visitGenericAssociationPrimaryExpressin(this);
}

GenericAssociationPrimaryExpressin *GenericAssociationPrimaryExpressin::clone() const
{
  return new GenericAssociationPrimaryExpressin(*this);
}



/********************   GenericPrimaryExpressin    ********************/
GenericPrimaryExpressin::GenericPrimaryExpressin(AssignExpr *p1)
{
  assignexpr_ = p1;

}

GenericPrimaryExpressin::GenericPrimaryExpressin(const GenericPrimaryExpressin & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

GenericPrimaryExpressin &GenericPrimaryExpressin::operator=(const GenericPrimaryExpressin & other)
{
  GenericPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void GenericPrimaryExpressin::swap(GenericPrimaryExpressin & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

GenericPrimaryExpressin::~GenericPrimaryExpressin()
{
  delete(assignexpr_);

}

void GenericPrimaryExpressin::accept(Visitor *v)
{
  v->visitGenericPrimaryExpressin(this);
}

GenericPrimaryExpressin *GenericPrimaryExpressin::clone() const
{
  return new GenericPrimaryExpressin(*this);
}



/********************   BracketsPostfixExpression    ********************/
BracketsPostfixExpression::BracketsPostfixExpression(AssignExpr *p1, LBRACKET p2, ListExpression *p3, RBRACKET p4)
{
  assignexpr_ = p1;
  lbracket_ = p2;
  listexpression_ = p3;
  rbracket_ = p4;

}

BracketsPostfixExpression::BracketsPostfixExpression(const BracketsPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  lbracket_ = other.lbracket_;
  listexpression_ = other.listexpression_->clone();
  rbracket_ = other.rbracket_;

}

BracketsPostfixExpression &BracketsPostfixExpression::operator=(const BracketsPostfixExpression & other)
{
  BracketsPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void BracketsPostfixExpression::swap(BracketsPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(lbracket_, other.lbracket_);
  std::swap(listexpression_, other.listexpression_);
  std::swap(rbracket_, other.rbracket_);

}

BracketsPostfixExpression::~BracketsPostfixExpression()
{
  delete(assignexpr_);
  delete(listexpression_);

}

void BracketsPostfixExpression::accept(Visitor *v)
{
  v->visitBracketsPostfixExpression(this);
}

BracketsPostfixExpression *BracketsPostfixExpression::clone() const
{
  return new BracketsPostfixExpression(*this);
}



/********************   ArgumentsPostfixExpression    ********************/
ArgumentsPostfixExpression::ArgumentsPostfixExpression(AssignExpr *p1, Arguments *p2, GhostArgumentsOpt *p3)
{
  assignexpr_ = p1;
  arguments_ = p2;
  ghostargumentsopt_ = p3;

}

ArgumentsPostfixExpression::ArgumentsPostfixExpression(const ArgumentsPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  arguments_ = other.arguments_->clone();
  ghostargumentsopt_ = other.ghostargumentsopt_->clone();

}

ArgumentsPostfixExpression &ArgumentsPostfixExpression::operator=(const ArgumentsPostfixExpression & other)
{
  ArgumentsPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void ArgumentsPostfixExpression::swap(ArgumentsPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(arguments_, other.arguments_);
  std::swap(ghostargumentsopt_, other.ghostargumentsopt_);

}

ArgumentsPostfixExpression::~ArgumentsPostfixExpression()
{
  delete(assignexpr_);
  delete(arguments_);
  delete(ghostargumentsopt_);

}

void ArgumentsPostfixExpression::accept(Visitor *v)
{
  v->visitArgumentsPostfixExpression(this);
}

ArgumentsPostfixExpression *ArgumentsPostfixExpression::clone() const
{
  return new ArgumentsPostfixExpression(*this);
}



/********************   BuiltinVaArgPostfixExpression    ********************/
BuiltinVaArgPostfixExpression::BuiltinVaArgPostfixExpression(Expression *p1, TypeName *p2)
{
  expression_ = p1;
  typename_ = p2;

}

BuiltinVaArgPostfixExpression::BuiltinVaArgPostfixExpression(const BuiltinVaArgPostfixExpression & other)
{
  expression_ = other.expression_->clone();
  typename_ = other.typename_->clone();

}

BuiltinVaArgPostfixExpression &BuiltinVaArgPostfixExpression::operator=(const BuiltinVaArgPostfixExpression & other)
{
  BuiltinVaArgPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void BuiltinVaArgPostfixExpression::swap(BuiltinVaArgPostfixExpression & other)
{
  std::swap(expression_, other.expression_);
  std::swap(typename_, other.typename_);

}

BuiltinVaArgPostfixExpression::~BuiltinVaArgPostfixExpression()
{
  delete(expression_);
  delete(typename_);

}

void BuiltinVaArgPostfixExpression::accept(Visitor *v)
{
  v->visitBuiltinVaArgPostfixExpression(this);
}

BuiltinVaArgPostfixExpression *BuiltinVaArgPostfixExpression::clone() const
{
  return new BuiltinVaArgPostfixExpression(*this);
}



/********************   BuiltinTypesCompatPostfixExpression    ********************/
BuiltinTypesCompatPostfixExpression::BuiltinTypesCompatPostfixExpression(TypeName *p1, TypeName *p2)
{
  typename_1 = p1;
  typename_2 = p2;

}

BuiltinTypesCompatPostfixExpression::BuiltinTypesCompatPostfixExpression(const BuiltinTypesCompatPostfixExpression & other)
{
  typename_1 = other.typename_1->clone();
  typename_2 = other.typename_2->clone();

}

BuiltinTypesCompatPostfixExpression &BuiltinTypesCompatPostfixExpression::operator=(const BuiltinTypesCompatPostfixExpression & other)
{
  BuiltinTypesCompatPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void BuiltinTypesCompatPostfixExpression::swap(BuiltinTypesCompatPostfixExpression & other)
{
  std::swap(typename_1, other.typename_1);
  std::swap(typename_2, other.typename_2);

}

BuiltinTypesCompatPostfixExpression::~BuiltinTypesCompatPostfixExpression()
{
  delete(typename_1);
  delete(typename_2);

}

void BuiltinTypesCompatPostfixExpression::accept(Visitor *v)
{
  v->visitBuiltinTypesCompatPostfixExpression(this);
}

BuiltinTypesCompatPostfixExpression *BuiltinTypesCompatPostfixExpression::clone() const
{
  return new BuiltinTypesCompatPostfixExpression(*this);
}



/********************   BuiltinOffsetOfPostfixExpression    ********************/
BuiltinOffsetOfPostfixExpression::BuiltinOffsetOfPostfixExpression(TypeName *p1, OffsetofMemberDesignator *p2)
{
  typename_ = p1;
  offsetofmemberdesignator_ = p2;

}

BuiltinOffsetOfPostfixExpression::BuiltinOffsetOfPostfixExpression(const BuiltinOffsetOfPostfixExpression & other)
{
  typename_ = other.typename_->clone();
  offsetofmemberdesignator_ = other.offsetofmemberdesignator_->clone();

}

BuiltinOffsetOfPostfixExpression &BuiltinOffsetOfPostfixExpression::operator=(const BuiltinOffsetOfPostfixExpression & other)
{
  BuiltinOffsetOfPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void BuiltinOffsetOfPostfixExpression::swap(BuiltinOffsetOfPostfixExpression & other)
{
  std::swap(typename_, other.typename_);
  std::swap(offsetofmemberdesignator_, other.offsetofmemberdesignator_);

}

BuiltinOffsetOfPostfixExpression::~BuiltinOffsetOfPostfixExpression()
{
  delete(typename_);
  delete(offsetofmemberdesignator_);

}

void BuiltinOffsetOfPostfixExpression::accept(Visitor *v)
{
  v->visitBuiltinOffsetOfPostfixExpression(this);
}

BuiltinOffsetOfPostfixExpression *BuiltinOffsetOfPostfixExpression::clone() const
{
  return new BuiltinOffsetOfPostfixExpression(*this);
}



/********************   DotPostfixExpression    ********************/
DotPostfixExpression::DotPostfixExpression(AssignExpr *p1, IdOrTypename *p2)
{
  assignexpr_ = p1;
  idortypename_ = p2;

}

DotPostfixExpression::DotPostfixExpression(const DotPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  idortypename_ = other.idortypename_->clone();

}

DotPostfixExpression &DotPostfixExpression::operator=(const DotPostfixExpression & other)
{
  DotPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void DotPostfixExpression::swap(DotPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(idortypename_, other.idortypename_);

}

DotPostfixExpression::~DotPostfixExpression()
{
  delete(assignexpr_);
  delete(idortypename_);

}

void DotPostfixExpression::accept(Visitor *v)
{
  v->visitDotPostfixExpression(this);
}

DotPostfixExpression *DotPostfixExpression::clone() const
{
  return new DotPostfixExpression(*this);
}



/********************   ArrowPostfixExpression    ********************/
ArrowPostfixExpression::ArrowPostfixExpression(AssignExpr *p1, IdOrTypename *p2)
{
  assignexpr_ = p1;
  idortypename_ = p2;

}

ArrowPostfixExpression::ArrowPostfixExpression(const ArrowPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  idortypename_ = other.idortypename_->clone();

}

ArrowPostfixExpression &ArrowPostfixExpression::operator=(const ArrowPostfixExpression & other)
{
  ArrowPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void ArrowPostfixExpression::swap(ArrowPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(idortypename_, other.idortypename_);

}

ArrowPostfixExpression::~ArrowPostfixExpression()
{
  delete(assignexpr_);
  delete(idortypename_);

}

void ArrowPostfixExpression::accept(Visitor *v)
{
  v->visitArrowPostfixExpression(this);
}

ArrowPostfixExpression *ArrowPostfixExpression::clone() const
{
  return new ArrowPostfixExpression(*this);
}



/********************   PlusPlusPostfixExpression    ********************/
PlusPlusPostfixExpression::PlusPlusPostfixExpression(AssignExpr *p1)
{
  assignexpr_ = p1;

}

PlusPlusPostfixExpression::PlusPlusPostfixExpression(const PlusPlusPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

PlusPlusPostfixExpression &PlusPlusPostfixExpression::operator=(const PlusPlusPostfixExpression & other)
{
  PlusPlusPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void PlusPlusPostfixExpression::swap(PlusPlusPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

PlusPlusPostfixExpression::~PlusPlusPostfixExpression()
{
  delete(assignexpr_);

}

void PlusPlusPostfixExpression::accept(Visitor *v)
{
  v->visitPlusPlusPostfixExpression(this);
}

PlusPlusPostfixExpression *PlusPlusPostfixExpression::clone() const
{
  return new PlusPlusPostfixExpression(*this);
}



/********************   MinusMinusPostfixExpression    ********************/
MinusMinusPostfixExpression::MinusMinusPostfixExpression(AssignExpr *p1)
{
  assignexpr_ = p1;

}

MinusMinusPostfixExpression::MinusMinusPostfixExpression(const MinusMinusPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

MinusMinusPostfixExpression &MinusMinusPostfixExpression::operator=(const MinusMinusPostfixExpression & other)
{
  MinusMinusPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void MinusMinusPostfixExpression::swap(MinusMinusPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

MinusMinusPostfixExpression::~MinusMinusPostfixExpression()
{
  delete(assignexpr_);

}

void MinusMinusPostfixExpression::accept(Visitor *v)
{
  v->visitMinusMinusPostfixExpression(this);
}

MinusMinusPostfixExpression *MinusMinusPostfixExpression::clone() const
{
  return new MinusMinusPostfixExpression(*this);
}



/********************   ConstructorPostfixExpression    ********************/
ConstructorPostfixExpression::ConstructorPostfixExpression(TypeName *p1, LBRACE p2, InitializerListOpt *p3, RBRACE p4)
{
  typename_ = p1;
  lbrace_ = p2;
  initializerlistopt_ = p3;
  rbrace_ = p4;

}

ConstructorPostfixExpression::ConstructorPostfixExpression(const ConstructorPostfixExpression & other)
{
  typename_ = other.typename_->clone();
  lbrace_ = other.lbrace_;
  initializerlistopt_ = other.initializerlistopt_->clone();
  rbrace_ = other.rbrace_;

}

ConstructorPostfixExpression &ConstructorPostfixExpression::operator=(const ConstructorPostfixExpression & other)
{
  ConstructorPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void ConstructorPostfixExpression::swap(ConstructorPostfixExpression & other)
{
  std::swap(typename_, other.typename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(initializerlistopt_, other.initializerlistopt_);
  std::swap(rbrace_, other.rbrace_);

}

ConstructorPostfixExpression::~ConstructorPostfixExpression()
{
  delete(typename_);
  delete(initializerlistopt_);

}

void ConstructorPostfixExpression::accept(Visitor *v)
{
  v->visitConstructorPostfixExpression(this);
}

ConstructorPostfixExpression *ConstructorPostfixExpression::clone() const
{
  return new ConstructorPostfixExpression(*this);
}



/********************   UnaryExprPlusPlus    ********************/
UnaryExprPlusPlus::UnaryExprPlusPlus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprPlusPlus::UnaryExprPlusPlus(const UnaryExprPlusPlus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprPlusPlus &UnaryExprPlusPlus::operator=(const UnaryExprPlusPlus & other)
{
  UnaryExprPlusPlus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprPlusPlus::swap(UnaryExprPlusPlus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprPlusPlus::~UnaryExprPlusPlus()
{
  delete(assignexpr_);

}

void UnaryExprPlusPlus::accept(Visitor *v)
{
  v->visitUnaryExprPlusPlus(this);
}

UnaryExprPlusPlus *UnaryExprPlusPlus::clone() const
{
  return new UnaryExprPlusPlus(*this);
}



/********************   UnaryExprMinusMinus    ********************/
UnaryExprMinusMinus::UnaryExprMinusMinus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprMinusMinus::UnaryExprMinusMinus(const UnaryExprMinusMinus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprMinusMinus &UnaryExprMinusMinus::operator=(const UnaryExprMinusMinus & other)
{
  UnaryExprMinusMinus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprMinusMinus::swap(UnaryExprMinusMinus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprMinusMinus::~UnaryExprMinusMinus()
{
  delete(assignexpr_);

}

void UnaryExprMinusMinus::accept(Visitor *v)
{
  v->visitUnaryExprMinusMinus(this);
}

UnaryExprMinusMinus *UnaryExprMinusMinus::clone() const
{
  return new UnaryExprMinusMinus(*this);
}



/********************   UnaryExprSizeOf    ********************/
UnaryExprSizeOf::UnaryExprSizeOf(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprSizeOf::UnaryExprSizeOf(const UnaryExprSizeOf & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprSizeOf &UnaryExprSizeOf::operator=(const UnaryExprSizeOf & other)
{
  UnaryExprSizeOf tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprSizeOf::swap(UnaryExprSizeOf & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprSizeOf::~UnaryExprSizeOf()
{
  delete(assignexpr_);

}

void UnaryExprSizeOf::accept(Visitor *v)
{
  v->visitUnaryExprSizeOf(this);
}

UnaryExprSizeOf *UnaryExprSizeOf::clone() const
{
  return new UnaryExprSizeOf(*this);
}



/********************   UnaryExprSizeOfTypeName    ********************/
UnaryExprSizeOfTypeName::UnaryExprSizeOfTypeName(TypeName *p1)
{
  typename_ = p1;

}

UnaryExprSizeOfTypeName::UnaryExprSizeOfTypeName(const UnaryExprSizeOfTypeName & other)
{
  typename_ = other.typename_->clone();

}

UnaryExprSizeOfTypeName &UnaryExprSizeOfTypeName::operator=(const UnaryExprSizeOfTypeName & other)
{
  UnaryExprSizeOfTypeName tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprSizeOfTypeName::swap(UnaryExprSizeOfTypeName & other)
{
  std::swap(typename_, other.typename_);

}

UnaryExprSizeOfTypeName::~UnaryExprSizeOfTypeName()
{
  delete(typename_);

}

void UnaryExprSizeOfTypeName::accept(Visitor *v)
{
  v->visitUnaryExprSizeOfTypeName(this);
}

UnaryExprSizeOfTypeName *UnaryExprSizeOfTypeName::clone() const
{
  return new UnaryExprSizeOfTypeName(*this);
}



/********************   UnaryExprAlignOfUnaryExpr    ********************/
UnaryExprAlignOfUnaryExpr::UnaryExprAlignOfUnaryExpr(ALIGNOF p1, AssignExpr *p2)
{
  alignof_ = p1;
  assignexpr_ = p2;

}

UnaryExprAlignOfUnaryExpr::UnaryExprAlignOfUnaryExpr(const UnaryExprAlignOfUnaryExpr & other)
{
  alignof_ = other.alignof_;
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprAlignOfUnaryExpr &UnaryExprAlignOfUnaryExpr::operator=(const UnaryExprAlignOfUnaryExpr & other)
{
  UnaryExprAlignOfUnaryExpr tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprAlignOfUnaryExpr::swap(UnaryExprAlignOfUnaryExpr & other)
{
  std::swap(alignof_, other.alignof_);
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprAlignOfUnaryExpr::~UnaryExprAlignOfUnaryExpr()
{
  delete(assignexpr_);

}

void UnaryExprAlignOfUnaryExpr::accept(Visitor *v)
{
  v->visitUnaryExprAlignOfUnaryExpr(this);
}

UnaryExprAlignOfUnaryExpr *UnaryExprAlignOfUnaryExpr::clone() const
{
  return new UnaryExprAlignOfUnaryExpr(*this);
}



/********************   UnaryExprAlignOfTypeName    ********************/
UnaryExprAlignOfTypeName::UnaryExprAlignOfTypeName(ALIGNOF p1, TypeName *p2)
{
  alignof_ = p1;
  typename_ = p2;

}

UnaryExprAlignOfTypeName::UnaryExprAlignOfTypeName(const UnaryExprAlignOfTypeName & other)
{
  alignof_ = other.alignof_;
  typename_ = other.typename_->clone();

}

UnaryExprAlignOfTypeName &UnaryExprAlignOfTypeName::operator=(const UnaryExprAlignOfTypeName & other)
{
  UnaryExprAlignOfTypeName tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprAlignOfTypeName::swap(UnaryExprAlignOfTypeName & other)
{
  std::swap(alignof_, other.alignof_);
  std::swap(typename_, other.typename_);

}

UnaryExprAlignOfTypeName::~UnaryExprAlignOfTypeName()
{
  delete(typename_);

}

void UnaryExprAlignOfTypeName::accept(Visitor *v)
{
  v->visitUnaryExprAlignOfTypeName(this);
}

UnaryExprAlignOfTypeName *UnaryExprAlignOfTypeName::clone() const
{
  return new UnaryExprAlignOfTypeName(*this);
}



/********************   UnaryExprPlus    ********************/
UnaryExprPlus::UnaryExprPlus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprPlus::UnaryExprPlus(const UnaryExprPlus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprPlus &UnaryExprPlus::operator=(const UnaryExprPlus & other)
{
  UnaryExprPlus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprPlus::swap(UnaryExprPlus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprPlus::~UnaryExprPlus()
{
  delete(assignexpr_);

}

void UnaryExprPlus::accept(Visitor *v)
{
  v->visitUnaryExprPlus(this);
}

UnaryExprPlus *UnaryExprPlus::clone() const
{
  return new UnaryExprPlus(*this);
}



/********************   UnaryExprMinus    ********************/
UnaryExprMinus::UnaryExprMinus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprMinus::UnaryExprMinus(const UnaryExprMinus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprMinus &UnaryExprMinus::operator=(const UnaryExprMinus & other)
{
  UnaryExprMinus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprMinus::swap(UnaryExprMinus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprMinus::~UnaryExprMinus()
{
  delete(assignexpr_);

}

void UnaryExprMinus::accept(Visitor *v)
{
  v->visitUnaryExprMinus(this);
}

UnaryExprMinus *UnaryExprMinus::clone() const
{
  return new UnaryExprMinus(*this);
}



/********************   UnaryExprMult    ********************/
UnaryExprMult::UnaryExprMult(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprMult::UnaryExprMult(const UnaryExprMult & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprMult &UnaryExprMult::operator=(const UnaryExprMult & other)
{
  UnaryExprMult tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprMult::swap(UnaryExprMult & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprMult::~UnaryExprMult()
{
  delete(assignexpr_);

}

void UnaryExprMult::accept(Visitor *v)
{
  v->visitUnaryExprMult(this);
}

UnaryExprMult *UnaryExprMult::clone() const
{
  return new UnaryExprMult(*this);
}



/********************   UnaryExprAmp    ********************/
UnaryExprAmp::UnaryExprAmp(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprAmp::UnaryExprAmp(const UnaryExprAmp & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprAmp &UnaryExprAmp::operator=(const UnaryExprAmp & other)
{
  UnaryExprAmp tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprAmp::swap(UnaryExprAmp & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprAmp::~UnaryExprAmp()
{
  delete(assignexpr_);

}

void UnaryExprAmp::accept(Visitor *v)
{
  v->visitUnaryExprAmp(this);
}

UnaryExprAmp *UnaryExprAmp::clone() const
{
  return new UnaryExprAmp(*this);
}



/********************   UnaryExprNot    ********************/
UnaryExprNot::UnaryExprNot(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprNot::UnaryExprNot(const UnaryExprNot & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprNot &UnaryExprNot::operator=(const UnaryExprNot & other)
{
  UnaryExprNot tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprNot::swap(UnaryExprNot & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprNot::~UnaryExprNot()
{
  delete(assignexpr_);

}

void UnaryExprNot::accept(Visitor *v)
{
  v->visitUnaryExprNot(this);
}

UnaryExprNot *UnaryExprNot::clone() const
{
  return new UnaryExprNot(*this);
}



/********************   UnaryExprTilde    ********************/
UnaryExprTilde::UnaryExprTilde(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprTilde::UnaryExprTilde(const UnaryExprTilde & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprTilde &UnaryExprTilde::operator=(const UnaryExprTilde & other)
{
  UnaryExprTilde tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprTilde::swap(UnaryExprTilde & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprTilde::~UnaryExprTilde()
{
  delete(assignexpr_);

}

void UnaryExprTilde::accept(Visitor *v)
{
  v->visitUnaryExprTilde(this);
}

UnaryExprTilde *UnaryExprTilde::clone() const
{
  return new UnaryExprTilde(*this);
}



/********************   UnaryExprAddress    ********************/
UnaryExprAddress::UnaryExprAddress(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

UnaryExprAddress::UnaryExprAddress(const UnaryExprAddress & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

UnaryExprAddress &UnaryExprAddress::operator=(const UnaryExprAddress & other)
{
  UnaryExprAddress tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprAddress::swap(UnaryExprAddress & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

UnaryExprAddress::~UnaryExprAddress()
{
  delete(idortypenameasid_);

}

void UnaryExprAddress::accept(Visitor *v)
{
  v->visitUnaryExprAddress(this);
}

UnaryExprAddress *UnaryExprAddress::clone() const
{
  return new UnaryExprAddress(*this);
}



/********************   CastExpr    ********************/
CastExpr::CastExpr(TypeName *p1, AssignExpr *p2)
{
  typename_ = p1;
  assignexpr_ = p2;

}

CastExpr::CastExpr(const CastExpr & other)
{
  typename_ = other.typename_->clone();
  assignexpr_ = other.assignexpr_->clone();

}

CastExpr &CastExpr::operator=(const CastExpr & other)
{
  CastExpr tmp(other);
  swap(tmp);
  return *this;
}

void CastExpr::swap(CastExpr & other)
{
  std::swap(typename_, other.typename_);
  std::swap(assignexpr_, other.assignexpr_);

}

CastExpr::~CastExpr()
{
  delete(typename_);
  delete(assignexpr_);

}

void CastExpr::accept(Visitor *v)
{
  v->visitCastExpr(this);
}

CastExpr *CastExpr::clone() const
{
  return new CastExpr(*this);
}



/********************   MulsExpr    ********************/
MulsExpr::MulsExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MulsExpr::MulsExpr(const MulsExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MulsExpr &MulsExpr::operator=(const MulsExpr & other)
{
  MulsExpr tmp(other);
  swap(tmp);
  return *this;
}

void MulsExpr::swap(MulsExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MulsExpr::~MulsExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MulsExpr::accept(Visitor *v)
{
  v->visitMulsExpr(this);
}

MulsExpr *MulsExpr::clone() const
{
  return new MulsExpr(*this);
}



/********************   DivExpr    ********************/
DivExpr::DivExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

DivExpr::DivExpr(const DivExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

DivExpr &DivExpr::operator=(const DivExpr & other)
{
  DivExpr tmp(other);
  swap(tmp);
  return *this;
}

void DivExpr::swap(DivExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

DivExpr::~DivExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void DivExpr::accept(Visitor *v)
{
  v->visitDivExpr(this);
}

DivExpr *DivExpr::clone() const
{
  return new DivExpr(*this);
}



/********************   ModExpr    ********************/
ModExpr::ModExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

ModExpr::ModExpr(const ModExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

ModExpr &ModExpr::operator=(const ModExpr & other)
{
  ModExpr tmp(other);
  swap(tmp);
  return *this;
}

void ModExpr::swap(ModExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

ModExpr::~ModExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void ModExpr::accept(Visitor *v)
{
  v->visitModExpr(this);
}

ModExpr *ModExpr::clone() const
{
  return new ModExpr(*this);
}



/********************   PlusExpr    ********************/
PlusExpr::PlusExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

PlusExpr::PlusExpr(const PlusExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

PlusExpr &PlusExpr::operator=(const PlusExpr & other)
{
  PlusExpr tmp(other);
  swap(tmp);
  return *this;
}

void PlusExpr::swap(PlusExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

PlusExpr::~PlusExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void PlusExpr::accept(Visitor *v)
{
  v->visitPlusExpr(this);
}

PlusExpr *PlusExpr::clone() const
{
  return new PlusExpr(*this);
}



/********************   MinusExpr    ********************/
MinusExpr::MinusExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MinusExpr::MinusExpr(const MinusExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MinusExpr &MinusExpr::operator=(const MinusExpr & other)
{
  MinusExpr tmp(other);
  swap(tmp);
  return *this;
}

void MinusExpr::swap(MinusExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MinusExpr::~MinusExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MinusExpr::accept(Visitor *v)
{
  v->visitMinusExpr(this);
}

MinusExpr *MinusExpr::clone() const
{
  return new MinusExpr(*this);
}



/********************   LeftShiftExpr    ********************/
LeftShiftExpr::LeftShiftExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LeftShiftExpr::LeftShiftExpr(const LeftShiftExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LeftShiftExpr &LeftShiftExpr::operator=(const LeftShiftExpr & other)
{
  LeftShiftExpr tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftExpr::swap(LeftShiftExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LeftShiftExpr::~LeftShiftExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LeftShiftExpr::accept(Visitor *v)
{
  v->visitLeftShiftExpr(this);
}

LeftShiftExpr *LeftShiftExpr::clone() const
{
  return new LeftShiftExpr(*this);
}



/********************   RightShiftExpr    ********************/
RightShiftExpr::RightShiftExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

RightShiftExpr::RightShiftExpr(const RightShiftExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

RightShiftExpr &RightShiftExpr::operator=(const RightShiftExpr & other)
{
  RightShiftExpr tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftExpr::swap(RightShiftExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

RightShiftExpr::~RightShiftExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void RightShiftExpr::accept(Visitor *v)
{
  v->visitRightShiftExpr(this);
}

RightShiftExpr *RightShiftExpr::clone() const
{
  return new RightShiftExpr(*this);
}



/********************   LessExpr    ********************/
LessExpr::LessExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LessExpr::LessExpr(const LessExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LessExpr &LessExpr::operator=(const LessExpr & other)
{
  LessExpr tmp(other);
  swap(tmp);
  return *this;
}

void LessExpr::swap(LessExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LessExpr::~LessExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LessExpr::accept(Visitor *v)
{
  v->visitLessExpr(this);
}

LessExpr *LessExpr::clone() const
{
  return new LessExpr(*this);
}



/********************   GreaterExpr    ********************/
GreaterExpr::GreaterExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

GreaterExpr::GreaterExpr(const GreaterExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

GreaterExpr &GreaterExpr::operator=(const GreaterExpr & other)
{
  GreaterExpr tmp(other);
  swap(tmp);
  return *this;
}

void GreaterExpr::swap(GreaterExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

GreaterExpr::~GreaterExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void GreaterExpr::accept(Visitor *v)
{
  v->visitGreaterExpr(this);
}

GreaterExpr *GreaterExpr::clone() const
{
  return new GreaterExpr(*this);
}



/********************   LessEqualExpr    ********************/
LessEqualExpr::LessEqualExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LessEqualExpr::LessEqualExpr(const LessEqualExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LessEqualExpr &LessEqualExpr::operator=(const LessEqualExpr & other)
{
  LessEqualExpr tmp(other);
  swap(tmp);
  return *this;
}

void LessEqualExpr::swap(LessEqualExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LessEqualExpr::~LessEqualExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LessEqualExpr::accept(Visitor *v)
{
  v->visitLessEqualExpr(this);
}

LessEqualExpr *LessEqualExpr::clone() const
{
  return new LessEqualExpr(*this);
}



/********************   GreaterEqualExpr    ********************/
GreaterEqualExpr::GreaterEqualExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

GreaterEqualExpr::GreaterEqualExpr(const GreaterEqualExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

GreaterEqualExpr &GreaterEqualExpr::operator=(const GreaterEqualExpr & other)
{
  GreaterEqualExpr tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqualExpr::swap(GreaterEqualExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

GreaterEqualExpr::~GreaterEqualExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void GreaterEqualExpr::accept(Visitor *v)
{
  v->visitGreaterEqualExpr(this);
}

GreaterEqualExpr *GreaterEqualExpr::clone() const
{
  return new GreaterEqualExpr(*this);
}



/********************   EqExpr    ********************/
EqExpr::EqExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

EqExpr::EqExpr(const EqExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

EqExpr &EqExpr::operator=(const EqExpr & other)
{
  EqExpr tmp(other);
  swap(tmp);
  return *this;
}

void EqExpr::swap(EqExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

EqExpr::~EqExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void EqExpr::accept(Visitor *v)
{
  v->visitEqExpr(this);
}

EqExpr *EqExpr::clone() const
{
  return new EqExpr(*this);
}



/********************   NotEqExpr    ********************/
NotEqExpr::NotEqExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

NotEqExpr::NotEqExpr(const NotEqExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

NotEqExpr &NotEqExpr::operator=(const NotEqExpr & other)
{
  NotEqExpr tmp(other);
  swap(tmp);
  return *this;
}

void NotEqExpr::swap(NotEqExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

NotEqExpr::~NotEqExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void NotEqExpr::accept(Visitor *v)
{
  v->visitNotEqExpr(this);
}

NotEqExpr *NotEqExpr::clone() const
{
  return new NotEqExpr(*this);
}



/********************   BitAndExpr    ********************/
BitAndExpr::BitAndExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

BitAndExpr::BitAndExpr(const BitAndExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

BitAndExpr &BitAndExpr::operator=(const BitAndExpr & other)
{
  BitAndExpr tmp(other);
  swap(tmp);
  return *this;
}

void BitAndExpr::swap(BitAndExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

BitAndExpr::~BitAndExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void BitAndExpr::accept(Visitor *v)
{
  v->visitBitAndExpr(this);
}

BitAndExpr *BitAndExpr::clone() const
{
  return new BitAndExpr(*this);
}



/********************   BitXorExpr    ********************/
BitXorExpr::BitXorExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

BitXorExpr::BitXorExpr(const BitXorExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

BitXorExpr &BitXorExpr::operator=(const BitXorExpr & other)
{
  BitXorExpr tmp(other);
  swap(tmp);
  return *this;
}

void BitXorExpr::swap(BitXorExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

BitXorExpr::~BitXorExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void BitXorExpr::accept(Visitor *v)
{
  v->visitBitXorExpr(this);
}

BitXorExpr *BitXorExpr::clone() const
{
  return new BitXorExpr(*this);
}



/********************   BitOrExpr    ********************/
BitOrExpr::BitOrExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

BitOrExpr::BitOrExpr(const BitOrExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

BitOrExpr &BitOrExpr::operator=(const BitOrExpr & other)
{
  BitOrExpr tmp(other);
  swap(tmp);
  return *this;
}

void BitOrExpr::swap(BitOrExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

BitOrExpr::~BitOrExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void BitOrExpr::accept(Visitor *v)
{
  v->visitBitOrExpr(this);
}

BitOrExpr *BitOrExpr::clone() const
{
  return new BitOrExpr(*this);
}



/********************   AndExpr    ********************/
AndExpr::AndExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

AndExpr::AndExpr(const AndExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

AndExpr &AndExpr::operator=(const AndExpr & other)
{
  AndExpr tmp(other);
  swap(tmp);
  return *this;
}

void AndExpr::swap(AndExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

AndExpr::~AndExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void AndExpr::accept(Visitor *v)
{
  v->visitAndExpr(this);
}

AndExpr *AndExpr::clone() const
{
  return new AndExpr(*this);
}



/********************   OrExpr    ********************/
OrExpr::OrExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

OrExpr::OrExpr(const OrExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

OrExpr &OrExpr::operator=(const OrExpr & other)
{
  OrExpr tmp(other);
  swap(tmp);
  return *this;
}

void OrExpr::swap(OrExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

OrExpr::~OrExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void OrExpr::accept(Visitor *v)
{
  v->visitOrExpr(this);
}

OrExpr *OrExpr::clone() const
{
  return new OrExpr(*this);
}



/********************   TernaryCondExpr    ********************/
TernaryCondExpr::TernaryCondExpr(AssignExpr *p1, OptExpression *p2, AssignExpr *p3)
{
  assignexpr_1 = p1;
  optexpression_ = p2;
  assignexpr_2 = p3;

}

TernaryCondExpr::TernaryCondExpr(const TernaryCondExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  optexpression_ = other.optexpression_->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

TernaryCondExpr &TernaryCondExpr::operator=(const TernaryCondExpr & other)
{
  TernaryCondExpr tmp(other);
  swap(tmp);
  return *this;
}

void TernaryCondExpr::swap(TernaryCondExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(optexpression_, other.optexpression_);
  std::swap(assignexpr_2, other.assignexpr_2);

}

TernaryCondExpr::~TernaryCondExpr()
{
  delete(assignexpr_1);
  delete(optexpression_);
  delete(assignexpr_2);

}

void TernaryCondExpr::accept(Visitor *v)
{
  v->visitTernaryCondExpr(this);
}

TernaryCondExpr *TernaryCondExpr::clone() const
{
  return new TernaryCondExpr(*this);
}



/********************   EqAssignExpr    ********************/
EqAssignExpr::EqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

EqAssignExpr::EqAssignExpr(const EqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

EqAssignExpr &EqAssignExpr::operator=(const EqAssignExpr & other)
{
  EqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void EqAssignExpr::swap(EqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

EqAssignExpr::~EqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void EqAssignExpr::accept(Visitor *v)
{
  v->visitEqAssignExpr(this);
}

EqAssignExpr *EqAssignExpr::clone() const
{
  return new EqAssignExpr(*this);
}



/********************   PlusEqAssignExpr    ********************/
PlusEqAssignExpr::PlusEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

PlusEqAssignExpr::PlusEqAssignExpr(const PlusEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

PlusEqAssignExpr &PlusEqAssignExpr::operator=(const PlusEqAssignExpr & other)
{
  PlusEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void PlusEqAssignExpr::swap(PlusEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

PlusEqAssignExpr::~PlusEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void PlusEqAssignExpr::accept(Visitor *v)
{
  v->visitPlusEqAssignExpr(this);
}

PlusEqAssignExpr *PlusEqAssignExpr::clone() const
{
  return new PlusEqAssignExpr(*this);
}



/********************   MinusEqAssignExpr    ********************/
MinusEqAssignExpr::MinusEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MinusEqAssignExpr::MinusEqAssignExpr(const MinusEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MinusEqAssignExpr &MinusEqAssignExpr::operator=(const MinusEqAssignExpr & other)
{
  MinusEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void MinusEqAssignExpr::swap(MinusEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MinusEqAssignExpr::~MinusEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MinusEqAssignExpr::accept(Visitor *v)
{
  v->visitMinusEqAssignExpr(this);
}

MinusEqAssignExpr *MinusEqAssignExpr::clone() const
{
  return new MinusEqAssignExpr(*this);
}



/********************   MultEqAssignExpr    ********************/
MultEqAssignExpr::MultEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MultEqAssignExpr::MultEqAssignExpr(const MultEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MultEqAssignExpr &MultEqAssignExpr::operator=(const MultEqAssignExpr & other)
{
  MultEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void MultEqAssignExpr::swap(MultEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MultEqAssignExpr::~MultEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MultEqAssignExpr::accept(Visitor *v)
{
  v->visitMultEqAssignExpr(this);
}

MultEqAssignExpr *MultEqAssignExpr::clone() const
{
  return new MultEqAssignExpr(*this);
}



/********************   DivEqAssignExpr    ********************/
DivEqAssignExpr::DivEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

DivEqAssignExpr::DivEqAssignExpr(const DivEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

DivEqAssignExpr &DivEqAssignExpr::operator=(const DivEqAssignExpr & other)
{
  DivEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void DivEqAssignExpr::swap(DivEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

DivEqAssignExpr::~DivEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void DivEqAssignExpr::accept(Visitor *v)
{
  v->visitDivEqAssignExpr(this);
}

DivEqAssignExpr *DivEqAssignExpr::clone() const
{
  return new DivEqAssignExpr(*this);
}



/********************   ModEqAssignExpr    ********************/
ModEqAssignExpr::ModEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

ModEqAssignExpr::ModEqAssignExpr(const ModEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

ModEqAssignExpr &ModEqAssignExpr::operator=(const ModEqAssignExpr & other)
{
  ModEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void ModEqAssignExpr::swap(ModEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

ModEqAssignExpr::~ModEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void ModEqAssignExpr::accept(Visitor *v)
{
  v->visitModEqAssignExpr(this);
}

ModEqAssignExpr *ModEqAssignExpr::clone() const
{
  return new ModEqAssignExpr(*this);
}



/********************   AndEqAssignExpr    ********************/
AndEqAssignExpr::AndEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

AndEqAssignExpr::AndEqAssignExpr(const AndEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

AndEqAssignExpr &AndEqAssignExpr::operator=(const AndEqAssignExpr & other)
{
  AndEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void AndEqAssignExpr::swap(AndEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

AndEqAssignExpr::~AndEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void AndEqAssignExpr::accept(Visitor *v)
{
  v->visitAndEqAssignExpr(this);
}

AndEqAssignExpr *AndEqAssignExpr::clone() const
{
  return new AndEqAssignExpr(*this);
}



/********************   OrEqAssignExpr    ********************/
OrEqAssignExpr::OrEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

OrEqAssignExpr::OrEqAssignExpr(const OrEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

OrEqAssignExpr &OrEqAssignExpr::operator=(const OrEqAssignExpr & other)
{
  OrEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void OrEqAssignExpr::swap(OrEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

OrEqAssignExpr::~OrEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void OrEqAssignExpr::accept(Visitor *v)
{
  v->visitOrEqAssignExpr(this);
}

OrEqAssignExpr *OrEqAssignExpr::clone() const
{
  return new OrEqAssignExpr(*this);
}



/********************   XorEqAssignExpr    ********************/
XorEqAssignExpr::XorEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

XorEqAssignExpr::XorEqAssignExpr(const XorEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

XorEqAssignExpr &XorEqAssignExpr::operator=(const XorEqAssignExpr & other)
{
  XorEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void XorEqAssignExpr::swap(XorEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

XorEqAssignExpr::~XorEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void XorEqAssignExpr::accept(Visitor *v)
{
  v->visitXorEqAssignExpr(this);
}

XorEqAssignExpr *XorEqAssignExpr::clone() const
{
  return new XorEqAssignExpr(*this);
}



/********************   LeftShiftEqAssignExpr    ********************/
LeftShiftEqAssignExpr::LeftShiftEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LeftShiftEqAssignExpr::LeftShiftEqAssignExpr(const LeftShiftEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LeftShiftEqAssignExpr &LeftShiftEqAssignExpr::operator=(const LeftShiftEqAssignExpr & other)
{
  LeftShiftEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftEqAssignExpr::swap(LeftShiftEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LeftShiftEqAssignExpr::~LeftShiftEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LeftShiftEqAssignExpr::accept(Visitor *v)
{
  v->visitLeftShiftEqAssignExpr(this);
}

LeftShiftEqAssignExpr *LeftShiftEqAssignExpr::clone() const
{
  return new LeftShiftEqAssignExpr(*this);
}



/********************   RightShiftEqAssignExpr    ********************/
RightShiftEqAssignExpr::RightShiftEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

RightShiftEqAssignExpr::RightShiftEqAssignExpr(const RightShiftEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

RightShiftEqAssignExpr &RightShiftEqAssignExpr::operator=(const RightShiftEqAssignExpr & other)
{
  RightShiftEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftEqAssignExpr::swap(RightShiftEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

RightShiftEqAssignExpr::~RightShiftEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void RightShiftEqAssignExpr::accept(Visitor *v)
{
  v->visitRightShiftEqAssignExpr(this);
}

RightShiftEqAssignExpr *RightShiftEqAssignExpr::clone() const
{
  return new RightShiftEqAssignExpr(*this);
}



/********************   IdTypenameOffsetMembetDesignator    ********************/
IdTypenameOffsetMembetDesignator::IdTypenameOffsetMembetDesignator(IdOrTypename *p1)
{
  idortypename_ = p1;

}

IdTypenameOffsetMembetDesignator::IdTypenameOffsetMembetDesignator(const IdTypenameOffsetMembetDesignator & other)
{
  idortypename_ = other.idortypename_->clone();

}

IdTypenameOffsetMembetDesignator &IdTypenameOffsetMembetDesignator::operator=(const IdTypenameOffsetMembetDesignator & other)
{
  IdTypenameOffsetMembetDesignator tmp(other);
  swap(tmp);
  return *this;
}

void IdTypenameOffsetMembetDesignator::swap(IdTypenameOffsetMembetDesignator & other)
{
  std::swap(idortypename_, other.idortypename_);

}

IdTypenameOffsetMembetDesignator::~IdTypenameOffsetMembetDesignator()
{
  delete(idortypename_);

}

void IdTypenameOffsetMembetDesignator::accept(Visitor *v)
{
  v->visitIdTypenameOffsetMembetDesignator(this);
}

IdTypenameOffsetMembetDesignator *IdTypenameOffsetMembetDesignator::clone() const
{
  return new IdTypenameOffsetMembetDesignator(*this);
}



/********************   DotOffsetMembetDesignator    ********************/
DotOffsetMembetDesignator::DotOffsetMembetDesignator(OffsetofMemberDesignator *p1, Ident p2)
{
  offsetofmemberdesignator_ = p1;
  ident_ = p2;

}

DotOffsetMembetDesignator::DotOffsetMembetDesignator(const DotOffsetMembetDesignator & other)
{
  offsetofmemberdesignator_ = other.offsetofmemberdesignator_->clone();
  ident_ = other.ident_;

}

DotOffsetMembetDesignator &DotOffsetMembetDesignator::operator=(const DotOffsetMembetDesignator & other)
{
  DotOffsetMembetDesignator tmp(other);
  swap(tmp);
  return *this;
}

void DotOffsetMembetDesignator::swap(DotOffsetMembetDesignator & other)
{
  std::swap(offsetofmemberdesignator_, other.offsetofmemberdesignator_);
  std::swap(ident_, other.ident_);

}

DotOffsetMembetDesignator::~DotOffsetMembetDesignator()
{
  delete(offsetofmemberdesignator_);

}

void DotOffsetMembetDesignator::accept(Visitor *v)
{
  v->visitDotOffsetMembetDesignator(this);
}

DotOffsetMembetDesignator *DotOffsetMembetDesignator::clone() const
{
  return new DotOffsetMembetDesignator(*this);
}



/********************   BracketsOffsetMembetDesignator    ********************/
BracketsOffsetMembetDesignator::BracketsOffsetMembetDesignator(OffsetofMemberDesignator *p1, LBRACKET p2, ListExpression *p3, RBRACKET p4)
{
  offsetofmemberdesignator_ = p1;
  lbracket_ = p2;
  listexpression_ = p3;
  rbracket_ = p4;

}

BracketsOffsetMembetDesignator::BracketsOffsetMembetDesignator(const BracketsOffsetMembetDesignator & other)
{
  offsetofmemberdesignator_ = other.offsetofmemberdesignator_->clone();
  lbracket_ = other.lbracket_;
  listexpression_ = other.listexpression_->clone();
  rbracket_ = other.rbracket_;

}

BracketsOffsetMembetDesignator &BracketsOffsetMembetDesignator::operator=(const BracketsOffsetMembetDesignator & other)
{
  BracketsOffsetMembetDesignator tmp(other);
  swap(tmp);
  return *this;
}

void BracketsOffsetMembetDesignator::swap(BracketsOffsetMembetDesignator & other)
{
  std::swap(offsetofmemberdesignator_, other.offsetofmemberdesignator_);
  std::swap(lbracket_, other.lbracket_);
  std::swap(listexpression_, other.listexpression_);
  std::swap(rbracket_, other.rbracket_);

}

BracketsOffsetMembetDesignator::~BracketsOffsetMembetDesignator()
{
  delete(offsetofmemberdesignator_);
  delete(listexpression_);

}

void BracketsOffsetMembetDesignator::accept(Visitor *v)
{
  v->visitBracketsOffsetMembetDesignator(this);
}

BracketsOffsetMembetDesignator *BracketsOffsetMembetDesignator::clone() const
{
  return new BracketsOffsetMembetDesignator(*this);
}



/********************   AssignmentExpr    ********************/
AssignmentExpr::AssignmentExpr(AssignExpr *p1)
{
  assignexpr_ = p1;

}

AssignmentExpr::AssignmentExpr(const AssignmentExpr & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

AssignmentExpr &AssignmentExpr::operator=(const AssignmentExpr & other)
{
  AssignmentExpr tmp(other);
  swap(tmp);
  return *this;
}

void AssignmentExpr::swap(AssignmentExpr & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

AssignmentExpr::~AssignmentExpr()
{
  delete(assignexpr_);

}

void AssignmentExpr::accept(Visitor *v)
{
  v->visitAssignmentExpr(this);
}

AssignmentExpr *AssignmentExpr::clone() const
{
  return new AssignmentExpr(*this);
}



/********************   ConstantInt    ********************/
ConstantInt::ConstantInt(Integer p1)
{
  integer_ = p1;

}

ConstantInt::ConstantInt(const ConstantInt & other)
{
  integer_ = other.integer_;

}

ConstantInt &ConstantInt::operator=(const ConstantInt & other)
{
  ConstantInt tmp(other);
  swap(tmp);
  return *this;
}

void ConstantInt::swap(ConstantInt & other)
{
  std::swap(integer_, other.integer_);

}

ConstantInt::~ConstantInt()
{

}

void ConstantInt::accept(Visitor *v)
{
  v->visitConstantInt(this);
}

ConstantInt *ConstantInt::clone() const
{
  return new ConstantInt(*this);
}



/********************   ConstantFloat    ********************/
ConstantFloat::ConstantFloat(Double p1)
{
  double_ = p1;

}

ConstantFloat::ConstantFloat(const ConstantFloat & other)
{
  double_ = other.double_;

}

ConstantFloat &ConstantFloat::operator=(const ConstantFloat & other)
{
  ConstantFloat tmp(other);
  swap(tmp);
  return *this;
}

void ConstantFloat::swap(ConstantFloat & other)
{
  std::swap(double_, other.double_);

}

ConstantFloat::~ConstantFloat()
{

}

void ConstantFloat::accept(Visitor *v)
{
  v->visitConstantFloat(this);
}

ConstantFloat *ConstantFloat::clone() const
{
  return new ConstantFloat(*this);
}



/********************   ConstantChar    ********************/
ConstantChar::ConstantChar(Char p1)
{
  char_ = p1;

}

ConstantChar::ConstantChar(const ConstantChar & other)
{
  char_ = other.char_;

}

ConstantChar &ConstantChar::operator=(const ConstantChar & other)
{
  ConstantChar tmp(other);
  swap(tmp);
  return *this;
}

void ConstantChar::swap(ConstantChar & other)
{
  std::swap(char_, other.char_);

}

ConstantChar::~ConstantChar()
{

}

void ConstantChar::accept(Visitor *v)
{
  v->visitConstantChar(this);
}

ConstantChar *ConstantChar::clone() const
{
  return new ConstantChar(*this);
}



/********************   ConstantWChar    ********************/
ConstantWChar::ConstantWChar(CST_WCHAR p1)
{
  cst_wchar_ = p1;

}

ConstantWChar::ConstantWChar(const ConstantWChar & other)
{
  cst_wchar_ = other.cst_wchar_;

}

ConstantWChar &ConstantWChar::operator=(const ConstantWChar & other)
{
  ConstantWChar tmp(other);
  swap(tmp);
  return *this;
}

void ConstantWChar::swap(ConstantWChar & other)
{
  std::swap(cst_wchar_, other.cst_wchar_);

}

ConstantWChar::~ConstantWChar()
{

}

void ConstantWChar::accept(Visitor *v)
{
  v->visitConstantWChar(this);
}

ConstantWChar *ConstantWChar::clone() const
{
  return new ConstantWChar(*this);
}



/********************   ConstantString    ********************/
ConstantString::ConstantString(StringConstant *p1)
{
  stringconstant_ = p1;

}

ConstantString::ConstantString(const ConstantString & other)
{
  stringconstant_ = other.stringconstant_->clone();

}

ConstantString &ConstantString::operator=(const ConstantString & other)
{
  ConstantString tmp(other);
  swap(tmp);
  return *this;
}

void ConstantString::swap(ConstantString & other)
{
  std::swap(stringconstant_, other.stringconstant_);

}

ConstantString::~ConstantString()
{
  delete(stringconstant_);

}

void ConstantString::accept(Visitor *v)
{
  v->visitConstantString(this);
}

ConstantString *ConstantString::clone() const
{
  return new ConstantString(*this);
}



/********************   ConstantWString    ********************/
ConstantWString::ConstantWString(WStringList *p1)
{
  wstringlist_ = p1;

}

ConstantWString::ConstantWString(const ConstantWString & other)
{
  wstringlist_ = other.wstringlist_->clone();

}

ConstantWString &ConstantWString::operator=(const ConstantWString & other)
{
  ConstantWString tmp(other);
  swap(tmp);
  return *this;
}

void ConstantWString::swap(ConstantWString & other)
{
  std::swap(wstringlist_, other.wstringlist_);

}

ConstantWString::~ConstantWString()
{
  delete(wstringlist_);

}

void ConstantWString::accept(Visitor *v)
{
  v->visitConstantWString(this);
}

ConstantWString *ConstantWString::clone() const
{
  return new ConstantWString(*this);
}



/********************   StringConst    ********************/
StringConst::StringConst(ListOneString *p1)
{
  listonestring_ = p1;

}

StringConst::StringConst(const StringConst & other)
{
  listonestring_ = other.listonestring_->clone();

}

StringConst &StringConst::operator=(const StringConst & other)
{
  StringConst tmp(other);
  swap(tmp);
  return *this;
}

void StringConst::swap(StringConst & other)
{
  std::swap(listonestring_, other.listonestring_);

}

StringConst::~StringConst()
{
  delete(listonestring_);

}

void StringConst::accept(Visitor *v)
{
  v->visitStringConst(this);
}

StringConst *StringConst::clone() const
{
  return new StringConst(*this);
}



/********************   LastConstantWString    ********************/
LastConstantWString::LastConstantWString(CST_WSTRING p1)
{
  cst_wstring_ = p1;

}

LastConstantWString::LastConstantWString(const LastConstantWString & other)
{
  cst_wstring_ = other.cst_wstring_;

}

LastConstantWString &LastConstantWString::operator=(const LastConstantWString & other)
{
  LastConstantWString tmp(other);
  swap(tmp);
  return *this;
}

void LastConstantWString::swap(LastConstantWString & other)
{
  std::swap(cst_wstring_, other.cst_wstring_);

}

LastConstantWString::~LastConstantWString()
{

}

void LastConstantWString::accept(Visitor *v)
{
  v->visitLastConstantWString(this);
}

LastConstantWString *LastConstantWString::clone() const
{
  return new LastConstantWString(*this);
}



/********************   OneStringWithList    ********************/
OneStringWithList::OneStringWithList(OneString *p1, WStringList *p2)
{
  onestring_ = p1;
  wstringlist_ = p2;

}

OneStringWithList::OneStringWithList(const OneStringWithList & other)
{
  onestring_ = other.onestring_->clone();
  wstringlist_ = other.wstringlist_->clone();

}

OneStringWithList &OneStringWithList::operator=(const OneStringWithList & other)
{
  OneStringWithList tmp(other);
  swap(tmp);
  return *this;
}

void OneStringWithList::swap(OneStringWithList & other)
{
  std::swap(onestring_, other.onestring_);
  std::swap(wstringlist_, other.wstringlist_);

}

OneStringWithList::~OneStringWithList()
{
  delete(onestring_);
  delete(wstringlist_);

}

void OneStringWithList::accept(Visitor *v)
{
  v->visitOneStringWithList(this);
}

OneStringWithList *OneStringWithList::clone() const
{
  return new OneStringWithList(*this);
}



/********************   WStringWithList    ********************/
WStringWithList::WStringWithList(CST_WSTRING p1, WStringList *p2)
{
  cst_wstring_ = p1;
  wstringlist_ = p2;

}

WStringWithList::WStringWithList(const WStringWithList & other)
{
  cst_wstring_ = other.cst_wstring_;
  wstringlist_ = other.wstringlist_->clone();

}

WStringWithList &WStringWithList::operator=(const WStringWithList & other)
{
  WStringWithList tmp(other);
  swap(tmp);
  return *this;
}

void WStringWithList::swap(WStringWithList & other)
{
  std::swap(cst_wstring_, other.cst_wstring_);
  std::swap(wstringlist_, other.wstringlist_);

}

WStringWithList::~WStringWithList()
{
  delete(wstringlist_);

}

void WStringWithList::accept(Visitor *v)
{
  v->visitWStringWithList(this);
}

WStringWithList *WStringWithList::clone() const
{
  return new WStringWithList(*this);
}



/********************   LatersConstantWString    ********************/
LatersConstantWString::LatersConstantWString(CST_WSTRING p1, ListOneString *p2)
{
  cst_wstring_ = p1;
  listonestring_ = p2;

}

LatersConstantWString::LatersConstantWString(const LatersConstantWString & other)
{
  cst_wstring_ = other.cst_wstring_;
  listonestring_ = other.listonestring_->clone();

}

LatersConstantWString &LatersConstantWString::operator=(const LatersConstantWString & other)
{
  LatersConstantWString tmp(other);
  swap(tmp);
  return *this;
}

void LatersConstantWString::swap(LatersConstantWString & other)
{
  std::swap(cst_wstring_, other.cst_wstring_);
  std::swap(listonestring_, other.listonestring_);

}

LatersConstantWString::~LatersConstantWString()
{
  delete(listonestring_);

}

void LatersConstantWString::accept(Visitor *v)
{
  v->visitLatersConstantWString(this);
}

LatersConstantWString *LatersConstantWString::clone() const
{
  return new LatersConstantWString(*this);
}



/********************   SimpleConstantString    ********************/
SimpleConstantString::SimpleConstantString(String p1)
{
  string_ = p1;

}

SimpleConstantString::SimpleConstantString(const SimpleConstantString & other)
{
  string_ = other.string_;

}

SimpleConstantString &SimpleConstantString::operator=(const SimpleConstantString & other)
{
  SimpleConstantString tmp(other);
  swap(tmp);
  return *this;
}

void SimpleConstantString::swap(SimpleConstantString & other)
{
  std::swap(string_, other.string_);

}

SimpleConstantString::~SimpleConstantString()
{

}

void SimpleConstantString::accept(Visitor *v)
{
  v->visitSimpleConstantString(this);
}

SimpleConstantString *SimpleConstantString::clone() const
{
  return new SimpleConstantString(*this);
}



/********************   FunctionConstantString    ********************/
FunctionConstantString::FunctionConstantString(FUNCTION__ p1)
{
  function___ = p1;

}

FunctionConstantString::FunctionConstantString(const FunctionConstantString & other)
{
  function___ = other.function___;

}

FunctionConstantString &FunctionConstantString::operator=(const FunctionConstantString & other)
{
  FunctionConstantString tmp(other);
  swap(tmp);
  return *this;
}

void FunctionConstantString::swap(FunctionConstantString & other)
{
  std::swap(function___, other.function___);

}

FunctionConstantString::~FunctionConstantString()
{

}

void FunctionConstantString::accept(Visitor *v)
{
  v->visitFunctionConstantString(this);
}

FunctionConstantString *FunctionConstantString::clone() const
{
  return new FunctionConstantString(*this);
}



/********************   PrettyFunctionConstantString    ********************/
PrettyFunctionConstantString::PrettyFunctionConstantString()
{

}

PrettyFunctionConstantString::PrettyFunctionConstantString(const PrettyFunctionConstantString & other)
{

}

PrettyFunctionConstantString &PrettyFunctionConstantString::operator=(const PrettyFunctionConstantString & other)
{
  PrettyFunctionConstantString tmp(other);
  swap(tmp);
  return *this;
}

void PrettyFunctionConstantString::swap(PrettyFunctionConstantString & other)
{

}

PrettyFunctionConstantString::~PrettyFunctionConstantString()
{

}

void PrettyFunctionConstantString::accept(Visitor *v)
{
  v->visitPrettyFunctionConstantString(this);
}

PrettyFunctionConstantString *PrettyFunctionConstantString::clone() const
{
  return new PrettyFunctionConstantString(*this);
}



/********************   SimpleExpression    ********************/
SimpleExpression::SimpleExpression(Expression *p1)
{
  expression_ = p1;

}

SimpleExpression::SimpleExpression(const SimpleExpression & other)
{
  expression_ = other.expression_->clone();

}

SimpleExpression &SimpleExpression::operator=(const SimpleExpression & other)
{
  SimpleExpression tmp(other);
  swap(tmp);
  return *this;
}

void SimpleExpression::swap(SimpleExpression & other)
{
  std::swap(expression_, other.expression_);

}

SimpleExpression::~SimpleExpression()
{
  delete(expression_);

}

void SimpleExpression::accept(Visitor *v)
{
  v->visitSimpleExpression(this);
}

SimpleExpression *SimpleExpression::clone() const
{
  return new SimpleExpression(*this);
}



/********************   BracesExpression    ********************/
BracesExpression::BracesExpression(LBRACE p1, InitializerListOpt *p2, RBRACE p3)
{
  lbrace_ = p1;
  initializerlistopt_ = p2;
  rbrace_ = p3;

}

BracesExpression::BracesExpression(const BracesExpression & other)
{
  lbrace_ = other.lbrace_;
  initializerlistopt_ = other.initializerlistopt_->clone();
  rbrace_ = other.rbrace_;

}

BracesExpression &BracesExpression::operator=(const BracesExpression & other)
{
  BracesExpression tmp(other);
  swap(tmp);
  return *this;
}

void BracesExpression::swap(BracesExpression & other)
{
  std::swap(lbrace_, other.lbrace_);
  std::swap(initializerlistopt_, other.initializerlistopt_);
  std::swap(rbrace_, other.rbrace_);

}

BracesExpression::~BracesExpression()
{
  delete(initializerlistopt_);

}

void BracesExpression::accept(Visitor *v)
{
  v->visitBracesExpression(this);
}

BracesExpression *BracesExpression::clone() const
{
  return new BracesExpression(*this);
}



/********************   EmptyInitializerList    ********************/
EmptyInitializerList::EmptyInitializerList()
{

}

EmptyInitializerList::EmptyInitializerList(const EmptyInitializerList & other)
{

}

EmptyInitializerList &EmptyInitializerList::operator=(const EmptyInitializerList & other)
{
  EmptyInitializerList tmp(other);
  swap(tmp);
  return *this;
}

void EmptyInitializerList::swap(EmptyInitializerList & other)
{

}

EmptyInitializerList::~EmptyInitializerList()
{

}

void EmptyInitializerList::accept(Visitor *v)
{
  v->visitEmptyInitializerList(this);
}

EmptyInitializerList *EmptyInitializerList::clone() const
{
  return new EmptyInitializerList(*this);
}



/********************   InitializerList    ********************/
InitializerList::InitializerList(ListInitializerSingle *p1)
{
  listinitializersingle_ = p1;

}

InitializerList::InitializerList(const InitializerList & other)
{
  listinitializersingle_ = other.listinitializersingle_->clone();

}

InitializerList &InitializerList::operator=(const InitializerList & other)
{
  InitializerList tmp(other);
  swap(tmp);
  return *this;
}

void InitializerList::swap(InitializerList & other)
{
  std::swap(listinitializersingle_, other.listinitializersingle_);

}

InitializerList::~InitializerList()
{
  delete(listinitializersingle_);

}

void InitializerList::accept(Visitor *v)
{
  v->visitInitializerList(this);
}

InitializerList *InitializerList::clone() const
{
  return new InitializerList(*this);
}



/********************   InitializerListComma    ********************/
InitializerListComma::InitializerListComma(ListInitializerSingle *p1)
{
  listinitializersingle_ = p1;

}

InitializerListComma::InitializerListComma(const InitializerListComma & other)
{
  listinitializersingle_ = other.listinitializersingle_->clone();

}

InitializerListComma &InitializerListComma::operator=(const InitializerListComma & other)
{
  InitializerListComma tmp(other);
  swap(tmp);
  return *this;
}

void InitializerListComma::swap(InitializerListComma & other)
{
  std::swap(listinitializersingle_, other.listinitializersingle_);

}

InitializerListComma::~InitializerListComma()
{
  delete(listinitializersingle_);

}

void InitializerListComma::accept(Visitor *v)
{
  v->visitInitializerListComma(this);
}

InitializerListComma *InitializerListComma::clone() const
{
  return new InitializerListComma(*this);
}



/********************   InitializerDesignator    ********************/
InitializerDesignator::InitializerDesignator(InitDesignators *p1, EqOpt *p2, InitExpression *p3)
{
  initdesignators_ = p1;
  eqopt_ = p2;
  initexpression_ = p3;

}

InitializerDesignator::InitializerDesignator(const InitializerDesignator & other)
{
  initdesignators_ = other.initdesignators_->clone();
  eqopt_ = other.eqopt_->clone();
  initexpression_ = other.initexpression_->clone();

}

InitializerDesignator &InitializerDesignator::operator=(const InitializerDesignator & other)
{
  InitializerDesignator tmp(other);
  swap(tmp);
  return *this;
}

void InitializerDesignator::swap(InitializerDesignator & other)
{
  std::swap(initdesignators_, other.initdesignators_);
  std::swap(eqopt_, other.eqopt_);
  std::swap(initexpression_, other.initexpression_);

}

InitializerDesignator::~InitializerDesignator()
{
  delete(initdesignators_);
  delete(eqopt_);
  delete(initexpression_);

}

void InitializerDesignator::accept(Visitor *v)
{
  v->visitInitializerDesignator(this);
}

InitializerDesignator *InitializerDesignator::clone() const
{
  return new InitializerDesignator(*this);
}



/********************   InitializerGCCDesignator    ********************/
InitializerGCCDesignator::InitializerGCCDesignator(IdOrTypename *p1, InitExpression *p2)
{
  idortypename_ = p1;
  initexpression_ = p2;

}

InitializerGCCDesignator::InitializerGCCDesignator(const InitializerGCCDesignator & other)
{
  idortypename_ = other.idortypename_->clone();
  initexpression_ = other.initexpression_->clone();

}

InitializerGCCDesignator &InitializerGCCDesignator::operator=(const InitializerGCCDesignator & other)
{
  InitializerGCCDesignator tmp(other);
  swap(tmp);
  return *this;
}

void InitializerGCCDesignator::swap(InitializerGCCDesignator & other)
{
  std::swap(idortypename_, other.idortypename_);
  std::swap(initexpression_, other.initexpression_);

}

InitializerGCCDesignator::~InitializerGCCDesignator()
{
  delete(idortypename_);
  delete(initexpression_);

}

void InitializerGCCDesignator::accept(Visitor *v)
{
  v->visitInitializerGCCDesignator(this);
}

InitializerGCCDesignator *InitializerGCCDesignator::clone() const
{
  return new InitializerGCCDesignator(*this);
}



/********************   EmptyInitializer    ********************/
EmptyInitializer::EmptyInitializer(InitExpression *p1)
{
  initexpression_ = p1;

}

EmptyInitializer::EmptyInitializer(const EmptyInitializer & other)
{
  initexpression_ = other.initexpression_->clone();

}

EmptyInitializer &EmptyInitializer::operator=(const EmptyInitializer & other)
{
  EmptyInitializer tmp(other);
  swap(tmp);
  return *this;
}

void EmptyInitializer::swap(EmptyInitializer & other)
{
  std::swap(initexpression_, other.initexpression_);

}

EmptyInitializer::~EmptyInitializer()
{
  delete(initexpression_);

}

void EmptyInitializer::accept(Visitor *v)
{
  v->visitEmptyInitializer(this);
}

EmptyInitializer *EmptyInitializer::clone() const
{
  return new EmptyInitializer(*this);
}



/********************   EquationSign    ********************/
EquationSign::EquationSign()
{

}

EquationSign::EquationSign(const EquationSign & other)
{

}

EquationSign &EquationSign::operator=(const EquationSign & other)
{
  EquationSign tmp(other);
  swap(tmp);
  return *this;
}

void EquationSign::swap(EquationSign & other)
{

}

EquationSign::~EquationSign()
{

}

void EquationSign::accept(Visitor *v)
{
  v->visitEquationSign(this);
}

EquationSign *EquationSign::clone() const
{
  return new EquationSign(*this);
}



/********************   NoEquationSign    ********************/
NoEquationSign::NoEquationSign()
{

}

NoEquationSign::NoEquationSign(const NoEquationSign & other)
{

}

NoEquationSign &NoEquationSign::operator=(const NoEquationSign & other)
{
  NoEquationSign tmp(other);
  swap(tmp);
  return *this;
}

void NoEquationSign::swap(NoEquationSign & other)
{

}

NoEquationSign::~NoEquationSign()
{

}

void NoEquationSign::accept(Visitor *v)
{
  v->visitNoEquationSign(this);
}

NoEquationSign *NoEquationSign::clone() const
{
  return new NoEquationSign(*this);
}



/********************   DotInitDesignator    ********************/
DotInitDesignator::DotInitDesignator(IdOrTypename *p1, InitDesignatorsOpt *p2)
{
  idortypename_ = p1;
  initdesignatorsopt_ = p2;

}

DotInitDesignator::DotInitDesignator(const DotInitDesignator & other)
{
  idortypename_ = other.idortypename_->clone();
  initdesignatorsopt_ = other.initdesignatorsopt_->clone();

}

DotInitDesignator &DotInitDesignator::operator=(const DotInitDesignator & other)
{
  DotInitDesignator tmp(other);
  swap(tmp);
  return *this;
}

void DotInitDesignator::swap(DotInitDesignator & other)
{
  std::swap(idortypename_, other.idortypename_);
  std::swap(initdesignatorsopt_, other.initdesignatorsopt_);

}

DotInitDesignator::~DotInitDesignator()
{
  delete(idortypename_);
  delete(initdesignatorsopt_);

}

void DotInitDesignator::accept(Visitor *v)
{
  v->visitDotInitDesignator(this);
}

DotInitDesignator *DotInitDesignator::clone() const
{
  return new DotInitDesignator(*this);
}



/********************   BracketsInitDesignator    ********************/
BracketsInitDesignator::BracketsInitDesignator(LBRACKET p1, Expression *p2, RBRACKET p3, InitDesignatorsOpt *p4)
{
  lbracket_ = p1;
  expression_ = p2;
  rbracket_ = p3;
  initdesignatorsopt_ = p4;

}

BracketsInitDesignator::BracketsInitDesignator(const BracketsInitDesignator & other)
{
  lbracket_ = other.lbracket_;
  expression_ = other.expression_->clone();
  rbracket_ = other.rbracket_;
  initdesignatorsopt_ = other.initdesignatorsopt_->clone();

}

BracketsInitDesignator &BracketsInitDesignator::operator=(const BracketsInitDesignator & other)
{
  BracketsInitDesignator tmp(other);
  swap(tmp);
  return *this;
}

void BracketsInitDesignator::swap(BracketsInitDesignator & other)
{
  std::swap(lbracket_, other.lbracket_);
  std::swap(expression_, other.expression_);
  std::swap(rbracket_, other.rbracket_);
  std::swap(initdesignatorsopt_, other.initdesignatorsopt_);

}

BracketsInitDesignator::~BracketsInitDesignator()
{
  delete(expression_);
  delete(initdesignatorsopt_);

}

void BracketsInitDesignator::accept(Visitor *v)
{
  v->visitBracketsInitDesignator(this);
}

BracketsInitDesignator *BracketsInitDesignator::clone() const
{
  return new BracketsInitDesignator(*this);
}



/********************   BracketsSliceInitDesignator    ********************/
BracketsSliceInitDesignator::BracketsSliceInitDesignator(LBRACKET p1, Expression *p2, Expression *p3, RBRACKET p4)
{
  lbracket_ = p1;
  expression_1 = p2;
  expression_2 = p3;
  rbracket_ = p4;

}

BracketsSliceInitDesignator::BracketsSliceInitDesignator(const BracketsSliceInitDesignator & other)
{
  lbracket_ = other.lbracket_;
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  rbracket_ = other.rbracket_;

}

BracketsSliceInitDesignator &BracketsSliceInitDesignator::operator=(const BracketsSliceInitDesignator & other)
{
  BracketsSliceInitDesignator tmp(other);
  swap(tmp);
  return *this;
}

void BracketsSliceInitDesignator::swap(BracketsSliceInitDesignator & other)
{
  std::swap(lbracket_, other.lbracket_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(rbracket_, other.rbracket_);

}

BracketsSliceInitDesignator::~BracketsSliceInitDesignator()
{
  delete(expression_1);
  delete(expression_2);

}

void BracketsSliceInitDesignator::accept(Visitor *v)
{
  v->visitBracketsSliceInitDesignator(this);
}

BracketsSliceInitDesignator *BracketsSliceInitDesignator::clone() const
{
  return new BracketsSliceInitDesignator(*this);
}



/********************   NoInitDesignator    ********************/
NoInitDesignator::NoInitDesignator()
{

}

NoInitDesignator::NoInitDesignator(const NoInitDesignator & other)
{

}

NoInitDesignator &NoInitDesignator::operator=(const NoInitDesignator & other)
{
  NoInitDesignator tmp(other);
  swap(tmp);
  return *this;
}

void NoInitDesignator::swap(NoInitDesignator & other)
{

}

NoInitDesignator::~NoInitDesignator()
{

}

void NoInitDesignator::accept(Visitor *v)
{
  v->visitNoInitDesignator(this);
}

NoInitDesignator *NoInitDesignator::clone() const
{
  return new NoInitDesignator(*this);
}



/********************   SomeInitDesignator    ********************/
SomeInitDesignator::SomeInitDesignator(InitDesignators *p1)
{
  initdesignators_ = p1;

}

SomeInitDesignator::SomeInitDesignator(const SomeInitDesignator & other)
{
  initdesignators_ = other.initdesignators_->clone();

}

SomeInitDesignator &SomeInitDesignator::operator=(const SomeInitDesignator & other)
{
  SomeInitDesignator tmp(other);
  swap(tmp);
  return *this;
}

void SomeInitDesignator::swap(SomeInitDesignator & other)
{
  std::swap(initdesignators_, other.initdesignators_);

}

SomeInitDesignator::~SomeInitDesignator()
{
  delete(initdesignators_);

}

void SomeInitDesignator::accept(Visitor *v)
{
  v->visitSomeInitDesignator(this);
}

SomeInitDesignator *SomeInitDesignator::clone() const
{
  return new SomeInitDesignator(*this);
}



/********************   NoGhostArguments    ********************/
NoGhostArguments::NoGhostArguments()
{

}

NoGhostArguments::NoGhostArguments(const NoGhostArguments & other)
{

}

NoGhostArguments &NoGhostArguments::operator=(const NoGhostArguments & other)
{
  NoGhostArguments tmp(other);
  swap(tmp);
  return *this;
}

void NoGhostArguments::swap(NoGhostArguments & other)
{

}

NoGhostArguments::~NoGhostArguments()
{

}

void NoGhostArguments::accept(Visitor *v)
{
  v->visitNoGhostArguments(this);
}

NoGhostArguments *NoGhostArguments::clone() const
{
  return new NoGhostArguments(*this);
}



/********************   SomeGhostArguments    ********************/
SomeGhostArguments::SomeGhostArguments(Arguments *p1, RGHOST p2)
{
  arguments_ = p1;
  rghost_ = p2;

}

SomeGhostArguments::SomeGhostArguments(const SomeGhostArguments & other)
{
  arguments_ = other.arguments_->clone();
  rghost_ = other.rghost_;

}

SomeGhostArguments &SomeGhostArguments::operator=(const SomeGhostArguments & other)
{
  SomeGhostArguments tmp(other);
  swap(tmp);
  return *this;
}

void SomeGhostArguments::swap(SomeGhostArguments & other)
{
  std::swap(arguments_, other.arguments_);
  std::swap(rghost_, other.rghost_);

}

SomeGhostArguments::~SomeGhostArguments()
{
  delete(arguments_);

}

void SomeGhostArguments::accept(Visitor *v)
{
  v->visitSomeGhostArguments(this);
}

SomeGhostArguments *SomeGhostArguments::clone() const
{
  return new SomeGhostArguments(*this);
}



/********************   NoArguments    ********************/
NoArguments::NoArguments()
{

}

NoArguments::NoArguments(const NoArguments & other)
{

}

NoArguments &NoArguments::operator=(const NoArguments & other)
{
  NoArguments tmp(other);
  swap(tmp);
  return *this;
}

void NoArguments::swap(NoArguments & other)
{

}

NoArguments::~NoArguments()
{

}

void NoArguments::accept(Visitor *v)
{
  v->visitNoArguments(this);
}

NoArguments *NoArguments::clone() const
{
  return new NoArguments(*this);
}



/********************   SomeArguments    ********************/
SomeArguments::SomeArguments(ListExpression *p1)
{
  listexpression_ = p1;

}

SomeArguments::SomeArguments(const SomeArguments & other)
{
  listexpression_ = other.listexpression_->clone();

}

SomeArguments &SomeArguments::operator=(const SomeArguments & other)
{
  SomeArguments tmp(other);
  swap(tmp);
  return *this;
}

void SomeArguments::swap(SomeArguments & other)
{
  std::swap(listexpression_, other.listexpression_);

}

SomeArguments::~SomeArguments()
{
  delete(listexpression_);

}

void SomeArguments::accept(Visitor *v)
{
  v->visitSomeArguments(this);
}

SomeArguments *SomeArguments::clone() const
{
  return new SomeArguments(*this);
}



/********************   NoExpression    ********************/
NoExpression::NoExpression()
{

}

NoExpression::NoExpression(const NoExpression & other)
{

}

NoExpression &NoExpression::operator=(const NoExpression & other)
{
  NoExpression tmp(other);
  swap(tmp);
  return *this;
}

void NoExpression::swap(NoExpression & other)
{

}

NoExpression::~NoExpression()
{

}

void NoExpression::accept(Visitor *v)
{
  v->visitNoExpression(this);
}

NoExpression *NoExpression::clone() const
{
  return new NoExpression(*this);
}



/********************   SomeExpression    ********************/
SomeExpression::SomeExpression(ListExpression *p1)
{
  listexpression_ = p1;

}

SomeExpression::SomeExpression(const SomeExpression & other)
{
  listexpression_ = other.listexpression_->clone();

}

SomeExpression &SomeExpression::operator=(const SomeExpression & other)
{
  SomeExpression tmp(other);
  swap(tmp);
  return *this;
}

void SomeExpression::swap(SomeExpression & other)
{
  std::swap(listexpression_, other.listexpression_);

}

SomeExpression::~SomeExpression()
{
  delete(listexpression_);

}

void SomeExpression::accept(Visitor *v)
{
  v->visitSomeExpression(this);
}

SomeExpression *SomeExpression::clone() const
{
  return new SomeExpression(*this);
}



/********************   NoCommaExpression    ********************/
NoCommaExpression::NoCommaExpression()
{

}

NoCommaExpression::NoCommaExpression(const NoCommaExpression & other)
{

}

NoCommaExpression &NoCommaExpression::operator=(const NoCommaExpression & other)
{
  NoCommaExpression tmp(other);
  swap(tmp);
  return *this;
}

void NoCommaExpression::swap(NoCommaExpression & other)
{

}

NoCommaExpression::~NoCommaExpression()
{

}

void NoCommaExpression::accept(Visitor *v)
{
  v->visitNoCommaExpression(this);
}

NoCommaExpression *NoCommaExpression::clone() const
{
  return new NoCommaExpression(*this);
}



/********************   SomeCommaExpression    ********************/
SomeCommaExpression::SomeCommaExpression(ListExpression *p1)
{
  listexpression_ = p1;

}

SomeCommaExpression::SomeCommaExpression(const SomeCommaExpression & other)
{
  listexpression_ = other.listexpression_->clone();

}

SomeCommaExpression &SomeCommaExpression::operator=(const SomeCommaExpression & other)
{
  SomeCommaExpression tmp(other);
  swap(tmp);
  return *this;
}

void SomeCommaExpression::swap(SomeCommaExpression & other)
{
  std::swap(listexpression_, other.listexpression_);

}

SomeCommaExpression::~SomeCommaExpression()
{
  delete(listexpression_);

}

void SomeCommaExpression::accept(Visitor *v)
{
  v->visitSomeCommaExpression(this);
}

SomeCommaExpression *SomeCommaExpression::clone() const
{
  return new SomeCommaExpression(*this);
}



/********************   ABlock    ********************/
ABlock::ABlock(LBRACE p1, ListLocalLabel *p2, BlockAttrs *p3, ListBlockElement *p4, ListAnnot *p5, RBRACE p6)
{
  lbrace_ = p1;
  listlocallabel_ = p2;
  blockattrs_ = p3;
  listblockelement_ = p4;
  listannot_ = p5;
  rbrace_ = p6;

}

ABlock::ABlock(const ABlock & other)
{
  lbrace_ = other.lbrace_;
  listlocallabel_ = other.listlocallabel_->clone();
  blockattrs_ = other.blockattrs_->clone();
  listblockelement_ = other.listblockelement_->clone();
  listannot_ = other.listannot_->clone();
  rbrace_ = other.rbrace_;

}

ABlock &ABlock::operator=(const ABlock & other)
{
  ABlock tmp(other);
  swap(tmp);
  return *this;
}

void ABlock::swap(ABlock & other)
{
  std::swap(lbrace_, other.lbrace_);
  std::swap(listlocallabel_, other.listlocallabel_);
  std::swap(blockattrs_, other.blockattrs_);
  std::swap(listblockelement_, other.listblockelement_);
  std::swap(listannot_, other.listannot_);
  std::swap(rbrace_, other.rbrace_);

}

ABlock::~ABlock()
{
  delete(listlocallabel_);
  delete(blockattrs_);
  delete(listblockelement_);
  delete(listannot_);

}

void ABlock::accept(Visitor *v)
{
  v->visitABlock(this);
}

ABlock *ABlock::clone() const
{
  return new ABlock(*this);
}



/********************   NoBlockAttrs    ********************/
NoBlockAttrs::NoBlockAttrs()
{

}

NoBlockAttrs::NoBlockAttrs(const NoBlockAttrs & other)
{

}

NoBlockAttrs &NoBlockAttrs::operator=(const NoBlockAttrs & other)
{
  NoBlockAttrs tmp(other);
  swap(tmp);
  return *this;
}

void NoBlockAttrs::swap(NoBlockAttrs & other)
{

}

NoBlockAttrs::~NoBlockAttrs()
{

}

void NoBlockAttrs::accept(Visitor *v)
{
  v->visitNoBlockAttrs(this);
}

NoBlockAttrs *NoBlockAttrs::clone() const
{
  return new NoBlockAttrs(*this);
}



/********************   SomeBlockAttrs    ********************/
SomeBlockAttrs::SomeBlockAttrs(BLOCKATTRIBUTE p1, ListAttr *p2)
{
  blockattribute_ = p1;
  listattr_ = p2;

}

SomeBlockAttrs::SomeBlockAttrs(const SomeBlockAttrs & other)
{
  blockattribute_ = other.blockattribute_;
  listattr_ = other.listattr_->clone();

}

SomeBlockAttrs &SomeBlockAttrs::operator=(const SomeBlockAttrs & other)
{
  SomeBlockAttrs tmp(other);
  swap(tmp);
  return *this;
}

void SomeBlockAttrs::swap(SomeBlockAttrs & other)
{
  std::swap(blockattribute_, other.blockattribute_);
  std::swap(listattr_, other.listattr_);

}

SomeBlockAttrs::~SomeBlockAttrs()
{
  delete(listattr_);

}

void SomeBlockAttrs::accept(Visitor *v)
{
  v->visitSomeBlockAttrs(this);
}

SomeBlockAttrs *SomeBlockAttrs::clone() const
{
  return new SomeBlockAttrs(*this);
}



/********************   DeclarationElement    ********************/
DeclarationElement::DeclarationElement(ListAnnot *p1, Declaration *p2)
{
  listannot_ = p1;
  declaration_ = p2;

}

DeclarationElement::DeclarationElement(const DeclarationElement & other)
{
  listannot_ = other.listannot_->clone();
  declaration_ = other.declaration_->clone();

}

DeclarationElement &DeclarationElement::operator=(const DeclarationElement & other)
{
  DeclarationElement tmp(other);
  swap(tmp);
  return *this;
}

void DeclarationElement::swap(DeclarationElement & other)
{
  std::swap(listannot_, other.listannot_);
  std::swap(declaration_, other.declaration_);

}

DeclarationElement::~DeclarationElement()
{
  delete(listannot_);
  delete(declaration_);

}

void DeclarationElement::accept(Visitor *v)
{
  v->visitDeclarationElement(this);
}

DeclarationElement *DeclarationElement::clone() const
{
  return new DeclarationElement(*this);
}



/********************   StatementElement    ********************/
StatementElement::StatementElement(ListAnnot *p1, Statement *p2)
{
  listannot_ = p1;
  statement_ = p2;

}

StatementElement::StatementElement(const StatementElement & other)
{
  listannot_ = other.listannot_->clone();
  statement_ = other.statement_->clone();

}

StatementElement &StatementElement::operator=(const StatementElement & other)
{
  StatementElement tmp(other);
  swap(tmp);
  return *this;
}

void StatementElement::swap(StatementElement & other)
{
  std::swap(listannot_, other.listannot_);
  std::swap(statement_, other.statement_);

}

StatementElement::~StatementElement()
{
  delete(listannot_);
  delete(statement_);

}

void StatementElement::accept(Visitor *v)
{
  v->visitStatementElement(this);
}

StatementElement *StatementElement::clone() const
{
  return new StatementElement(*this);
}



/********************   PragmaElement    ********************/
PragmaElement::PragmaElement(ListAnnot *p1, Pragma *p2)
{
  listannot_ = p1;
  pragma_ = p2;

}

PragmaElement::PragmaElement(const PragmaElement & other)
{
  listannot_ = other.listannot_->clone();
  pragma_ = other.pragma_->clone();

}

PragmaElement &PragmaElement::operator=(const PragmaElement & other)
{
  PragmaElement tmp(other);
  swap(tmp);
  return *this;
}

void PragmaElement::swap(PragmaElement & other)
{
  std::swap(listannot_, other.listannot_);
  std::swap(pragma_, other.pragma_);

}

PragmaElement::~PragmaElement()
{
  delete(listannot_);
  delete(pragma_);

}

void PragmaElement::accept(Visitor *v)
{
  v->visitPragmaElement(this);
}

PragmaElement *PragmaElement::clone() const
{
  return new PragmaElement(*this);
}



/********************   CodeAnnot    ********************/
CodeAnnot::CodeAnnot(PragmaOrCodeAnnotation *p1)
{
  pragmaorcodeannotation_ = p1;

}

CodeAnnot::CodeAnnot(const CodeAnnot & other)
{
  pragmaorcodeannotation_ = other.pragmaorcodeannotation_->clone();

}

CodeAnnot &CodeAnnot::operator=(const CodeAnnot & other)
{
  CodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void CodeAnnot::swap(CodeAnnot & other)
{
  std::swap(pragmaorcodeannotation_, other.pragmaorcodeannotation_);

}

CodeAnnot::~CodeAnnot()
{
  delete(pragmaorcodeannotation_);

}

void CodeAnnot::accept(Visitor *v)
{
  v->visitCodeAnnot(this);
}

CodeAnnot *CodeAnnot::clone() const
{
  return new CodeAnnot(*this);
}



/********************   GhostAnnot    ********************/
GhostAnnot::GhostAnnot(ListBlockElement *p1, ListAnnot *p2, RGHOST p3)
{
  listblockelement_ = p1;
  listannot_ = p2;
  rghost_ = p3;

}

GhostAnnot::GhostAnnot(const GhostAnnot & other)
{
  listblockelement_ = other.listblockelement_->clone();
  listannot_ = other.listannot_->clone();
  rghost_ = other.rghost_;

}

GhostAnnot &GhostAnnot::operator=(const GhostAnnot & other)
{
  GhostAnnot tmp(other);
  swap(tmp);
  return *this;
}

void GhostAnnot::swap(GhostAnnot & other)
{
  std::swap(listblockelement_, other.listblockelement_);
  std::swap(listannot_, other.listannot_);
  std::swap(rghost_, other.rghost_);

}

GhostAnnot::~GhostAnnot()
{
  delete(listblockelement_);
  delete(listannot_);

}

void GhostAnnot::accept(Visitor *v)
{
  v->visitGhostAnnot(this);
}

GhostAnnot *GhostAnnot::clone() const
{
  return new GhostAnnot(*this);
}



/********************   LocalLable    ********************/
LocalLable::LocalLable(ListLocalLabelName *p1)
{
  listlocallabelname_ = p1;

}

LocalLable::LocalLable(const LocalLable & other)
{
  listlocallabelname_ = other.listlocallabelname_->clone();

}

LocalLable &LocalLable::operator=(const LocalLable & other)
{
  LocalLable tmp(other);
  swap(tmp);
  return *this;
}

void LocalLable::swap(LocalLable & other)
{
  std::swap(listlocallabelname_, other.listlocallabelname_);

}

LocalLable::~LocalLable()
{
  delete(listlocallabelname_);

}

void LocalLable::accept(Visitor *v)
{
  v->visitLocalLable(this);
}

LocalLable *LocalLable::clone() const
{
  return new LocalLable(*this);
}



/********************   ALocalLabelName    ********************/
ALocalLabelName::ALocalLabelName(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

ALocalLabelName::ALocalLabelName(const ALocalLabelName & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

ALocalLabelName &ALocalLabelName::operator=(const ALocalLabelName & other)
{
  ALocalLabelName tmp(other);
  swap(tmp);
  return *this;
}

void ALocalLabelName::swap(ALocalLabelName & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

ALocalLabelName::~ALocalLabelName()
{
  delete(idortypenameasid_);

}

void ALocalLabelName::accept(Visitor *v)
{
  v->visitALocalLabelName(this);
}

ALocalLabelName *ALocalLabelName::clone() const
{
  return new ALocalLabelName(*this);
}



/********************   AnnotatedStatement    ********************/
AnnotatedStatement::AnnotatedStatement(ListAnnot *p1, Statement *p2)
{
  listannot_ = p1;
  statement_ = p2;

}

AnnotatedStatement::AnnotatedStatement(const AnnotatedStatement & other)
{
  listannot_ = other.listannot_->clone();
  statement_ = other.statement_->clone();

}

AnnotatedStatement &AnnotatedStatement::operator=(const AnnotatedStatement & other)
{
  AnnotatedStatement tmp(other);
  swap(tmp);
  return *this;
}

void AnnotatedStatement::swap(AnnotatedStatement & other)
{
  std::swap(listannot_, other.listannot_);
  std::swap(statement_, other.statement_);

}

AnnotatedStatement::~AnnotatedStatement()
{
  delete(listannot_);
  delete(statement_);

}

void AnnotatedStatement::accept(Visitor *v)
{
  v->visitAnnotatedStatement(this);
}

AnnotatedStatement *AnnotatedStatement::clone() const
{
  return new AnnotatedStatement(*this);
}



/********************   NoElsePart    ********************/
NoElsePart::NoElsePart()
{

}

NoElsePart::NoElsePart(const NoElsePart & other)
{

}

NoElsePart &NoElsePart::operator=(const NoElsePart & other)
{
  NoElsePart tmp(other);
  swap(tmp);
  return *this;
}

void NoElsePart::swap(NoElsePart & other)
{

}

NoElsePart::~NoElsePart()
{

}

void NoElsePart::accept(Visitor *v)
{
  v->visitNoElsePart(this);
}

NoElsePart *NoElsePart::clone() const
{
  return new NoElsePart(*this);
}



/********************   SimpleElsePart    ********************/
SimpleElsePart::SimpleElsePart(AnnotatedStmt *p1)
{
  annotatedstmt_ = p1;

}

SimpleElsePart::SimpleElsePart(const SimpleElsePart & other)
{
  annotatedstmt_ = other.annotatedstmt_->clone();

}

SimpleElsePart &SimpleElsePart::operator=(const SimpleElsePart & other)
{
  SimpleElsePart tmp(other);
  swap(tmp);
  return *this;
}

void SimpleElsePart::swap(SimpleElsePart & other)
{
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

SimpleElsePart::~SimpleElsePart()
{
  delete(annotatedstmt_);

}

void SimpleElsePart::accept(Visitor *v)
{
  v->visitSimpleElsePart(this);
}

SimpleElsePart *SimpleElsePart::clone() const
{
  return new SimpleElsePart(*this);
}



/********************   SimpleGhostElsePart    ********************/
SimpleGhostElsePart::SimpleGhostElsePart(AnnotatedStmt *p1, RGHOST p2)
{
  annotatedstmt_ = p1;
  rghost_ = p2;

}

SimpleGhostElsePart::SimpleGhostElsePart(const SimpleGhostElsePart & other)
{
  annotatedstmt_ = other.annotatedstmt_->clone();
  rghost_ = other.rghost_;

}

SimpleGhostElsePart &SimpleGhostElsePart::operator=(const SimpleGhostElsePart & other)
{
  SimpleGhostElsePart tmp(other);
  swap(tmp);
  return *this;
}

void SimpleGhostElsePart::swap(SimpleGhostElsePart & other)
{
  std::swap(annotatedstmt_, other.annotatedstmt_);
  std::swap(rghost_, other.rghost_);

}

SimpleGhostElsePart::~SimpleGhostElsePart()
{
  delete(annotatedstmt_);

}

void SimpleGhostElsePart::accept(Visitor *v)
{
  v->visitSimpleGhostElsePart(this);
}

SimpleGhostElsePart *SimpleGhostElsePart::clone() const
{
  return new SimpleGhostElsePart(*this);
}



/********************   GhostElsePart    ********************/
GhostElsePart::GhostElsePart(AnnotatedStmt *p1, RGHOST p2, AnnotatedStmt *p3)
{
  annotatedstmt_1 = p1;
  rghost_ = p2;
  annotatedstmt_2 = p3;

}

GhostElsePart::GhostElsePart(const GhostElsePart & other)
{
  annotatedstmt_1 = other.annotatedstmt_1->clone();
  rghost_ = other.rghost_;
  annotatedstmt_2 = other.annotatedstmt_2->clone();

}

GhostElsePart &GhostElsePart::operator=(const GhostElsePart & other)
{
  GhostElsePart tmp(other);
  swap(tmp);
  return *this;
}

void GhostElsePart::swap(GhostElsePart & other)
{
  std::swap(annotatedstmt_1, other.annotatedstmt_1);
  std::swap(rghost_, other.rghost_);
  std::swap(annotatedstmt_2, other.annotatedstmt_2);

}

GhostElsePart::~GhostElsePart()
{
  delete(annotatedstmt_1);
  delete(annotatedstmt_2);

}

void GhostElsePart::accept(Visitor *v)
{
  v->visitGhostElsePart(this);
}

GhostElsePart *GhostElsePart::clone() const
{
  return new GhostElsePart(*this);
}



/********************   SemicolonStatement    ********************/
SemicolonStatement::SemicolonStatement()
{

}

SemicolonStatement::SemicolonStatement(const SemicolonStatement & other)
{

}

SemicolonStatement &SemicolonStatement::operator=(const SemicolonStatement & other)
{
  SemicolonStatement tmp(other);
  swap(tmp);
  return *this;
}

void SemicolonStatement::swap(SemicolonStatement & other)
{

}

SemicolonStatement::~SemicolonStatement()
{

}

void SemicolonStatement::accept(Visitor *v)
{
  v->visitSemicolonStatement(this);
}

SemicolonStatement *SemicolonStatement::clone() const
{
  return new SemicolonStatement(*this);
}



/********************   SpecStatement    ********************/
SpecStatement::SpecStatement(IsACSLSpec *p1, ListWildcard *p2, AnnotatedStmt *p3)
{
  isacslspec_ = p1;
  listwildcard_ = p2;
  annotatedstmt_ = p3;

}

SpecStatement::SpecStatement(const SpecStatement & other)
{
  isacslspec_ = other.isacslspec_->clone();
  listwildcard_ = other.listwildcard_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

SpecStatement &SpecStatement::operator=(const SpecStatement & other)
{
  SpecStatement tmp(other);
  swap(tmp);
  return *this;
}

void SpecStatement::swap(SpecStatement & other)
{
  std::swap(isacslspec_, other.isacslspec_);
  std::swap(listwildcard_, other.listwildcard_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

SpecStatement::~SpecStatement()
{
  delete(isacslspec_);
  delete(listwildcard_);
  delete(annotatedstmt_);

}

void SpecStatement::accept(Visitor *v)
{
  v->visitSpecStatement(this);
}

SpecStatement *SpecStatement::clone() const
{
  return new SpecStatement(*this);
}



/********************   ExprsStatement    ********************/
ExprsStatement::ExprsStatement(ListExpression *p1)
{
  listexpression_ = p1;

}

ExprsStatement::ExprsStatement(const ExprsStatement & other)
{
  listexpression_ = other.listexpression_->clone();

}

ExprsStatement &ExprsStatement::operator=(const ExprsStatement & other)
{
  ExprsStatement tmp(other);
  swap(tmp);
  return *this;
}

void ExprsStatement::swap(ExprsStatement & other)
{
  std::swap(listexpression_, other.listexpression_);

}

ExprsStatement::~ExprsStatement()
{
  delete(listexpression_);

}

void ExprsStatement::accept(Visitor *v)
{
  v->visitExprsStatement(this);
}

ExprsStatement *ExprsStatement::clone() const
{
  return new ExprsStatement(*this);
}



/********************   BlockStatement    ********************/
BlockStatement::BlockStatement(Block *p1)
{
  block_ = p1;

}

BlockStatement::BlockStatement(const BlockStatement & other)
{
  block_ = other.block_->clone();

}

BlockStatement &BlockStatement::operator=(const BlockStatement & other)
{
  BlockStatement tmp(other);
  swap(tmp);
  return *this;
}

void BlockStatement::swap(BlockStatement & other)
{
  std::swap(block_, other.block_);

}

BlockStatement::~BlockStatement()
{
  delete(block_);

}

void BlockStatement::accept(Visitor *v)
{
  v->visitBlockStatement(this);
}

BlockStatement *BlockStatement::clone() const
{
  return new BlockStatement(*this);
}



/********************   IfStatement    ********************/
IfStatement::IfStatement(ListExpression *p1, AnnotatedStmt *p2, ElsePart *p3)
{
  listexpression_ = p1;
  annotatedstmt_ = p2;
  elsepart_ = p3;

}

IfStatement::IfStatement(const IfStatement & other)
{
  listexpression_ = other.listexpression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();
  elsepart_ = other.elsepart_->clone();

}

IfStatement &IfStatement::operator=(const IfStatement & other)
{
  IfStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfStatement::swap(IfStatement & other)
{
  std::swap(listexpression_, other.listexpression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);
  std::swap(elsepart_, other.elsepart_);

}

IfStatement::~IfStatement()
{
  delete(listexpression_);
  delete(annotatedstmt_);
  delete(elsepart_);

}

void IfStatement::accept(Visitor *v)
{
  v->visitIfStatement(this);
}

IfStatement *IfStatement::clone() const
{
  return new IfStatement(*this);
}



/********************   SwitchStatement    ********************/
SwitchStatement::SwitchStatement(ListExpression *p1, AnnotatedStmt *p2)
{
  listexpression_ = p1;
  annotatedstmt_ = p2;

}

SwitchStatement::SwitchStatement(const SwitchStatement & other)
{
  listexpression_ = other.listexpression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

SwitchStatement &SwitchStatement::operator=(const SwitchStatement & other)
{
  SwitchStatement tmp(other);
  swap(tmp);
  return *this;
}

void SwitchStatement::swap(SwitchStatement & other)
{
  std::swap(listexpression_, other.listexpression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

SwitchStatement::~SwitchStatement()
{
  delete(listexpression_);
  delete(annotatedstmt_);

}

void SwitchStatement::accept(Visitor *v)
{
  v->visitSwitchStatement(this);
}

SwitchStatement *SwitchStatement::clone() const
{
  return new SwitchStatement(*this);
}



/********************   WhileStatement    ********************/
WhileStatement::WhileStatement(OptLoopAnnotations *p1, ListExpression *p2, AnnotatedStmt *p3)
{
  optloopannotations_ = p1;
  listexpression_ = p2;
  annotatedstmt_ = p3;

}

WhileStatement::WhileStatement(const WhileStatement & other)
{
  optloopannotations_ = other.optloopannotations_->clone();
  listexpression_ = other.listexpression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

WhileStatement &WhileStatement::operator=(const WhileStatement & other)
{
  WhileStatement tmp(other);
  swap(tmp);
  return *this;
}

void WhileStatement::swap(WhileStatement & other)
{
  std::swap(optloopannotations_, other.optloopannotations_);
  std::swap(listexpression_, other.listexpression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

WhileStatement::~WhileStatement()
{
  delete(optloopannotations_);
  delete(listexpression_);
  delete(annotatedstmt_);

}

void WhileStatement::accept(Visitor *v)
{
  v->visitWhileStatement(this);
}

WhileStatement *WhileStatement::clone() const
{
  return new WhileStatement(*this);
}



/********************   DoWhileStatement    ********************/
DoWhileStatement::DoWhileStatement(OptLoopAnnotations *p1, AnnotatedStmt *p2, ListExpression *p3)
{
  optloopannotations_ = p1;
  annotatedstmt_ = p2;
  listexpression_ = p3;

}

DoWhileStatement::DoWhileStatement(const DoWhileStatement & other)
{
  optloopannotations_ = other.optloopannotations_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();
  listexpression_ = other.listexpression_->clone();

}

DoWhileStatement &DoWhileStatement::operator=(const DoWhileStatement & other)
{
  DoWhileStatement tmp(other);
  swap(tmp);
  return *this;
}

void DoWhileStatement::swap(DoWhileStatement & other)
{
  std::swap(optloopannotations_, other.optloopannotations_);
  std::swap(annotatedstmt_, other.annotatedstmt_);
  std::swap(listexpression_, other.listexpression_);

}

DoWhileStatement::~DoWhileStatement()
{
  delete(optloopannotations_);
  delete(annotatedstmt_);
  delete(listexpression_);

}

void DoWhileStatement::accept(Visitor *v)
{
  v->visitDoWhileStatement(this);
}

DoWhileStatement *DoWhileStatement::clone() const
{
  return new DoWhileStatement(*this);
}



/********************   ForStatement    ********************/
ForStatement::ForStatement(OptLoopAnnotations *p1, ForClause *p2, OptExpression *p3, OptExpression *p4, AnnotatedStmt *p5)
{
  optloopannotations_ = p1;
  forclause_ = p2;
  optexpression_1 = p3;
  optexpression_2 = p4;
  annotatedstmt_ = p5;

}

ForStatement::ForStatement(const ForStatement & other)
{
  optloopannotations_ = other.optloopannotations_->clone();
  forclause_ = other.forclause_->clone();
  optexpression_1 = other.optexpression_1->clone();
  optexpression_2 = other.optexpression_2->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

ForStatement &ForStatement::operator=(const ForStatement & other)
{
  ForStatement tmp(other);
  swap(tmp);
  return *this;
}

void ForStatement::swap(ForStatement & other)
{
  std::swap(optloopannotations_, other.optloopannotations_);
  std::swap(forclause_, other.forclause_);
  std::swap(optexpression_1, other.optexpression_1);
  std::swap(optexpression_2, other.optexpression_2);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

ForStatement::~ForStatement()
{
  delete(optloopannotations_);
  delete(forclause_);
  delete(optexpression_1);
  delete(optexpression_2);
  delete(annotatedstmt_);

}

void ForStatement::accept(Visitor *v)
{
  v->visitForStatement(this);
}

ForStatement *ForStatement::clone() const
{
  return new ForStatement(*this);
}



/********************   ColonStatement    ********************/
ColonStatement::ColonStatement(IdOrTypenameAsId *p1, ListAttributeNocv *p2, AnnotatedStmt *p3)
{
  idortypenameasid_ = p1;
  listattributenocv_ = p2;
  annotatedstmt_ = p3;

}

ColonStatement::ColonStatement(const ColonStatement & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();
  listattributenocv_ = other.listattributenocv_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

ColonStatement &ColonStatement::operator=(const ColonStatement & other)
{
  ColonStatement tmp(other);
  swap(tmp);
  return *this;
}

void ColonStatement::swap(ColonStatement & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);
  std::swap(listattributenocv_, other.listattributenocv_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

ColonStatement::~ColonStatement()
{
  delete(idortypenameasid_);
  delete(listattributenocv_);
  delete(annotatedstmt_);

}

void ColonStatement::accept(Visitor *v)
{
  v->visitColonStatement(this);
}

ColonStatement *ColonStatement::clone() const
{
  return new ColonStatement(*this);
}



/********************   CaseStatement    ********************/
CaseStatement::CaseStatement(Expression *p1, AnnotatedStmt *p2)
{
  expression_ = p1;
  annotatedstmt_ = p2;

}

CaseStatement::CaseStatement(const CaseStatement & other)
{
  expression_ = other.expression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

CaseStatement &CaseStatement::operator=(const CaseStatement & other)
{
  CaseStatement tmp(other);
  swap(tmp);
  return *this;
}

void CaseStatement::swap(CaseStatement & other)
{
  std::swap(expression_, other.expression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

CaseStatement::~CaseStatement()
{
  delete(expression_);
  delete(annotatedstmt_);

}

void CaseStatement::accept(Visitor *v)
{
  v->visitCaseStatement(this);
}

CaseStatement *CaseStatement::clone() const
{
  return new CaseStatement(*this);
}



/********************   CaseSliceStatement    ********************/
CaseSliceStatement::CaseSliceStatement(Expression *p1, Expression *p2, AnnotatedStmt *p3)
{
  expression_1 = p1;
  expression_2 = p2;
  annotatedstmt_ = p3;

}

CaseSliceStatement::CaseSliceStatement(const CaseSliceStatement & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

CaseSliceStatement &CaseSliceStatement::operator=(const CaseSliceStatement & other)
{
  CaseSliceStatement tmp(other);
  swap(tmp);
  return *this;
}

void CaseSliceStatement::swap(CaseSliceStatement & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

CaseSliceStatement::~CaseSliceStatement()
{
  delete(expression_1);
  delete(expression_2);
  delete(annotatedstmt_);

}

void CaseSliceStatement::accept(Visitor *v)
{
  v->visitCaseSliceStatement(this);
}

CaseSliceStatement *CaseSliceStatement::clone() const
{
  return new CaseSliceStatement(*this);
}



/********************   DefaultStatement    ********************/
DefaultStatement::DefaultStatement(AnnotatedStmt *p1)
{
  annotatedstmt_ = p1;

}

DefaultStatement::DefaultStatement(const DefaultStatement & other)
{
  annotatedstmt_ = other.annotatedstmt_->clone();

}

DefaultStatement &DefaultStatement::operator=(const DefaultStatement & other)
{
  DefaultStatement tmp(other);
  swap(tmp);
  return *this;
}

void DefaultStatement::swap(DefaultStatement & other)
{
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

DefaultStatement::~DefaultStatement()
{
  delete(annotatedstmt_);

}

void DefaultStatement::accept(Visitor *v)
{
  v->visitDefaultStatement(this);
}

DefaultStatement *DefaultStatement::clone() const
{
  return new DefaultStatement(*this);
}



/********************   EmptyReturnStatement    ********************/
EmptyReturnStatement::EmptyReturnStatement()
{

}

EmptyReturnStatement::EmptyReturnStatement(const EmptyReturnStatement & other)
{

}

EmptyReturnStatement &EmptyReturnStatement::operator=(const EmptyReturnStatement & other)
{
  EmptyReturnStatement tmp(other);
  swap(tmp);
  return *this;
}

void EmptyReturnStatement::swap(EmptyReturnStatement & other)
{

}

EmptyReturnStatement::~EmptyReturnStatement()
{

}

void EmptyReturnStatement::accept(Visitor *v)
{
  v->visitEmptyReturnStatement(this);
}

EmptyReturnStatement *EmptyReturnStatement::clone() const
{
  return new EmptyReturnStatement(*this);
}



/********************   ReturnStatement    ********************/
ReturnStatement::ReturnStatement(ListExpression *p1)
{
  listexpression_ = p1;

}

ReturnStatement::ReturnStatement(const ReturnStatement & other)
{
  listexpression_ = other.listexpression_->clone();

}

ReturnStatement &ReturnStatement::operator=(const ReturnStatement & other)
{
  ReturnStatement tmp(other);
  swap(tmp);
  return *this;
}

void ReturnStatement::swap(ReturnStatement & other)
{
  std::swap(listexpression_, other.listexpression_);

}

ReturnStatement::~ReturnStatement()
{
  delete(listexpression_);

}

void ReturnStatement::accept(Visitor *v)
{
  v->visitReturnStatement(this);
}

ReturnStatement *ReturnStatement::clone() const
{
  return new ReturnStatement(*this);
}



/********************   BreakStatement    ********************/
BreakStatement::BreakStatement()
{

}

BreakStatement::BreakStatement(const BreakStatement & other)
{

}

BreakStatement &BreakStatement::operator=(const BreakStatement & other)
{
  BreakStatement tmp(other);
  swap(tmp);
  return *this;
}

void BreakStatement::swap(BreakStatement & other)
{

}

BreakStatement::~BreakStatement()
{

}

void BreakStatement::accept(Visitor *v)
{
  v->visitBreakStatement(this);
}

BreakStatement *BreakStatement::clone() const
{
  return new BreakStatement(*this);
}



/********************   ContinueStatement    ********************/
ContinueStatement::ContinueStatement()
{

}

ContinueStatement::ContinueStatement(const ContinueStatement & other)
{

}

ContinueStatement &ContinueStatement::operator=(const ContinueStatement & other)
{
  ContinueStatement tmp(other);
  swap(tmp);
  return *this;
}

void ContinueStatement::swap(ContinueStatement & other)
{

}

ContinueStatement::~ContinueStatement()
{

}

void ContinueStatement::accept(Visitor *v)
{
  v->visitContinueStatement(this);
}

ContinueStatement *ContinueStatement::clone() const
{
  return new ContinueStatement(*this);
}



/********************   GotoStatement    ********************/
GotoStatement::GotoStatement(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

GotoStatement::GotoStatement(const GotoStatement & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

GotoStatement &GotoStatement::operator=(const GotoStatement & other)
{
  GotoStatement tmp(other);
  swap(tmp);
  return *this;
}

void GotoStatement::swap(GotoStatement & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

GotoStatement::~GotoStatement()
{
  delete(idortypenameasid_);

}

void GotoStatement::accept(Visitor *v)
{
  v->visitGotoStatement(this);
}

GotoStatement *GotoStatement::clone() const
{
  return new GotoStatement(*this);
}



/********************   StarGotoStatement    ********************/
StarGotoStatement::StarGotoStatement(ListExpression *p1)
{
  listexpression_ = p1;

}

StarGotoStatement::StarGotoStatement(const StarGotoStatement & other)
{
  listexpression_ = other.listexpression_->clone();

}

StarGotoStatement &StarGotoStatement::operator=(const StarGotoStatement & other)
{
  StarGotoStatement tmp(other);
  swap(tmp);
  return *this;
}

void StarGotoStatement::swap(StarGotoStatement & other)
{
  std::swap(listexpression_, other.listexpression_);

}

StarGotoStatement::~StarGotoStatement()
{
  delete(listexpression_);

}

void StarGotoStatement::accept(Visitor *v)
{
  v->visitStarGotoStatement(this);
}

StarGotoStatement *StarGotoStatement::clone() const
{
  return new StarGotoStatement(*this);
}



/********************   AsmGotoAsmattrStatement    ********************/
AsmGotoAsmattrStatement::AsmGotoAsmattrStatement(ASM p1, ListAsmattr *p2, ListOneString *p3, Asmoutputs *p4)
{
  asm_ = p1;
  listasmattr_ = p2;
  listonestring_ = p3;
  asmoutputs_ = p4;

}

AsmGotoAsmattrStatement::AsmGotoAsmattrStatement(const AsmGotoAsmattrStatement & other)
{
  asm_ = other.asm_;
  listasmattr_ = other.listasmattr_->clone();
  listonestring_ = other.listonestring_->clone();
  asmoutputs_ = other.asmoutputs_->clone();

}

AsmGotoAsmattrStatement &AsmGotoAsmattrStatement::operator=(const AsmGotoAsmattrStatement & other)
{
  AsmGotoAsmattrStatement tmp(other);
  swap(tmp);
  return *this;
}

void AsmGotoAsmattrStatement::swap(AsmGotoAsmattrStatement & other)
{
  std::swap(asm_, other.asm_);
  std::swap(listasmattr_, other.listasmattr_);
  std::swap(listonestring_, other.listonestring_);
  std::swap(asmoutputs_, other.asmoutputs_);

}

AsmGotoAsmattrStatement::~AsmGotoAsmattrStatement()
{
  delete(listasmattr_);
  delete(listonestring_);
  delete(asmoutputs_);

}

void AsmGotoAsmattrStatement::accept(Visitor *v)
{
  v->visitAsmGotoAsmattrStatement(this);
}

AsmGotoAsmattrStatement *AsmGotoAsmattrStatement::clone() const
{
  return new AsmGotoAsmattrStatement(*this);
}



/********************   AsmAsmattrStatement    ********************/
AsmAsmattrStatement::AsmAsmattrStatement(ASM p1, ListAsmattr *p2, ListOneString *p3, Asmoutputs *p4)
{
  asm_ = p1;
  listasmattr_ = p2;
  listonestring_ = p3;
  asmoutputs_ = p4;

}

AsmAsmattrStatement::AsmAsmattrStatement(const AsmAsmattrStatement & other)
{
  asm_ = other.asm_;
  listasmattr_ = other.listasmattr_->clone();
  listonestring_ = other.listonestring_->clone();
  asmoutputs_ = other.asmoutputs_->clone();

}

AsmAsmattrStatement &AsmAsmattrStatement::operator=(const AsmAsmattrStatement & other)
{
  AsmAsmattrStatement tmp(other);
  swap(tmp);
  return *this;
}

void AsmAsmattrStatement::swap(AsmAsmattrStatement & other)
{
  std::swap(asm_, other.asm_);
  std::swap(listasmattr_, other.listasmattr_);
  std::swap(listonestring_, other.listonestring_);
  std::swap(asmoutputs_, other.asmoutputs_);

}

AsmAsmattrStatement::~AsmAsmattrStatement()
{
  delete(listasmattr_);
  delete(listonestring_);
  delete(asmoutputs_);

}

void AsmAsmattrStatement::accept(Visitor *v)
{
  v->visitAsmAsmattrStatement(this);
}

AsmAsmattrStatement *AsmAsmattrStatement::clone() const
{
  return new AsmAsmattrStatement(*this);
}



/********************   AsmStatement    ********************/
AsmStatement::AsmStatement(ASM p1)
{
  asm_ = p1;

}

AsmStatement::AsmStatement(const AsmStatement & other)
{
  asm_ = other.asm_;

}

AsmStatement &AsmStatement::operator=(const AsmStatement & other)
{
  AsmStatement tmp(other);
  swap(tmp);
  return *this;
}

void AsmStatement::swap(AsmStatement & other)
{
  std::swap(asm_, other.asm_);

}

AsmStatement::~AsmStatement()
{

}

void AsmStatement::accept(Visitor *v)
{
  v->visitAsmStatement(this);
}

AsmStatement *AsmStatement::clone() const
{
  return new AsmStatement(*this);
}



/********************   TryExceptStatement    ********************/
TryExceptStatement::TryExceptStatement(Block *p1, ListExpression *p2, Block *p3)
{
  block_1 = p1;
  listexpression_ = p2;
  block_2 = p3;

}

TryExceptStatement::TryExceptStatement(const TryExceptStatement & other)
{
  block_1 = other.block_1->clone();
  listexpression_ = other.listexpression_->clone();
  block_2 = other.block_2->clone();

}

TryExceptStatement &TryExceptStatement::operator=(const TryExceptStatement & other)
{
  TryExceptStatement tmp(other);
  swap(tmp);
  return *this;
}

void TryExceptStatement::swap(TryExceptStatement & other)
{
  std::swap(block_1, other.block_1);
  std::swap(listexpression_, other.listexpression_);
  std::swap(block_2, other.block_2);

}

TryExceptStatement::~TryExceptStatement()
{
  delete(block_1);
  delete(listexpression_);
  delete(block_2);

}

void TryExceptStatement::accept(Visitor *v)
{
  v->visitTryExceptStatement(this);
}

TryExceptStatement *TryExceptStatement::clone() const
{
  return new TryExceptStatement(*this);
}



/********************   TryFinallyStatement    ********************/
TryFinallyStatement::TryFinallyStatement(Block *p1, Block *p2)
{
  block_1 = p1;
  block_2 = p2;

}

TryFinallyStatement::TryFinallyStatement(const TryFinallyStatement & other)
{
  block_1 = other.block_1->clone();
  block_2 = other.block_2->clone();

}

TryFinallyStatement &TryFinallyStatement::operator=(const TryFinallyStatement & other)
{
  TryFinallyStatement tmp(other);
  swap(tmp);
  return *this;
}

void TryFinallyStatement::swap(TryFinallyStatement & other)
{
  std::swap(block_1, other.block_1);
  std::swap(block_2, other.block_2);

}

TryFinallyStatement::~TryFinallyStatement()
{
  delete(block_1);
  delete(block_2);

}

void TryFinallyStatement::accept(Visitor *v)
{
  v->visitTryFinallyStatement(this);
}

TryFinallyStatement *TryFinallyStatement::clone() const
{
  return new TryFinallyStatement(*this);
}



/********************   NoLoopAnnotations    ********************/
NoLoopAnnotations::NoLoopAnnotations()
{

}

NoLoopAnnotations::NoLoopAnnotations(const NoLoopAnnotations & other)
{

}

NoLoopAnnotations &NoLoopAnnotations::operator=(const NoLoopAnnotations & other)
{
  NoLoopAnnotations tmp(other);
  swap(tmp);
  return *this;
}

void NoLoopAnnotations::swap(NoLoopAnnotations & other)
{

}

NoLoopAnnotations::~NoLoopAnnotations()
{

}

void NoLoopAnnotations::accept(Visitor *v)
{
  v->visitNoLoopAnnotations(this);
}

NoLoopAnnotations *NoLoopAnnotations::clone() const
{
  return new NoLoopAnnotations(*this);
}



/********************   SomeLoopAnnotations    ********************/
SomeLoopAnnotations::SomeLoopAnnotations(LoopAnnotStack *p1)
{
  loopannotstack_ = p1;

}

SomeLoopAnnotations::SomeLoopAnnotations(const SomeLoopAnnotations & other)
{
  loopannotstack_ = other.loopannotstack_->clone();

}

SomeLoopAnnotations &SomeLoopAnnotations::operator=(const SomeLoopAnnotations & other)
{
  SomeLoopAnnotations tmp(other);
  swap(tmp);
  return *this;
}

void SomeLoopAnnotations::swap(SomeLoopAnnotations & other)
{
  std::swap(loopannotstack_, other.loopannotstack_);

}

SomeLoopAnnotations::~SomeLoopAnnotations()
{
  delete(loopannotstack_);

}

void SomeLoopAnnotations::accept(Visitor *v)
{
  v->visitSomeLoopAnnotations(this);
}

SomeLoopAnnotations *SomeLoopAnnotations::clone() const
{
  return new SomeLoopAnnotations(*this);
}



/********************   ForClauseExpression    ********************/
ForClauseExpression::ForClauseExpression(OptExpression *p1)
{
  optexpression_ = p1;

}

ForClauseExpression::ForClauseExpression(const ForClauseExpression & other)
{
  optexpression_ = other.optexpression_->clone();

}

ForClauseExpression &ForClauseExpression::operator=(const ForClauseExpression & other)
{
  ForClauseExpression tmp(other);
  swap(tmp);
  return *this;
}

void ForClauseExpression::swap(ForClauseExpression & other)
{
  std::swap(optexpression_, other.optexpression_);

}

ForClauseExpression::~ForClauseExpression()
{
  delete(optexpression_);

}

void ForClauseExpression::accept(Visitor *v)
{
  v->visitForClauseExpression(this);
}

ForClauseExpression *ForClauseExpression::clone() const
{
  return new ForClauseExpression(*this);
}



/********************   ForClauseDeclaration    ********************/
ForClauseDeclaration::ForClauseDeclaration(Declaration *p1)
{
  declaration_ = p1;

}

ForClauseDeclaration::ForClauseDeclaration(const ForClauseDeclaration & other)
{
  declaration_ = other.declaration_->clone();

}

ForClauseDeclaration &ForClauseDeclaration::operator=(const ForClauseDeclaration & other)
{
  ForClauseDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void ForClauseDeclaration::swap(ForClauseDeclaration & other)
{
  std::swap(declaration_, other.declaration_);

}

ForClauseDeclaration::~ForClauseDeclaration()
{
  delete(declaration_);

}

void ForClauseDeclaration::accept(Visitor *v)
{
  v->visitForClauseDeclaration(this);
}

ForClauseDeclaration *ForClauseDeclaration::clone() const
{
  return new ForClauseDeclaration(*this);
}



/********************   NoGhostParameter    ********************/
NoGhostParameter::NoGhostParameter()
{

}

NoGhostParameter::NoGhostParameter(const NoGhostParameter & other)
{

}

NoGhostParameter &NoGhostParameter::operator=(const NoGhostParameter & other)
{
  NoGhostParameter tmp(other);
  swap(tmp);
  return *this;
}

void NoGhostParameter::swap(NoGhostParameter & other)
{

}

NoGhostParameter::~NoGhostParameter()
{

}

void NoGhostParameter::accept(Visitor *v)
{
  v->visitNoGhostParameter(this);
}

NoGhostParameter *NoGhostParameter::clone() const
{
  return new NoGhostParameter(*this);
}



/********************   SomeGhostParameter    ********************/
SomeGhostParameter::SomeGhostParameter(RestParList *p1, RGHOST p2)
{
  restparlist_ = p1;
  rghost_ = p2;

}

SomeGhostParameter::SomeGhostParameter(const SomeGhostParameter & other)
{
  restparlist_ = other.restparlist_->clone();
  rghost_ = other.rghost_;

}

SomeGhostParameter &SomeGhostParameter::operator=(const SomeGhostParameter & other)
{
  SomeGhostParameter tmp(other);
  swap(tmp);
  return *this;
}

void SomeGhostParameter::swap(SomeGhostParameter & other)
{
  std::swap(restparlist_, other.restparlist_);
  std::swap(rghost_, other.rghost_);

}

SomeGhostParameter::~SomeGhostParameter()
{
  delete(restparlist_);

}

void SomeGhostParameter::accept(Visitor *v)
{
  v->visitSomeGhostParameter(this);
}

SomeGhostParameter *SomeGhostParameter::clone() const
{
  return new SomeGhostParameter(*this);
}



/********************   DeclSpecInitDecl    ********************/
DeclSpecInitDecl::DeclSpecInitDecl(DeclSpecList *p1, DeclAndInitDeclAttrList *p2)
{
  declspeclist_ = p1;
  declandinitdeclattrlist_ = p2;

}

DeclSpecInitDecl::DeclSpecInitDecl(const DeclSpecInitDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  declandinitdeclattrlist_ = other.declandinitdeclattrlist_->clone();

}

DeclSpecInitDecl &DeclSpecInitDecl::operator=(const DeclSpecInitDecl & other)
{
  DeclSpecInitDecl tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecInitDecl::swap(DeclSpecInitDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declandinitdeclattrlist_, other.declandinitdeclattrlist_);

}

DeclSpecInitDecl::~DeclSpecInitDecl()
{
  delete(declspeclist_);
  delete(declandinitdeclattrlist_);

}

void DeclSpecInitDecl::accept(Visitor *v)
{
  v->visitDeclSpecInitDecl(this);
}

DeclSpecInitDecl *DeclSpecInitDecl::clone() const
{
  return new DeclSpecInitDecl(*this);
}



/********************   DeclSpec    ********************/
DeclSpec::DeclSpec(DeclSpecList *p1)
{
  declspeclist_ = p1;

}

DeclSpec::DeclSpec(const DeclSpec & other)
{
  declspeclist_ = other.declspeclist_->clone();

}

DeclSpec &DeclSpec::operator=(const DeclSpec & other)
{
  DeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpec::swap(DeclSpec & other)
{
  std::swap(declspeclist_, other.declspeclist_);

}

DeclSpec::~DeclSpec()
{
  delete(declspeclist_);

}

void DeclSpec::accept(Visitor *v)
{
  v->visitDeclSpec(this);
}

DeclSpec *DeclSpec::clone() const
{
  return new DeclSpec(*this);
}



/********************   SpecDeclSpecInitDecl    ********************/
SpecDeclSpecInitDecl::SpecDeclSpecInitDecl(IsACSLSpec *p1, ListWildcard *p2, DeclSpecList *p3, DeclAndInitDeclAttrList *p4)
{
  isacslspec_ = p1;
  listwildcard_ = p2;
  declspeclist_ = p3;
  declandinitdeclattrlist_ = p4;

}

SpecDeclSpecInitDecl::SpecDeclSpecInitDecl(const SpecDeclSpecInitDecl & other)
{
  isacslspec_ = other.isacslspec_->clone();
  listwildcard_ = other.listwildcard_->clone();
  declspeclist_ = other.declspeclist_->clone();
  declandinitdeclattrlist_ = other.declandinitdeclattrlist_->clone();

}

SpecDeclSpecInitDecl &SpecDeclSpecInitDecl::operator=(const SpecDeclSpecInitDecl & other)
{
  SpecDeclSpecInitDecl tmp(other);
  swap(tmp);
  return *this;
}

void SpecDeclSpecInitDecl::swap(SpecDeclSpecInitDecl & other)
{
  std::swap(isacslspec_, other.isacslspec_);
  std::swap(listwildcard_, other.listwildcard_);
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declandinitdeclattrlist_, other.declandinitdeclattrlist_);

}

SpecDeclSpecInitDecl::~SpecDeclSpecInitDecl()
{
  delete(isacslspec_);
  delete(listwildcard_);
  delete(declspeclist_);
  delete(declandinitdeclattrlist_);

}

void SpecDeclSpecInitDecl::accept(Visitor *v)
{
  v->visitSpecDeclSpecInitDecl(this);
}

SpecDeclSpecInitDecl *SpecDeclSpecInitDecl::clone() const
{
  return new SpecDeclSpecInitDecl(*this);
}



/********************   SpecDeclSpec    ********************/
SpecDeclSpec::SpecDeclSpec(IsACSLSpec *p1, ListWildcard *p2, DeclSpecList *p3)
{
  isacslspec_ = p1;
  listwildcard_ = p2;
  declspeclist_ = p3;

}

SpecDeclSpec::SpecDeclSpec(const SpecDeclSpec & other)
{
  isacslspec_ = other.isacslspec_->clone();
  listwildcard_ = other.listwildcard_->clone();
  declspeclist_ = other.declspeclist_->clone();

}

SpecDeclSpec &SpecDeclSpec::operator=(const SpecDeclSpec & other)
{
  SpecDeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void SpecDeclSpec::swap(SpecDeclSpec & other)
{
  std::swap(isacslspec_, other.isacslspec_);
  std::swap(listwildcard_, other.listwildcard_);
  std::swap(declspeclist_, other.declspeclist_);

}

SpecDeclSpec::~SpecDeclSpec()
{
  delete(isacslspec_);
  delete(listwildcard_);
  delete(declspeclist_);

}

void SpecDeclSpec::accept(Visitor *v)
{
  v->visitSpecDeclSpec(this);
}

SpecDeclSpec *SpecDeclSpec::clone() const
{
  return new SpecDeclSpec(*this);
}



/********************   StaticAssertDecl    ********************/
StaticAssertDecl::StaticAssertDecl(Expression *p1)
{
  expression_ = p1;

}

StaticAssertDecl::StaticAssertDecl(const StaticAssertDecl & other)
{
  expression_ = other.expression_->clone();

}

StaticAssertDecl &StaticAssertDecl::operator=(const StaticAssertDecl & other)
{
  StaticAssertDecl tmp(other);
  swap(tmp);
  return *this;
}

void StaticAssertDecl::swap(StaticAssertDecl & other)
{
  std::swap(expression_, other.expression_);

}

StaticAssertDecl::~StaticAssertDecl()
{
  delete(expression_);

}

void StaticAssertDecl::accept(Visitor *v)
{
  v->visitStaticAssertDecl(this);
}

StaticAssertDecl *StaticAssertDecl::clone() const
{
  return new StaticAssertDecl(*this);
}



/********************   StaticAssertDeclStringConst    ********************/
StaticAssertDeclStringConst::StaticAssertDeclStringConst(Expression *p1, StringConstant *p2)
{
  expression_ = p1;
  stringconstant_ = p2;

}

StaticAssertDeclStringConst::StaticAssertDeclStringConst(const StaticAssertDeclStringConst & other)
{
  expression_ = other.expression_->clone();
  stringconstant_ = other.stringconstant_->clone();

}

StaticAssertDeclStringConst &StaticAssertDeclStringConst::operator=(const StaticAssertDeclStringConst & other)
{
  StaticAssertDeclStringConst tmp(other);
  swap(tmp);
  return *this;
}

void StaticAssertDeclStringConst::swap(StaticAssertDeclStringConst & other)
{
  std::swap(expression_, other.expression_);
  std::swap(stringconstant_, other.stringconstant_);

}

StaticAssertDeclStringConst::~StaticAssertDeclStringConst()
{
  delete(expression_);
  delete(stringconstant_);

}

void StaticAssertDeclStringConst::accept(Visitor *v)
{
  v->visitStaticAssertDeclStringConst(this);
}

StaticAssertDeclStringConst *StaticAssertDeclStringConst::clone() const
{
  return new StaticAssertDeclStringConst(*this);
}



/********************   ColonGenericAssociation    ********************/
ColonGenericAssociation::ColonGenericAssociation(TypeName *p1, AssignExpr *p2)
{
  typename_ = p1;
  assignexpr_ = p2;

}

ColonGenericAssociation::ColonGenericAssociation(const ColonGenericAssociation & other)
{
  typename_ = other.typename_->clone();
  assignexpr_ = other.assignexpr_->clone();

}

ColonGenericAssociation &ColonGenericAssociation::operator=(const ColonGenericAssociation & other)
{
  ColonGenericAssociation tmp(other);
  swap(tmp);
  return *this;
}

void ColonGenericAssociation::swap(ColonGenericAssociation & other)
{
  std::swap(typename_, other.typename_);
  std::swap(assignexpr_, other.assignexpr_);

}

ColonGenericAssociation::~ColonGenericAssociation()
{
  delete(typename_);
  delete(assignexpr_);

}

void ColonGenericAssociation::accept(Visitor *v)
{
  v->visitColonGenericAssociation(this);
}

ColonGenericAssociation *ColonGenericAssociation::clone() const
{
  return new ColonGenericAssociation(*this);
}



/********************   DefaultGenericAssociation    ********************/
DefaultGenericAssociation::DefaultGenericAssociation(AssignExpr *p1)
{
  assignexpr_ = p1;

}

DefaultGenericAssociation::DefaultGenericAssociation(const DefaultGenericAssociation & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

DefaultGenericAssociation &DefaultGenericAssociation::operator=(const DefaultGenericAssociation & other)
{
  DefaultGenericAssociation tmp(other);
  swap(tmp);
  return *this;
}

void DefaultGenericAssociation::swap(DefaultGenericAssociation & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

DefaultGenericAssociation::~DefaultGenericAssociation()
{
  delete(assignexpr_);

}

void DefaultGenericAssociation::accept(Visitor *v)
{
  v->visitDefaultGenericAssociation(this);
}

DefaultGenericAssociation *DefaultGenericAssociation::clone() const
{
  return new DefaultGenericAssociation(*this);
}



/********************   InitDeclaration    ********************/
InitDeclaration::InitDeclaration(InitDeclarator *p1)
{
  initdeclarator_ = p1;

}

InitDeclaration::InitDeclaration(const InitDeclaration & other)
{
  initdeclarator_ = other.initdeclarator_->clone();

}

InitDeclaration &InitDeclaration::operator=(const InitDeclaration & other)
{
  InitDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclaration::swap(InitDeclaration & other)
{
  std::swap(initdeclarator_, other.initdeclarator_);

}

InitDeclaration::~InitDeclaration()
{
  delete(initdeclarator_);

}

void InitDeclaration::accept(Visitor *v)
{
  v->visitInitDeclaration(this);
}

InitDeclaration *InitDeclaration::clone() const
{
  return new InitDeclaration(*this);
}



/********************   InitDeclarationWithAttr    ********************/
InitDeclarationWithAttr::InitDeclarationWithAttr(InitDeclarator *p1, ListInitDeclaratorAttr *p2)
{
  initdeclarator_ = p1;
  listinitdeclaratorattr_ = p2;

}

InitDeclarationWithAttr::InitDeclarationWithAttr(const InitDeclarationWithAttr & other)
{
  initdeclarator_ = other.initdeclarator_->clone();
  listinitdeclaratorattr_ = other.listinitdeclaratorattr_->clone();

}

InitDeclarationWithAttr &InitDeclarationWithAttr::operator=(const InitDeclarationWithAttr & other)
{
  InitDeclarationWithAttr tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclarationWithAttr::swap(InitDeclarationWithAttr & other)
{
  std::swap(initdeclarator_, other.initdeclarator_);
  std::swap(listinitdeclaratorattr_, other.listinitdeclaratorattr_);

}

InitDeclarationWithAttr::~InitDeclarationWithAttr()
{
  delete(initdeclarator_);
  delete(listinitdeclaratorattr_);

}

void InitDeclarationWithAttr::accept(Visitor *v)
{
  v->visitInitDeclarationWithAttr(this);
}

InitDeclarationWithAttr *InitDeclarationWithAttr::clone() const
{
  return new InitDeclarationWithAttr(*this);
}



/********************   InitDeclaratorAttribute    ********************/
InitDeclaratorAttribute::InitDeclaratorAttribute(ListAttributeNocv *p1, InitDeclarator *p2)
{
  listattributenocv_ = p1;
  initdeclarator_ = p2;

}

InitDeclaratorAttribute::InitDeclaratorAttribute(const InitDeclaratorAttribute & other)
{
  listattributenocv_ = other.listattributenocv_->clone();
  initdeclarator_ = other.initdeclarator_->clone();

}

InitDeclaratorAttribute &InitDeclaratorAttribute::operator=(const InitDeclaratorAttribute & other)
{
  InitDeclaratorAttribute tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclaratorAttribute::swap(InitDeclaratorAttribute & other)
{
  std::swap(listattributenocv_, other.listattributenocv_);
  std::swap(initdeclarator_, other.initdeclarator_);

}

InitDeclaratorAttribute::~InitDeclaratorAttribute()
{
  delete(listattributenocv_);
  delete(initdeclarator_);

}

void InitDeclaratorAttribute::accept(Visitor *v)
{
  v->visitInitDeclaratorAttribute(this);
}

InitDeclaratorAttribute *InitDeclaratorAttribute::clone() const
{
  return new InitDeclaratorAttribute(*this);
}



/********************   SimpleInitDeclarator    ********************/
SimpleInitDeclarator::SimpleInitDeclarator(Declarator *p1)
{
  declarator_ = p1;

}

SimpleInitDeclarator::SimpleInitDeclarator(const SimpleInitDeclarator & other)
{
  declarator_ = other.declarator_->clone();

}

SimpleInitDeclarator &SimpleInitDeclarator::operator=(const SimpleInitDeclarator & other)
{
  SimpleInitDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void SimpleInitDeclarator::swap(SimpleInitDeclarator & other)
{
  std::swap(declarator_, other.declarator_);

}

SimpleInitDeclarator::~SimpleInitDeclarator()
{
  delete(declarator_);

}

void SimpleInitDeclarator::accept(Visitor *v)
{
  v->visitSimpleInitDeclarator(this);
}

SimpleInitDeclarator *SimpleInitDeclarator::clone() const
{
  return new SimpleInitDeclarator(*this);
}



/********************   InitDeclaratorExpression    ********************/
InitDeclaratorExpression::InitDeclaratorExpression(Declarator *p1, InitExpression *p2)
{
  declarator_ = p1;
  initexpression_ = p2;

}

InitDeclaratorExpression::InitDeclaratorExpression(const InitDeclaratorExpression & other)
{
  declarator_ = other.declarator_->clone();
  initexpression_ = other.initexpression_->clone();

}

InitDeclaratorExpression &InitDeclaratorExpression::operator=(const InitDeclaratorExpression & other)
{
  InitDeclaratorExpression tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclaratorExpression::swap(InitDeclaratorExpression & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(initexpression_, other.initexpression_);

}

InitDeclaratorExpression::~InitDeclaratorExpression()
{
  delete(declarator_);
  delete(initexpression_);

}

void InitDeclaratorExpression::accept(Visitor *v)
{
  v->visitInitDeclaratorExpression(this);
}

InitDeclaratorExpression *InitDeclaratorExpression::clone() const
{
  return new InitDeclaratorExpression(*this);
}



/********************   DeclSpecWOTypeTypedefKeyWord    ********************/
DeclSpecWOTypeTypedefKeyWord::DeclSpecWOTypeTypedefKeyWord()
{

}

DeclSpecWOTypeTypedefKeyWord::DeclSpecWOTypeTypedefKeyWord(const DeclSpecWOTypeTypedefKeyWord & other)
{

}

DeclSpecWOTypeTypedefKeyWord &DeclSpecWOTypeTypedefKeyWord::operator=(const DeclSpecWOTypeTypedefKeyWord & other)
{
  DeclSpecWOTypeTypedefKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeTypedefKeyWord::swap(DeclSpecWOTypeTypedefKeyWord & other)
{

}

DeclSpecWOTypeTypedefKeyWord::~DeclSpecWOTypeTypedefKeyWord()
{

}

void DeclSpecWOTypeTypedefKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeTypedefKeyWord(this);
}

DeclSpecWOTypeTypedefKeyWord *DeclSpecWOTypeTypedefKeyWord::clone() const
{
  return new DeclSpecWOTypeTypedefKeyWord(*this);
}



/********************   DeclSpecWOTypeExternKeyWord    ********************/
DeclSpecWOTypeExternKeyWord::DeclSpecWOTypeExternKeyWord()
{

}

DeclSpecWOTypeExternKeyWord::DeclSpecWOTypeExternKeyWord(const DeclSpecWOTypeExternKeyWord & other)
{

}

DeclSpecWOTypeExternKeyWord &DeclSpecWOTypeExternKeyWord::operator=(const DeclSpecWOTypeExternKeyWord & other)
{
  DeclSpecWOTypeExternKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeExternKeyWord::swap(DeclSpecWOTypeExternKeyWord & other)
{

}

DeclSpecWOTypeExternKeyWord::~DeclSpecWOTypeExternKeyWord()
{

}

void DeclSpecWOTypeExternKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeExternKeyWord(this);
}

DeclSpecWOTypeExternKeyWord *DeclSpecWOTypeExternKeyWord::clone() const
{
  return new DeclSpecWOTypeExternKeyWord(*this);
}



/********************   DeclSpecWOTypeStaticKeyWord    ********************/
DeclSpecWOTypeStaticKeyWord::DeclSpecWOTypeStaticKeyWord()
{

}

DeclSpecWOTypeStaticKeyWord::DeclSpecWOTypeStaticKeyWord(const DeclSpecWOTypeStaticKeyWord & other)
{

}

DeclSpecWOTypeStaticKeyWord &DeclSpecWOTypeStaticKeyWord::operator=(const DeclSpecWOTypeStaticKeyWord & other)
{
  DeclSpecWOTypeStaticKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeStaticKeyWord::swap(DeclSpecWOTypeStaticKeyWord & other)
{

}

DeclSpecWOTypeStaticKeyWord::~DeclSpecWOTypeStaticKeyWord()
{

}

void DeclSpecWOTypeStaticKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeStaticKeyWord(this);
}

DeclSpecWOTypeStaticKeyWord *DeclSpecWOTypeStaticKeyWord::clone() const
{
  return new DeclSpecWOTypeStaticKeyWord(*this);
}



/********************   DeclSpecWOTypeAutoKeyWord    ********************/
DeclSpecWOTypeAutoKeyWord::DeclSpecWOTypeAutoKeyWord()
{

}

DeclSpecWOTypeAutoKeyWord::DeclSpecWOTypeAutoKeyWord(const DeclSpecWOTypeAutoKeyWord & other)
{

}

DeclSpecWOTypeAutoKeyWord &DeclSpecWOTypeAutoKeyWord::operator=(const DeclSpecWOTypeAutoKeyWord & other)
{
  DeclSpecWOTypeAutoKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeAutoKeyWord::swap(DeclSpecWOTypeAutoKeyWord & other)
{

}

DeclSpecWOTypeAutoKeyWord::~DeclSpecWOTypeAutoKeyWord()
{

}

void DeclSpecWOTypeAutoKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeAutoKeyWord(this);
}

DeclSpecWOTypeAutoKeyWord *DeclSpecWOTypeAutoKeyWord::clone() const
{
  return new DeclSpecWOTypeAutoKeyWord(*this);
}



/********************   DeclSpecWOTypeRegisterKeyWord    ********************/
DeclSpecWOTypeRegisterKeyWord::DeclSpecWOTypeRegisterKeyWord()
{

}

DeclSpecWOTypeRegisterKeyWord::DeclSpecWOTypeRegisterKeyWord(const DeclSpecWOTypeRegisterKeyWord & other)
{

}

DeclSpecWOTypeRegisterKeyWord &DeclSpecWOTypeRegisterKeyWord::operator=(const DeclSpecWOTypeRegisterKeyWord & other)
{
  DeclSpecWOTypeRegisterKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeRegisterKeyWord::swap(DeclSpecWOTypeRegisterKeyWord & other)
{

}

DeclSpecWOTypeRegisterKeyWord::~DeclSpecWOTypeRegisterKeyWord()
{

}

void DeclSpecWOTypeRegisterKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeRegisterKeyWord(this);
}

DeclSpecWOTypeRegisterKeyWord *DeclSpecWOTypeRegisterKeyWord::clone() const
{
  return new DeclSpecWOTypeRegisterKeyWord(*this);
}



/********************   DeclSpecWOTypeInlineKeyWord    ********************/
DeclSpecWOTypeInlineKeyWord::DeclSpecWOTypeInlineKeyWord(INLINE p1)
{
  inline_ = p1;

}

DeclSpecWOTypeInlineKeyWord::DeclSpecWOTypeInlineKeyWord(const DeclSpecWOTypeInlineKeyWord & other)
{
  inline_ = other.inline_;

}

DeclSpecWOTypeInlineKeyWord &DeclSpecWOTypeInlineKeyWord::operator=(const DeclSpecWOTypeInlineKeyWord & other)
{
  DeclSpecWOTypeInlineKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeInlineKeyWord::swap(DeclSpecWOTypeInlineKeyWord & other)
{
  std::swap(inline_, other.inline_);

}

DeclSpecWOTypeInlineKeyWord::~DeclSpecWOTypeInlineKeyWord()
{

}

void DeclSpecWOTypeInlineKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeInlineKeyWord(this);
}

DeclSpecWOTypeInlineKeyWord *DeclSpecWOTypeInlineKeyWord::clone() const
{
  return new DeclSpecWOTypeInlineKeyWord(*this);
}



/********************   DeclSpecWOTypeNoReturnKeyWord    ********************/
DeclSpecWOTypeNoReturnKeyWord::DeclSpecWOTypeNoReturnKeyWord()
{

}

DeclSpecWOTypeNoReturnKeyWord::DeclSpecWOTypeNoReturnKeyWord(const DeclSpecWOTypeNoReturnKeyWord & other)
{

}

DeclSpecWOTypeNoReturnKeyWord &DeclSpecWOTypeNoReturnKeyWord::operator=(const DeclSpecWOTypeNoReturnKeyWord & other)
{
  DeclSpecWOTypeNoReturnKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeNoReturnKeyWord::swap(DeclSpecWOTypeNoReturnKeyWord & other)
{

}

DeclSpecWOTypeNoReturnKeyWord::~DeclSpecWOTypeNoReturnKeyWord()
{

}

void DeclSpecWOTypeNoReturnKeyWord::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeNoReturnKeyWord(this);
}

DeclSpecWOTypeNoReturnKeyWord *DeclSpecWOTypeNoReturnKeyWord::clone() const
{
  return new DeclSpecWOTypeNoReturnKeyWord(*this);
}



/********************   DeclSpecWOTypeDeclSpecCVSpec    ********************/
DeclSpecWOTypeDeclSpecCVSpec::DeclSpecWOTypeDeclSpecCVSpec(CVSpec *p1)
{
  cvspec_ = p1;

}

DeclSpecWOTypeDeclSpecCVSpec::DeclSpecWOTypeDeclSpecCVSpec(const DeclSpecWOTypeDeclSpecCVSpec & other)
{
  cvspec_ = other.cvspec_->clone();

}

DeclSpecWOTypeDeclSpecCVSpec &DeclSpecWOTypeDeclSpecCVSpec::operator=(const DeclSpecWOTypeDeclSpecCVSpec & other)
{
  DeclSpecWOTypeDeclSpecCVSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeDeclSpecCVSpec::swap(DeclSpecWOTypeDeclSpecCVSpec & other)
{
  std::swap(cvspec_, other.cvspec_);

}

DeclSpecWOTypeDeclSpecCVSpec::~DeclSpecWOTypeDeclSpecCVSpec()
{
  delete(cvspec_);

}

void DeclSpecWOTypeDeclSpecCVSpec::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeDeclSpecCVSpec(this);
}

DeclSpecWOTypeDeclSpecCVSpec *DeclSpecWOTypeDeclSpecCVSpec::clone() const
{
  return new DeclSpecWOTypeDeclSpecCVSpec(*this);
}



/********************   DeclSpecWOTypeDeclSpecAtribNOCV    ********************/
DeclSpecWOTypeDeclSpecAtribNOCV::DeclSpecWOTypeDeclSpecAtribNOCV(AttributeNocv *p1)
{
  attributenocv_ = p1;

}

DeclSpecWOTypeDeclSpecAtribNOCV::DeclSpecWOTypeDeclSpecAtribNOCV(const DeclSpecWOTypeDeclSpecAtribNOCV & other)
{
  attributenocv_ = other.attributenocv_->clone();

}

DeclSpecWOTypeDeclSpecAtribNOCV &DeclSpecWOTypeDeclSpecAtribNOCV::operator=(const DeclSpecWOTypeDeclSpecAtribNOCV & other)
{
  DeclSpecWOTypeDeclSpecAtribNOCV tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWOTypeDeclSpecAtribNOCV::swap(DeclSpecWOTypeDeclSpecAtribNOCV & other)
{
  std::swap(attributenocv_, other.attributenocv_);

}

DeclSpecWOTypeDeclSpecAtribNOCV::~DeclSpecWOTypeDeclSpecAtribNOCV()
{
  delete(attributenocv_);

}

void DeclSpecWOTypeDeclSpecAtribNOCV::accept(Visitor *v)
{
  v->visitDeclSpecWOTypeDeclSpecAtribNOCV(this);
}

DeclSpecWOTypeDeclSpecAtribNOCV *DeclSpecWOTypeDeclSpecAtribNOCV::clone() const
{
  return new DeclSpecWOTypeDeclSpecAtribNOCV(*this);
}



/********************   DeclSpecWoType    ********************/
DeclSpecWoType::DeclSpecWoType(DeclSpecWOType *p1)
{
  declspecwotype_ = p1;

}

DeclSpecWoType::DeclSpecWoType(const DeclSpecWoType & other)
{
  declspecwotype_ = other.declspecwotype_->clone();

}

DeclSpecWoType &DeclSpecWoType::operator=(const DeclSpecWoType & other)
{
  DeclSpecWoType tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWoType::swap(DeclSpecWoType & other)
{
  std::swap(declspecwotype_, other.declspecwotype_);

}

DeclSpecWoType::~DeclSpecWoType()
{
  delete(declspecwotype_);

}

void DeclSpecWoType::accept(Visitor *v)
{
  v->visitDeclSpecWoType(this);
}

DeclSpecWoType *DeclSpecWoType::clone() const
{
  return new DeclSpecWoType(*this);
}



/********************   DeclSpecWoTypeNext    ********************/
DeclSpecWoTypeNext::DeclSpecWoTypeNext(DeclSpecWOType *p1, DeclSpecList *p2)
{
  declspecwotype_ = p1;
  declspeclist_ = p2;

}

DeclSpecWoTypeNext::DeclSpecWoTypeNext(const DeclSpecWoTypeNext & other)
{
  declspecwotype_ = other.declspecwotype_->clone();
  declspeclist_ = other.declspeclist_->clone();

}

DeclSpecWoTypeNext &DeclSpecWoTypeNext::operator=(const DeclSpecWoTypeNext & other)
{
  DeclSpecWoTypeNext tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecWoTypeNext::swap(DeclSpecWoTypeNext & other)
{
  std::swap(declspecwotype_, other.declspecwotype_);
  std::swap(declspeclist_, other.declspeclist_);

}

DeclSpecWoTypeNext::~DeclSpecWoTypeNext()
{
  delete(declspecwotype_);
  delete(declspeclist_);

}

void DeclSpecWoTypeNext::accept(Visitor *v)
{
  v->visitDeclSpecWoTypeNext(this);
}

DeclSpecWoTypeNext *DeclSpecWoTypeNext::clone() const
{
  return new DeclSpecWoTypeNext(*this);
}



/********************   DeclSpecTypeSpec    ********************/
DeclSpecTypeSpec::DeclSpecTypeSpec(TypeSpec *p1)
{
  typespec_ = p1;

}

DeclSpecTypeSpec::DeclSpecTypeSpec(const DeclSpecTypeSpec & other)
{
  typespec_ = other.typespec_->clone();

}

DeclSpecTypeSpec &DeclSpecTypeSpec::operator=(const DeclSpecTypeSpec & other)
{
  DeclSpecTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecTypeSpec::swap(DeclSpecTypeSpec & other)
{
  std::swap(typespec_, other.typespec_);

}

DeclSpecTypeSpec::~DeclSpecTypeSpec()
{
  delete(typespec_);

}

void DeclSpecTypeSpec::accept(Visitor *v)
{
  v->visitDeclSpecTypeSpec(this);
}

DeclSpecTypeSpec *DeclSpecTypeSpec::clone() const
{
  return new DeclSpecTypeSpec(*this);
}



/********************   DeclSpecTypeSpecNext    ********************/
DeclSpecTypeSpecNext::DeclSpecTypeSpecNext(TypeSpec *p1, DeclSpecListNoNamed *p2)
{
  typespec_ = p1;
  declspeclistnonamed_ = p2;

}

DeclSpecTypeSpecNext::DeclSpecTypeSpecNext(const DeclSpecTypeSpecNext & other)
{
  typespec_ = other.typespec_->clone();
  declspeclistnonamed_ = other.declspeclistnonamed_->clone();

}

DeclSpecTypeSpecNext &DeclSpecTypeSpecNext::operator=(const DeclSpecTypeSpecNext & other)
{
  DeclSpecTypeSpecNext tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecTypeSpecNext::swap(DeclSpecTypeSpecNext & other)
{
  std::swap(typespec_, other.typespec_);
  std::swap(declspeclistnonamed_, other.declspeclistnonamed_);

}

DeclSpecTypeSpecNext::~DeclSpecTypeSpecNext()
{
  delete(typespec_);
  delete(declspeclistnonamed_);

}

void DeclSpecTypeSpecNext::accept(Visitor *v)
{
  v->visitDeclSpecTypeSpecNext(this);
}

DeclSpecTypeSpecNext *DeclSpecTypeSpecNext::clone() const
{
  return new DeclSpecTypeSpecNext(*this);
}



/********************   DeclSpecNoNamedWOType    ********************/
DeclSpecNoNamedWOType::DeclSpecNoNamedWOType(DeclSpecWOType *p1)
{
  declspecwotype_ = p1;

}

DeclSpecNoNamedWOType::DeclSpecNoNamedWOType(const DeclSpecNoNamedWOType & other)
{
  declspecwotype_ = other.declspecwotype_->clone();

}

DeclSpecNoNamedWOType &DeclSpecNoNamedWOType::operator=(const DeclSpecNoNamedWOType & other)
{
  DeclSpecNoNamedWOType tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecNoNamedWOType::swap(DeclSpecNoNamedWOType & other)
{
  std::swap(declspecwotype_, other.declspecwotype_);

}

DeclSpecNoNamedWOType::~DeclSpecNoNamedWOType()
{
  delete(declspecwotype_);

}

void DeclSpecNoNamedWOType::accept(Visitor *v)
{
  v->visitDeclSpecNoNamedWOType(this);
}

DeclSpecNoNamedWOType *DeclSpecNoNamedWOType::clone() const
{
  return new DeclSpecNoNamedWOType(*this);
}



/********************   DeclSpecNoNamedWOTypeNext    ********************/
DeclSpecNoNamedWOTypeNext::DeclSpecNoNamedWOTypeNext(DeclSpecWOType *p1, DeclSpecListNoNamed *p2)
{
  declspecwotype_ = p1;
  declspeclistnonamed_ = p2;

}

DeclSpecNoNamedWOTypeNext::DeclSpecNoNamedWOTypeNext(const DeclSpecNoNamedWOTypeNext & other)
{
  declspecwotype_ = other.declspecwotype_->clone();
  declspeclistnonamed_ = other.declspeclistnonamed_->clone();

}

DeclSpecNoNamedWOTypeNext &DeclSpecNoNamedWOTypeNext::operator=(const DeclSpecNoNamedWOTypeNext & other)
{
  DeclSpecNoNamedWOTypeNext tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecNoNamedWOTypeNext::swap(DeclSpecNoNamedWOTypeNext & other)
{
  std::swap(declspecwotype_, other.declspecwotype_);
  std::swap(declspeclistnonamed_, other.declspeclistnonamed_);

}

DeclSpecNoNamedWOTypeNext::~DeclSpecNoNamedWOTypeNext()
{
  delete(declspecwotype_);
  delete(declspeclistnonamed_);

}

void DeclSpecNoNamedWOTypeNext::accept(Visitor *v)
{
  v->visitDeclSpecNoNamedWOTypeNext(this);
}

DeclSpecNoNamedWOTypeNext *DeclSpecNoNamedWOTypeNext::clone() const
{
  return new DeclSpecNoNamedWOTypeNext(*this);
}



/********************   DeclSpecNoNamedTypeSpec    ********************/
DeclSpecNoNamedTypeSpec::DeclSpecNoNamedTypeSpec(TypeSpec *p1)
{
  typespec_ = p1;

}

DeclSpecNoNamedTypeSpec::DeclSpecNoNamedTypeSpec(const DeclSpecNoNamedTypeSpec & other)
{
  typespec_ = other.typespec_->clone();

}

DeclSpecNoNamedTypeSpec &DeclSpecNoNamedTypeSpec::operator=(const DeclSpecNoNamedTypeSpec & other)
{
  DeclSpecNoNamedTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecNoNamedTypeSpec::swap(DeclSpecNoNamedTypeSpec & other)
{
  std::swap(typespec_, other.typespec_);

}

DeclSpecNoNamedTypeSpec::~DeclSpecNoNamedTypeSpec()
{
  delete(typespec_);

}

void DeclSpecNoNamedTypeSpec::accept(Visitor *v)
{
  v->visitDeclSpecNoNamedTypeSpec(this);
}

DeclSpecNoNamedTypeSpec *DeclSpecNoNamedTypeSpec::clone() const
{
  return new DeclSpecNoNamedTypeSpec(*this);
}



/********************   DeclSpecNoNamedTypeSpecNext    ********************/
DeclSpecNoNamedTypeSpecNext::DeclSpecNoNamedTypeSpecNext(TypeSpec *p1, DeclSpecListNoNamed *p2)
{
  typespec_ = p1;
  declspeclistnonamed_ = p2;

}

DeclSpecNoNamedTypeSpecNext::DeclSpecNoNamedTypeSpecNext(const DeclSpecNoNamedTypeSpecNext & other)
{
  typespec_ = other.typespec_->clone();
  declspeclistnonamed_ = other.declspeclistnonamed_->clone();

}

DeclSpecNoNamedTypeSpecNext &DeclSpecNoNamedTypeSpecNext::operator=(const DeclSpecNoNamedTypeSpecNext & other)
{
  DeclSpecNoNamedTypeSpecNext tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecNoNamedTypeSpecNext::swap(DeclSpecNoNamedTypeSpecNext & other)
{
  std::swap(typespec_, other.typespec_);
  std::swap(declspeclistnonamed_, other.declspeclistnonamed_);

}

DeclSpecNoNamedTypeSpecNext::~DeclSpecNoNamedTypeSpecNext()
{
  delete(typespec_);
  delete(declspeclistnonamed_);

}

void DeclSpecNoNamedTypeSpecNext::accept(Visitor *v)
{
  v->visitDeclSpecNoNamedTypeSpecNext(this);
}

DeclSpecNoNamedTypeSpecNext *DeclSpecNoNamedTypeSpecNext::clone() const
{
  return new DeclSpecNoNamedTypeSpecNext(*this);
}



/********************   TypeSpecVoidKeyWord    ********************/
TypeSpecVoidKeyWord::TypeSpecVoidKeyWord()
{

}

TypeSpecVoidKeyWord::TypeSpecVoidKeyWord(const TypeSpecVoidKeyWord & other)
{

}

TypeSpecVoidKeyWord &TypeSpecVoidKeyWord::operator=(const TypeSpecVoidKeyWord & other)
{
  TypeSpecVoidKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecVoidKeyWord::swap(TypeSpecVoidKeyWord & other)
{

}

TypeSpecVoidKeyWord::~TypeSpecVoidKeyWord()
{

}

void TypeSpecVoidKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecVoidKeyWord(this);
}

TypeSpecVoidKeyWord *TypeSpecVoidKeyWord::clone() const
{
  return new TypeSpecVoidKeyWord(*this);
}



/********************   TypeSpecCharKeyWord    ********************/
TypeSpecCharKeyWord::TypeSpecCharKeyWord()
{

}

TypeSpecCharKeyWord::TypeSpecCharKeyWord(const TypeSpecCharKeyWord & other)
{

}

TypeSpecCharKeyWord &TypeSpecCharKeyWord::operator=(const TypeSpecCharKeyWord & other)
{
  TypeSpecCharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecCharKeyWord::swap(TypeSpecCharKeyWord & other)
{

}

TypeSpecCharKeyWord::~TypeSpecCharKeyWord()
{

}

void TypeSpecCharKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecCharKeyWord(this);
}

TypeSpecCharKeyWord *TypeSpecCharKeyWord::clone() const
{
  return new TypeSpecCharKeyWord(*this);
}



/********************   TypeSpecBoolKeyWord    ********************/
TypeSpecBoolKeyWord::TypeSpecBoolKeyWord()
{

}

TypeSpecBoolKeyWord::TypeSpecBoolKeyWord(const TypeSpecBoolKeyWord & other)
{

}

TypeSpecBoolKeyWord &TypeSpecBoolKeyWord::operator=(const TypeSpecBoolKeyWord & other)
{
  TypeSpecBoolKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecBoolKeyWord::swap(TypeSpecBoolKeyWord & other)
{

}

TypeSpecBoolKeyWord::~TypeSpecBoolKeyWord()
{

}

void TypeSpecBoolKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecBoolKeyWord(this);
}

TypeSpecBoolKeyWord *TypeSpecBoolKeyWord::clone() const
{
  return new TypeSpecBoolKeyWord(*this);
}



/********************   TypeSpecShortKeyWord    ********************/
TypeSpecShortKeyWord::TypeSpecShortKeyWord()
{

}

TypeSpecShortKeyWord::TypeSpecShortKeyWord(const TypeSpecShortKeyWord & other)
{

}

TypeSpecShortKeyWord &TypeSpecShortKeyWord::operator=(const TypeSpecShortKeyWord & other)
{
  TypeSpecShortKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecShortKeyWord::swap(TypeSpecShortKeyWord & other)
{

}

TypeSpecShortKeyWord::~TypeSpecShortKeyWord()
{

}

void TypeSpecShortKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecShortKeyWord(this);
}

TypeSpecShortKeyWord *TypeSpecShortKeyWord::clone() const
{
  return new TypeSpecShortKeyWord(*this);
}



/********************   TypeSpecIntKeyWord    ********************/
TypeSpecIntKeyWord::TypeSpecIntKeyWord()
{

}

TypeSpecIntKeyWord::TypeSpecIntKeyWord(const TypeSpecIntKeyWord & other)
{

}

TypeSpecIntKeyWord &TypeSpecIntKeyWord::operator=(const TypeSpecIntKeyWord & other)
{
  TypeSpecIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecIntKeyWord::swap(TypeSpecIntKeyWord & other)
{

}

TypeSpecIntKeyWord::~TypeSpecIntKeyWord()
{

}

void TypeSpecIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecIntKeyWord(this);
}

TypeSpecIntKeyWord *TypeSpecIntKeyWord::clone() const
{
  return new TypeSpecIntKeyWord(*this);
}



/********************   TypeSpecInt32KeyWord    ********************/
TypeSpecInt32KeyWord::TypeSpecInt32KeyWord()
{

}

TypeSpecInt32KeyWord::TypeSpecInt32KeyWord(const TypeSpecInt32KeyWord & other)
{

}

TypeSpecInt32KeyWord &TypeSpecInt32KeyWord::operator=(const TypeSpecInt32KeyWord & other)
{
  TypeSpecInt32KeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecInt32KeyWord::swap(TypeSpecInt32KeyWord & other)
{

}

TypeSpecInt32KeyWord::~TypeSpecInt32KeyWord()
{

}

void TypeSpecInt32KeyWord::accept(Visitor *v)
{
  v->visitTypeSpecInt32KeyWord(this);
}

TypeSpecInt32KeyWord *TypeSpecInt32KeyWord::clone() const
{
  return new TypeSpecInt32KeyWord(*this);
}



/********************   TypeSpecLongKeyWord    ********************/
TypeSpecLongKeyWord::TypeSpecLongKeyWord()
{

}

TypeSpecLongKeyWord::TypeSpecLongKeyWord(const TypeSpecLongKeyWord & other)
{

}

TypeSpecLongKeyWord &TypeSpecLongKeyWord::operator=(const TypeSpecLongKeyWord & other)
{
  TypeSpecLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecLongKeyWord::swap(TypeSpecLongKeyWord & other)
{

}

TypeSpecLongKeyWord::~TypeSpecLongKeyWord()
{

}

void TypeSpecLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecLongKeyWord(this);
}

TypeSpecLongKeyWord *TypeSpecLongKeyWord::clone() const
{
  return new TypeSpecLongKeyWord(*this);
}



/********************   TypeSpecInt64KeyWord    ********************/
TypeSpecInt64KeyWord::TypeSpecInt64KeyWord()
{

}

TypeSpecInt64KeyWord::TypeSpecInt64KeyWord(const TypeSpecInt64KeyWord & other)
{

}

TypeSpecInt64KeyWord &TypeSpecInt64KeyWord::operator=(const TypeSpecInt64KeyWord & other)
{
  TypeSpecInt64KeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecInt64KeyWord::swap(TypeSpecInt64KeyWord & other)
{

}

TypeSpecInt64KeyWord::~TypeSpecInt64KeyWord()
{

}

void TypeSpecInt64KeyWord::accept(Visitor *v)
{
  v->visitTypeSpecInt64KeyWord(this);
}

TypeSpecInt64KeyWord *TypeSpecInt64KeyWord::clone() const
{
  return new TypeSpecInt64KeyWord(*this);
}



/********************   TypeSpecFloatKeyWord    ********************/
TypeSpecFloatKeyWord::TypeSpecFloatKeyWord()
{

}

TypeSpecFloatKeyWord::TypeSpecFloatKeyWord(const TypeSpecFloatKeyWord & other)
{

}

TypeSpecFloatKeyWord &TypeSpecFloatKeyWord::operator=(const TypeSpecFloatKeyWord & other)
{
  TypeSpecFloatKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecFloatKeyWord::swap(TypeSpecFloatKeyWord & other)
{

}

TypeSpecFloatKeyWord::~TypeSpecFloatKeyWord()
{

}

void TypeSpecFloatKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecFloatKeyWord(this);
}

TypeSpecFloatKeyWord *TypeSpecFloatKeyWord::clone() const
{
  return new TypeSpecFloatKeyWord(*this);
}



/********************   TypeSpecDoubleKeyWord    ********************/
TypeSpecDoubleKeyWord::TypeSpecDoubleKeyWord()
{

}

TypeSpecDoubleKeyWord::TypeSpecDoubleKeyWord(const TypeSpecDoubleKeyWord & other)
{

}

TypeSpecDoubleKeyWord &TypeSpecDoubleKeyWord::operator=(const TypeSpecDoubleKeyWord & other)
{
  TypeSpecDoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecDoubleKeyWord::swap(TypeSpecDoubleKeyWord & other)
{

}

TypeSpecDoubleKeyWord::~TypeSpecDoubleKeyWord()
{

}

void TypeSpecDoubleKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecDoubleKeyWord(this);
}

TypeSpecDoubleKeyWord *TypeSpecDoubleKeyWord::clone() const
{
  return new TypeSpecDoubleKeyWord(*this);
}



/********************   TypeSpecSignedKeyWord    ********************/
TypeSpecSignedKeyWord::TypeSpecSignedKeyWord(SIGNED p1)
{
  signed_ = p1;

}

TypeSpecSignedKeyWord::TypeSpecSignedKeyWord(const TypeSpecSignedKeyWord & other)
{
  signed_ = other.signed_;

}

TypeSpecSignedKeyWord &TypeSpecSignedKeyWord::operator=(const TypeSpecSignedKeyWord & other)
{
  TypeSpecSignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSignedKeyWord::swap(TypeSpecSignedKeyWord & other)
{
  std::swap(signed_, other.signed_);

}

TypeSpecSignedKeyWord::~TypeSpecSignedKeyWord()
{

}

void TypeSpecSignedKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSignedKeyWord(this);
}

TypeSpecSignedKeyWord *TypeSpecSignedKeyWord::clone() const
{
  return new TypeSpecSignedKeyWord(*this);
}



/********************   TypeSpecUnsignedKeyWord    ********************/
TypeSpecUnsignedKeyWord::TypeSpecUnsignedKeyWord()
{

}

TypeSpecUnsignedKeyWord::TypeSpecUnsignedKeyWord(const TypeSpecUnsignedKeyWord & other)
{

}

TypeSpecUnsignedKeyWord &TypeSpecUnsignedKeyWord::operator=(const TypeSpecUnsignedKeyWord & other)
{
  TypeSpecUnsignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecUnsignedKeyWord::swap(TypeSpecUnsignedKeyWord & other)
{

}

TypeSpecUnsignedKeyWord::~TypeSpecUnsignedKeyWord()
{

}

void TypeSpecUnsignedKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecUnsignedKeyWord(this);
}

TypeSpecUnsignedKeyWord *TypeSpecUnsignedKeyWord::clone() const
{
  return new TypeSpecUnsignedKeyWord(*this);
}



/********************   StructId    ********************/
StructId::StructId(IdOrTypename *p1)
{
  idortypename_ = p1;

}

StructId::StructId(const StructId & other)
{
  idortypename_ = other.idortypename_->clone();

}

StructId &StructId::operator=(const StructId & other)
{
  StructId tmp(other);
  swap(tmp);
  return *this;
}

void StructId::swap(StructId & other)
{
  std::swap(idortypename_, other.idortypename_);

}

StructId::~StructId()
{
  delete(idortypename_);

}

void StructId::accept(Visitor *v)
{
  v->visitStructId(this);
}

StructId *StructId::clone() const
{
  return new StructId(*this);
}



/********************   StructJustAttr    ********************/
StructJustAttr::StructJustAttr(ListJustAttribute *p1, IdOrTypename *p2)
{
  listjustattribute_ = p1;
  idortypename_ = p2;

}

StructJustAttr::StructJustAttr(const StructJustAttr & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  idortypename_ = other.idortypename_->clone();

}

StructJustAttr &StructJustAttr::operator=(const StructJustAttr & other)
{
  StructJustAttr tmp(other);
  swap(tmp);
  return *this;
}

void StructJustAttr::swap(StructJustAttr & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(idortypename_, other.idortypename_);

}

StructJustAttr::~StructJustAttr()
{
  delete(listjustattribute_);
  delete(idortypename_);

}

void StructJustAttr::accept(Visitor *v)
{
  v->visitStructJustAttr(this);
}

StructJustAttr *StructJustAttr::clone() const
{
  return new StructJustAttr(*this);
}



/********************   StructIdBraces    ********************/
StructIdBraces::StructIdBraces(IdOrTypename *p1, LBRACE p2, StructDeclList *p3, RBRACE p4)
{
  idortypename_ = p1;
  lbrace_ = p2;
  structdecllist_ = p3;
  rbrace_ = p4;

}

StructIdBraces::StructIdBraces(const StructIdBraces & other)
{
  idortypename_ = other.idortypename_->clone();
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

StructIdBraces &StructIdBraces::operator=(const StructIdBraces & other)
{
  StructIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void StructIdBraces::swap(StructIdBraces & other)
{
  std::swap(idortypename_, other.idortypename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

StructIdBraces::~StructIdBraces()
{
  delete(idortypename_);
  delete(structdecllist_);

}

void StructIdBraces::accept(Visitor *v)
{
  v->visitStructIdBraces(this);
}

StructIdBraces *StructIdBraces::clone() const
{
  return new StructIdBraces(*this);
}



/********************   StructBraces    ********************/
StructBraces::StructBraces(LBRACE p1, StructDeclList *p2, RBRACE p3)
{
  lbrace_ = p1;
  structdecllist_ = p2;
  rbrace_ = p3;

}

StructBraces::StructBraces(const StructBraces & other)
{
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

StructBraces &StructBraces::operator=(const StructBraces & other)
{
  StructBraces tmp(other);
  swap(tmp);
  return *this;
}

void StructBraces::swap(StructBraces & other)
{
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

StructBraces::~StructBraces()
{
  delete(structdecllist_);

}

void StructBraces::accept(Visitor *v)
{
  v->visitStructBraces(this);
}

StructBraces *StructBraces::clone() const
{
  return new StructBraces(*this);
}



/********************   StructJustAttrIdBraces    ********************/
StructJustAttrIdBraces::StructJustAttrIdBraces(ListJustAttribute *p1, IdOrTypename *p2, LBRACE p3, StructDeclList *p4, RBRACE p5)
{
  listjustattribute_ = p1;
  idortypename_ = p2;
  lbrace_ = p3;
  structdecllist_ = p4;
  rbrace_ = p5;

}

StructJustAttrIdBraces::StructJustAttrIdBraces(const StructJustAttrIdBraces & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  idortypename_ = other.idortypename_->clone();
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

StructJustAttrIdBraces &StructJustAttrIdBraces::operator=(const StructJustAttrIdBraces & other)
{
  StructJustAttrIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void StructJustAttrIdBraces::swap(StructJustAttrIdBraces & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(idortypename_, other.idortypename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

StructJustAttrIdBraces::~StructJustAttrIdBraces()
{
  delete(listjustattribute_);
  delete(idortypename_);
  delete(structdecllist_);

}

void StructJustAttrIdBraces::accept(Visitor *v)
{
  v->visitStructJustAttrIdBraces(this);
}

StructJustAttrIdBraces *StructJustAttrIdBraces::clone() const
{
  return new StructJustAttrIdBraces(*this);
}



/********************   StructJustAttrBraces    ********************/
StructJustAttrBraces::StructJustAttrBraces(ListJustAttribute *p1, LBRACE p2, StructDeclList *p3, RBRACE p4)
{
  listjustattribute_ = p1;
  lbrace_ = p2;
  structdecllist_ = p3;
  rbrace_ = p4;

}

StructJustAttrBraces::StructJustAttrBraces(const StructJustAttrBraces & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

StructJustAttrBraces &StructJustAttrBraces::operator=(const StructJustAttrBraces & other)
{
  StructJustAttrBraces tmp(other);
  swap(tmp);
  return *this;
}

void StructJustAttrBraces::swap(StructJustAttrBraces & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

StructJustAttrBraces::~StructJustAttrBraces()
{
  delete(listjustattribute_);
  delete(structdecllist_);

}

void StructJustAttrBraces::accept(Visitor *v)
{
  v->visitStructJustAttrBraces(this);
}

StructJustAttrBraces *StructJustAttrBraces::clone() const
{
  return new StructJustAttrBraces(*this);
}



/********************   UnionId    ********************/
UnionId::UnionId(IdOrTypename *p1)
{
  idortypename_ = p1;

}

UnionId::UnionId(const UnionId & other)
{
  idortypename_ = other.idortypename_->clone();

}

UnionId &UnionId::operator=(const UnionId & other)
{
  UnionId tmp(other);
  swap(tmp);
  return *this;
}

void UnionId::swap(UnionId & other)
{
  std::swap(idortypename_, other.idortypename_);

}

UnionId::~UnionId()
{
  delete(idortypename_);

}

void UnionId::accept(Visitor *v)
{
  v->visitUnionId(this);
}

UnionId *UnionId::clone() const
{
  return new UnionId(*this);
}



/********************   UnionIdBraces    ********************/
UnionIdBraces::UnionIdBraces(IdOrTypename *p1, LBRACE p2, StructDeclList *p3, RBRACE p4)
{
  idortypename_ = p1;
  lbrace_ = p2;
  structdecllist_ = p3;
  rbrace_ = p4;

}

UnionIdBraces::UnionIdBraces(const UnionIdBraces & other)
{
  idortypename_ = other.idortypename_->clone();
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

UnionIdBraces &UnionIdBraces::operator=(const UnionIdBraces & other)
{
  UnionIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void UnionIdBraces::swap(UnionIdBraces & other)
{
  std::swap(idortypename_, other.idortypename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

UnionIdBraces::~UnionIdBraces()
{
  delete(idortypename_);
  delete(structdecllist_);

}

void UnionIdBraces::accept(Visitor *v)
{
  v->visitUnionIdBraces(this);
}

UnionIdBraces *UnionIdBraces::clone() const
{
  return new UnionIdBraces(*this);
}



/********************   UnionBraces    ********************/
UnionBraces::UnionBraces(LBRACE p1, StructDeclList *p2, RBRACE p3)
{
  lbrace_ = p1;
  structdecllist_ = p2;
  rbrace_ = p3;

}

UnionBraces::UnionBraces(const UnionBraces & other)
{
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

UnionBraces &UnionBraces::operator=(const UnionBraces & other)
{
  UnionBraces tmp(other);
  swap(tmp);
  return *this;
}

void UnionBraces::swap(UnionBraces & other)
{
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

UnionBraces::~UnionBraces()
{
  delete(structdecllist_);

}

void UnionBraces::accept(Visitor *v)
{
  v->visitUnionBraces(this);
}

UnionBraces *UnionBraces::clone() const
{
  return new UnionBraces(*this);
}



/********************   UnionJustAttrIdBraces    ********************/
UnionJustAttrIdBraces::UnionJustAttrIdBraces(ListJustAttribute *p1, IdOrTypename *p2, LBRACE p3, StructDeclList *p4, RBRACE p5)
{
  listjustattribute_ = p1;
  idortypename_ = p2;
  lbrace_ = p3;
  structdecllist_ = p4;
  rbrace_ = p5;

}

UnionJustAttrIdBraces::UnionJustAttrIdBraces(const UnionJustAttrIdBraces & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  idortypename_ = other.idortypename_->clone();
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

UnionJustAttrIdBraces &UnionJustAttrIdBraces::operator=(const UnionJustAttrIdBraces & other)
{
  UnionJustAttrIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void UnionJustAttrIdBraces::swap(UnionJustAttrIdBraces & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(idortypename_, other.idortypename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

UnionJustAttrIdBraces::~UnionJustAttrIdBraces()
{
  delete(listjustattribute_);
  delete(idortypename_);
  delete(structdecllist_);

}

void UnionJustAttrIdBraces::accept(Visitor *v)
{
  v->visitUnionJustAttrIdBraces(this);
}

UnionJustAttrIdBraces *UnionJustAttrIdBraces::clone() const
{
  return new UnionJustAttrIdBraces(*this);
}



/********************   UnionJustAttrBraces    ********************/
UnionJustAttrBraces::UnionJustAttrBraces(ListJustAttribute *p1, LBRACE p2, StructDeclList *p3, RBRACE p4)
{
  listjustattribute_ = p1;
  lbrace_ = p2;
  structdecllist_ = p3;
  rbrace_ = p4;

}

UnionJustAttrBraces::UnionJustAttrBraces(const UnionJustAttrBraces & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  lbrace_ = other.lbrace_;
  structdecllist_ = other.structdecllist_->clone();
  rbrace_ = other.rbrace_;

}

UnionJustAttrBraces &UnionJustAttrBraces::operator=(const UnionJustAttrBraces & other)
{
  UnionJustAttrBraces tmp(other);
  swap(tmp);
  return *this;
}

void UnionJustAttrBraces::swap(UnionJustAttrBraces & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(structdecllist_, other.structdecllist_);
  std::swap(rbrace_, other.rbrace_);

}

UnionJustAttrBraces::~UnionJustAttrBraces()
{
  delete(listjustattribute_);
  delete(structdecllist_);

}

void UnionJustAttrBraces::accept(Visitor *v)
{
  v->visitUnionJustAttrBraces(this);
}

UnionJustAttrBraces *UnionJustAttrBraces::clone() const
{
  return new UnionJustAttrBraces(*this);
}



/********************   EnumId    ********************/
EnumId::EnumId(IdOrTypename *p1)
{
  idortypename_ = p1;

}

EnumId::EnumId(const EnumId & other)
{
  idortypename_ = other.idortypename_->clone();

}

EnumId &EnumId::operator=(const EnumId & other)
{
  EnumId tmp(other);
  swap(tmp);
  return *this;
}

void EnumId::swap(EnumId & other)
{
  std::swap(idortypename_, other.idortypename_);

}

EnumId::~EnumId()
{
  delete(idortypename_);

}

void EnumId::accept(Visitor *v)
{
  v->visitEnumId(this);
}

EnumId *EnumId::clone() const
{
  return new EnumId(*this);
}



/********************   EnumIdBraces    ********************/
EnumIdBraces::EnumIdBraces(IdOrTypename *p1, LBRACE p2, ListEnumerator *p3, MaybeComma *p4, RBRACE p5)
{
  idortypename_ = p1;
  lbrace_ = p2;
  listenumerator_ = p3;
  maybecomma_ = p4;
  rbrace_ = p5;

}

EnumIdBraces::EnumIdBraces(const EnumIdBraces & other)
{
  idortypename_ = other.idortypename_->clone();
  lbrace_ = other.lbrace_;
  listenumerator_ = other.listenumerator_->clone();
  maybecomma_ = other.maybecomma_->clone();
  rbrace_ = other.rbrace_;

}

EnumIdBraces &EnumIdBraces::operator=(const EnumIdBraces & other)
{
  EnumIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void EnumIdBraces::swap(EnumIdBraces & other)
{
  std::swap(idortypename_, other.idortypename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(listenumerator_, other.listenumerator_);
  std::swap(maybecomma_, other.maybecomma_);
  std::swap(rbrace_, other.rbrace_);

}

EnumIdBraces::~EnumIdBraces()
{
  delete(idortypename_);
  delete(listenumerator_);
  delete(maybecomma_);

}

void EnumIdBraces::accept(Visitor *v)
{
  v->visitEnumIdBraces(this);
}

EnumIdBraces *EnumIdBraces::clone() const
{
  return new EnumIdBraces(*this);
}



/********************   EnumBraces    ********************/
EnumBraces::EnumBraces(LBRACE p1, ListEnumerator *p2, MaybeComma *p3, RBRACE p4)
{
  lbrace_ = p1;
  listenumerator_ = p2;
  maybecomma_ = p3;
  rbrace_ = p4;

}

EnumBraces::EnumBraces(const EnumBraces & other)
{
  lbrace_ = other.lbrace_;
  listenumerator_ = other.listenumerator_->clone();
  maybecomma_ = other.maybecomma_->clone();
  rbrace_ = other.rbrace_;

}

EnumBraces &EnumBraces::operator=(const EnumBraces & other)
{
  EnumBraces tmp(other);
  swap(tmp);
  return *this;
}

void EnumBraces::swap(EnumBraces & other)
{
  std::swap(lbrace_, other.lbrace_);
  std::swap(listenumerator_, other.listenumerator_);
  std::swap(maybecomma_, other.maybecomma_);
  std::swap(rbrace_, other.rbrace_);

}

EnumBraces::~EnumBraces()
{
  delete(listenumerator_);
  delete(maybecomma_);

}

void EnumBraces::accept(Visitor *v)
{
  v->visitEnumBraces(this);
}

EnumBraces *EnumBraces::clone() const
{
  return new EnumBraces(*this);
}



/********************   EnumJustAttrIdBraces    ********************/
EnumJustAttrIdBraces::EnumJustAttrIdBraces(ListJustAttribute *p1, IdOrTypename *p2, LBRACE p3, ListEnumerator *p4, MaybeComma *p5, RBRACE p6)
{
  listjustattribute_ = p1;
  idortypename_ = p2;
  lbrace_ = p3;
  listenumerator_ = p4;
  maybecomma_ = p5;
  rbrace_ = p6;

}

EnumJustAttrIdBraces::EnumJustAttrIdBraces(const EnumJustAttrIdBraces & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  idortypename_ = other.idortypename_->clone();
  lbrace_ = other.lbrace_;
  listenumerator_ = other.listenumerator_->clone();
  maybecomma_ = other.maybecomma_->clone();
  rbrace_ = other.rbrace_;

}

EnumJustAttrIdBraces &EnumJustAttrIdBraces::operator=(const EnumJustAttrIdBraces & other)
{
  EnumJustAttrIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void EnumJustAttrIdBraces::swap(EnumJustAttrIdBraces & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(idortypename_, other.idortypename_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(listenumerator_, other.listenumerator_);
  std::swap(maybecomma_, other.maybecomma_);
  std::swap(rbrace_, other.rbrace_);

}

EnumJustAttrIdBraces::~EnumJustAttrIdBraces()
{
  delete(listjustattribute_);
  delete(idortypename_);
  delete(listenumerator_);
  delete(maybecomma_);

}

void EnumJustAttrIdBraces::accept(Visitor *v)
{
  v->visitEnumJustAttrIdBraces(this);
}

EnumJustAttrIdBraces *EnumJustAttrIdBraces::clone() const
{
  return new EnumJustAttrIdBraces(*this);
}



/********************   EnumJustAttrBraces    ********************/
EnumJustAttrBraces::EnumJustAttrBraces(ListJustAttribute *p1, LBRACE p2, ListEnumerator *p3, MaybeComma *p4, RBRACE p5)
{
  listjustattribute_ = p1;
  lbrace_ = p2;
  listenumerator_ = p3;
  maybecomma_ = p4;
  rbrace_ = p5;

}

EnumJustAttrBraces::EnumJustAttrBraces(const EnumJustAttrBraces & other)
{
  listjustattribute_ = other.listjustattribute_->clone();
  lbrace_ = other.lbrace_;
  listenumerator_ = other.listenumerator_->clone();
  maybecomma_ = other.maybecomma_->clone();
  rbrace_ = other.rbrace_;

}

EnumJustAttrBraces &EnumJustAttrBraces::operator=(const EnumJustAttrBraces & other)
{
  EnumJustAttrBraces tmp(other);
  swap(tmp);
  return *this;
}

void EnumJustAttrBraces::swap(EnumJustAttrBraces & other)
{
  std::swap(listjustattribute_, other.listjustattribute_);
  std::swap(lbrace_, other.lbrace_);
  std::swap(listenumerator_, other.listenumerator_);
  std::swap(maybecomma_, other.maybecomma_);
  std::swap(rbrace_, other.rbrace_);

}

EnumJustAttrBraces::~EnumJustAttrBraces()
{
  delete(listjustattribute_);
  delete(listenumerator_);
  delete(maybecomma_);

}

void EnumJustAttrBraces::accept(Visitor *v)
{
  v->visitEnumJustAttrBraces(this);
}

EnumJustAttrBraces *EnumJustAttrBraces::clone() const
{
  return new EnumJustAttrBraces(*this);
}



/********************   NamedTypeTypeSpec    ********************/
NamedTypeTypeSpec::NamedTypeTypeSpec(NAMEDTYPE p1)
{
  namedtype_ = p1;

}

NamedTypeTypeSpec::NamedTypeTypeSpec(const NamedTypeTypeSpec & other)
{
  namedtype_ = other.namedtype_;

}

NamedTypeTypeSpec &NamedTypeTypeSpec::operator=(const NamedTypeTypeSpec & other)
{
  NamedTypeTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void NamedTypeTypeSpec::swap(NamedTypeTypeSpec & other)
{
  std::swap(namedtype_, other.namedtype_);

}

NamedTypeTypeSpec::~NamedTypeTypeSpec()
{

}

void NamedTypeTypeSpec::accept(Visitor *v)
{
  v->visitNamedTypeTypeSpec(this);
}

NamedTypeTypeSpec *NamedTypeTypeSpec::clone() const
{
  return new NamedTypeTypeSpec(*this);
}



/********************   TypeOfExpression    ********************/
TypeOfExpression::TypeOfExpression(TYPEOF p1, Expression *p2)
{
  typeof_ = p1;
  expression_ = p2;

}

TypeOfExpression::TypeOfExpression(const TypeOfExpression & other)
{
  typeof_ = other.typeof_;
  expression_ = other.expression_->clone();

}

TypeOfExpression &TypeOfExpression::operator=(const TypeOfExpression & other)
{
  TypeOfExpression tmp(other);
  swap(tmp);
  return *this;
}

void TypeOfExpression::swap(TypeOfExpression & other)
{
  std::swap(typeof_, other.typeof_);
  std::swap(expression_, other.expression_);

}

TypeOfExpression::~TypeOfExpression()
{
  delete(expression_);

}

void TypeOfExpression::accept(Visitor *v)
{
  v->visitTypeOfExpression(this);
}

TypeOfExpression *TypeOfExpression::clone() const
{
  return new TypeOfExpression(*this);
}



/********************   TypeOfTypeName    ********************/
TypeOfTypeName::TypeOfTypeName(TYPEOF p1, TypeName *p2)
{
  typeof_ = p1;
  typename_ = p2;

}

TypeOfTypeName::TypeOfTypeName(const TypeOfTypeName & other)
{
  typeof_ = other.typeof_;
  typename_ = other.typename_->clone();

}

TypeOfTypeName &TypeOfTypeName::operator=(const TypeOfTypeName & other)
{
  TypeOfTypeName tmp(other);
  swap(tmp);
  return *this;
}

void TypeOfTypeName::swap(TypeOfTypeName & other)
{
  std::swap(typeof_, other.typeof_);
  std::swap(typename_, other.typename_);

}

TypeOfTypeName::~TypeOfTypeName()
{
  delete(typename_);

}

void TypeOfTypeName::accept(Visitor *v)
{
  v->visitTypeOfTypeName(this);
}

TypeOfTypeName *TypeOfTypeName::clone() const
{
  return new TypeOfTypeName(*this);
}



/********************   EmptyStructDecl    ********************/
EmptyStructDecl::EmptyStructDecl()
{

}

EmptyStructDecl::EmptyStructDecl(const EmptyStructDecl & other)
{

}

EmptyStructDecl &EmptyStructDecl::operator=(const EmptyStructDecl & other)
{
  EmptyStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void EmptyStructDecl::swap(EmptyStructDecl & other)
{

}

EmptyStructDecl::~EmptyStructDecl()
{

}

void EmptyStructDecl::accept(Visitor *v)
{
  v->visitEmptyStructDecl(this);
}

EmptyStructDecl *EmptyStructDecl::clone() const
{
  return new EmptyStructDecl(*this);
}



/********************   DeclSpecStructDecl    ********************/
DeclSpecStructDecl::DeclSpecStructDecl(DeclSpecList *p1, StructDeclList *p2)
{
  declspeclist_ = p1;
  structdecllist_ = p2;

}

DeclSpecStructDecl::DeclSpecStructDecl(const DeclSpecStructDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

DeclSpecStructDecl &DeclSpecStructDecl::operator=(const DeclSpecStructDecl & other)
{
  DeclSpecStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecStructDecl::swap(DeclSpecStructDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(structdecllist_, other.structdecllist_);

}

DeclSpecStructDecl::~DeclSpecStructDecl()
{
  delete(declspeclist_);
  delete(structdecllist_);

}

void DeclSpecStructDecl::accept(Visitor *v)
{
  v->visitDeclSpecStructDecl(this);
}

DeclSpecStructDecl *DeclSpecStructDecl::clone() const
{
  return new DeclSpecStructDecl(*this);
}



/********************   SemicolonStructDecl    ********************/
SemicolonStructDecl::SemicolonStructDecl(StructDeclList *p1)
{
  structdecllist_ = p1;

}

SemicolonStructDecl::SemicolonStructDecl(const SemicolonStructDecl & other)
{
  structdecllist_ = other.structdecllist_->clone();

}

SemicolonStructDecl &SemicolonStructDecl::operator=(const SemicolonStructDecl & other)
{
  SemicolonStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void SemicolonStructDecl::swap(SemicolonStructDecl & other)
{
  std::swap(structdecllist_, other.structdecllist_);

}

SemicolonStructDecl::~SemicolonStructDecl()
{
  delete(structdecllist_);

}

void SemicolonStructDecl::accept(Visitor *v)
{
  v->visitSemicolonStructDecl(this);
}

SemicolonStructDecl *SemicolonStructDecl::clone() const
{
  return new SemicolonStructDecl(*this);
}



/********************   SpecFieldDeclStructDecl    ********************/
SpecFieldDeclStructDecl::SpecFieldDeclStructDecl(DeclSpecList *p1, ListFieldDecl *p2, StructDeclList *p3)
{
  declspeclist_ = p1;
  listfielddecl_ = p2;
  structdecllist_ = p3;

}

SpecFieldDeclStructDecl::SpecFieldDeclStructDecl(const SpecFieldDeclStructDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  listfielddecl_ = other.listfielddecl_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

SpecFieldDeclStructDecl &SpecFieldDeclStructDecl::operator=(const SpecFieldDeclStructDecl & other)
{
  SpecFieldDeclStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void SpecFieldDeclStructDecl::swap(SpecFieldDeclStructDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(listfielddecl_, other.listfielddecl_);
  std::swap(structdecllist_, other.structdecllist_);

}

SpecFieldDeclStructDecl::~SpecFieldDeclStructDecl()
{
  delete(declspeclist_);
  delete(listfielddecl_);
  delete(structdecllist_);

}

void SpecFieldDeclStructDecl::accept(Visitor *v)
{
  v->visitSpecFieldDeclStructDecl(this);
}

SpecFieldDeclStructDecl *SpecFieldDeclStructDecl::clone() const
{
  return new SpecFieldDeclStructDecl(*this);
}



/********************   PragmaStructDecl    ********************/
PragmaStructDecl::PragmaStructDecl(Pragma *p1, StructDeclList *p2)
{
  pragma_ = p1;
  structdecllist_ = p2;

}

PragmaStructDecl::PragmaStructDecl(const PragmaStructDecl & other)
{
  pragma_ = other.pragma_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

PragmaStructDecl &PragmaStructDecl::operator=(const PragmaStructDecl & other)
{
  PragmaStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void PragmaStructDecl::swap(PragmaStructDecl & other)
{
  std::swap(pragma_, other.pragma_);
  std::swap(structdecllist_, other.structdecllist_);

}

PragmaStructDecl::~PragmaStructDecl()
{
  delete(pragma_);
  delete(structdecllist_);

}

void PragmaStructDecl::accept(Visitor *v)
{
  v->visitPragmaStructDecl(this);
}

PragmaStructDecl *PragmaStructDecl::clone() const
{
  return new PragmaStructDecl(*this);
}



/********************   StaticAssertStructDecl    ********************/
StaticAssertStructDecl::StaticAssertStructDecl(StaticAssertDeclaration *p1)
{
  staticassertdeclaration_ = p1;

}

StaticAssertStructDecl::StaticAssertStructDecl(const StaticAssertStructDecl & other)
{
  staticassertdeclaration_ = other.staticassertdeclaration_->clone();

}

StaticAssertStructDecl &StaticAssertStructDecl::operator=(const StaticAssertStructDecl & other)
{
  StaticAssertStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void StaticAssertStructDecl::swap(StaticAssertStructDecl & other)
{
  std::swap(staticassertdeclaration_, other.staticassertdeclaration_);

}

StaticAssertStructDecl::~StaticAssertStructDecl()
{
  delete(staticassertdeclaration_);

}

void StaticAssertStructDecl::accept(Visitor *v)
{
  v->visitStaticAssertStructDecl(this);
}

StaticAssertStructDecl *StaticAssertStructDecl::clone() const
{
  return new StaticAssertStructDecl(*this);
}



/********************   StaticAssertStructDeclNext    ********************/
StaticAssertStructDeclNext::StaticAssertStructDeclNext(StaticAssertDeclaration *p1, StructDeclList *p2)
{
  staticassertdeclaration_ = p1;
  structdecllist_ = p2;

}

StaticAssertStructDeclNext::StaticAssertStructDeclNext(const StaticAssertStructDeclNext & other)
{
  staticassertdeclaration_ = other.staticassertdeclaration_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

StaticAssertStructDeclNext &StaticAssertStructDeclNext::operator=(const StaticAssertStructDeclNext & other)
{
  StaticAssertStructDeclNext tmp(other);
  swap(tmp);
  return *this;
}

void StaticAssertStructDeclNext::swap(StaticAssertStructDeclNext & other)
{
  std::swap(staticassertdeclaration_, other.staticassertdeclaration_);
  std::swap(structdecllist_, other.structdecllist_);

}

StaticAssertStructDeclNext::~StaticAssertStructDeclNext()
{
  delete(staticassertdeclaration_);
  delete(structdecllist_);

}

void StaticAssertStructDeclNext::accept(Visitor *v)
{
  v->visitStaticAssertStructDeclNext(this);
}

StaticAssertStructDeclNext *StaticAssertStructDeclNext::clone() const
{
  return new StaticAssertStructDeclNext(*this);
}



/********************   StaticAssert    ********************/
StaticAssert::StaticAssert(Expression *p1)
{
  expression_ = p1;

}

StaticAssert::StaticAssert(const StaticAssert & other)
{
  expression_ = other.expression_->clone();

}

StaticAssert &StaticAssert::operator=(const StaticAssert & other)
{
  StaticAssert tmp(other);
  swap(tmp);
  return *this;
}

void StaticAssert::swap(StaticAssert & other)
{
  std::swap(expression_, other.expression_);

}

StaticAssert::~StaticAssert()
{
  delete(expression_);

}

void StaticAssert::accept(Visitor *v)
{
  v->visitStaticAssert(this);
}

StaticAssert *StaticAssert::clone() const
{
  return new StaticAssert(*this);
}



/********************   StaticAssertStringConst    ********************/
StaticAssertStringConst::StaticAssertStringConst(Expression *p1, StringConstant *p2)
{
  expression_ = p1;
  stringconstant_ = p2;

}

StaticAssertStringConst::StaticAssertStringConst(const StaticAssertStringConst & other)
{
  expression_ = other.expression_->clone();
  stringconstant_ = other.stringconstant_->clone();

}

StaticAssertStringConst &StaticAssertStringConst::operator=(const StaticAssertStringConst & other)
{
  StaticAssertStringConst tmp(other);
  swap(tmp);
  return *this;
}

void StaticAssertStringConst::swap(StaticAssertStringConst & other)
{
  std::swap(expression_, other.expression_);
  std::swap(stringconstant_, other.stringconstant_);

}

StaticAssertStringConst::~StaticAssertStringConst()
{
  delete(expression_);
  delete(stringconstant_);

}

void StaticAssertStringConst::accept(Visitor *v)
{
  v->visitStaticAssertStringConst(this);
}

StaticAssertStringConst *StaticAssertStringConst::clone() const
{
  return new StaticAssertStringConst(*this);
}



/********************   FieldDeclDeclarator    ********************/
FieldDeclDeclarator::FieldDeclDeclarator(Declarator *p1)
{
  declarator_ = p1;

}

FieldDeclDeclarator::FieldDeclDeclarator(const FieldDeclDeclarator & other)
{
  declarator_ = other.declarator_->clone();

}

FieldDeclDeclarator &FieldDeclDeclarator::operator=(const FieldDeclDeclarator & other)
{
  FieldDeclDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void FieldDeclDeclarator::swap(FieldDeclDeclarator & other)
{
  std::swap(declarator_, other.declarator_);

}

FieldDeclDeclarator::~FieldDeclDeclarator()
{
  delete(declarator_);

}

void FieldDeclDeclarator::accept(Visitor *v)
{
  v->visitFieldDeclDeclarator(this);
}

FieldDeclDeclarator *FieldDeclDeclarator::clone() const
{
  return new FieldDeclDeclarator(*this);
}



/********************   FieldDeclDeclaratorColon    ********************/
FieldDeclDeclaratorColon::FieldDeclDeclaratorColon(Declarator *p1, Expression *p2, ListAttribute *p3)
{
  declarator_ = p1;
  expression_ = p2;
  listattribute_ = p3;

}

FieldDeclDeclaratorColon::FieldDeclDeclaratorColon(const FieldDeclDeclaratorColon & other)
{
  declarator_ = other.declarator_->clone();
  expression_ = other.expression_->clone();
  listattribute_ = other.listattribute_->clone();

}

FieldDeclDeclaratorColon &FieldDeclDeclaratorColon::operator=(const FieldDeclDeclaratorColon & other)
{
  FieldDeclDeclaratorColon tmp(other);
  swap(tmp);
  return *this;
}

void FieldDeclDeclaratorColon::swap(FieldDeclDeclaratorColon & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(expression_, other.expression_);
  std::swap(listattribute_, other.listattribute_);

}

FieldDeclDeclaratorColon::~FieldDeclDeclaratorColon()
{
  delete(declarator_);
  delete(expression_);
  delete(listattribute_);

}

void FieldDeclDeclaratorColon::accept(Visitor *v)
{
  v->visitFieldDeclDeclaratorColon(this);
}

FieldDeclDeclaratorColon *FieldDeclDeclaratorColon::clone() const
{
  return new FieldDeclDeclaratorColon(*this);
}



/********************   FieldDeclColonExpression    ********************/
FieldDeclColonExpression::FieldDeclColonExpression(Expression *p1)
{
  expression_ = p1;

}

FieldDeclColonExpression::FieldDeclColonExpression(const FieldDeclColonExpression & other)
{
  expression_ = other.expression_->clone();

}

FieldDeclColonExpression &FieldDeclColonExpression::operator=(const FieldDeclColonExpression & other)
{
  FieldDeclColonExpression tmp(other);
  swap(tmp);
  return *this;
}

void FieldDeclColonExpression::swap(FieldDeclColonExpression & other)
{
  std::swap(expression_, other.expression_);

}

FieldDeclColonExpression::~FieldDeclColonExpression()
{
  delete(expression_);

}

void FieldDeclColonExpression::accept(Visitor *v)
{
  v->visitFieldDeclColonExpression(this);
}

FieldDeclColonExpression *FieldDeclColonExpression::clone() const
{
  return new FieldDeclColonExpression(*this);
}



/********************   IdentEnumerator    ********************/
IdentEnumerator::IdentEnumerator(Ident p1)
{
  ident_ = p1;

}

IdentEnumerator::IdentEnumerator(const IdentEnumerator & other)
{
  ident_ = other.ident_;

}

IdentEnumerator &IdentEnumerator::operator=(const IdentEnumerator & other)
{
  IdentEnumerator tmp(other);
  swap(tmp);
  return *this;
}

void IdentEnumerator::swap(IdentEnumerator & other)
{
  std::swap(ident_, other.ident_);

}

IdentEnumerator::~IdentEnumerator()
{

}

void IdentEnumerator::accept(Visitor *v)
{
  v->visitIdentEnumerator(this);
}

IdentEnumerator *IdentEnumerator::clone() const
{
  return new IdentEnumerator(*this);
}



/********************   IdentAssignExpr    ********************/
IdentAssignExpr::IdentAssignExpr(Ident p1, Expression *p2)
{
  ident_ = p1;
  expression_ = p2;

}

IdentAssignExpr::IdentAssignExpr(const IdentAssignExpr & other)
{
  ident_ = other.ident_;
  expression_ = other.expression_->clone();

}

IdentAssignExpr &IdentAssignExpr::operator=(const IdentAssignExpr & other)
{
  IdentAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void IdentAssignExpr::swap(IdentAssignExpr & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expression_, other.expression_);

}

IdentAssignExpr::~IdentAssignExpr()
{
  delete(expression_);

}

void IdentAssignExpr::accept(Visitor *v)
{
  v->visitIdentAssignExpr(this);
}

IdentAssignExpr *IdentAssignExpr::clone() const
{
  return new IdentAssignExpr(*this);
}



/********************   ADeclarator    ********************/
ADeclarator::ADeclarator(PointerOpt *p1, DirectDecl *p2, AttributesWithAsm *p3)
{
  pointeropt_ = p1;
  directdecl_ = p2;
  attributeswithasm_ = p3;

}

ADeclarator::ADeclarator(const ADeclarator & other)
{
  pointeropt_ = other.pointeropt_->clone();
  directdecl_ = other.directdecl_->clone();
  attributeswithasm_ = other.attributeswithasm_->clone();

}

ADeclarator &ADeclarator::operator=(const ADeclarator & other)
{
  ADeclarator tmp(other);
  swap(tmp);
  return *this;
}

void ADeclarator::swap(ADeclarator & other)
{
  std::swap(pointeropt_, other.pointeropt_);
  std::swap(directdecl_, other.directdecl_);
  std::swap(attributeswithasm_, other.attributeswithasm_);

}

ADeclarator::~ADeclarator()
{
  delete(pointeropt_);
  delete(directdecl_);
  delete(attributeswithasm_);

}

void ADeclarator::accept(Visitor *v)
{
  v->visitADeclarator(this);
}

ADeclarator *ADeclarator::clone() const
{
  return new ADeclarator(*this);
}



/********************   AttributesCommaExpression    ********************/
AttributesCommaExpression::AttributesCommaExpression(ListAttribute *p1, CommaExpressionOpt *p2)
{
  listattribute_ = p1;
  commaexpressionopt_ = p2;

}

AttributesCommaExpression::AttributesCommaExpression(const AttributesCommaExpression & other)
{
  listattribute_ = other.listattribute_->clone();
  commaexpressionopt_ = other.commaexpressionopt_->clone();

}

AttributesCommaExpression &AttributesCommaExpression::operator=(const AttributesCommaExpression & other)
{
  AttributesCommaExpression tmp(other);
  swap(tmp);
  return *this;
}

void AttributesCommaExpression::swap(AttributesCommaExpression & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(commaexpressionopt_, other.commaexpressionopt_);

}

AttributesCommaExpression::~AttributesCommaExpression()
{
  delete(listattribute_);
  delete(commaexpressionopt_);

}

void AttributesCommaExpression::accept(Visitor *v)
{
  v->visitAttributesCommaExpression(this);
}

AttributesCommaExpression *AttributesCommaExpression::clone() const
{
  return new AttributesCommaExpression(*this);
}



/********************   AttributesStaticExpression    ********************/
AttributesStaticExpression::AttributesStaticExpression(Attribute *p1, ListAttribute *p2, ListExpression *p3)
{
  attribute_ = p1;
  listattribute_ = p2;
  listexpression_ = p3;

}

AttributesStaticExpression::AttributesStaticExpression(const AttributesStaticExpression & other)
{
  attribute_ = other.attribute_->clone();
  listattribute_ = other.listattribute_->clone();
  listexpression_ = other.listexpression_->clone();

}

AttributesStaticExpression &AttributesStaticExpression::operator=(const AttributesStaticExpression & other)
{
  AttributesStaticExpression tmp(other);
  swap(tmp);
  return *this;
}

void AttributesStaticExpression::swap(AttributesStaticExpression & other)
{
  std::swap(attribute_, other.attribute_);
  std::swap(listattribute_, other.listattribute_);
  std::swap(listexpression_, other.listexpression_);

}

AttributesStaticExpression::~AttributesStaticExpression()
{
  delete(attribute_);
  delete(listattribute_);
  delete(listexpression_);

}

void AttributesStaticExpression::accept(Visitor *v)
{
  v->visitAttributesStaticExpression(this);
}

AttributesStaticExpression *AttributesStaticExpression::clone() const
{
  return new AttributesStaticExpression(*this);
}



/********************   StaticAttributesExpression    ********************/
StaticAttributesExpression::StaticAttributesExpression(ListAttribute *p1, ListExpression *p2)
{
  listattribute_ = p1;
  listexpression_ = p2;

}

StaticAttributesExpression::StaticAttributesExpression(const StaticAttributesExpression & other)
{
  listattribute_ = other.listattribute_->clone();
  listexpression_ = other.listexpression_->clone();

}

StaticAttributesExpression &StaticAttributesExpression::operator=(const StaticAttributesExpression & other)
{
  StaticAttributesExpression tmp(other);
  swap(tmp);
  return *this;
}

void StaticAttributesExpression::swap(StaticAttributesExpression & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(listexpression_, other.listexpression_);

}

StaticAttributesExpression::~StaticAttributesExpression()
{
  delete(listattribute_);
  delete(listexpression_);

}

void StaticAttributesExpression::accept(Visitor *v)
{
  v->visitStaticAttributesExpression(this);
}

StaticAttributesExpression *StaticAttributesExpression::clone() const
{
  return new StaticAttributesExpression(*this);
}



/********************   DirectDeclIdTypename    ********************/
DirectDeclIdTypename::DirectDeclIdTypename(IdOrTypename *p1)
{
  idortypename_ = p1;

}

DirectDeclIdTypename::DirectDeclIdTypename(const DirectDeclIdTypename & other)
{
  idortypename_ = other.idortypename_->clone();

}

DirectDeclIdTypename &DirectDeclIdTypename::operator=(const DirectDeclIdTypename & other)
{
  DirectDeclIdTypename tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclIdTypename::swap(DirectDeclIdTypename & other)
{
  std::swap(idortypename_, other.idortypename_);

}

DirectDeclIdTypename::~DirectDeclIdTypename()
{
  delete(idortypename_);

}

void DirectDeclIdTypename::accept(Visitor *v)
{
  v->visitDirectDeclIdTypename(this);
}

DirectDeclIdTypename *DirectDeclIdTypename::clone() const
{
  return new DirectDeclIdTypename(*this);
}



/********************   DirectDeclAttrDecl    ********************/
DirectDeclAttrDecl::DirectDeclAttrDecl(ListAttribute *p1, Declarator *p2)
{
  listattribute_ = p1;
  declarator_ = p2;

}

DirectDeclAttrDecl::DirectDeclAttrDecl(const DirectDeclAttrDecl & other)
{
  listattribute_ = other.listattribute_->clone();
  declarator_ = other.declarator_->clone();

}

DirectDeclAttrDecl &DirectDeclAttrDecl::operator=(const DirectDeclAttrDecl & other)
{
  DirectDeclAttrDecl tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclAttrDecl::swap(DirectDeclAttrDecl & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(declarator_, other.declarator_);

}

DirectDeclAttrDecl::~DirectDeclAttrDecl()
{
  delete(listattribute_);
  delete(declarator_);

}

void DirectDeclAttrDecl::accept(Visitor *v)
{
  v->visitDirectDeclAttrDecl(this);
}

DirectDeclAttrDecl *DirectDeclAttrDecl::clone() const
{
  return new DirectDeclAttrDecl(*this);
}



/********************   DirectDeclAttrStatic    ********************/
DirectDeclAttrStatic::DirectDeclAttrStatic(DirectDecl *p1, LBRACKET p2, AttributesOrStatic *p3, RBRACKET p4)
{
  directdecl_ = p1;
  lbracket_ = p2;
  attributesorstatic_ = p3;
  rbracket_ = p4;

}

DirectDeclAttrStatic::DirectDeclAttrStatic(const DirectDeclAttrStatic & other)
{
  directdecl_ = other.directdecl_->clone();
  lbracket_ = other.lbracket_;
  attributesorstatic_ = other.attributesorstatic_->clone();
  rbracket_ = other.rbracket_;

}

DirectDeclAttrStatic &DirectDeclAttrStatic::operator=(const DirectDeclAttrStatic & other)
{
  DirectDeclAttrStatic tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclAttrStatic::swap(DirectDeclAttrStatic & other)
{
  std::swap(directdecl_, other.directdecl_);
  std::swap(lbracket_, other.lbracket_);
  std::swap(attributesorstatic_, other.attributesorstatic_);
  std::swap(rbracket_, other.rbracket_);

}

DirectDeclAttrStatic::~DirectDeclAttrStatic()
{
  delete(directdecl_);
  delete(attributesorstatic_);

}

void DirectDeclAttrStatic::accept(Visitor *v)
{
  v->visitDirectDeclAttrStatic(this);
}

DirectDeclAttrStatic *DirectDeclAttrStatic::clone() const
{
  return new DirectDeclAttrStatic(*this);
}



/********************   DirectDeclGhostParam    ********************/
DirectDeclGhostParam::DirectDeclGhostParam(DirectDecl *p1, GhostParameterOpt *p2)
{
  directdecl_ = p1;
  ghostparameteropt_ = p2;

}

DirectDeclGhostParam::DirectDeclGhostParam(const DirectDeclGhostParam & other)
{
  directdecl_ = other.directdecl_->clone();
  ghostparameteropt_ = other.ghostparameteropt_->clone();

}

DirectDeclGhostParam &DirectDeclGhostParam::operator=(const DirectDeclGhostParam & other)
{
  DirectDeclGhostParam tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclGhostParam::swap(DirectDeclGhostParam & other)
{
  std::swap(directdecl_, other.directdecl_);
  std::swap(ghostparameteropt_, other.ghostparameteropt_);

}

DirectDeclGhostParam::~DirectDeclGhostParam()
{
  delete(directdecl_);
  delete(ghostparameteropt_);

}

void DirectDeclGhostParam::accept(Visitor *v)
{
  v->visitDirectDeclGhostParam(this);
}

DirectDeclGhostParam *DirectDeclGhostParam::clone() const
{
  return new DirectDeclGhostParam(*this);
}



/********************   DirectDeclGhostRestParParam    ********************/
DirectDeclGhostRestParParam::DirectDeclGhostRestParParam(DirectDecl *p1, RestParList *p2, GhostParameterOpt *p3)
{
  directdecl_ = p1;
  restparlist_ = p2;
  ghostparameteropt_ = p3;

}

DirectDeclGhostRestParParam::DirectDeclGhostRestParParam(const DirectDeclGhostRestParParam & other)
{
  directdecl_ = other.directdecl_->clone();
  restparlist_ = other.restparlist_->clone();
  ghostparameteropt_ = other.ghostparameteropt_->clone();

}

DirectDeclGhostRestParParam &DirectDeclGhostRestParParam::operator=(const DirectDeclGhostRestParParam & other)
{
  DirectDeclGhostRestParParam tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclGhostRestParParam::swap(DirectDeclGhostRestParParam & other)
{
  std::swap(directdecl_, other.directdecl_);
  std::swap(restparlist_, other.restparlist_);
  std::swap(ghostparameteropt_, other.ghostparameteropt_);

}

DirectDeclGhostRestParParam::~DirectDeclGhostRestParParam()
{
  delete(directdecl_);
  delete(restparlist_);
  delete(ghostparameteropt_);

}

void DirectDeclGhostRestParParam::accept(Visitor *v)
{
  v->visitDirectDeclGhostRestParParam(this);
}

DirectDeclGhostRestParParam *DirectDeclGhostRestParParam::clone() const
{
  return new DirectDeclGhostRestParParam(*this);
}



/********************   SimpleParameterDecl    ********************/
SimpleParameterDecl::SimpleParameterDecl(ListParameterDecl *p1)
{
  listparameterdecl_ = p1;

}

SimpleParameterDecl::SimpleParameterDecl(const SimpleParameterDecl & other)
{
  listparameterdecl_ = other.listparameterdecl_->clone();

}

SimpleParameterDecl &SimpleParameterDecl::operator=(const SimpleParameterDecl & other)
{
  SimpleParameterDecl tmp(other);
  swap(tmp);
  return *this;
}

void SimpleParameterDecl::swap(SimpleParameterDecl & other)
{
  std::swap(listparameterdecl_, other.listparameterdecl_);

}

SimpleParameterDecl::~SimpleParameterDecl()
{
  delete(listparameterdecl_);

}

void SimpleParameterDecl::accept(Visitor *v)
{
  v->visitSimpleParameterDecl(this);
}

SimpleParameterDecl *SimpleParameterDecl::clone() const
{
  return new SimpleParameterDecl(*this);
}



/********************   DotDotDotParameterDecl    ********************/
DotDotDotParameterDecl::DotDotDotParameterDecl(ListParameterDecl *p1)
{
  listparameterdecl_ = p1;

}

DotDotDotParameterDecl::DotDotDotParameterDecl(const DotDotDotParameterDecl & other)
{
  listparameterdecl_ = other.listparameterdecl_->clone();

}

DotDotDotParameterDecl &DotDotDotParameterDecl::operator=(const DotDotDotParameterDecl & other)
{
  DotDotDotParameterDecl tmp(other);
  swap(tmp);
  return *this;
}

void DotDotDotParameterDecl::swap(DotDotDotParameterDecl & other)
{
  std::swap(listparameterdecl_, other.listparameterdecl_);

}

DotDotDotParameterDecl::~DotDotDotParameterDecl()
{
  delete(listparameterdecl_);

}

void DotDotDotParameterDecl::accept(Visitor *v)
{
  v->visitDotDotDotParameterDecl(this);
}

DotDotDotParameterDecl *DotDotDotParameterDecl::clone() const
{
  return new DotDotDotParameterDecl(*this);
}



/********************   ParameterDeclSpecDeclarator    ********************/
ParameterDeclSpecDeclarator::ParameterDeclSpecDeclarator(DeclSpecList *p1, Declarator *p2)
{
  declspeclist_ = p1;
  declarator_ = p2;

}

ParameterDeclSpecDeclarator::ParameterDeclSpecDeclarator(const ParameterDeclSpecDeclarator & other)
{
  declspeclist_ = other.declspeclist_->clone();
  declarator_ = other.declarator_->clone();

}

ParameterDeclSpecDeclarator &ParameterDeclSpecDeclarator::operator=(const ParameterDeclSpecDeclarator & other)
{
  ParameterDeclSpecDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclSpecDeclarator::swap(ParameterDeclSpecDeclarator & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declarator_, other.declarator_);

}

ParameterDeclSpecDeclarator::~ParameterDeclSpecDeclarator()
{
  delete(declspeclist_);
  delete(declarator_);

}

void ParameterDeclSpecDeclarator::accept(Visitor *v)
{
  v->visitParameterDeclSpecDeclarator(this);
}

ParameterDeclSpecDeclarator *ParameterDeclSpecDeclarator::clone() const
{
  return new ParameterDeclSpecDeclarator(*this);
}



/********************   ParameterDeclSpecAbstract    ********************/
ParameterDeclSpecAbstract::ParameterDeclSpecAbstract(DeclSpecList *p1, AbstractDecl *p2)
{
  declspeclist_ = p1;
  abstractdecl_ = p2;

}

ParameterDeclSpecAbstract::ParameterDeclSpecAbstract(const ParameterDeclSpecAbstract & other)
{
  declspeclist_ = other.declspeclist_->clone();
  abstractdecl_ = other.abstractdecl_->clone();

}

ParameterDeclSpecAbstract &ParameterDeclSpecAbstract::operator=(const ParameterDeclSpecAbstract & other)
{
  ParameterDeclSpecAbstract tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclSpecAbstract::swap(ParameterDeclSpecAbstract & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(abstractdecl_, other.abstractdecl_);

}

ParameterDeclSpecAbstract::~ParameterDeclSpecAbstract()
{
  delete(declspeclist_);
  delete(abstractdecl_);

}

void ParameterDeclSpecAbstract::accept(Visitor *v)
{
  v->visitParameterDeclSpecAbstract(this);
}

ParameterDeclSpecAbstract *ParameterDeclSpecAbstract::clone() const
{
  return new ParameterDeclSpecAbstract(*this);
}



/********************   ParameterDeclSpec    ********************/
ParameterDeclSpec::ParameterDeclSpec(DeclSpecList *p1)
{
  declspeclist_ = p1;

}

ParameterDeclSpec::ParameterDeclSpec(const ParameterDeclSpec & other)
{
  declspeclist_ = other.declspeclist_->clone();

}

ParameterDeclSpec &ParameterDeclSpec::operator=(const ParameterDeclSpec & other)
{
  ParameterDeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclSpec::swap(ParameterDeclSpec & other)
{
  std::swap(declspeclist_, other.declspeclist_);

}

ParameterDeclSpec::~ParameterDeclSpec()
{
  delete(declspeclist_);

}

void ParameterDeclSpec::accept(Visitor *v)
{
  v->visitParameterDeclSpec(this);
}

ParameterDeclSpec *ParameterDeclSpec::clone() const
{
  return new ParameterDeclSpec(*this);
}



/********************   ParameterDeclPar    ********************/
ParameterDeclPar::ParameterDeclPar(ParameterDecl *p1)
{
  parameterdecl_ = p1;

}

ParameterDeclPar::ParameterDeclPar(const ParameterDeclPar & other)
{
  parameterdecl_ = other.parameterdecl_->clone();

}

ParameterDeclPar &ParameterDeclPar::operator=(const ParameterDeclPar & other)
{
  ParameterDeclPar tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclPar::swap(ParameterDeclPar & other)
{
  std::swap(parameterdecl_, other.parameterdecl_);

}

ParameterDeclPar::~ParameterDeclPar()
{
  delete(parameterdecl_);

}

void ParameterDeclPar::accept(Visitor *v)
{
  v->visitParameterDeclPar(this);
}

ParameterDeclPar *ParameterDeclPar::clone() const
{
  return new ParameterDeclPar(*this);
}



/********************   OldDirectProtoDecl    ********************/
OldDirectProtoDecl::OldDirectProtoDecl(DirectDecl *p1, ListIdent *p2, OldPardefList *p3)
{
  directdecl_ = p1;
  listident_ = p2;
  oldpardeflist_ = p3;

}

OldDirectProtoDecl::OldDirectProtoDecl(const OldDirectProtoDecl & other)
{
  directdecl_ = other.directdecl_->clone();
  listident_ = other.listident_->clone();
  oldpardeflist_ = other.oldpardeflist_->clone();

}

OldDirectProtoDecl &OldDirectProtoDecl::operator=(const OldDirectProtoDecl & other)
{
  OldDirectProtoDecl tmp(other);
  swap(tmp);
  return *this;
}

void OldDirectProtoDecl::swap(OldDirectProtoDecl & other)
{
  std::swap(directdecl_, other.directdecl_);
  std::swap(listident_, other.listident_);
  std::swap(oldpardeflist_, other.oldpardeflist_);

}

OldDirectProtoDecl::~OldDirectProtoDecl()
{
  delete(directdecl_);
  delete(listident_);
  delete(oldpardeflist_);

}

void OldDirectProtoDecl::accept(Visitor *v)
{
  v->visitOldDirectProtoDecl(this);
}

OldDirectProtoDecl *OldDirectProtoDecl::clone() const
{
  return new OldDirectProtoDecl(*this);
}



/********************   EmptyOldPardefList    ********************/
EmptyOldPardefList::EmptyOldPardefList()
{

}

EmptyOldPardefList::EmptyOldPardefList(const EmptyOldPardefList & other)
{

}

EmptyOldPardefList &EmptyOldPardefList::operator=(const EmptyOldPardefList & other)
{
  EmptyOldPardefList tmp(other);
  swap(tmp);
  return *this;
}

void EmptyOldPardefList::swap(EmptyOldPardefList & other)
{

}

EmptyOldPardefList::~EmptyOldPardefList()
{

}

void EmptyOldPardefList::accept(Visitor *v)
{
  v->visitEmptyOldPardefList(this);
}

EmptyOldPardefList *EmptyOldPardefList::clone() const
{
  return new EmptyOldPardefList(*this);
}



/********************   DotDotDotOldPardefList    ********************/
DotDotDotOldPardefList::DotDotDotOldPardefList(ListOldPardef *p1)
{
  listoldpardef_ = p1;

}

DotDotDotOldPardefList::DotDotDotOldPardefList(const DotDotDotOldPardefList & other)
{
  listoldpardef_ = other.listoldpardef_->clone();

}

DotDotDotOldPardefList &DotDotDotOldPardefList::operator=(const DotDotDotOldPardefList & other)
{
  DotDotDotOldPardefList tmp(other);
  swap(tmp);
  return *this;
}

void DotDotDotOldPardefList::swap(DotDotDotOldPardefList & other)
{
  std::swap(listoldpardef_, other.listoldpardef_);

}

DotDotDotOldPardefList::~DotDotDotOldPardefList()
{
  delete(listoldpardef_);

}

void DotDotDotOldPardefList::accept(Visitor *v)
{
  v->visitDotDotDotOldPardefList(this);
}

DotDotDotOldPardefList *DotDotDotOldPardefList::clone() const
{
  return new DotDotDotOldPardefList(*this);
}



/********************   SimpleOldPardefList    ********************/
SimpleOldPardefList::SimpleOldPardefList(ListOldPardef *p1)
{
  listoldpardef_ = p1;

}

SimpleOldPardefList::SimpleOldPardefList(const SimpleOldPardefList & other)
{
  listoldpardef_ = other.listoldpardef_->clone();

}

SimpleOldPardefList &SimpleOldPardefList::operator=(const SimpleOldPardefList & other)
{
  SimpleOldPardefList tmp(other);
  swap(tmp);
  return *this;
}

void SimpleOldPardefList::swap(SimpleOldPardefList & other)
{
  std::swap(listoldpardef_, other.listoldpardef_);

}

SimpleOldPardefList::~SimpleOldPardefList()
{
  delete(listoldpardef_);

}

void SimpleOldPardefList::accept(Visitor *v)
{
  v->visitSimpleOldPardefList(this);
}

SimpleOldPardefList *SimpleOldPardefList::clone() const
{
  return new SimpleOldPardefList(*this);
}



/********************   OldParDef    ********************/
OldParDef::OldParDef(DeclSpecList *p1, ListDeclarator *p2)
{
  declspeclist_ = p1;
  listdeclarator_ = p2;

}

OldParDef::OldParDef(const OldParDef & other)
{
  declspeclist_ = other.declspeclist_->clone();
  listdeclarator_ = other.listdeclarator_->clone();

}

OldParDef &OldParDef::operator=(const OldParDef & other)
{
  OldParDef tmp(other);
  swap(tmp);
  return *this;
}

void OldParDef::swap(OldParDef & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(listdeclarator_, other.listdeclarator_);

}

OldParDef::~OldParDef()
{
  delete(declspeclist_);
  delete(listdeclarator_);

}

void OldParDef::accept(Visitor *v)
{
  v->visitOldParDef(this);
}

OldParDef *OldParDef::clone() const
{
  return new OldParDef(*this);
}



/********************   NoPointer    ********************/
NoPointer::NoPointer()
{

}

NoPointer::NoPointer(const NoPointer & other)
{

}

NoPointer &NoPointer::operator=(const NoPointer & other)
{
  NoPointer tmp(other);
  swap(tmp);
  return *this;
}

void NoPointer::swap(NoPointer & other)
{

}

NoPointer::~NoPointer()
{

}

void NoPointer::accept(Visitor *v)
{
  v->visitNoPointer(this);
}

NoPointer *NoPointer::clone() const
{
  return new NoPointer(*this);
}



/********************   SomePointer    ********************/
SomePointer::SomePointer(ListAttribute *p1, PointerOpt *p2)
{
  listattribute_ = p1;
  pointeropt_ = p2;

}

SomePointer::SomePointer(const SomePointer & other)
{
  listattribute_ = other.listattribute_->clone();
  pointeropt_ = other.pointeropt_->clone();

}

SomePointer &SomePointer::operator=(const SomePointer & other)
{
  SomePointer tmp(other);
  swap(tmp);
  return *this;
}

void SomePointer::swap(SomePointer & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(pointeropt_, other.pointeropt_);

}

SomePointer::~SomePointer()
{
  delete(listattribute_);
  delete(pointeropt_);

}

void SomePointer::accept(Visitor *v)
{
  v->visitSomePointer(this);
}

SomePointer *SomePointer::clone() const
{
  return new SomePointer(*this);
}



/********************   TypeNameAbstractDecl    ********************/
TypeNameAbstractDecl::TypeNameAbstractDecl(DeclSpecList *p1, AbstractDecl *p2)
{
  declspeclist_ = p1;
  abstractdecl_ = p2;

}

TypeNameAbstractDecl::TypeNameAbstractDecl(const TypeNameAbstractDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  abstractdecl_ = other.abstractdecl_->clone();

}

TypeNameAbstractDecl &TypeNameAbstractDecl::operator=(const TypeNameAbstractDecl & other)
{
  TypeNameAbstractDecl tmp(other);
  swap(tmp);
  return *this;
}

void TypeNameAbstractDecl::swap(TypeNameAbstractDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(abstractdecl_, other.abstractdecl_);

}

TypeNameAbstractDecl::~TypeNameAbstractDecl()
{
  delete(declspeclist_);
  delete(abstractdecl_);

}

void TypeNameAbstractDecl::accept(Visitor *v)
{
  v->visitTypeNameAbstractDecl(this);
}

TypeNameAbstractDecl *TypeNameAbstractDecl::clone() const
{
  return new TypeNameAbstractDecl(*this);
}



/********************   TypeNameDeclSpecList    ********************/
TypeNameDeclSpecList::TypeNameDeclSpecList(DeclSpecList *p1)
{
  declspeclist_ = p1;

}

TypeNameDeclSpecList::TypeNameDeclSpecList(const TypeNameDeclSpecList & other)
{
  declspeclist_ = other.declspeclist_->clone();

}

TypeNameDeclSpecList &TypeNameDeclSpecList::operator=(const TypeNameDeclSpecList & other)
{
  TypeNameDeclSpecList tmp(other);
  swap(tmp);
  return *this;
}

void TypeNameDeclSpecList::swap(TypeNameDeclSpecList & other)
{
  std::swap(declspeclist_, other.declspeclist_);

}

TypeNameDeclSpecList::~TypeNameDeclSpecList()
{
  delete(declspeclist_);

}

void TypeNameDeclSpecList::accept(Visitor *v)
{
  v->visitTypeNameDeclSpecList(this);
}

TypeNameDeclSpecList *TypeNameDeclSpecList::clone() const
{
  return new TypeNameDeclSpecList(*this);
}



/********************   AbstractDeclAttr    ********************/
AbstractDeclAttr::AbstractDeclAttr(PointerOpt *p1, AbsDirectDecl *p2, ListAttribute *p3)
{
  pointeropt_ = p1;
  absdirectdecl_ = p2;
  listattribute_ = p3;

}

AbstractDeclAttr::AbstractDeclAttr(const AbstractDeclAttr & other)
{
  pointeropt_ = other.pointeropt_->clone();
  absdirectdecl_ = other.absdirectdecl_->clone();
  listattribute_ = other.listattribute_->clone();

}

AbstractDeclAttr &AbstractDeclAttr::operator=(const AbstractDeclAttr & other)
{
  AbstractDeclAttr tmp(other);
  swap(tmp);
  return *this;
}

void AbstractDeclAttr::swap(AbstractDeclAttr & other)
{
  std::swap(pointeropt_, other.pointeropt_);
  std::swap(absdirectdecl_, other.absdirectdecl_);
  std::swap(listattribute_, other.listattribute_);

}

AbstractDeclAttr::~AbstractDeclAttr()
{
  delete(pointeropt_);
  delete(absdirectdecl_);
  delete(listattribute_);

}

void AbstractDeclAttr::accept(Visitor *v)
{
  v->visitAbstractDeclAttr(this);
}

AbstractDeclAttr *AbstractDeclAttr::clone() const
{
  return new AbstractDeclAttr(*this);
}



/********************   AbstractDeclPointer    ********************/
AbstractDeclPointer::AbstractDeclPointer(ListAttribute *p1, PointerOpt *p2)
{
  listattribute_ = p1;
  pointeropt_ = p2;

}

AbstractDeclPointer::AbstractDeclPointer(const AbstractDeclPointer & other)
{
  listattribute_ = other.listattribute_->clone();
  pointeropt_ = other.pointeropt_->clone();

}

AbstractDeclPointer &AbstractDeclPointer::operator=(const AbstractDeclPointer & other)
{
  AbstractDeclPointer tmp(other);
  swap(tmp);
  return *this;
}

void AbstractDeclPointer::swap(AbstractDeclPointer & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(pointeropt_, other.pointeropt_);

}

AbstractDeclPointer::~AbstractDeclPointer()
{
  delete(listattribute_);
  delete(pointeropt_);

}

void AbstractDeclPointer::accept(Visitor *v)
{
  v->visitAbstractDeclPointer(this);
}

AbstractDeclPointer *AbstractDeclPointer::clone() const
{
  return new AbstractDeclPointer(*this);
}



/********************   AbsDirectDeclPar    ********************/
AbsDirectDeclPar::AbsDirectDeclPar(ListAttribute *p1, AbstractDecl *p2)
{
  listattribute_ = p1;
  abstractdecl_ = p2;

}

AbsDirectDeclPar::AbsDirectDeclPar(const AbsDirectDeclPar & other)
{
  listattribute_ = other.listattribute_->clone();
  abstractdecl_ = other.abstractdecl_->clone();

}

AbsDirectDeclPar &AbsDirectDeclPar::operator=(const AbsDirectDeclPar & other)
{
  AbsDirectDeclPar tmp(other);
  swap(tmp);
  return *this;
}

void AbsDirectDeclPar::swap(AbsDirectDeclPar & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(abstractdecl_, other.abstractdecl_);

}

AbsDirectDeclPar::~AbsDirectDeclPar()
{
  delete(listattribute_);
  delete(abstractdecl_);

}

void AbsDirectDeclPar::accept(Visitor *v)
{
  v->visitAbsDirectDeclPar(this);
}

AbsDirectDeclPar *AbsDirectDeclPar::clone() const
{
  return new AbsDirectDeclPar(*this);
}



/********************   AbsDirectDeclBreckets    ********************/
AbsDirectDeclBreckets::AbsDirectDeclBreckets(AbsDirectDeclOpt *p1, LBRACKET p2, CommaExpressionOpt *p3, RBRACKET p4)
{
  absdirectdeclopt_ = p1;
  lbracket_ = p2;
  commaexpressionopt_ = p3;
  rbracket_ = p4;

}

AbsDirectDeclBreckets::AbsDirectDeclBreckets(const AbsDirectDeclBreckets & other)
{
  absdirectdeclopt_ = other.absdirectdeclopt_->clone();
  lbracket_ = other.lbracket_;
  commaexpressionopt_ = other.commaexpressionopt_->clone();
  rbracket_ = other.rbracket_;

}

AbsDirectDeclBreckets &AbsDirectDeclBreckets::operator=(const AbsDirectDeclBreckets & other)
{
  AbsDirectDeclBreckets tmp(other);
  swap(tmp);
  return *this;
}

void AbsDirectDeclBreckets::swap(AbsDirectDeclBreckets & other)
{
  std::swap(absdirectdeclopt_, other.absdirectdeclopt_);
  std::swap(lbracket_, other.lbracket_);
  std::swap(commaexpressionopt_, other.commaexpressionopt_);
  std::swap(rbracket_, other.rbracket_);

}

AbsDirectDeclBreckets::~AbsDirectDeclBreckets()
{
  delete(absdirectdeclopt_);
  delete(commaexpressionopt_);

}

void AbsDirectDeclBreckets::accept(Visitor *v)
{
  v->visitAbsDirectDeclBreckets(this);
}

AbsDirectDeclBreckets *AbsDirectDeclBreckets::clone() const
{
  return new AbsDirectDeclBreckets(*this);
}



/********************   AbsDirectDeclRestPar    ********************/
AbsDirectDeclRestPar::AbsDirectDeclRestPar(AbsDirectDecl *p1, RestParList *p2)
{
  absdirectdecl_ = p1;
  restparlist_ = p2;

}

AbsDirectDeclRestPar::AbsDirectDeclRestPar(const AbsDirectDeclRestPar & other)
{
  absdirectdecl_ = other.absdirectdecl_->clone();
  restparlist_ = other.restparlist_->clone();

}

AbsDirectDeclRestPar &AbsDirectDeclRestPar::operator=(const AbsDirectDeclRestPar & other)
{
  AbsDirectDeclRestPar tmp(other);
  swap(tmp);
  return *this;
}

void AbsDirectDeclRestPar::swap(AbsDirectDeclRestPar & other)
{
  std::swap(absdirectdecl_, other.absdirectdecl_);
  std::swap(restparlist_, other.restparlist_);

}

AbsDirectDeclRestPar::~AbsDirectDeclRestPar()
{
  delete(absdirectdecl_);
  delete(restparlist_);

}

void AbsDirectDeclRestPar::accept(Visitor *v)
{
  v->visitAbsDirectDeclRestPar(this);
}

AbsDirectDeclRestPar *AbsDirectDeclRestPar::clone() const
{
  return new AbsDirectDeclRestPar(*this);
}



/********************   AbsDirectDeclNoRestPar    ********************/
AbsDirectDeclNoRestPar::AbsDirectDeclNoRestPar(AbsDirectDecl *p1)
{
  absdirectdecl_ = p1;

}

AbsDirectDeclNoRestPar::AbsDirectDeclNoRestPar(const AbsDirectDeclNoRestPar & other)
{
  absdirectdecl_ = other.absdirectdecl_->clone();

}

AbsDirectDeclNoRestPar &AbsDirectDeclNoRestPar::operator=(const AbsDirectDeclNoRestPar & other)
{
  AbsDirectDeclNoRestPar tmp(other);
  swap(tmp);
  return *this;
}

void AbsDirectDeclNoRestPar::swap(AbsDirectDeclNoRestPar & other)
{
  std::swap(absdirectdecl_, other.absdirectdecl_);

}

AbsDirectDeclNoRestPar::~AbsDirectDeclNoRestPar()
{
  delete(absdirectdecl_);

}

void AbsDirectDeclNoRestPar::accept(Visitor *v)
{
  v->visitAbsDirectDeclNoRestPar(this);
}

AbsDirectDeclNoRestPar *AbsDirectDeclNoRestPar::clone() const
{
  return new AbsDirectDeclNoRestPar(*this);
}



/********************   SomeAbsDirectDecl    ********************/
SomeAbsDirectDecl::SomeAbsDirectDecl(AbsDirectDecl *p1)
{
  absdirectdecl_ = p1;

}

SomeAbsDirectDecl::SomeAbsDirectDecl(const SomeAbsDirectDecl & other)
{
  absdirectdecl_ = other.absdirectdecl_->clone();

}

SomeAbsDirectDecl &SomeAbsDirectDecl::operator=(const SomeAbsDirectDecl & other)
{
  SomeAbsDirectDecl tmp(other);
  swap(tmp);
  return *this;
}

void SomeAbsDirectDecl::swap(SomeAbsDirectDecl & other)
{
  std::swap(absdirectdecl_, other.absdirectdecl_);

}

SomeAbsDirectDecl::~SomeAbsDirectDecl()
{
  delete(absdirectdecl_);

}

void SomeAbsDirectDecl::accept(Visitor *v)
{
  v->visitSomeAbsDirectDecl(this);
}

SomeAbsDirectDecl *SomeAbsDirectDecl::clone() const
{
  return new SomeAbsDirectDecl(*this);
}



/********************   NoAbsDirectDecl    ********************/
NoAbsDirectDecl::NoAbsDirectDecl()
{

}

NoAbsDirectDecl::NoAbsDirectDecl(const NoAbsDirectDecl & other)
{

}

NoAbsDirectDecl &NoAbsDirectDecl::operator=(const NoAbsDirectDecl & other)
{
  NoAbsDirectDecl tmp(other);
  swap(tmp);
  return *this;
}

void NoAbsDirectDecl::swap(NoAbsDirectDecl & other)
{

}

NoAbsDirectDecl::~NoAbsDirectDecl()
{

}

void NoAbsDirectDecl::accept(Visitor *v)
{
  v->visitNoAbsDirectDecl(this);
}

NoAbsDirectDecl *NoAbsDirectDecl::clone() const
{
  return new NoAbsDirectDecl(*this);
}



/********************   FunctionDefSpec    ********************/
FunctionDefSpec::FunctionDefSpec(IsACSLSpec *p1, ListWildcard *p2, FunctionDefStart *p3, Block *p4)
{
  isacslspec_ = p1;
  listwildcard_ = p2;
  functiondefstart_ = p3;
  block_ = p4;

}

FunctionDefSpec::FunctionDefSpec(const FunctionDefSpec & other)
{
  isacslspec_ = other.isacslspec_->clone();
  listwildcard_ = other.listwildcard_->clone();
  functiondefstart_ = other.functiondefstart_->clone();
  block_ = other.block_->clone();

}

FunctionDefSpec &FunctionDefSpec::operator=(const FunctionDefSpec & other)
{
  FunctionDefSpec tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefSpec::swap(FunctionDefSpec & other)
{
  std::swap(isacslspec_, other.isacslspec_);
  std::swap(listwildcard_, other.listwildcard_);
  std::swap(functiondefstart_, other.functiondefstart_);
  std::swap(block_, other.block_);

}

FunctionDefSpec::~FunctionDefSpec()
{
  delete(isacslspec_);
  delete(listwildcard_);
  delete(functiondefstart_);
  delete(block_);

}

void FunctionDefSpec::accept(Visitor *v)
{
  v->visitFunctionDefSpec(this);
}

FunctionDefSpec *FunctionDefSpec::clone() const
{
  return new FunctionDefSpec(*this);
}



/********************   SimpleFunctionDef    ********************/
SimpleFunctionDef::SimpleFunctionDef(FunctionDefStart *p1, Block *p2)
{
  functiondefstart_ = p1;
  block_ = p2;

}

SimpleFunctionDef::SimpleFunctionDef(const SimpleFunctionDef & other)
{
  functiondefstart_ = other.functiondefstart_->clone();
  block_ = other.block_->clone();

}

SimpleFunctionDef &SimpleFunctionDef::operator=(const SimpleFunctionDef & other)
{
  SimpleFunctionDef tmp(other);
  swap(tmp);
  return *this;
}

void SimpleFunctionDef::swap(SimpleFunctionDef & other)
{
  std::swap(functiondefstart_, other.functiondefstart_);
  std::swap(block_, other.block_);

}

SimpleFunctionDef::~SimpleFunctionDef()
{
  delete(functiondefstart_);
  delete(block_);

}

void SimpleFunctionDef::accept(Visitor *v)
{
  v->visitSimpleFunctionDef(this);
}

SimpleFunctionDef *SimpleFunctionDef::clone() const
{
  return new SimpleFunctionDef(*this);
}



/********************   FunctionDefStartDeclarator    ********************/
FunctionDefStartDeclarator::FunctionDefStartDeclarator(DeclSpecList *p1, Declarator *p2)
{
  declspeclist_ = p1;
  declarator_ = p2;

}

FunctionDefStartDeclarator::FunctionDefStartDeclarator(const FunctionDefStartDeclarator & other)
{
  declspeclist_ = other.declspeclist_->clone();
  declarator_ = other.declarator_->clone();

}

FunctionDefStartDeclarator &FunctionDefStartDeclarator::operator=(const FunctionDefStartDeclarator & other)
{
  FunctionDefStartDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefStartDeclarator::swap(FunctionDefStartDeclarator & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declarator_, other.declarator_);

}

FunctionDefStartDeclarator::~FunctionDefStartDeclarator()
{
  delete(declspeclist_);
  delete(declarator_);

}

void FunctionDefStartDeclarator::accept(Visitor *v)
{
  v->visitFunctionDefStartDeclarator(this);
}

FunctionDefStartDeclarator *FunctionDefStartDeclarator::clone() const
{
  return new FunctionDefStartDeclarator(*this);
}



/********************   FunctionDefStartOldProtoDecl    ********************/
FunctionDefStartOldProtoDecl::FunctionDefStartOldProtoDecl(DeclSpecList *p1, PointerOpt *p2, DirectOldProtoDecl *p3)
{
  declspeclist_ = p1;
  pointeropt_ = p2;
  directoldprotodecl_ = p3;

}

FunctionDefStartOldProtoDecl::FunctionDefStartOldProtoDecl(const FunctionDefStartOldProtoDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  pointeropt_ = other.pointeropt_->clone();
  directoldprotodecl_ = other.directoldprotodecl_->clone();

}

FunctionDefStartOldProtoDecl &FunctionDefStartOldProtoDecl::operator=(const FunctionDefStartOldProtoDecl & other)
{
  FunctionDefStartOldProtoDecl tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefStartOldProtoDecl::swap(FunctionDefStartOldProtoDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(pointeropt_, other.pointeropt_);
  std::swap(directoldprotodecl_, other.directoldprotodecl_);

}

FunctionDefStartOldProtoDecl::~FunctionDefStartOldProtoDecl()
{
  delete(declspeclist_);
  delete(pointeropt_);
  delete(directoldprotodecl_);

}

void FunctionDefStartOldProtoDecl::accept(Visitor *v)
{
  v->visitFunctionDefStartOldProtoDecl(this);
}

FunctionDefStartOldProtoDecl *FunctionDefStartOldProtoDecl::clone() const
{
  return new FunctionDefStartOldProtoDecl(*this);
}



/********************   FunctionDefStartReatParGhostParameter    ********************/
FunctionDefStartReatParGhostParameter::FunctionDefStartReatParGhostParameter(Ident p1, RestParList *p2, GhostParameterOpt *p3)
{
  ident_ = p1;
  restparlist_ = p2;
  ghostparameteropt_ = p3;

}

FunctionDefStartReatParGhostParameter::FunctionDefStartReatParGhostParameter(const FunctionDefStartReatParGhostParameter & other)
{
  ident_ = other.ident_;
  restparlist_ = other.restparlist_->clone();
  ghostparameteropt_ = other.ghostparameteropt_->clone();

}

FunctionDefStartReatParGhostParameter &FunctionDefStartReatParGhostParameter::operator=(const FunctionDefStartReatParGhostParameter & other)
{
  FunctionDefStartReatParGhostParameter tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefStartReatParGhostParameter::swap(FunctionDefStartReatParGhostParameter & other)
{
  std::swap(ident_, other.ident_);
  std::swap(restparlist_, other.restparlist_);
  std::swap(ghostparameteropt_, other.ghostparameteropt_);

}

FunctionDefStartReatParGhostParameter::~FunctionDefStartReatParGhostParameter()
{
  delete(restparlist_);
  delete(ghostparameteropt_);

}

void FunctionDefStartReatParGhostParameter::accept(Visitor *v)
{
  v->visitFunctionDefStartReatParGhostParameter(this);
}

FunctionDefStartReatParGhostParameter *FunctionDefStartReatParGhostParameter::clone() const
{
  return new FunctionDefStartReatParGhostParameter(*this);
}



/********************   FunctionDefStartOldPardef    ********************/
FunctionDefStartOldPardef::FunctionDefStartOldPardef(Ident p1, ListIdent *p2, OldPardefList *p3)
{
  ident_ = p1;
  listident_ = p2;
  oldpardeflist_ = p3;

}

FunctionDefStartOldPardef::FunctionDefStartOldPardef(const FunctionDefStartOldPardef & other)
{
  ident_ = other.ident_;
  listident_ = other.listident_->clone();
  oldpardeflist_ = other.oldpardeflist_->clone();

}

FunctionDefStartOldPardef &FunctionDefStartOldPardef::operator=(const FunctionDefStartOldPardef & other)
{
  FunctionDefStartOldPardef tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefStartOldPardef::swap(FunctionDefStartOldPardef & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listident_, other.listident_);
  std::swap(oldpardeflist_, other.oldpardeflist_);

}

FunctionDefStartOldPardef::~FunctionDefStartOldPardef()
{
  delete(listident_);
  delete(oldpardeflist_);

}

void FunctionDefStartOldPardef::accept(Visitor *v)
{
  v->visitFunctionDefStartOldPardef(this);
}

FunctionDefStartOldPardef *FunctionDefStartOldPardef::clone() const
{
  return new FunctionDefStartOldPardef(*this);
}



/********************   FunctionDefStartGhostParameter    ********************/
FunctionDefStartGhostParameter::FunctionDefStartGhostParameter(Ident p1, GhostParameterOpt *p2)
{
  ident_ = p1;
  ghostparameteropt_ = p2;

}

FunctionDefStartGhostParameter::FunctionDefStartGhostParameter(const FunctionDefStartGhostParameter & other)
{
  ident_ = other.ident_;
  ghostparameteropt_ = other.ghostparameteropt_->clone();

}

FunctionDefStartGhostParameter &FunctionDefStartGhostParameter::operator=(const FunctionDefStartGhostParameter & other)
{
  FunctionDefStartGhostParameter tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefStartGhostParameter::swap(FunctionDefStartGhostParameter & other)
{
  std::swap(ident_, other.ident_);
  std::swap(ghostparameteropt_, other.ghostparameteropt_);

}

FunctionDefStartGhostParameter::~FunctionDefStartGhostParameter()
{
  delete(ghostparameteropt_);

}

void FunctionDefStartGhostParameter::accept(Visitor *v)
{
  v->visitFunctionDefStartGhostParameter(this);
}

FunctionDefStartGhostParameter *FunctionDefStartGhostParameter::clone() const
{
  return new FunctionDefStartGhostParameter(*this);
}



/********************   CVSpecConstKeyWord    ********************/
CVSpecConstKeyWord::CVSpecConstKeyWord(CONST p1)
{
  const_ = p1;

}

CVSpecConstKeyWord::CVSpecConstKeyWord(const CVSpecConstKeyWord & other)
{
  const_ = other.const_;

}

CVSpecConstKeyWord &CVSpecConstKeyWord::operator=(const CVSpecConstKeyWord & other)
{
  CVSpecConstKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CVSpecConstKeyWord::swap(CVSpecConstKeyWord & other)
{
  std::swap(const_, other.const_);

}

CVSpecConstKeyWord::~CVSpecConstKeyWord()
{

}

void CVSpecConstKeyWord::accept(Visitor *v)
{
  v->visitCVSpecConstKeyWord(this);
}

CVSpecConstKeyWord *CVSpecConstKeyWord::clone() const
{
  return new CVSpecConstKeyWord(*this);
}



/********************   CVSpecVolatileKeyWord    ********************/
CVSpecVolatileKeyWord::CVSpecVolatileKeyWord(VOLATILE p1)
{
  volatile_ = p1;

}

CVSpecVolatileKeyWord::CVSpecVolatileKeyWord(const CVSpecVolatileKeyWord & other)
{
  volatile_ = other.volatile_;

}

CVSpecVolatileKeyWord &CVSpecVolatileKeyWord::operator=(const CVSpecVolatileKeyWord & other)
{
  CVSpecVolatileKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CVSpecVolatileKeyWord::swap(CVSpecVolatileKeyWord & other)
{
  std::swap(volatile_, other.volatile_);

}

CVSpecVolatileKeyWord::~CVSpecVolatileKeyWord()
{

}

void CVSpecVolatileKeyWord::accept(Visitor *v)
{
  v->visitCVSpecVolatileKeyWord(this);
}

CVSpecVolatileKeyWord *CVSpecVolatileKeyWord::clone() const
{
  return new CVSpecVolatileKeyWord(*this);
}



/********************   CVSpecRestrictKeyWord    ********************/
CVSpecRestrictKeyWord::CVSpecRestrictKeyWord(RESTRICT p1)
{
  restrict_ = p1;

}

CVSpecRestrictKeyWord::CVSpecRestrictKeyWord(const CVSpecRestrictKeyWord & other)
{
  restrict_ = other.restrict_;

}

CVSpecRestrictKeyWord &CVSpecRestrictKeyWord::operator=(const CVSpecRestrictKeyWord & other)
{
  CVSpecRestrictKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CVSpecRestrictKeyWord::swap(CVSpecRestrictKeyWord & other)
{
  std::swap(restrict_, other.restrict_);

}

CVSpecRestrictKeyWord::~CVSpecRestrictKeyWord()
{

}

void CVSpecRestrictKeyWord::accept(Visitor *v)
{
  v->visitCVSpecRestrictKeyWord(this);
}

CVSpecRestrictKeyWord *CVSpecRestrictKeyWord::clone() const
{
  return new CVSpecRestrictKeyWord(*this);
}



/********************   CVSpecGhostKeyWord    ********************/
CVSpecGhostKeyWord::CVSpecGhostKeyWord()
{

}

CVSpecGhostKeyWord::CVSpecGhostKeyWord(const CVSpecGhostKeyWord & other)
{

}

CVSpecGhostKeyWord &CVSpecGhostKeyWord::operator=(const CVSpecGhostKeyWord & other)
{
  CVSpecGhostKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CVSpecGhostKeyWord::swap(CVSpecGhostKeyWord & other)
{

}

CVSpecGhostKeyWord::~CVSpecGhostKeyWord()
{

}

void CVSpecGhostKeyWord::accept(Visitor *v)
{
  v->visitCVSpecGhostKeyWord(this);
}

CVSpecGhostKeyWord *CVSpecGhostKeyWord::clone() const
{
  return new CVSpecGhostKeyWord(*this);
}



/********************   CVSpecAttribute_annotKeyWord    ********************/
CVSpecAttribute_annotKeyWord::CVSpecAttribute_annotKeyWord(Identifier *p1)
{
  identifier_ = p1;

}

CVSpecAttribute_annotKeyWord::CVSpecAttribute_annotKeyWord(const CVSpecAttribute_annotKeyWord & other)
{
  identifier_ = other.identifier_->clone();

}

CVSpecAttribute_annotKeyWord &CVSpecAttribute_annotKeyWord::operator=(const CVSpecAttribute_annotKeyWord & other)
{
  CVSpecAttribute_annotKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CVSpecAttribute_annotKeyWord::swap(CVSpecAttribute_annotKeyWord & other)
{
  std::swap(identifier_, other.identifier_);

}

CVSpecAttribute_annotKeyWord::~CVSpecAttribute_annotKeyWord()
{
  delete(identifier_);

}

void CVSpecAttribute_annotKeyWord::accept(Visitor *v)
{
  v->visitCVSpecAttribute_annotKeyWord(this);
}

CVSpecAttribute_annotKeyWord *CVSpecAttribute_annotKeyWord::clone() const
{
  return new CVSpecAttribute_annotKeyWord(*this);
}



/********************   EmptyAttrWithASM    ********************/
EmptyAttrWithASM::EmptyAttrWithASM()
{

}

EmptyAttrWithASM::EmptyAttrWithASM(const EmptyAttrWithASM & other)
{

}

EmptyAttrWithASM &EmptyAttrWithASM::operator=(const EmptyAttrWithASM & other)
{
  EmptyAttrWithASM tmp(other);
  swap(tmp);
  return *this;
}

void EmptyAttrWithASM::swap(EmptyAttrWithASM & other)
{

}

EmptyAttrWithASM::~EmptyAttrWithASM()
{

}

void EmptyAttrWithASM::accept(Visitor *v)
{
  v->visitEmptyAttrWithASM(this);
}

EmptyAttrWithASM *EmptyAttrWithASM::clone() const
{
  return new EmptyAttrWithASM(*this);
}



/********************   ListAttrWithASM    ********************/
ListAttrWithASM::ListAttrWithASM(Attribute *p1, ListAttribute *p2)
{
  attribute_ = p1;
  listattribute_ = p2;

}

ListAttrWithASM::ListAttrWithASM(const ListAttrWithASM & other)
{
  attribute_ = other.attribute_->clone();
  listattribute_ = other.listattribute_->clone();

}

ListAttrWithASM &ListAttrWithASM::operator=(const ListAttrWithASM & other)
{
  ListAttrWithASM tmp(other);
  swap(tmp);
  return *this;
}

void ListAttrWithASM::swap(ListAttrWithASM & other)
{
  std::swap(attribute_, other.attribute_);
  std::swap(listattribute_, other.listattribute_);

}

ListAttrWithASM::~ListAttrWithASM()
{
  delete(attribute_);
  delete(listattribute_);

}

void ListAttrWithASM::accept(Visitor *v)
{
  v->visitListAttrWithASM(this);
}

ListAttrWithASM *ListAttrWithASM::clone() const
{
  return new ListAttrWithASM(*this);
}



/********************   ListASMAttrWithASM    ********************/
ListASMAttrWithASM::ListASMAttrWithASM(Attribute *p1, ListAttribute *p2, ASM p3, StringConstant *p4, ListAttribute *p5)
{
  attribute_ = p1;
  listattribute_1 = p2;
  asm_ = p3;
  stringconstant_ = p4;
  listattribute_2 = p5;

}

ListASMAttrWithASM::ListASMAttrWithASM(const ListASMAttrWithASM & other)
{
  attribute_ = other.attribute_->clone();
  listattribute_1 = other.listattribute_1->clone();
  asm_ = other.asm_;
  stringconstant_ = other.stringconstant_->clone();
  listattribute_2 = other.listattribute_2->clone();

}

ListASMAttrWithASM &ListASMAttrWithASM::operator=(const ListASMAttrWithASM & other)
{
  ListASMAttrWithASM tmp(other);
  swap(tmp);
  return *this;
}

void ListASMAttrWithASM::swap(ListASMAttrWithASM & other)
{
  std::swap(attribute_, other.attribute_);
  std::swap(listattribute_1, other.listattribute_1);
  std::swap(asm_, other.asm_);
  std::swap(stringconstant_, other.stringconstant_);
  std::swap(listattribute_2, other.listattribute_2);

}

ListASMAttrWithASM::~ListASMAttrWithASM()
{
  delete(attribute_);
  delete(listattribute_1);
  delete(stringconstant_);
  delete(listattribute_2);

}

void ListASMAttrWithASM::accept(Visitor *v)
{
  v->visitListASMAttrWithASM(this);
}

ListASMAttrWithASM *ListASMAttrWithASM::clone() const
{
  return new ListASMAttrWithASM(*this);
}



/********************   ASMAttrWithASM    ********************/
ASMAttrWithASM::ASMAttrWithASM(ASM p1, StringConstant *p2, ListAttribute *p3)
{
  asm_ = p1;
  stringconstant_ = p2;
  listattribute_ = p3;

}

ASMAttrWithASM::ASMAttrWithASM(const ASMAttrWithASM & other)
{
  asm_ = other.asm_;
  stringconstant_ = other.stringconstant_->clone();
  listattribute_ = other.listattribute_->clone();

}

ASMAttrWithASM &ASMAttrWithASM::operator=(const ASMAttrWithASM & other)
{
  ASMAttrWithASM tmp(other);
  swap(tmp);
  return *this;
}

void ASMAttrWithASM::swap(ASMAttrWithASM & other)
{
  std::swap(asm_, other.asm_);
  std::swap(stringconstant_, other.stringconstant_);
  std::swap(listattribute_, other.listattribute_);

}

ASMAttrWithASM::~ASMAttrWithASM()
{
  delete(stringconstant_);
  delete(listattribute_);

}

void ASMAttrWithASM::accept(Visitor *v)
{
  v->visitASMAttrWithASM(this);
}

ASMAttrWithASM *ASMAttrWithASM::clone() const
{
  return new ASMAttrWithASM(*this);
}



/********************   AttributeAttrNocv    ********************/
AttributeAttrNocv::AttributeAttrNocv(ATTRIBUTE p1, AttrList *p2)
{
  attribute_ = p1;
  attrlist_ = p2;

}

AttributeAttrNocv::AttributeAttrNocv(const AttributeAttrNocv & other)
{
  attribute_ = other.attribute_;
  attrlist_ = other.attrlist_->clone();

}

AttributeAttrNocv &AttributeAttrNocv::operator=(const AttributeAttrNocv & other)
{
  AttributeAttrNocv tmp(other);
  swap(tmp);
  return *this;
}

void AttributeAttrNocv::swap(AttributeAttrNocv & other)
{
  std::swap(attribute_, other.attribute_);
  std::swap(attrlist_, other.attrlist_);

}

AttributeAttrNocv::~AttributeAttrNocv()
{
  delete(attrlist_);

}

void AttributeAttrNocv::accept(Visitor *v)
{
  v->visitAttributeAttrNocv(this);
}

AttributeAttrNocv *AttributeAttrNocv::clone() const
{
  return new AttributeAttrNocv(*this);
}



/********************   DeclspecAttrNocv    ********************/
DeclspecAttrNocv::DeclspecAttrNocv(ListAttr *p1)
{
  listattr_ = p1;

}

DeclspecAttrNocv::DeclspecAttrNocv(const DeclspecAttrNocv & other)
{
  listattr_ = other.listattr_->clone();

}

DeclspecAttrNocv &DeclspecAttrNocv::operator=(const DeclspecAttrNocv & other)
{
  DeclspecAttrNocv tmp(other);
  swap(tmp);
  return *this;
}

void DeclspecAttrNocv::swap(DeclspecAttrNocv & other)
{
  std::swap(listattr_, other.listattr_);

}

DeclspecAttrNocv::~DeclspecAttrNocv()
{
  delete(listattr_);

}

void DeclspecAttrNocv::accept(Visitor *v)
{
  v->visitDeclspecAttrNocv(this);
}

DeclspecAttrNocv *DeclspecAttrNocv::clone() const
{
  return new DeclspecAttrNocv(*this);
}



/********************   MsattrAttrNocv    ********************/
MsattrAttrNocv::MsattrAttrNocv(MSATTR p1)
{
  msattr_ = p1;

}

MsattrAttrNocv::MsattrAttrNocv(const MsattrAttrNocv & other)
{
  msattr_ = other.msattr_;

}

MsattrAttrNocv &MsattrAttrNocv::operator=(const MsattrAttrNocv & other)
{
  MsattrAttrNocv tmp(other);
  swap(tmp);
  return *this;
}

void MsattrAttrNocv::swap(MsattrAttrNocv & other)
{
  std::swap(msattr_, other.msattr_);

}

MsattrAttrNocv::~MsattrAttrNocv()
{

}

void MsattrAttrNocv::accept(Visitor *v)
{
  v->visitMsattrAttrNocv(this);
}

MsattrAttrNocv *MsattrAttrNocv::clone() const
{
  return new MsattrAttrNocv(*this);
}



/********************   ThreadAttrNocv    ********************/
ThreadAttrNocv::ThreadAttrNocv()
{

}

ThreadAttrNocv::ThreadAttrNocv(const ThreadAttrNocv & other)
{

}

ThreadAttrNocv &ThreadAttrNocv::operator=(const ThreadAttrNocv & other)
{
  ThreadAttrNocv tmp(other);
  swap(tmp);
  return *this;
}

void ThreadAttrNocv::swap(ThreadAttrNocv & other)
{

}

ThreadAttrNocv::~ThreadAttrNocv()
{

}

void ThreadAttrNocv::accept(Visitor *v)
{
  v->visitThreadAttrNocv(this);
}

ThreadAttrNocv *ThreadAttrNocv::clone() const
{
  return new ThreadAttrNocv(*this);
}



/********************   ThreadLocalAttrNocv    ********************/
ThreadLocalAttrNocv::ThreadLocalAttrNocv()
{

}

ThreadLocalAttrNocv::ThreadLocalAttrNocv(const ThreadLocalAttrNocv & other)
{

}

ThreadLocalAttrNocv &ThreadLocalAttrNocv::operator=(const ThreadLocalAttrNocv & other)
{
  ThreadLocalAttrNocv tmp(other);
  swap(tmp);
  return *this;
}

void ThreadLocalAttrNocv::swap(ThreadLocalAttrNocv & other)
{

}

ThreadLocalAttrNocv::~ThreadLocalAttrNocv()
{

}

void ThreadLocalAttrNocv::accept(Visitor *v)
{
  v->visitThreadLocalAttrNocv(this);
}

ThreadLocalAttrNocv *ThreadLocalAttrNocv::clone() const
{
  return new ThreadLocalAttrNocv(*this);
}



/********************   AttributeNoCV    ********************/
AttributeNoCV::AttributeNoCV(AttributeNocv *p1)
{
  attributenocv_ = p1;

}

AttributeNoCV::AttributeNoCV(const AttributeNoCV & other)
{
  attributenocv_ = other.attributenocv_->clone();

}

AttributeNoCV &AttributeNoCV::operator=(const AttributeNoCV & other)
{
  AttributeNoCV tmp(other);
  swap(tmp);
  return *this;
}

void AttributeNoCV::swap(AttributeNoCV & other)
{
  std::swap(attributenocv_, other.attributenocv_);

}

AttributeNoCV::~AttributeNoCV()
{
  delete(attributenocv_);

}

void AttributeNoCV::accept(Visitor *v)
{
  v->visitAttributeNoCV(this);
}

AttributeNoCV *AttributeNoCV::clone() const
{
  return new AttributeNoCV(*this);
}



/********************   AttributeConst    ********************/
AttributeConst::AttributeConst(CONST p1)
{
  const_ = p1;

}

AttributeConst::AttributeConst(const AttributeConst & other)
{
  const_ = other.const_;

}

AttributeConst &AttributeConst::operator=(const AttributeConst & other)
{
  AttributeConst tmp(other);
  swap(tmp);
  return *this;
}

void AttributeConst::swap(AttributeConst & other)
{
  std::swap(const_, other.const_);

}

AttributeConst::~AttributeConst()
{

}

void AttributeConst::accept(Visitor *v)
{
  v->visitAttributeConst(this);
}

AttributeConst *AttributeConst::clone() const
{
  return new AttributeConst(*this);
}



/********************   AttributeRestrict    ********************/
AttributeRestrict::AttributeRestrict(RESTRICT p1)
{
  restrict_ = p1;

}

AttributeRestrict::AttributeRestrict(const AttributeRestrict & other)
{
  restrict_ = other.restrict_;

}

AttributeRestrict &AttributeRestrict::operator=(const AttributeRestrict & other)
{
  AttributeRestrict tmp(other);
  swap(tmp);
  return *this;
}

void AttributeRestrict::swap(AttributeRestrict & other)
{
  std::swap(restrict_, other.restrict_);

}

AttributeRestrict::~AttributeRestrict()
{

}

void AttributeRestrict::accept(Visitor *v)
{
  v->visitAttributeRestrict(this);
}

AttributeRestrict *AttributeRestrict::clone() const
{
  return new AttributeRestrict(*this);
}



/********************   AttributeVolatile    ********************/
AttributeVolatile::AttributeVolatile(VOLATILE p1)
{
  volatile_ = p1;

}

AttributeVolatile::AttributeVolatile(const AttributeVolatile & other)
{
  volatile_ = other.volatile_;

}

AttributeVolatile &AttributeVolatile::operator=(const AttributeVolatile & other)
{
  AttributeVolatile tmp(other);
  swap(tmp);
  return *this;
}

void AttributeVolatile::swap(AttributeVolatile & other)
{
  std::swap(volatile_, other.volatile_);

}

AttributeVolatile::~AttributeVolatile()
{

}

void AttributeVolatile::accept(Visitor *v)
{
  v->visitAttributeVolatile(this);
}

AttributeVolatile *AttributeVolatile::clone() const
{
  return new AttributeVolatile(*this);
}



/********************   AttributeGhost    ********************/
AttributeGhost::AttributeGhost()
{

}

AttributeGhost::AttributeGhost(const AttributeGhost & other)
{

}

AttributeGhost &AttributeGhost::operator=(const AttributeGhost & other)
{
  AttributeGhost tmp(other);
  swap(tmp);
  return *this;
}

void AttributeGhost::swap(AttributeGhost & other)
{

}

AttributeGhost::~AttributeGhost()
{

}

void AttributeGhost::accept(Visitor *v)
{
  v->visitAttributeGhost(this);
}

AttributeGhost *AttributeGhost::clone() const
{
  return new AttributeGhost(*this);
}



/********************   AttributeAttributeAnnot    ********************/
AttributeAttributeAnnot::AttributeAttributeAnnot(Identifier *p1)
{
  identifier_ = p1;

}

AttributeAttributeAnnot::AttributeAttributeAnnot(const AttributeAttributeAnnot & other)
{
  identifier_ = other.identifier_->clone();

}

AttributeAttributeAnnot &AttributeAttributeAnnot::operator=(const AttributeAttributeAnnot & other)
{
  AttributeAttributeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void AttributeAttributeAnnot::swap(AttributeAttributeAnnot & other)
{
  std::swap(identifier_, other.identifier_);

}

AttributeAttributeAnnot::~AttributeAttributeAnnot()
{
  delete(identifier_);

}

void AttributeAttributeAnnot::accept(Visitor *v)
{
  v->visitAttributeAttributeAnnot(this);
}

AttributeAttributeAnnot *AttributeAttributeAnnot::clone() const
{
  return new AttributeAttributeAnnot(*this);
}



/********************   AttributeJustAttribute    ********************/
AttributeJustAttribute::AttributeJustAttribute(ATTRIBUTE p1, AttrList *p2)
{
  attribute_ = p1;
  attrlist_ = p2;

}

AttributeJustAttribute::AttributeJustAttribute(const AttributeJustAttribute & other)
{
  attribute_ = other.attribute_;
  attrlist_ = other.attrlist_->clone();

}

AttributeJustAttribute &AttributeJustAttribute::operator=(const AttributeJustAttribute & other)
{
  AttributeJustAttribute tmp(other);
  swap(tmp);
  return *this;
}

void AttributeJustAttribute::swap(AttributeJustAttribute & other)
{
  std::swap(attribute_, other.attribute_);
  std::swap(attrlist_, other.attrlist_);

}

AttributeJustAttribute::~AttributeJustAttribute()
{
  delete(attrlist_);

}

void AttributeJustAttribute::accept(Visitor *v)
{
  v->visitAttributeJustAttribute(this);
}

AttributeJustAttribute *AttributeJustAttribute::clone() const
{
  return new AttributeJustAttribute(*this);
}



/********************   DeclspecJustAttribute    ********************/
DeclspecJustAttribute::DeclspecJustAttribute(ListAttr *p1)
{
  listattr_ = p1;

}

DeclspecJustAttribute::DeclspecJustAttribute(const DeclspecJustAttribute & other)
{
  listattr_ = other.listattr_->clone();

}

DeclspecJustAttribute &DeclspecJustAttribute::operator=(const DeclspecJustAttribute & other)
{
  DeclspecJustAttribute tmp(other);
  swap(tmp);
  return *this;
}

void DeclspecJustAttribute::swap(DeclspecJustAttribute & other)
{
  std::swap(listattr_, other.listattr_);

}

DeclspecJustAttribute::~DeclspecJustAttribute()
{
  delete(listattr_);

}

void DeclspecJustAttribute::accept(Visitor *v)
{
  v->visitDeclspecJustAttribute(this);
}

DeclspecJustAttribute *DeclspecJustAttribute::clone() const
{
  return new DeclspecJustAttribute(*this);
}



/********************   SimplePragma    ********************/
SimplePragma::SimplePragma()
{

}

SimplePragma::SimplePragma(const SimplePragma & other)
{

}

SimplePragma &SimplePragma::operator=(const SimplePragma & other)
{
  SimplePragma tmp(other);
  swap(tmp);
  return *this;
}

void SimplePragma::swap(SimplePragma & other)
{

}

SimplePragma::~SimplePragma()
{

}

void SimplePragma::accept(Visitor *v)
{
  v->visitSimplePragma(this);
}

SimplePragma *SimplePragma::clone() const
{
  return new SimplePragma(*this);
}



/********************   AttrPragma    ********************/
AttrPragma::AttrPragma(Attr *p1)
{
  attr_ = p1;

}

AttrPragma::AttrPragma(const AttrPragma & other)
{
  attr_ = other.attr_->clone();

}

AttrPragma &AttrPragma::operator=(const AttrPragma & other)
{
  AttrPragma tmp(other);
  swap(tmp);
  return *this;
}

void AttrPragma::swap(AttrPragma & other)
{
  std::swap(attr_, other.attr_);

}

AttrPragma::~AttrPragma()
{
  delete(attr_);

}

void AttrPragma::accept(Visitor *v)
{
  v->visitAttrPragma(this);
}

AttrPragma *AttrPragma::clone() const
{
  return new AttrPragma(*this);
}



/********************   AttrPragmaSeparated    ********************/
AttrPragmaSeparated::AttrPragmaSeparated(Attr *p1)
{
  attr_ = p1;

}

AttrPragmaSeparated::AttrPragmaSeparated(const AttrPragmaSeparated & other)
{
  attr_ = other.attr_->clone();

}

AttrPragmaSeparated &AttrPragmaSeparated::operator=(const AttrPragmaSeparated & other)
{
  AttrPragmaSeparated tmp(other);
  swap(tmp);
  return *this;
}

void AttrPragmaSeparated::swap(AttrPragmaSeparated & other)
{
  std::swap(attr_, other.attr_);

}

AttrPragmaSeparated::~AttrPragmaSeparated()
{
  delete(attr_);

}

void AttrPragmaSeparated::accept(Visitor *v)
{
  v->visitAttrPragmaSeparated(this);
}

AttrPragmaSeparated *AttrPragmaSeparated::clone() const
{
  return new AttrPragmaSeparated(*this);
}



/********************   PragmaKeyrod    ********************/
PragmaKeyrod::PragmaKeyrod()
{

}

PragmaKeyrod::PragmaKeyrod(const PragmaKeyrod & other)
{

}

PragmaKeyrod &PragmaKeyrod::operator=(const PragmaKeyrod & other)
{
  PragmaKeyrod tmp(other);
  swap(tmp);
  return *this;
}

void PragmaKeyrod::swap(PragmaKeyrod & other)
{

}

PragmaKeyrod::~PragmaKeyrod()
{

}

void PragmaKeyrod::accept(Visitor *v)
{
  v->visitPragmaKeyrod(this);
}

PragmaKeyrod *PragmaKeyrod::clone() const
{
  return new PragmaKeyrod(*this);
}



/********************   IdentifierVarAttr    ********************/
IdentifierVarAttr::IdentifierVarAttr(Ident p1)
{
  ident_ = p1;

}

IdentifierVarAttr::IdentifierVarAttr(const IdentifierVarAttr & other)
{
  ident_ = other.ident_;

}

IdentifierVarAttr &IdentifierVarAttr::operator=(const IdentifierVarAttr & other)
{
  IdentifierVarAttr tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierVarAttr::swap(IdentifierVarAttr & other)
{
  std::swap(ident_, other.ident_);

}

IdentifierVarAttr::~IdentifierVarAttr()
{

}

void IdentifierVarAttr::accept(Visitor *v)
{
  v->visitIdentifierVarAttr(this);
}

IdentifierVarAttr *IdentifierVarAttr::clone() const
{
  return new IdentifierVarAttr(*this);
}



/********************   NamedTypeVarAttr    ********************/
NamedTypeVarAttr::NamedTypeVarAttr(NAMEDTYPE p1)
{
  namedtype_ = p1;

}

NamedTypeVarAttr::NamedTypeVarAttr(const NamedTypeVarAttr & other)
{
  namedtype_ = other.namedtype_;

}

NamedTypeVarAttr &NamedTypeVarAttr::operator=(const NamedTypeVarAttr & other)
{
  NamedTypeVarAttr tmp(other);
  swap(tmp);
  return *this;
}

void NamedTypeVarAttr::swap(NamedTypeVarAttr & other)
{
  std::swap(namedtype_, other.namedtype_);

}

NamedTypeVarAttr::~NamedTypeVarAttr()
{

}

void NamedTypeVarAttr::accept(Visitor *v)
{
  v->visitNamedTypeVarAttr(this);
}

NamedTypeVarAttr *NamedTypeVarAttr::clone() const
{
  return new NamedTypeVarAttr(*this);
}



/********************   DefaultVarAttr    ********************/
DefaultVarAttr::DefaultVarAttr(Integer p1)
{
  integer_ = p1;

}

DefaultVarAttr::DefaultVarAttr(const DefaultVarAttr & other)
{
  integer_ = other.integer_;

}

DefaultVarAttr &DefaultVarAttr::operator=(const DefaultVarAttr & other)
{
  DefaultVarAttr tmp(other);
  swap(tmp);
  return *this;
}

void DefaultVarAttr::swap(DefaultVarAttr & other)
{
  std::swap(integer_, other.integer_);

}

DefaultVarAttr::~DefaultVarAttr()
{

}

void DefaultVarAttr::accept(Visitor *v)
{
  v->visitDefaultVarAttr(this);
}

DefaultVarAttr *DefaultVarAttr::clone() const
{
  return new DefaultVarAttr(*this);
}



/********************   ConstVarAttr    ********************/
ConstVarAttr::ConstVarAttr(CONST p1)
{
  const_ = p1;

}

ConstVarAttr::ConstVarAttr(const ConstVarAttr & other)
{
  const_ = other.const_;

}

ConstVarAttr &ConstVarAttr::operator=(const ConstVarAttr & other)
{
  ConstVarAttr tmp(other);
  swap(tmp);
  return *this;
}

void ConstVarAttr::swap(ConstVarAttr & other)
{
  std::swap(const_, other.const_);

}

ConstVarAttr::~ConstVarAttr()
{

}

void ConstVarAttr::accept(Visitor *v)
{
  v->visitConstVarAttr(this);
}

ConstVarAttr *ConstVarAttr::clone() const
{
  return new ConstVarAttr(*this);
}



/********************   VolatileVarAttr    ********************/
VolatileVarAttr::VolatileVarAttr(VOLATILE p1)
{
  volatile_ = p1;

}

VolatileVarAttr::VolatileVarAttr(const VolatileVarAttr & other)
{
  volatile_ = other.volatile_;

}

VolatileVarAttr &VolatileVarAttr::operator=(const VolatileVarAttr & other)
{
  VolatileVarAttr tmp(other);
  swap(tmp);
  return *this;
}

void VolatileVarAttr::swap(VolatileVarAttr & other)
{
  std::swap(volatile_, other.volatile_);

}

VolatileVarAttr::~VolatileVarAttr()
{

}

void VolatileVarAttr::accept(Visitor *v)
{
  v->visitVolatileVarAttr(this);
}

VolatileVarAttr *VolatileVarAttr::clone() const
{
  return new VolatileVarAttr(*this);
}



/********************   ContIntVarAttr    ********************/
ContIntVarAttr::ContIntVarAttr(Integer p1, Integer p2)
{
  integer_1 = p1;
  integer_2 = p2;

}

ContIntVarAttr::ContIntVarAttr(const ContIntVarAttr & other)
{
  integer_1 = other.integer_1;
  integer_2 = other.integer_2;

}

ContIntVarAttr &ContIntVarAttr::operator=(const ContIntVarAttr & other)
{
  ContIntVarAttr tmp(other);
  swap(tmp);
  return *this;
}

void ContIntVarAttr::swap(ContIntVarAttr & other)
{
  std::swap(integer_1, other.integer_1);
  std::swap(integer_2, other.integer_2);

}

ContIntVarAttr::~ContIntVarAttr()
{

}

void ContIntVarAttr::accept(Visitor *v)
{
  v->visitContIntVarAttr(this);
}

ContIntVarAttr *ContIntVarAttr::clone() const
{
  return new ContIntVarAttr(*this);
}



/********************   BasicAttrConsInt    ********************/
BasicAttrConsInt::BasicAttrConsInt(Integer p1)
{
  integer_ = p1;

}

BasicAttrConsInt::BasicAttrConsInt(const BasicAttrConsInt & other)
{
  integer_ = other.integer_;

}

BasicAttrConsInt &BasicAttrConsInt::operator=(const BasicAttrConsInt & other)
{
  BasicAttrConsInt tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttrConsInt::swap(BasicAttrConsInt & other)
{
  std::swap(integer_, other.integer_);

}

BasicAttrConsInt::~BasicAttrConsInt()
{

}

void BasicAttrConsInt::accept(Visitor *v)
{
  v->visitBasicAttrConsInt(this);
}

BasicAttrConsInt *BasicAttrConsInt::clone() const
{
  return new BasicAttrConsInt(*this);
}



/********************   BasicAttrConsFloat    ********************/
BasicAttrConsFloat::BasicAttrConsFloat(Double p1)
{
  double_ = p1;

}

BasicAttrConsFloat::BasicAttrConsFloat(const BasicAttrConsFloat & other)
{
  double_ = other.double_;

}

BasicAttrConsFloat &BasicAttrConsFloat::operator=(const BasicAttrConsFloat & other)
{
  BasicAttrConsFloat tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttrConsFloat::swap(BasicAttrConsFloat & other)
{
  std::swap(double_, other.double_);

}

BasicAttrConsFloat::~BasicAttrConsFloat()
{

}

void BasicAttrConsFloat::accept(Visitor *v)
{
  v->visitBasicAttrConsFloat(this);
}

BasicAttrConsFloat *BasicAttrConsFloat::clone() const
{
  return new BasicAttrConsFloat(*this);
}



/********************   BasicAttrVar    ********************/
BasicAttrVar::BasicAttrVar(VarAttr *p1)
{
  varattr_ = p1;

}

BasicAttrVar::BasicAttrVar(const BasicAttrVar & other)
{
  varattr_ = other.varattr_->clone();

}

BasicAttrVar &BasicAttrVar::operator=(const BasicAttrVar & other)
{
  BasicAttrVar tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttrVar::swap(BasicAttrVar & other)
{
  std::swap(varattr_, other.varattr_);

}

BasicAttrVar::~BasicAttrVar()
{
  delete(varattr_);

}

void BasicAttrVar::accept(Visitor *v)
{
  v->visitBasicAttrVar(this);
}

BasicAttrVar *BasicAttrVar::clone() const
{
  return new BasicAttrVar(*this);
}



/********************   ParameterBasicAttr    ********************/
ParameterBasicAttr::ParameterBasicAttr(ListBasicAttribute *p1)
{
  listbasicattribute_ = p1;

}

ParameterBasicAttr::ParameterBasicAttr(const ParameterBasicAttr & other)
{
  listbasicattribute_ = other.listbasicattribute_->clone();

}

ParameterBasicAttr &ParameterBasicAttr::operator=(const ParameterBasicAttr & other)
{
  ParameterBasicAttr tmp(other);
  swap(tmp);
  return *this;
}

void ParameterBasicAttr::swap(ParameterBasicAttr & other)
{
  std::swap(listbasicattribute_, other.listbasicattribute_);

}

ParameterBasicAttr::~ParameterBasicAttr()
{
  delete(listbasicattribute_);

}

void ParameterBasicAttr::accept(Visitor *v)
{
  v->visitParameterBasicAttr(this);
}

ParameterBasicAttr *ParameterBasicAttr::clone() const
{
  return new ParameterBasicAttr(*this);
}



/********************   ParameterBasicAttrStringConst    ********************/
ParameterBasicAttrStringConst::ParameterBasicAttrStringConst(ListBasicAttribute *p1, StringConstant *p2)
{
  listbasicattribute_ = p1;
  stringconstant_ = p2;

}

ParameterBasicAttrStringConst::ParameterBasicAttrStringConst(const ParameterBasicAttrStringConst & other)
{
  listbasicattribute_ = other.listbasicattribute_->clone();
  stringconstant_ = other.stringconstant_->clone();

}

ParameterBasicAttrStringConst &ParameterBasicAttrStringConst::operator=(const ParameterBasicAttrStringConst & other)
{
  ParameterBasicAttrStringConst tmp(other);
  swap(tmp);
  return *this;
}

void ParameterBasicAttrStringConst::swap(ParameterBasicAttrStringConst & other)
{
  std::swap(listbasicattribute_, other.listbasicattribute_);
  std::swap(stringconstant_, other.stringconstant_);

}

ParameterBasicAttrStringConst::~ParameterBasicAttrStringConst()
{
  delete(listbasicattribute_);
  delete(stringconstant_);

}

void ParameterBasicAttrStringConst::accept(Visitor *v)
{
  v->visitParameterBasicAttrStringConst(this);
}

ParameterBasicAttrStringConst *ParameterBasicAttrStringConst::clone() const
{
  return new ParameterBasicAttrStringConst(*this);
}



/********************   ParameterBasicAttrStringConstNext    ********************/
ParameterBasicAttrStringConstNext::ParameterBasicAttrStringConstNext(ListBasicAttribute *p1, StringConstant *p2, ParameterAttrListNE *p3)
{
  listbasicattribute_ = p1;
  stringconstant_ = p2;
  parameterattrlistne_ = p3;

}

ParameterBasicAttrStringConstNext::ParameterBasicAttrStringConstNext(const ParameterBasicAttrStringConstNext & other)
{
  listbasicattribute_ = other.listbasicattribute_->clone();
  stringconstant_ = other.stringconstant_->clone();
  parameterattrlistne_ = other.parameterattrlistne_->clone();

}

ParameterBasicAttrStringConstNext &ParameterBasicAttrStringConstNext::operator=(const ParameterBasicAttrStringConstNext & other)
{
  ParameterBasicAttrStringConstNext tmp(other);
  swap(tmp);
  return *this;
}

void ParameterBasicAttrStringConstNext::swap(ParameterBasicAttrStringConstNext & other)
{
  std::swap(listbasicattribute_, other.listbasicattribute_);
  std::swap(stringconstant_, other.stringconstant_);
  std::swap(parameterattrlistne_, other.parameterattrlistne_);

}

ParameterBasicAttrStringConstNext::~ParameterBasicAttrStringConstNext()
{
  delete(listbasicattribute_);
  delete(stringconstant_);
  delete(parameterattrlistne_);

}

void ParameterBasicAttrStringConstNext::accept(Visitor *v)
{
  v->visitParameterBasicAttrStringConstNext(this);
}

ParameterBasicAttrStringConstNext *ParameterBasicAttrStringConstNext::clone() const
{
  return new ParameterBasicAttrStringConstNext(*this);
}



/********************   ParamAttrList    ********************/
ParamAttrList::ParamAttrList(ParameterAttrListNE *p1)
{
  parameterattrlistne_ = p1;

}

ParamAttrList::ParamAttrList(const ParamAttrList & other)
{
  parameterattrlistne_ = other.parameterattrlistne_->clone();

}

ParamAttrList &ParamAttrList::operator=(const ParamAttrList & other)
{
  ParamAttrList tmp(other);
  swap(tmp);
  return *this;
}

void ParamAttrList::swap(ParamAttrList & other)
{
  std::swap(parameterattrlistne_, other.parameterattrlistne_);

}

ParamAttrList::~ParamAttrList()
{
  delete(parameterattrlistne_);

}

void ParamAttrList::accept(Visitor *v)
{
  v->visitParamAttrList(this);
}

ParamAttrList *ParamAttrList::clone() const
{
  return new ParamAttrList(*this);
}



/********************   ParamStringConstant    ********************/
ParamStringConstant::ParamStringConstant(StringConstant *p1)
{
  stringconstant_ = p1;

}

ParamStringConstant::ParamStringConstant(const ParamStringConstant & other)
{
  stringconstant_ = other.stringconstant_->clone();

}

ParamStringConstant &ParamStringConstant::operator=(const ParamStringConstant & other)
{
  ParamStringConstant tmp(other);
  swap(tmp);
  return *this;
}

void ParamStringConstant::swap(ParamStringConstant & other)
{
  std::swap(stringconstant_, other.stringconstant_);

}

ParamStringConstant::~ParamStringConstant()
{
  delete(stringconstant_);

}

void ParamStringConstant::accept(Visitor *v)
{
  v->visitParamStringConstant(this);
}

ParamStringConstant *ParamStringConstant::clone() const
{
  return new ParamStringConstant(*this);
}



/********************   BasicAttr    ********************/
BasicAttr::BasicAttr(BasicAttribute *p1)
{
  basicattribute_ = p1;

}

BasicAttr::BasicAttr(const BasicAttr & other)
{
  basicattribute_ = other.basicattribute_->clone();

}

BasicAttr &BasicAttr::operator=(const BasicAttr & other)
{
  BasicAttr tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttr::swap(BasicAttr & other)
{
  std::swap(basicattribute_, other.basicattribute_);

}

BasicAttr::~BasicAttr()
{
  delete(basicattribute_);

}

void BasicAttr::accept(Visitor *v)
{
  v->visitBasicAttr(this);
}

BasicAttr *BasicAttr::clone() const
{
  return new BasicAttr(*this);
}



/********************   AttrStringConstant    ********************/
AttrStringConstant::AttrStringConstant(StringConstant *p1)
{
  stringconstant_ = p1;

}

AttrStringConstant::AttrStringConstant(const AttrStringConstant & other)
{
  stringconstant_ = other.stringconstant_->clone();

}

AttrStringConstant &AttrStringConstant::operator=(const AttrStringConstant & other)
{
  AttrStringConstant tmp(other);
  swap(tmp);
  return *this;
}

void AttrStringConstant::swap(AttrStringConstant & other)
{
  std::swap(stringconstant_, other.stringconstant_);

}

AttrStringConstant::~AttrStringConstant()
{
  delete(stringconstant_);

}

void AttrStringConstant::accept(Visitor *v)
{
  v->visitAttrStringConstant(this);
}

AttrStringConstant *AttrStringConstant::clone() const
{
  return new AttrStringConstant(*this);
}



/********************   FuncationCall    ********************/
FuncationCall::FuncationCall(IdOrTypenameAsId *p1, ListAttr *p2)
{
  idortypenameasid_ = p1;
  listattr_ = p2;

}

FuncationCall::FuncationCall(const FuncationCall & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();
  listattr_ = other.listattr_->clone();

}

FuncationCall &FuncationCall::operator=(const FuncationCall & other)
{
  FuncationCall tmp(other);
  swap(tmp);
  return *this;
}

void FuncationCall::swap(FuncationCall & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);
  std::swap(listattr_, other.listattr_);

}

FuncationCall::~FuncationCall()
{
  delete(idortypenameasid_);
  delete(listattr_);

}

void FuncationCall::accept(Visitor *v)
{
  v->visitFuncationCall(this);
}

FuncationCall *FuncationCall::clone() const
{
  return new FuncationCall(*this);
}



/********************   ProcedureCall    ********************/
ProcedureCall::ProcedureCall(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

ProcedureCall::ProcedureCall(const ProcedureCall & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

ProcedureCall &ProcedureCall::operator=(const ProcedureCall & other)
{
  ProcedureCall tmp(other);
  swap(tmp);
  return *this;
}

void ProcedureCall::swap(ProcedureCall & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

ProcedureCall::~ProcedureCall()
{
  delete(idortypenameasid_);

}

void ProcedureCall::accept(Visitor *v)
{
  v->visitProcedureCall(this);
}

ProcedureCall *ProcedureCall::clone() const
{
  return new ProcedureCall(*this);
}



/********************   BasicPostfix    ********************/
BasicPostfix::BasicPostfix(BasicAttribute *p1, ParamAttrListNE *p2)
{
  basicattribute_ = p1;
  paramattrlistne_ = p2;

}

BasicPostfix::BasicPostfix(const BasicPostfix & other)
{
  basicattribute_ = other.basicattribute_->clone();
  paramattrlistne_ = other.paramattrlistne_->clone();

}

BasicPostfix &BasicPostfix::operator=(const BasicPostfix & other)
{
  BasicPostfix tmp(other);
  swap(tmp);
  return *this;
}

void BasicPostfix::swap(BasicPostfix & other)
{
  std::swap(basicattribute_, other.basicattribute_);
  std::swap(paramattrlistne_, other.paramattrlistne_);

}

BasicPostfix::~BasicPostfix()
{
  delete(basicattribute_);
  delete(paramattrlistne_);

}

void BasicPostfix::accept(Visitor *v)
{
  v->visitBasicPostfix(this);
}

BasicPostfix *BasicPostfix::clone() const
{
  return new BasicPostfix(*this);
}



/********************   ArrowAttr    ********************/
ArrowAttr::ArrowAttr(Attr *p1, IdOrTypename *p2)
{
  attr_ = p1;
  idortypename_ = p2;

}

ArrowAttr::ArrowAttr(const ArrowAttr & other)
{
  attr_ = other.attr_->clone();
  idortypename_ = other.idortypename_->clone();

}

ArrowAttr &ArrowAttr::operator=(const ArrowAttr & other)
{
  ArrowAttr tmp(other);
  swap(tmp);
  return *this;
}

void ArrowAttr::swap(ArrowAttr & other)
{
  std::swap(attr_, other.attr_);
  std::swap(idortypename_, other.idortypename_);

}

ArrowAttr::~ArrowAttr()
{
  delete(attr_);
  delete(idortypename_);

}

void ArrowAttr::accept(Visitor *v)
{
  v->visitArrowAttr(this);
}

ArrowAttr *ArrowAttr::clone() const
{
  return new ArrowAttr(*this);
}



/********************   DotAttr    ********************/
DotAttr::DotAttr(Attr *p1, IdOrTypename *p2)
{
  attr_ = p1;
  idortypename_ = p2;

}

DotAttr::DotAttr(const DotAttr & other)
{
  attr_ = other.attr_->clone();
  idortypename_ = other.idortypename_->clone();

}

DotAttr &DotAttr::operator=(const DotAttr & other)
{
  DotAttr tmp(other);
  swap(tmp);
  return *this;
}

void DotAttr::swap(DotAttr & other)
{
  std::swap(attr_, other.attr_);
  std::swap(idortypename_, other.idortypename_);

}

DotAttr::~DotAttr()
{
  delete(attr_);
  delete(idortypename_);

}

void DotAttr::accept(Visitor *v)
{
  v->visitDotAttr(this);
}

DotAttr *DotAttr::clone() const
{
  return new DotAttr(*this);
}



/********************   ArrayAttr    ********************/
ArrayAttr::ArrayAttr(Attr *p1, LBRACKET p2, Attr *p3, RBRACKET p4)
{
  attr_1 = p1;
  lbracket_ = p2;
  attr_2 = p3;
  rbracket_ = p4;

}

ArrayAttr::ArrayAttr(const ArrayAttr & other)
{
  attr_1 = other.attr_1->clone();
  lbracket_ = other.lbracket_;
  attr_2 = other.attr_2->clone();
  rbracket_ = other.rbracket_;

}

ArrayAttr &ArrayAttr::operator=(const ArrayAttr & other)
{
  ArrayAttr tmp(other);
  swap(tmp);
  return *this;
}

void ArrayAttr::swap(ArrayAttr & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(lbracket_, other.lbracket_);
  std::swap(attr_2, other.attr_2);
  std::swap(rbracket_, other.rbracket_);

}

ArrayAttr::~ArrayAttr()
{
  delete(attr_1);
  delete(attr_2);

}

void ArrayAttr::accept(Visitor *v)
{
  v->visitArrayAttr(this);
}

ArrayAttr *ArrayAttr::clone() const
{
  return new ArrayAttr(*this);
}



/********************   SizeOfAttrUnary    ********************/
SizeOfAttrUnary::SizeOfAttrUnary(AssignExpr *p1)
{
  assignexpr_ = p1;

}

SizeOfAttrUnary::SizeOfAttrUnary(const SizeOfAttrUnary & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

SizeOfAttrUnary &SizeOfAttrUnary::operator=(const SizeOfAttrUnary & other)
{
  SizeOfAttrUnary tmp(other);
  swap(tmp);
  return *this;
}

void SizeOfAttrUnary::swap(SizeOfAttrUnary & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

SizeOfAttrUnary::~SizeOfAttrUnary()
{
  delete(assignexpr_);

}

void SizeOfAttrUnary::accept(Visitor *v)
{
  v->visitSizeOfAttrUnary(this);
}

SizeOfAttrUnary *SizeOfAttrUnary::clone() const
{
  return new SizeOfAttrUnary(*this);
}



/********************   SizeOfAttrTypeName    ********************/
SizeOfAttrTypeName::SizeOfAttrTypeName(TypeName *p1)
{
  typename_ = p1;

}

SizeOfAttrTypeName::SizeOfAttrTypeName(const SizeOfAttrTypeName & other)
{
  typename_ = other.typename_->clone();

}

SizeOfAttrTypeName &SizeOfAttrTypeName::operator=(const SizeOfAttrTypeName & other)
{
  SizeOfAttrTypeName tmp(other);
  swap(tmp);
  return *this;
}

void SizeOfAttrTypeName::swap(SizeOfAttrTypeName & other)
{
  std::swap(typename_, other.typename_);

}

SizeOfAttrTypeName::~SizeOfAttrTypeName()
{
  delete(typename_);

}

void SizeOfAttrTypeName::accept(Visitor *v)
{
  v->visitSizeOfAttrTypeName(this);
}

SizeOfAttrTypeName *SizeOfAttrTypeName::clone() const
{
  return new SizeOfAttrTypeName(*this);
}



/********************   AlignOfAttrUnary    ********************/
AlignOfAttrUnary::AlignOfAttrUnary(ALIGNOF p1, AssignExpr *p2)
{
  alignof_ = p1;
  assignexpr_ = p2;

}

AlignOfAttrUnary::AlignOfAttrUnary(const AlignOfAttrUnary & other)
{
  alignof_ = other.alignof_;
  assignexpr_ = other.assignexpr_->clone();

}

AlignOfAttrUnary &AlignOfAttrUnary::operator=(const AlignOfAttrUnary & other)
{
  AlignOfAttrUnary tmp(other);
  swap(tmp);
  return *this;
}

void AlignOfAttrUnary::swap(AlignOfAttrUnary & other)
{
  std::swap(alignof_, other.alignof_);
  std::swap(assignexpr_, other.assignexpr_);

}

AlignOfAttrUnary::~AlignOfAttrUnary()
{
  delete(assignexpr_);

}

void AlignOfAttrUnary::accept(Visitor *v)
{
  v->visitAlignOfAttrUnary(this);
}

AlignOfAttrUnary *AlignOfAttrUnary::clone() const
{
  return new AlignOfAttrUnary(*this);
}



/********************   AlignOfAttrTypeName    ********************/
AlignOfAttrTypeName::AlignOfAttrTypeName(ALIGNOF p1, TypeName *p2)
{
  alignof_ = p1;
  typename_ = p2;

}

AlignOfAttrTypeName::AlignOfAttrTypeName(const AlignOfAttrTypeName & other)
{
  alignof_ = other.alignof_;
  typename_ = other.typename_->clone();

}

AlignOfAttrTypeName &AlignOfAttrTypeName::operator=(const AlignOfAttrTypeName & other)
{
  AlignOfAttrTypeName tmp(other);
  swap(tmp);
  return *this;
}

void AlignOfAttrTypeName::swap(AlignOfAttrTypeName & other)
{
  std::swap(alignof_, other.alignof_);
  std::swap(typename_, other.typename_);

}

AlignOfAttrTypeName::~AlignOfAttrTypeName()
{
  delete(typename_);

}

void AlignOfAttrTypeName::accept(Visitor *v)
{
  v->visitAlignOfAttrTypeName(this);
}

AlignOfAttrTypeName *AlignOfAttrTypeName::clone() const
{
  return new AlignOfAttrTypeName(*this);
}



/********************   PlusUnaryAttr    ********************/
PlusUnaryAttr::PlusUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

PlusUnaryAttr::PlusUnaryAttr(const PlusUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

PlusUnaryAttr &PlusUnaryAttr::operator=(const PlusUnaryAttr & other)
{
  PlusUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void PlusUnaryAttr::swap(PlusUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

PlusUnaryAttr::~PlusUnaryAttr()
{
  delete(attr_);

}

void PlusUnaryAttr::accept(Visitor *v)
{
  v->visitPlusUnaryAttr(this);
}

PlusUnaryAttr *PlusUnaryAttr::clone() const
{
  return new PlusUnaryAttr(*this);
}



/********************   MinusUnaryAttr    ********************/
MinusUnaryAttr::MinusUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

MinusUnaryAttr::MinusUnaryAttr(const MinusUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

MinusUnaryAttr &MinusUnaryAttr::operator=(const MinusUnaryAttr & other)
{
  MinusUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void MinusUnaryAttr::swap(MinusUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

MinusUnaryAttr::~MinusUnaryAttr()
{
  delete(attr_);

}

void MinusUnaryAttr::accept(Visitor *v)
{
  v->visitMinusUnaryAttr(this);
}

MinusUnaryAttr *MinusUnaryAttr::clone() const
{
  return new MinusUnaryAttr(*this);
}



/********************   MultUnaryAttr    ********************/
MultUnaryAttr::MultUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

MultUnaryAttr::MultUnaryAttr(const MultUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

MultUnaryAttr &MultUnaryAttr::operator=(const MultUnaryAttr & other)
{
  MultUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void MultUnaryAttr::swap(MultUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

MultUnaryAttr::~MultUnaryAttr()
{
  delete(attr_);

}

void MultUnaryAttr::accept(Visitor *v)
{
  v->visitMultUnaryAttr(this);
}

MultUnaryAttr *MultUnaryAttr::clone() const
{
  return new MultUnaryAttr(*this);
}



/********************   AmpUnaryAttr    ********************/
AmpUnaryAttr::AmpUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

AmpUnaryAttr::AmpUnaryAttr(const AmpUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

AmpUnaryAttr &AmpUnaryAttr::operator=(const AmpUnaryAttr & other)
{
  AmpUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void AmpUnaryAttr::swap(AmpUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

AmpUnaryAttr::~AmpUnaryAttr()
{
  delete(attr_);

}

void AmpUnaryAttr::accept(Visitor *v)
{
  v->visitAmpUnaryAttr(this);
}

AmpUnaryAttr *AmpUnaryAttr::clone() const
{
  return new AmpUnaryAttr(*this);
}



/********************   NotUnaryAttr    ********************/
NotUnaryAttr::NotUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

NotUnaryAttr::NotUnaryAttr(const NotUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

NotUnaryAttr &NotUnaryAttr::operator=(const NotUnaryAttr & other)
{
  NotUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void NotUnaryAttr::swap(NotUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

NotUnaryAttr::~NotUnaryAttr()
{
  delete(attr_);

}

void NotUnaryAttr::accept(Visitor *v)
{
  v->visitNotUnaryAttr(this);
}

NotUnaryAttr *NotUnaryAttr::clone() const
{
  return new NotUnaryAttr(*this);
}



/********************   TildeUnaryAttr    ********************/
TildeUnaryAttr::TildeUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

TildeUnaryAttr::TildeUnaryAttr(const TildeUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

TildeUnaryAttr &TildeUnaryAttr::operator=(const TildeUnaryAttr & other)
{
  TildeUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void TildeUnaryAttr::swap(TildeUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

TildeUnaryAttr::~TildeUnaryAttr()
{
  delete(attr_);

}

void TildeUnaryAttr::accept(Visitor *v)
{
  v->visitTildeUnaryAttr(this);
}

TildeUnaryAttr *TildeUnaryAttr::clone() const
{
  return new TildeUnaryAttr(*this);
}



/********************   MultOp    ********************/
MultOp::MultOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

MultOp::MultOp(const MultOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

MultOp &MultOp::operator=(const MultOp & other)
{
  MultOp tmp(other);
  swap(tmp);
  return *this;
}

void MultOp::swap(MultOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

MultOp::~MultOp()
{
  delete(attr_1);
  delete(attr_2);

}

void MultOp::accept(Visitor *v)
{
  v->visitMultOp(this);
}

MultOp *MultOp::clone() const
{
  return new MultOp(*this);
}



/********************   DivOp    ********************/
DivOp::DivOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

DivOp::DivOp(const DivOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

DivOp &DivOp::operator=(const DivOp & other)
{
  DivOp tmp(other);
  swap(tmp);
  return *this;
}

void DivOp::swap(DivOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

DivOp::~DivOp()
{
  delete(attr_1);
  delete(attr_2);

}

void DivOp::accept(Visitor *v)
{
  v->visitDivOp(this);
}

DivOp *DivOp::clone() const
{
  return new DivOp(*this);
}



/********************   ModOp    ********************/
ModOp::ModOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

ModOp::ModOp(const ModOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

ModOp &ModOp::operator=(const ModOp & other)
{
  ModOp tmp(other);
  swap(tmp);
  return *this;
}

void ModOp::swap(ModOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

ModOp::~ModOp()
{
  delete(attr_1);
  delete(attr_2);

}

void ModOp::accept(Visitor *v)
{
  v->visitModOp(this);
}

ModOp *ModOp::clone() const
{
  return new ModOp(*this);
}



/********************   AddOp    ********************/
AddOp::AddOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

AddOp::AddOp(const AddOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

AddOp &AddOp::operator=(const AddOp & other)
{
  AddOp tmp(other);
  swap(tmp);
  return *this;
}

void AddOp::swap(AddOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

AddOp::~AddOp()
{
  delete(attr_1);
  delete(attr_2);

}

void AddOp::accept(Visitor *v)
{
  v->visitAddOp(this);
}

AddOp *AddOp::clone() const
{
  return new AddOp(*this);
}



/********************   SubOp    ********************/
SubOp::SubOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

SubOp::SubOp(const SubOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

SubOp &SubOp::operator=(const SubOp & other)
{
  SubOp tmp(other);
  swap(tmp);
  return *this;
}

void SubOp::swap(SubOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

SubOp::~SubOp()
{
  delete(attr_1);
  delete(attr_2);

}

void SubOp::accept(Visitor *v)
{
  v->visitSubOp(this);
}

SubOp *SubOp::clone() const
{
  return new SubOp(*this);
}



/********************   LeftShiftOp    ********************/
LeftShiftOp::LeftShiftOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

LeftShiftOp::LeftShiftOp(const LeftShiftOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

LeftShiftOp &LeftShiftOp::operator=(const LeftShiftOp & other)
{
  LeftShiftOp tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftOp::swap(LeftShiftOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

LeftShiftOp::~LeftShiftOp()
{
  delete(attr_1);
  delete(attr_2);

}

void LeftShiftOp::accept(Visitor *v)
{
  v->visitLeftShiftOp(this);
}

LeftShiftOp *LeftShiftOp::clone() const
{
  return new LeftShiftOp(*this);
}



/********************   RightShiftOp    ********************/
RightShiftOp::RightShiftOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

RightShiftOp::RightShiftOp(const RightShiftOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

RightShiftOp &RightShiftOp::operator=(const RightShiftOp & other)
{
  RightShiftOp tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftOp::swap(RightShiftOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

RightShiftOp::~RightShiftOp()
{
  delete(attr_1);
  delete(attr_2);

}

void RightShiftOp::accept(Visitor *v)
{
  v->visitRightShiftOp(this);
}

RightShiftOp *RightShiftOp::clone() const
{
  return new RightShiftOp(*this);
}



/********************   Less    ********************/
Less::Less(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Less::Less(const Less & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Less &Less::operator=(const Less & other)
{
  Less tmp(other);
  swap(tmp);
  return *this;
}

void Less::swap(Less & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Less::~Less()
{
  delete(attr_1);
  delete(attr_2);

}

void Less::accept(Visitor *v)
{
  v->visitLess(this);
}

Less *Less::clone() const
{
  return new Less(*this);
}



/********************   Greater    ********************/
Greater::Greater(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Greater::Greater(const Greater & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Greater &Greater::operator=(const Greater & other)
{
  Greater tmp(other);
  swap(tmp);
  return *this;
}

void Greater::swap(Greater & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Greater::~Greater()
{
  delete(attr_1);
  delete(attr_2);

}

void Greater::accept(Visitor *v)
{
  v->visitGreater(this);
}

Greater *Greater::clone() const
{
  return new Greater(*this);
}



/********************   LessEqual    ********************/
LessEqual::LessEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

LessEqual::LessEqual(const LessEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

LessEqual &LessEqual::operator=(const LessEqual & other)
{
  LessEqual tmp(other);
  swap(tmp);
  return *this;
}

void LessEqual::swap(LessEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

LessEqual::~LessEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void LessEqual::accept(Visitor *v)
{
  v->visitLessEqual(this);
}

LessEqual *LessEqual::clone() const
{
  return new LessEqual(*this);
}



/********************   GreaterEqual    ********************/
GreaterEqual::GreaterEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

GreaterEqual::GreaterEqual(const GreaterEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

GreaterEqual &GreaterEqual::operator=(const GreaterEqual & other)
{
  GreaterEqual tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqual::swap(GreaterEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

GreaterEqual::~GreaterEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void GreaterEqual::accept(Visitor *v)
{
  v->visitGreaterEqual(this);
}

GreaterEqual *GreaterEqual::clone() const
{
  return new GreaterEqual(*this);
}



/********************   EqualEqual    ********************/
EqualEqual::EqualEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

EqualEqual::EqualEqual(const EqualEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

EqualEqual &EqualEqual::operator=(const EqualEqual & other)
{
  EqualEqual tmp(other);
  swap(tmp);
  return *this;
}

void EqualEqual::swap(EqualEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

EqualEqual::~EqualEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void EqualEqual::accept(Visitor *v)
{
  v->visitEqualEqual(this);
}

EqualEqual *EqualEqual::clone() const
{
  return new EqualEqual(*this);
}



/********************   NotEqual    ********************/
NotEqual::NotEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

NotEqual::NotEqual(const NotEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

NotEqual &NotEqual::operator=(const NotEqual & other)
{
  NotEqual tmp(other);
  swap(tmp);
  return *this;
}

void NotEqual::swap(NotEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

NotEqual::~NotEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void NotEqual::accept(Visitor *v)
{
  v->visitNotEqual(this);
}

NotEqual *NotEqual::clone() const
{
  return new NotEqual(*this);
}



/********************   BitAnd    ********************/
BitAnd::BitAnd(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

BitAnd::BitAnd(const BitAnd & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

BitAnd &BitAnd::operator=(const BitAnd & other)
{
  BitAnd tmp(other);
  swap(tmp);
  return *this;
}

void BitAnd::swap(BitAnd & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

BitAnd::~BitAnd()
{
  delete(attr_1);
  delete(attr_2);

}

void BitAnd::accept(Visitor *v)
{
  v->visitBitAnd(this);
}

BitAnd *BitAnd::clone() const
{
  return new BitAnd(*this);
}



/********************   Xor    ********************/
Xor::Xor(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Xor::Xor(const Xor & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Xor &Xor::operator=(const Xor & other)
{
  Xor tmp(other);
  swap(tmp);
  return *this;
}

void Xor::swap(Xor & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Xor::~Xor()
{
  delete(attr_1);
  delete(attr_2);

}

void Xor::accept(Visitor *v)
{
  v->visitXor(this);
}

Xor *Xor::clone() const
{
  return new Xor(*this);
}



/********************   BitOr    ********************/
BitOr::BitOr(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

BitOr::BitOr(const BitOr & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

BitOr &BitOr::operator=(const BitOr & other)
{
  BitOr tmp(other);
  swap(tmp);
  return *this;
}

void BitOr::swap(BitOr & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

BitOr::~BitOr()
{
  delete(attr_1);
  delete(attr_2);

}

void BitOr::accept(Visitor *v)
{
  v->visitBitOr(this);
}

BitOr *BitOr::clone() const
{
  return new BitOr(*this);
}



/********************   And    ********************/
And::And(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

And::And(const And & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

And &And::operator=(const And & other)
{
  And tmp(other);
  swap(tmp);
  return *this;
}

void And::swap(And & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

And::~And()
{
  delete(attr_1);
  delete(attr_2);

}

void And::accept(Visitor *v)
{
  v->visitAnd(this);
}

And *And::clone() const
{
  return new And(*this);
}



/********************   Or    ********************/
Or::Or(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Or::Or(const Or & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Or &Or::operator=(const Or & other)
{
  Or tmp(other);
  swap(tmp);
  return *this;
}

void Or::swap(Or & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Or::~Or()
{
  delete(attr_1);
  delete(attr_2);

}

void Or::accept(Visitor *v)
{
  v->visitOr(this);
}

Or *Or::clone() const
{
  return new Or(*this);
}



/********************   TernaryCond    ********************/
TernaryCond::TernaryCond(Attr *p1, AttrTest *p2, Attr *p3, Attr *p4)
{
  attr_1 = p1;
  attrtest_ = p2;
  attr_2 = p3;
  attr_3 = p4;

}

TernaryCond::TernaryCond(const TernaryCond & other)
{
  attr_1 = other.attr_1->clone();
  attrtest_ = other.attrtest_->clone();
  attr_2 = other.attr_2->clone();
  attr_3 = other.attr_3->clone();

}

TernaryCond &TernaryCond::operator=(const TernaryCond & other)
{
  TernaryCond tmp(other);
  swap(tmp);
  return *this;
}

void TernaryCond::swap(TernaryCond & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attrtest_, other.attrtest_);
  std::swap(attr_2, other.attr_2);
  std::swap(attr_3, other.attr_3);

}

TernaryCond::~TernaryCond()
{
  delete(attr_1);
  delete(attrtest_);
  delete(attr_2);
  delete(attr_3);

}

void TernaryCond::accept(Visitor *v)
{
  v->visitTernaryCond(this);
}

TernaryCond *TernaryCond::clone() const
{
  return new TernaryCond(*this);
}



/********************   AnAttr    ********************/
AnAttr::AnAttr(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

AnAttr::AnAttr(const AnAttr & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

AnAttr &AnAttr::operator=(const AnAttr & other)
{
  AnAttr tmp(other);
  swap(tmp);
  return *this;
}

void AnAttr::swap(AnAttr & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

AnAttr::~AnAttr()
{
  delete(attr_1);
  delete(attr_2);

}

void AnAttr::accept(Visitor *v)
{
  v->visitAnAttr(this);
}

AnAttr *AnAttr::clone() const
{
  return new AnAttr(*this);
}



/********************   AvoidShiftReduce    ********************/
AvoidShiftReduce::AvoidShiftReduce()
{

}

AvoidShiftReduce::AvoidShiftReduce(const AvoidShiftReduce & other)
{

}

AvoidShiftReduce &AvoidShiftReduce::operator=(const AvoidShiftReduce & other)
{
  AvoidShiftReduce tmp(other);
  swap(tmp);
  return *this;
}

void AvoidShiftReduce::swap(AvoidShiftReduce & other)
{

}

AvoidShiftReduce::~AvoidShiftReduce()
{

}

void AvoidShiftReduce::accept(Visitor *v)
{
  v->visitAvoidShiftReduce(this);
}

AvoidShiftReduce *AvoidShiftReduce::clone() const
{
  return new AvoidShiftReduce(*this);
}



/********************   EmptyAtrList    ********************/
EmptyAtrList::EmptyAtrList()
{

}

EmptyAtrList::EmptyAtrList(const EmptyAtrList & other)
{

}

EmptyAtrList &EmptyAtrList::operator=(const EmptyAtrList & other)
{
  EmptyAtrList tmp(other);
  swap(tmp);
  return *this;
}

void EmptyAtrList::swap(EmptyAtrList & other)
{

}

EmptyAtrList::~EmptyAtrList()
{

}

void EmptyAtrList::accept(Visitor *v)
{
  v->visitEmptyAtrList(this);
}

EmptyAtrList *EmptyAtrList::clone() const
{
  return new EmptyAtrList(*this);
}



/********************   AtrList    ********************/
AtrList::AtrList(ListAttr *p1)
{
  listattr_ = p1;

}

AtrList::AtrList(const AtrList & other)
{
  listattr_ = other.listattr_->clone();

}

AtrList &AtrList::operator=(const AtrList & other)
{
  AtrList tmp(other);
  swap(tmp);
  return *this;
}

void AtrList::swap(AtrList & other)
{
  std::swap(listattr_, other.listattr_);

}

AtrList::~AtrList()
{
  delete(listattr_);

}

void AtrList::accept(Visitor *v)
{
  v->visitAtrList(this);
}

AtrList *AtrList::clone() const
{
  return new AtrList(*this);
}



/********************   VolatileKeyWrod    ********************/
VolatileKeyWrod::VolatileKeyWrod(VOLATILE p1)
{
  volatile_ = p1;

}

VolatileKeyWrod::VolatileKeyWrod(const VolatileKeyWrod & other)
{
  volatile_ = other.volatile_;

}

VolatileKeyWrod &VolatileKeyWrod::operator=(const VolatileKeyWrod & other)
{
  VolatileKeyWrod tmp(other);
  swap(tmp);
  return *this;
}

void VolatileKeyWrod::swap(VolatileKeyWrod & other)
{
  std::swap(volatile_, other.volatile_);

}

VolatileKeyWrod::~VolatileKeyWrod()
{

}

void VolatileKeyWrod::accept(Visitor *v)
{
  v->visitVolatileKeyWrod(this);
}

VolatileKeyWrod *VolatileKeyWrod::clone() const
{
  return new VolatileKeyWrod(*this);
}



/********************   ConstKeyWrod    ********************/
ConstKeyWrod::ConstKeyWrod(CONST p1)
{
  const_ = p1;

}

ConstKeyWrod::ConstKeyWrod(const ConstKeyWrod & other)
{
  const_ = other.const_;

}

ConstKeyWrod &ConstKeyWrod::operator=(const ConstKeyWrod & other)
{
  ConstKeyWrod tmp(other);
  swap(tmp);
  return *this;
}

void ConstKeyWrod::swap(ConstKeyWrod & other)
{
  std::swap(const_, other.const_);

}

ConstKeyWrod::~ConstKeyWrod()
{

}

void ConstKeyWrod::accept(Visitor *v)
{
  v->visitConstKeyWrod(this);
}

ConstKeyWrod *ConstKeyWrod::clone() const
{
  return new ConstKeyWrod(*this);
}



/********************   NoAsmoutputs    ********************/
NoAsmoutputs::NoAsmoutputs()
{

}

NoAsmoutputs::NoAsmoutputs(const NoAsmoutputs & other)
{

}

NoAsmoutputs &NoAsmoutputs::operator=(const NoAsmoutputs & other)
{
  NoAsmoutputs tmp(other);
  swap(tmp);
  return *this;
}

void NoAsmoutputs::swap(NoAsmoutputs & other)
{

}

NoAsmoutputs::~NoAsmoutputs()
{

}

void NoAsmoutputs::accept(Visitor *v)
{
  v->visitNoAsmoutputs(this);
}

NoAsmoutputs *NoAsmoutputs::clone() const
{
  return new NoAsmoutputs(*this);
}



/********************   SomeAsmoutputs    ********************/
SomeAsmoutputs::SomeAsmoutputs(Asmoperands *p1, Asminputs *p2)
{
  asmoperands_ = p1;
  asminputs_ = p2;

}

SomeAsmoutputs::SomeAsmoutputs(const SomeAsmoutputs & other)
{
  asmoperands_ = other.asmoperands_->clone();
  asminputs_ = other.asminputs_->clone();

}

SomeAsmoutputs &SomeAsmoutputs::operator=(const SomeAsmoutputs & other)
{
  SomeAsmoutputs tmp(other);
  swap(tmp);
  return *this;
}

void SomeAsmoutputs::swap(SomeAsmoutputs & other)
{
  std::swap(asmoperands_, other.asmoperands_);
  std::swap(asminputs_, other.asminputs_);

}

SomeAsmoutputs::~SomeAsmoutputs()
{
  delete(asmoperands_);
  delete(asminputs_);

}

void SomeAsmoutputs::accept(Visitor *v)
{
  v->visitSomeAsmoutputs(this);
}

SomeAsmoutputs *SomeAsmoutputs::clone() const
{
  return new SomeAsmoutputs(*this);
}



/********************   NoAsmoperands    ********************/
NoAsmoperands::NoAsmoperands()
{

}

NoAsmoperands::NoAsmoperands(const NoAsmoperands & other)
{

}

NoAsmoperands &NoAsmoperands::operator=(const NoAsmoperands & other)
{
  NoAsmoperands tmp(other);
  swap(tmp);
  return *this;
}

void NoAsmoperands::swap(NoAsmoperands & other)
{

}

NoAsmoperands::~NoAsmoperands()
{

}

void NoAsmoperands::accept(Visitor *v)
{
  v->visitNoAsmoperands(this);
}

NoAsmoperands *NoAsmoperands::clone() const
{
  return new NoAsmoperands(*this);
}



/********************   SomeAsmoperands    ********************/
SomeAsmoperands::SomeAsmoperands(ListAsmoperand *p1)
{
  listasmoperand_ = p1;

}

SomeAsmoperands::SomeAsmoperands(const SomeAsmoperands & other)
{
  listasmoperand_ = other.listasmoperand_->clone();

}

SomeAsmoperands &SomeAsmoperands::operator=(const SomeAsmoperands & other)
{
  SomeAsmoperands tmp(other);
  swap(tmp);
  return *this;
}

void SomeAsmoperands::swap(SomeAsmoperands & other)
{
  std::swap(listasmoperand_, other.listasmoperand_);

}

SomeAsmoperands::~SomeAsmoperands()
{
  delete(listasmoperand_);

}

void SomeAsmoperands::accept(Visitor *v)
{
  v->visitSomeAsmoperands(this);
}

SomeAsmoperands *SomeAsmoperands::clone() const
{
  return new SomeAsmoperands(*this);
}



/********************   AsmOperand    ********************/
AsmOperand::AsmOperand(Asmopname *p1, StringConstant *p2, Expression *p3)
{
  asmopname_ = p1;
  stringconstant_ = p2;
  expression_ = p3;

}

AsmOperand::AsmOperand(const AsmOperand & other)
{
  asmopname_ = other.asmopname_->clone();
  stringconstant_ = other.stringconstant_->clone();
  expression_ = other.expression_->clone();

}

AsmOperand &AsmOperand::operator=(const AsmOperand & other)
{
  AsmOperand tmp(other);
  swap(tmp);
  return *this;
}

void AsmOperand::swap(AsmOperand & other)
{
  std::swap(asmopname_, other.asmopname_);
  std::swap(stringconstant_, other.stringconstant_);
  std::swap(expression_, other.expression_);

}

AsmOperand::~AsmOperand()
{
  delete(asmopname_);
  delete(stringconstant_);
  delete(expression_);

}

void AsmOperand::accept(Visitor *v)
{
  v->visitAsmOperand(this);
}

AsmOperand *AsmOperand::clone() const
{
  return new AsmOperand(*this);
}



/********************   NoAsminputs    ********************/
NoAsminputs::NoAsminputs()
{

}

NoAsminputs::NoAsminputs(const NoAsminputs & other)
{

}

NoAsminputs &NoAsminputs::operator=(const NoAsminputs & other)
{
  NoAsminputs tmp(other);
  swap(tmp);
  return *this;
}

void NoAsminputs::swap(NoAsminputs & other)
{

}

NoAsminputs::~NoAsminputs()
{

}

void NoAsminputs::accept(Visitor *v)
{
  v->visitNoAsminputs(this);
}

NoAsminputs *NoAsminputs::clone() const
{
  return new NoAsminputs(*this);
}



/********************   SomeAsminputs    ********************/
SomeAsminputs::SomeAsminputs(Asmoperands *p1, Asmclobber *p2)
{
  asmoperands_ = p1;
  asmclobber_ = p2;

}

SomeAsminputs::SomeAsminputs(const SomeAsminputs & other)
{
  asmoperands_ = other.asmoperands_->clone();
  asmclobber_ = other.asmclobber_->clone();

}

SomeAsminputs &SomeAsminputs::operator=(const SomeAsminputs & other)
{
  SomeAsminputs tmp(other);
  swap(tmp);
  return *this;
}

void SomeAsminputs::swap(SomeAsminputs & other)
{
  std::swap(asmoperands_, other.asmoperands_);
  std::swap(asmclobber_, other.asmclobber_);

}

SomeAsminputs::~SomeAsminputs()
{
  delete(asmoperands_);
  delete(asmclobber_);

}

void SomeAsminputs::accept(Visitor *v)
{
  v->visitSomeAsminputs(this);
}

SomeAsminputs *SomeAsminputs::clone() const
{
  return new SomeAsminputs(*this);
}



/********************   NoAsmopname    ********************/
NoAsmopname::NoAsmopname()
{

}

NoAsmopname::NoAsmopname(const NoAsmopname & other)
{

}

NoAsmopname &NoAsmopname::operator=(const NoAsmopname & other)
{
  NoAsmopname tmp(other);
  swap(tmp);
  return *this;
}

void NoAsmopname::swap(NoAsmopname & other)
{

}

NoAsmopname::~NoAsmopname()
{

}

void NoAsmopname::accept(Visitor *v)
{
  v->visitNoAsmopname(this);
}

NoAsmopname *NoAsmopname::clone() const
{
  return new NoAsmopname(*this);
}



/********************   SomeAsmopname    ********************/
SomeAsmopname::SomeAsmopname(LBRACKET p1, Ident p2, RBRACKET p3)
{
  lbracket_ = p1;
  ident_ = p2;
  rbracket_ = p3;

}

SomeAsmopname::SomeAsmopname(const SomeAsmopname & other)
{
  lbracket_ = other.lbracket_;
  ident_ = other.ident_;
  rbracket_ = other.rbracket_;

}

SomeAsmopname &SomeAsmopname::operator=(const SomeAsmopname & other)
{
  SomeAsmopname tmp(other);
  swap(tmp);
  return *this;
}

void SomeAsmopname::swap(SomeAsmopname & other)
{
  std::swap(lbracket_, other.lbracket_);
  std::swap(ident_, other.ident_);
  std::swap(rbracket_, other.rbracket_);

}

SomeAsmopname::~SomeAsmopname()
{

}

void SomeAsmopname::accept(Visitor *v)
{
  v->visitSomeAsmopname(this);
}

SomeAsmopname *SomeAsmopname::clone() const
{
  return new SomeAsmopname(*this);
}



/********************   NoAsmclobber    ********************/
NoAsmclobber::NoAsmclobber()
{

}

NoAsmclobber::NoAsmclobber(const NoAsmclobber & other)
{

}

NoAsmclobber &NoAsmclobber::operator=(const NoAsmclobber & other)
{
  NoAsmclobber tmp(other);
  swap(tmp);
  return *this;
}

void NoAsmclobber::swap(NoAsmclobber & other)
{

}

NoAsmclobber::~NoAsmclobber()
{

}

void NoAsmclobber::accept(Visitor *v)
{
  v->visitNoAsmclobber(this);
}

NoAsmclobber *NoAsmclobber::clone() const
{
  return new NoAsmclobber(*this);
}



/********************   ColonAsmclobber    ********************/
ColonAsmclobber::ColonAsmclobber(Asmlabels *p1)
{
  asmlabels_ = p1;

}

ColonAsmclobber::ColonAsmclobber(const ColonAsmclobber & other)
{
  asmlabels_ = other.asmlabels_->clone();

}

ColonAsmclobber &ColonAsmclobber::operator=(const ColonAsmclobber & other)
{
  ColonAsmclobber tmp(other);
  swap(tmp);
  return *this;
}

void ColonAsmclobber::swap(ColonAsmclobber & other)
{
  std::swap(asmlabels_, other.asmlabels_);

}

ColonAsmclobber::~ColonAsmclobber()
{
  delete(asmlabels_);

}

void ColonAsmclobber::accept(Visitor *v)
{
  v->visitColonAsmclobber(this);
}

ColonAsmclobber *ColonAsmclobber::clone() const
{
  return new ColonAsmclobber(*this);
}



/********************   ColonStringAsmclobber    ********************/
ColonStringAsmclobber::ColonStringAsmclobber(ListStringConstant *p1, Asmlabels *p2)
{
  liststringconstant_ = p1;
  asmlabels_ = p2;

}

ColonStringAsmclobber::ColonStringAsmclobber(const ColonStringAsmclobber & other)
{
  liststringconstant_ = other.liststringconstant_->clone();
  asmlabels_ = other.asmlabels_->clone();

}

ColonStringAsmclobber &ColonStringAsmclobber::operator=(const ColonStringAsmclobber & other)
{
  ColonStringAsmclobber tmp(other);
  swap(tmp);
  return *this;
}

void ColonStringAsmclobber::swap(ColonStringAsmclobber & other)
{
  std::swap(liststringconstant_, other.liststringconstant_);
  std::swap(asmlabels_, other.asmlabels_);

}

ColonStringAsmclobber::~ColonStringAsmclobber()
{
  delete(liststringconstant_);
  delete(asmlabels_);

}

void ColonStringAsmclobber::accept(Visitor *v)
{
  v->visitColonStringAsmclobber(this);
}

ColonStringAsmclobber *ColonStringAsmclobber::clone() const
{
  return new ColonStringAsmclobber(*this);
}



/********************   NoAsmlabels    ********************/
NoAsmlabels::NoAsmlabels()
{

}

NoAsmlabels::NoAsmlabels(const NoAsmlabels & other)
{

}

NoAsmlabels &NoAsmlabels::operator=(const NoAsmlabels & other)
{
  NoAsmlabels tmp(other);
  swap(tmp);
  return *this;
}

void NoAsmlabels::swap(NoAsmlabels & other)
{

}

NoAsmlabels::~NoAsmlabels()
{

}

void NoAsmlabels::accept(Visitor *v)
{
  v->visitNoAsmlabels(this);
}

NoAsmlabels *NoAsmlabels::clone() const
{
  return new NoAsmlabels(*this);
}



/********************   SomeAsmlabels    ********************/
SomeAsmlabels::SomeAsmlabels(ListLocalLabelName *p1)
{
  listlocallabelname_ = p1;

}

SomeAsmlabels::SomeAsmlabels(const SomeAsmlabels & other)
{
  listlocallabelname_ = other.listlocallabelname_->clone();

}

SomeAsmlabels &SomeAsmlabels::operator=(const SomeAsmlabels & other)
{
  SomeAsmlabels tmp(other);
  swap(tmp);
  return *this;
}

void SomeAsmlabels::swap(SomeAsmlabels & other)
{
  std::swap(listlocallabelname_, other.listlocallabelname_);

}

SomeAsmlabels::~SomeAsmlabels()
{
  delete(listlocallabelname_);

}

void SomeAsmlabels::accept(Visitor *v)
{
  v->visitSomeAsmlabels(this);
}

SomeAsmlabels *SomeAsmlabels::clone() const
{
  return new SomeAsmlabels(*this);
}



/********************   LexprEof    ********************/
LexprEof::LexprEof(Lexpr *p1)
{
  lexpr_ = p1;

}

LexprEof::LexprEof(const LexprEof & other)
{
  lexpr_ = other.lexpr_->clone();

}

LexprEof &LexprEof::operator=(const LexprEof & other)
{
  LexprEof tmp(other);
  swap(tmp);
  return *this;
}

void LexprEof::swap(LexprEof & other)
{
  std::swap(lexpr_, other.lexpr_);

}

LexprEof::~LexprEof()
{
  delete(lexpr_);

}

void LexprEof::accept(Visitor *v)
{
  v->visitLexprEof(this);
}

LexprEof *LexprEof::clone() const
{
  return new LexprEof(*this);
}



/********************   EmptyLexprList    ********************/
EmptyLexprList::EmptyLexprList()
{

}

EmptyLexprList::EmptyLexprList(const EmptyLexprList & other)
{

}

EmptyLexprList &EmptyLexprList::operator=(const EmptyLexprList & other)
{
  EmptyLexprList tmp(other);
  swap(tmp);
  return *this;
}

void EmptyLexprList::swap(EmptyLexprList & other)
{

}

EmptyLexprList::~EmptyLexprList()
{

}

void EmptyLexprList::accept(Visitor *v)
{
  v->visitEmptyLexprList(this);
}

EmptyLexprList *EmptyLexprList::clone() const
{
  return new EmptyLexprList(*this);
}



/********************   NonEmptyLexprList    ********************/
NonEmptyLexprList::NonEmptyLexprList(ListLexpr *p1)
{
  listlexpr_ = p1;

}

NonEmptyLexprList::NonEmptyLexprList(const NonEmptyLexprList & other)
{
  listlexpr_ = other.listlexpr_->clone();

}

NonEmptyLexprList &NonEmptyLexprList::operator=(const NonEmptyLexprList & other)
{
  NonEmptyLexprList tmp(other);
  swap(tmp);
  return *this;
}

void NonEmptyLexprList::swap(NonEmptyLexprList & other)
{
  std::swap(listlexpr_, other.listlexpr_);

}

NonEmptyLexprList::~NonEmptyLexprList()
{
  delete(listlexpr_);

}

void NonEmptyLexprList::accept(Visitor *v)
{
  v->visitNonEmptyLexprList(this);
}

NonEmptyLexprList *NonEmptyLexprList::clone() const
{
  return new NonEmptyLexprList(*this);
}



/********************   NoLexprOption    ********************/
NoLexprOption::NoLexprOption()
{

}

NoLexprOption::NoLexprOption(const NoLexprOption & other)
{

}

NoLexprOption &NoLexprOption::operator=(const NoLexprOption & other)
{
  NoLexprOption tmp(other);
  swap(tmp);
  return *this;
}

void NoLexprOption::swap(NoLexprOption & other)
{

}

NoLexprOption::~NoLexprOption()
{

}

void NoLexprOption::accept(Visitor *v)
{
  v->visitNoLexprOption(this);
}

NoLexprOption *NoLexprOption::clone() const
{
  return new NoLexprOption(*this);
}



/********************   SomeLexprOption    ********************/
SomeLexprOption::SomeLexprOption(Lexpr *p1)
{
  lexpr_ = p1;

}

SomeLexprOption::SomeLexprOption(const SomeLexprOption & other)
{
  lexpr_ = other.lexpr_->clone();

}

SomeLexprOption &SomeLexprOption::operator=(const SomeLexprOption & other)
{
  SomeLexprOption tmp(other);
  swap(tmp);
  return *this;
}

void SomeLexprOption::swap(SomeLexprOption & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SomeLexprOption::~SomeLexprOption()
{
  delete(lexpr_);

}

void SomeLexprOption::accept(Visitor *v)
{
  v->visitSomeLexprOption(this);
}

SomeLexprOption *SomeLexprOption::clone() const
{
  return new SomeLexprOption(*this);
}



/********************   NoLexpr    ********************/
NoLexpr::NoLexpr()
{

}

NoLexpr::NoLexpr(const NoLexpr & other)
{

}

NoLexpr &NoLexpr::operator=(const NoLexpr & other)
{
  NoLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NoLexpr::swap(NoLexpr & other)
{

}

NoLexpr::~NoLexpr()
{

}

void NoLexpr::accept(Visitor *v)
{
  v->visitNoLexpr(this);
}

NoLexpr *NoLexpr::clone() const
{
  return new NoLexpr(*this);
}



/********************   ImplLexpr    ********************/
ImplLexpr::ImplLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

ImplLexpr::ImplLexpr(const ImplLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

ImplLexpr &ImplLexpr::operator=(const ImplLexpr & other)
{
  ImplLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ImplLexpr::swap(ImplLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

ImplLexpr::~ImplLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void ImplLexpr::accept(Visitor *v)
{
  v->visitImplLexpr(this);
}

ImplLexpr *ImplLexpr::clone() const
{
  return new ImplLexpr(*this);
}



/********************   IffLexpr    ********************/
IffLexpr::IffLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

IffLexpr::IffLexpr(const IffLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

IffLexpr &IffLexpr::operator=(const IffLexpr & other)
{
  IffLexpr tmp(other);
  swap(tmp);
  return *this;
}

void IffLexpr::swap(IffLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

IffLexpr::~IffLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void IffLexpr::accept(Visitor *v)
{
  v->visitIffLexpr(this);
}

IffLexpr *IffLexpr::clone() const
{
  return new IffLexpr(*this);
}



/********************   OrLexpr    ********************/
OrLexpr::OrLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

OrLexpr::OrLexpr(const OrLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

OrLexpr &OrLexpr::operator=(const OrLexpr & other)
{
  OrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void OrLexpr::swap(OrLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

OrLexpr::~OrLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void OrLexpr::accept(Visitor *v)
{
  v->visitOrLexpr(this);
}

OrLexpr *OrLexpr::clone() const
{
  return new OrLexpr(*this);
}



/********************   AndLexpr    ********************/
AndLexpr::AndLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AndLexpr::AndLexpr(const AndLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AndLexpr &AndLexpr::operator=(const AndLexpr & other)
{
  AndLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AndLexpr::swap(AndLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AndLexpr::~AndLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AndLexpr::accept(Visitor *v)
{
  v->visitAndLexpr(this);
}

AndLexpr *AndLexpr::clone() const
{
  return new AndLexpr(*this);
}



/********************   HatHatLexpr    ********************/
HatHatLexpr::HatHatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

HatHatLexpr::HatHatLexpr(const HatHatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

HatHatLexpr &HatHatLexpr::operator=(const HatHatLexpr & other)
{
  HatHatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void HatHatLexpr::swap(HatHatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

HatHatLexpr::~HatHatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void HatHatLexpr::accept(Visitor *v)
{
  v->visitHatHatLexpr(this);
}

HatHatLexpr *HatHatLexpr::clone() const
{
  return new HatHatLexpr(*this);
}



/********************   AmpLexpr    ********************/
AmpLexpr::AmpLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AmpLexpr::AmpLexpr(const AmpLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AmpLexpr &AmpLexpr::operator=(const AmpLexpr & other)
{
  AmpLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AmpLexpr::swap(AmpLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AmpLexpr::~AmpLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AmpLexpr::accept(Visitor *v)
{
  v->visitAmpLexpr(this);
}

AmpLexpr *AmpLexpr::clone() const
{
  return new AmpLexpr(*this);
}



/********************   PipeLexpr    ********************/
PipeLexpr::PipeLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

PipeLexpr::PipeLexpr(const PipeLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

PipeLexpr &PipeLexpr::operator=(const PipeLexpr & other)
{
  PipeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PipeLexpr::swap(PipeLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

PipeLexpr::~PipeLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void PipeLexpr::accept(Visitor *v)
{
  v->visitPipeLexpr(this);
}

PipeLexpr *PipeLexpr::clone() const
{
  return new PipeLexpr(*this);
}



/********************   HatLexpr    ********************/
HatLexpr::HatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

HatLexpr::HatLexpr(const HatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

HatLexpr &HatLexpr::operator=(const HatLexpr & other)
{
  HatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void HatLexpr::swap(HatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

HatLexpr::~HatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void HatLexpr::accept(Visitor *v)
{
  v->visitHatLexpr(this);
}

HatLexpr *HatLexpr::clone() const
{
  return new HatLexpr(*this);
}



/********************   BimpliesLexpr    ********************/
BimpliesLexpr::BimpliesLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

BimpliesLexpr::BimpliesLexpr(const BimpliesLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

BimpliesLexpr &BimpliesLexpr::operator=(const BimpliesLexpr & other)
{
  BimpliesLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BimpliesLexpr::swap(BimpliesLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

BimpliesLexpr::~BimpliesLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void BimpliesLexpr::accept(Visitor *v)
{
  v->visitBimpliesLexpr(this);
}

BimpliesLexpr *BimpliesLexpr::clone() const
{
  return new BimpliesLexpr(*this);
}



/********************   BiffLexpr    ********************/
BiffLexpr::BiffLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

BiffLexpr::BiffLexpr(const BiffLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

BiffLexpr &BiffLexpr::operator=(const BiffLexpr & other)
{
  BiffLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BiffLexpr::swap(BiffLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

BiffLexpr::~BiffLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void BiffLexpr::accept(Visitor *v)
{
  v->visitBiffLexpr(this);
}

BiffLexpr *BiffLexpr::clone() const
{
  return new BiffLexpr(*this);
}



/********************   InLexpr    ********************/
InLexpr::InLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

InLexpr::InLexpr(const InLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

InLexpr &InLexpr::operator=(const InLexpr & other)
{
  InLexpr tmp(other);
  swap(tmp);
  return *this;
}

void InLexpr::swap(InLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

InLexpr::~InLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void InLexpr::accept(Visitor *v)
{
  v->visitInLexpr(this);
}

InLexpr *InLexpr::clone() const
{
  return new InLexpr(*this);
}



/********************   TernaryLexpr    ********************/
TernaryLexpr::TernaryLexpr(Lexpr *p1, Lexpr *p2, Lexpr *p3)
{
  lexpr_1 = p1;
  lexpr_2 = p2;
  lexpr_3 = p3;

}

TernaryLexpr::TernaryLexpr(const TernaryLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();
  lexpr_3 = other.lexpr_3->clone();

}

TernaryLexpr &TernaryLexpr::operator=(const TernaryLexpr & other)
{
  TernaryLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TernaryLexpr::swap(TernaryLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);
  std::swap(lexpr_3, other.lexpr_3);

}

TernaryLexpr::~TernaryLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);
  delete(lexpr_3);

}

void TernaryLexpr::accept(Visitor *v)
{
  v->visitTernaryLexpr(this);
}

TernaryLexpr *TernaryLexpr::clone() const
{
  return new TernaryLexpr(*this);
}



/********************   IdAssignLexpr    ********************/
IdAssignLexpr::IdAssignLexpr(AnyIdentifier *p1, Lexpr *p2)
{
  anyidentifier_ = p1;
  lexpr_ = p2;

}

IdAssignLexpr::IdAssignLexpr(const IdAssignLexpr & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  lexpr_ = other.lexpr_->clone();

}

IdAssignLexpr &IdAssignLexpr::operator=(const IdAssignLexpr & other)
{
  IdAssignLexpr tmp(other);
  swap(tmp);
  return *this;
}

void IdAssignLexpr::swap(IdAssignLexpr & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(lexpr_, other.lexpr_);

}

IdAssignLexpr::~IdAssignLexpr()
{
  delete(anyidentifier_);
  delete(lexpr_);

}

void IdAssignLexpr::accept(Visitor *v)
{
  v->visitIdAssignLexpr(this);
}

IdAssignLexpr *IdAssignLexpr::clone() const
{
  return new IdAssignLexpr(*this);
}



/********************   StrAssignLexpr    ********************/
StrAssignLexpr::StrAssignLexpr(ListSTRING_LITERAL *p1, Lexpr *p2)
{
  liststring_literal_ = p1;
  lexpr_ = p2;

}

StrAssignLexpr::StrAssignLexpr(const StrAssignLexpr & other)
{
  liststring_literal_ = other.liststring_literal_->clone();
  lexpr_ = other.lexpr_->clone();

}

StrAssignLexpr &StrAssignLexpr::operator=(const StrAssignLexpr & other)
{
  StrAssignLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StrAssignLexpr::swap(StrAssignLexpr & other)
{
  std::swap(liststring_literal_, other.liststring_literal_);
  std::swap(lexpr_, other.lexpr_);

}

StrAssignLexpr::~StrAssignLexpr()
{
  delete(liststring_literal_);
  delete(lexpr_);

}

void StrAssignLexpr::accept(Visitor *v)
{
  v->visitStrAssignLexpr(this);
}

StrAssignLexpr *StrAssignLexpr::clone() const
{
  return new StrAssignLexpr(*this);
}



/********************   RelationLexpr    ********************/
RelationLexpr::RelationLexpr(Lexpr *p1, ListLexprRelInner *p2, Relation *p3, Lexpr *p4)
{
  lexpr_1 = p1;
  listlexprrelinner_ = p2;
  relation_ = p3;
  lexpr_2 = p4;

}

RelationLexpr::RelationLexpr(const RelationLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  listlexprrelinner_ = other.listlexprrelinner_->clone();
  relation_ = other.relation_->clone();
  lexpr_2 = other.lexpr_2->clone();

}

RelationLexpr &RelationLexpr::operator=(const RelationLexpr & other)
{
  RelationLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RelationLexpr::swap(RelationLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(listlexprrelinner_, other.listlexprrelinner_);
  std::swap(relation_, other.relation_);
  std::swap(lexpr_2, other.lexpr_2);

}

RelationLexpr::~RelationLexpr()
{
  delete(lexpr_1);
  delete(listlexprrelinner_);
  delete(relation_);
  delete(lexpr_2);

}

void RelationLexpr::accept(Visitor *v)
{
  v->visitRelationLexpr(this);
}

RelationLexpr *RelationLexpr::clone() const
{
  return new RelationLexpr(*this);
}



/********************   BinderLexpr    ********************/
BinderLexpr::BinderLexpr(LexprBinder *p1)
{
  lexprbinder_ = p1;

}

BinderLexpr::BinderLexpr(const BinderLexpr & other)
{
  lexprbinder_ = other.lexprbinder_->clone();

}

BinderLexpr &BinderLexpr::operator=(const BinderLexpr & other)
{
  BinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BinderLexpr::swap(BinderLexpr & other)
{
  std::swap(lexprbinder_, other.lexprbinder_);

}

BinderLexpr::~BinderLexpr()
{
  delete(lexprbinder_);

}

void BinderLexpr::accept(Visitor *v)
{
  v->visitBinderLexpr(this);
}

BinderLexpr *BinderLexpr::clone() const
{
  return new BinderLexpr(*this);
}



/********************   NotBinderLexpr    ********************/
NotBinderLexpr::NotBinderLexpr(LexprBinder *p1)
{
  lexprbinder_ = p1;

}

NotBinderLexpr::NotBinderLexpr(const NotBinderLexpr & other)
{
  lexprbinder_ = other.lexprbinder_->clone();

}

NotBinderLexpr &NotBinderLexpr::operator=(const NotBinderLexpr & other)
{
  NotBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NotBinderLexpr::swap(NotBinderLexpr & other)
{
  std::swap(lexprbinder_, other.lexprbinder_);

}

NotBinderLexpr::~NotBinderLexpr()
{
  delete(lexprbinder_);

}

void NotBinderLexpr::accept(Visitor *v)
{
  v->visitNotBinderLexpr(this);
}

NotBinderLexpr *NotBinderLexpr::clone() const
{
  return new NotBinderLexpr(*this);
}



/********************   StringLexpr    ********************/
StringLexpr::StringLexpr(ListSTRING_LITERAL *p1)
{
  liststring_literal_ = p1;

}

StringLexpr::StringLexpr(const StringLexpr & other)
{
  liststring_literal_ = other.liststring_literal_->clone();

}

StringLexpr &StringLexpr::operator=(const StringLexpr & other)
{
  StringLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StringLexpr::swap(StringLexpr & other)
{
  std::swap(liststring_literal_, other.liststring_literal_);

}

StringLexpr::~StringLexpr()
{
  delete(liststring_literal_);

}

void StringLexpr::accept(Visitor *v)
{
  v->visitStringLexpr(this);
}

StringLexpr *StringLexpr::clone() const
{
  return new StringLexpr(*this);
}



/********************   NotLexprInner    ********************/
NotLexprInner::NotLexprInner(Lexpr *p1)
{
  lexpr_ = p1;

}

NotLexprInner::NotLexprInner(const NotLexprInner & other)
{
  lexpr_ = other.lexpr_->clone();

}

NotLexprInner &NotLexprInner::operator=(const NotLexprInner & other)
{
  NotLexprInner tmp(other);
  swap(tmp);
  return *this;
}

void NotLexprInner::swap(NotLexprInner & other)
{
  std::swap(lexpr_, other.lexpr_);

}

NotLexprInner::~NotLexprInner()
{
  delete(lexpr_);

}

void NotLexprInner::accept(Visitor *v)
{
  v->visitNotLexprInner(this);
}

NotLexprInner *NotLexprInner::clone() const
{
  return new NotLexprInner(*this);
}



/********************   TrueLexpr    ********************/
TrueLexpr::TrueLexpr()
{

}

TrueLexpr::TrueLexpr(const TrueLexpr & other)
{

}

TrueLexpr &TrueLexpr::operator=(const TrueLexpr & other)
{
  TrueLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TrueLexpr::swap(TrueLexpr & other)
{

}

TrueLexpr::~TrueLexpr()
{

}

void TrueLexpr::accept(Visitor *v)
{
  v->visitTrueLexpr(this);
}

TrueLexpr *TrueLexpr::clone() const
{
  return new TrueLexpr(*this);
}



/********************   FalseLexpr    ********************/
FalseLexpr::FalseLexpr()
{

}

FalseLexpr::FalseLexpr(const FalseLexpr & other)
{

}

FalseLexpr &FalseLexpr::operator=(const FalseLexpr & other)
{
  FalseLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FalseLexpr::swap(FalseLexpr & other)
{

}

FalseLexpr::~FalseLexpr()
{

}

void FalseLexpr::accept(Visitor *v)
{
  v->visitFalseLexpr(this);
}

FalseLexpr *FalseLexpr::clone() const
{
  return new FalseLexpr(*this);
}



/********************   PointerLexpr    ********************/
PointerLexpr::PointerLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

PointerLexpr::PointerLexpr(const PointerLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

PointerLexpr &PointerLexpr::operator=(const PointerLexpr & other)
{
  PointerLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PointerLexpr::swap(PointerLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

PointerLexpr::~PointerLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void PointerLexpr::accept(Visitor *v)
{
  v->visitPointerLexpr(this);
}

PointerLexpr *PointerLexpr::clone() const
{
  return new PointerLexpr(*this);
}



/********************   ValidLexpr    ********************/
ValidLexpr::ValidLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

ValidLexpr::ValidLexpr(const ValidLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

ValidLexpr &ValidLexpr::operator=(const ValidLexpr & other)
{
  ValidLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ValidLexpr::swap(ValidLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

ValidLexpr::~ValidLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void ValidLexpr::accept(Visitor *v)
{
  v->visitValidLexpr(this);
}

ValidLexpr *ValidLexpr::clone() const
{
  return new ValidLexpr(*this);
}



/********************   ValidReadLexpr    ********************/
ValidReadLexpr::ValidReadLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

ValidReadLexpr::ValidReadLexpr(const ValidReadLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

ValidReadLexpr &ValidReadLexpr::operator=(const ValidReadLexpr & other)
{
  ValidReadLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ValidReadLexpr::swap(ValidReadLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

ValidReadLexpr::~ValidReadLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void ValidReadLexpr::accept(Visitor *v)
{
  v->visitValidReadLexpr(this);
}

ValidReadLexpr *ValidReadLexpr::clone() const
{
  return new ValidReadLexpr(*this);
}



/********************   ValidFuncLexpr    ********************/
ValidFuncLexpr::ValidFuncLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

ValidFuncLexpr::ValidFuncLexpr(const ValidFuncLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

ValidFuncLexpr &ValidFuncLexpr::operator=(const ValidFuncLexpr & other)
{
  ValidFuncLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ValidFuncLexpr::swap(ValidFuncLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

ValidFuncLexpr::~ValidFuncLexpr()
{
  delete(lexpr_);

}

void ValidFuncLexpr::accept(Visitor *v)
{
  v->visitValidFuncLexpr(this);
}

ValidFuncLexpr *ValidFuncLexpr::clone() const
{
  return new ValidFuncLexpr(*this);
}



/********************   ValidIndxLexpr    ********************/
ValidIndxLexpr::ValidIndxLexpr(OptLabel *p1, Lexpr *p2, Lexpr *p3)
{
  optlabel_ = p1;
  lexpr_1 = p2;
  lexpr_2 = p3;

}

ValidIndxLexpr::ValidIndxLexpr(const ValidIndxLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

ValidIndxLexpr &ValidIndxLexpr::operator=(const ValidIndxLexpr & other)
{
  ValidIndxLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ValidIndxLexpr::swap(ValidIndxLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

ValidIndxLexpr::~ValidIndxLexpr()
{
  delete(optlabel_);
  delete(lexpr_1);
  delete(lexpr_2);

}

void ValidIndxLexpr::accept(Visitor *v)
{
  v->visitValidIndxLexpr(this);
}

ValidIndxLexpr *ValidIndxLexpr::clone() const
{
  return new ValidIndxLexpr(*this);
}



/********************   ValidRangeLexpr    ********************/
ValidRangeLexpr::ValidRangeLexpr(OptLabel *p1, Lexpr *p2, Lexpr *p3, Lexpr *p4)
{
  optlabel_ = p1;
  lexpr_1 = p2;
  lexpr_2 = p3;
  lexpr_3 = p4;

}

ValidRangeLexpr::ValidRangeLexpr(const ValidRangeLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();
  lexpr_3 = other.lexpr_3->clone();

}

ValidRangeLexpr &ValidRangeLexpr::operator=(const ValidRangeLexpr & other)
{
  ValidRangeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ValidRangeLexpr::swap(ValidRangeLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);
  std::swap(lexpr_3, other.lexpr_3);

}

ValidRangeLexpr::~ValidRangeLexpr()
{
  delete(optlabel_);
  delete(lexpr_1);
  delete(lexpr_2);
  delete(lexpr_3);

}

void ValidRangeLexpr::accept(Visitor *v)
{
  v->visitValidRangeLexpr(this);
}

ValidRangeLexpr *ValidRangeLexpr::clone() const
{
  return new ValidRangeLexpr(*this);
}



/********************   InitializedLexpr    ********************/
InitializedLexpr::InitializedLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

InitializedLexpr::InitializedLexpr(const InitializedLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

InitializedLexpr &InitializedLexpr::operator=(const InitializedLexpr & other)
{
  InitializedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void InitializedLexpr::swap(InitializedLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

InitializedLexpr::~InitializedLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void InitializedLexpr::accept(Visitor *v)
{
  v->visitInitializedLexpr(this);
}

InitializedLexpr *InitializedLexpr::clone() const
{
  return new InitializedLexpr(*this);
}



/********************   DanglingLexpr    ********************/
DanglingLexpr::DanglingLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

DanglingLexpr::DanglingLexpr(const DanglingLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

DanglingLexpr &DanglingLexpr::operator=(const DanglingLexpr & other)
{
  DanglingLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DanglingLexpr::swap(DanglingLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

DanglingLexpr::~DanglingLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void DanglingLexpr::accept(Visitor *v)
{
  v->visitDanglingLexpr(this);
}

DanglingLexpr *DanglingLexpr::clone() const
{
  return new DanglingLexpr(*this);
}



/********************   FreshLexpr    ********************/
FreshLexpr::FreshLexpr(OptLabel *p1, Lexpr *p2, Lexpr *p3)
{
  optlabel_ = p1;
  lexpr_1 = p2;
  lexpr_2 = p3;

}

FreshLexpr::FreshLexpr(const FreshLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

FreshLexpr &FreshLexpr::operator=(const FreshLexpr & other)
{
  FreshLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FreshLexpr::swap(FreshLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

FreshLexpr::~FreshLexpr()
{
  delete(optlabel_);
  delete(lexpr_1);
  delete(lexpr_2);

}

void FreshLexpr::accept(Visitor *v)
{
  v->visitFreshLexpr(this);
}

FreshLexpr *FreshLexpr::clone() const
{
  return new FreshLexpr(*this);
}



/********************   BaseAddrLexpr    ********************/
BaseAddrLexpr::BaseAddrLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

BaseAddrLexpr::BaseAddrLexpr(const BaseAddrLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

BaseAddrLexpr &BaseAddrLexpr::operator=(const BaseAddrLexpr & other)
{
  BaseAddrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BaseAddrLexpr::swap(BaseAddrLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

BaseAddrLexpr::~BaseAddrLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void BaseAddrLexpr::accept(Visitor *v)
{
  v->visitBaseAddrLexpr(this);
}

BaseAddrLexpr *BaseAddrLexpr::clone() const
{
  return new BaseAddrLexpr(*this);
}



/********************   BlockLengthLexpr    ********************/
BlockLengthLexpr::BlockLengthLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

BlockLengthLexpr::BlockLengthLexpr(const BlockLengthLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

BlockLengthLexpr &BlockLengthLexpr::operator=(const BlockLengthLexpr & other)
{
  BlockLengthLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BlockLengthLexpr::swap(BlockLengthLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

BlockLengthLexpr::~BlockLengthLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void BlockLengthLexpr::accept(Visitor *v)
{
  v->visitBlockLengthLexpr(this);
}

BlockLengthLexpr *BlockLengthLexpr::clone() const
{
  return new BlockLengthLexpr(*this);
}



/********************   OffsetLexpr    ********************/
OffsetLexpr::OffsetLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

OffsetLexpr::OffsetLexpr(const OffsetLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

OffsetLexpr &OffsetLexpr::operator=(const OffsetLexpr & other)
{
  OffsetLexpr tmp(other);
  swap(tmp);
  return *this;
}

void OffsetLexpr::swap(OffsetLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

OffsetLexpr::~OffsetLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void OffsetLexpr::accept(Visitor *v)
{
  v->visitOffsetLexpr(this);
}

OffsetLexpr *OffsetLexpr::clone() const
{
  return new OffsetLexpr(*this);
}



/********************   AllocableLexpr    ********************/
AllocableLexpr::AllocableLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

AllocableLexpr::AllocableLexpr(const AllocableLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

AllocableLexpr &AllocableLexpr::operator=(const AllocableLexpr & other)
{
  AllocableLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AllocableLexpr::swap(AllocableLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

AllocableLexpr::~AllocableLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void AllocableLexpr::accept(Visitor *v)
{
  v->visitAllocableLexpr(this);
}

AllocableLexpr *AllocableLexpr::clone() const
{
  return new AllocableLexpr(*this);
}



/********************   FreeableLexpr    ********************/
FreeableLexpr::FreeableLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

FreeableLexpr::FreeableLexpr(const FreeableLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

FreeableLexpr &FreeableLexpr::operator=(const FreeableLexpr & other)
{
  FreeableLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FreeableLexpr::swap(FreeableLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

FreeableLexpr::~FreeableLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void FreeableLexpr::accept(Visitor *v)
{
  v->visitFreeableLexpr(this);
}

FreeableLexpr *FreeableLexpr::clone() const
{
  return new FreeableLexpr(*this);
}



/********************   AllocationLexpr    ********************/
AllocationLexpr::AllocationLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

AllocationLexpr::AllocationLexpr(const AllocationLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

AllocationLexpr &AllocationLexpr::operator=(const AllocationLexpr & other)
{
  AllocationLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AllocationLexpr::swap(AllocationLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

AllocationLexpr::~AllocationLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void AllocationLexpr::accept(Visitor *v)
{
  v->visitAllocationLexpr(this);
}

AllocationLexpr *AllocationLexpr::clone() const
{
  return new AllocationLexpr(*this);
}



/********************   AutomaticLexpr    ********************/
AutomaticLexpr::AutomaticLexpr()
{

}

AutomaticLexpr::AutomaticLexpr(const AutomaticLexpr & other)
{

}

AutomaticLexpr &AutomaticLexpr::operator=(const AutomaticLexpr & other)
{
  AutomaticLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AutomaticLexpr::swap(AutomaticLexpr & other)
{

}

AutomaticLexpr::~AutomaticLexpr()
{

}

void AutomaticLexpr::accept(Visitor *v)
{
  v->visitAutomaticLexpr(this);
}

AutomaticLexpr *AutomaticLexpr::clone() const
{
  return new AutomaticLexpr(*this);
}



/********************   DynamicLexpr    ********************/
DynamicLexpr::DynamicLexpr()
{

}

DynamicLexpr::DynamicLexpr(const DynamicLexpr & other)
{

}

DynamicLexpr &DynamicLexpr::operator=(const DynamicLexpr & other)
{
  DynamicLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DynamicLexpr::swap(DynamicLexpr & other)
{

}

DynamicLexpr::~DynamicLexpr()
{

}

void DynamicLexpr::accept(Visitor *v)
{
  v->visitDynamicLexpr(this);
}

DynamicLexpr *DynamicLexpr::clone() const
{
  return new DynamicLexpr(*this);
}



/********************   RegisterLexpr    ********************/
RegisterLexpr::RegisterLexpr()
{

}

RegisterLexpr::RegisterLexpr(const RegisterLexpr & other)
{

}

RegisterLexpr &RegisterLexpr::operator=(const RegisterLexpr & other)
{
  RegisterLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RegisterLexpr::swap(RegisterLexpr & other)
{

}

RegisterLexpr::~RegisterLexpr()
{

}

void RegisterLexpr::accept(Visitor *v)
{
  v->visitRegisterLexpr(this);
}

RegisterLexpr *RegisterLexpr::clone() const
{
  return new RegisterLexpr(*this);
}



/********************   StaticLexpr    ********************/
StaticLexpr::StaticLexpr()
{

}

StaticLexpr::StaticLexpr(const StaticLexpr & other)
{

}

StaticLexpr &StaticLexpr::operator=(const StaticLexpr & other)
{
  StaticLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StaticLexpr::swap(StaticLexpr & other)
{

}

StaticLexpr::~StaticLexpr()
{

}

void StaticLexpr::accept(Visitor *v)
{
  v->visitStaticLexpr(this);
}

StaticLexpr *StaticLexpr::clone() const
{
  return new StaticLexpr(*this);
}



/********************   UnallocatedLexpr    ********************/
UnallocatedLexpr::UnallocatedLexpr()
{

}

UnallocatedLexpr::UnallocatedLexpr(const UnallocatedLexpr & other)
{

}

UnallocatedLexpr &UnallocatedLexpr::operator=(const UnallocatedLexpr & other)
{
  UnallocatedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void UnallocatedLexpr::swap(UnallocatedLexpr & other)
{

}

UnallocatedLexpr::~UnallocatedLexpr()
{

}

void UnallocatedLexpr::accept(Visitor *v)
{
  v->visitUnallocatedLexpr(this);
}

UnallocatedLexpr *UnallocatedLexpr::clone() const
{
  return new UnallocatedLexpr(*this);
}



/********************   NullLexpr    ********************/
NullLexpr::NullLexpr()
{

}

NullLexpr::NullLexpr(const NullLexpr & other)
{

}

NullLexpr &NullLexpr::operator=(const NullLexpr & other)
{
  NullLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NullLexpr::swap(NullLexpr & other)
{

}

NullLexpr::~NullLexpr()
{

}

void NullLexpr::accept(Visitor *v)
{
  v->visitNullLexpr(this);
}

NullLexpr *NullLexpr::clone() const
{
  return new NullLexpr(*this);
}



/********************   LexprIntConst    ********************/
LexprIntConst::LexprIntConst(Integer p1)
{
  integer_ = p1;

}

LexprIntConst::LexprIntConst(const LexprIntConst & other)
{
  integer_ = other.integer_;

}

LexprIntConst &LexprIntConst::operator=(const LexprIntConst & other)
{
  LexprIntConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprIntConst::swap(LexprIntConst & other)
{
  std::swap(integer_, other.integer_);

}

LexprIntConst::~LexprIntConst()
{

}

void LexprIntConst::accept(Visitor *v)
{
  v->visitLexprIntConst(this);
}

LexprIntConst *LexprIntConst::clone() const
{
  return new LexprIntConst(*this);
}



/********************   LexprFloatConst    ********************/
LexprFloatConst::LexprFloatConst(Double p1)
{
  double_ = p1;

}

LexprFloatConst::LexprFloatConst(const LexprFloatConst & other)
{
  double_ = other.double_;

}

LexprFloatConst &LexprFloatConst::operator=(const LexprFloatConst & other)
{
  LexprFloatConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprFloatConst::swap(LexprFloatConst & other)
{
  std::swap(double_, other.double_);

}

LexprFloatConst::~LexprFloatConst()
{

}

void LexprFloatConst::accept(Visitor *v)
{
  v->visitLexprFloatConst(this);
}

LexprFloatConst *LexprFloatConst::clone() const
{
  return new LexprFloatConst(*this);
}



/********************   LexprStringConst    ********************/
LexprStringConst::LexprStringConst(String p1)
{
  string_ = p1;

}

LexprStringConst::LexprStringConst(const LexprStringConst & other)
{
  string_ = other.string_;

}

LexprStringConst &LexprStringConst::operator=(const LexprStringConst & other)
{
  LexprStringConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprStringConst::swap(LexprStringConst & other)
{
  std::swap(string_, other.string_);

}

LexprStringConst::~LexprStringConst()
{

}

void LexprStringConst::accept(Visitor *v)
{
  v->visitLexprStringConst(this);
}

LexprStringConst *LexprStringConst::clone() const
{
  return new LexprStringConst(*this);
}



/********************   LexprWStringConst    ********************/
LexprWStringConst::LexprWStringConst(WSTRING_CONSTANT p1)
{
  wstring_constant_ = p1;

}

LexprWStringConst::LexprWStringConst(const LexprWStringConst & other)
{
  wstring_constant_ = other.wstring_constant_;

}

LexprWStringConst &LexprWStringConst::operator=(const LexprWStringConst & other)
{
  LexprWStringConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprWStringConst::swap(LexprWStringConst & other)
{
  std::swap(wstring_constant_, other.wstring_constant_);

}

LexprWStringConst::~LexprWStringConst()
{

}

void LexprWStringConst::accept(Visitor *v)
{
  v->visitLexprWStringConst(this);
}

LexprWStringConst *LexprWStringConst::clone() const
{
  return new LexprWStringConst(*this);
}



/********************   AddLexpr    ********************/
AddLexpr::AddLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AddLexpr::AddLexpr(const AddLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AddLexpr &AddLexpr::operator=(const AddLexpr & other)
{
  AddLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AddLexpr::swap(AddLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AddLexpr::~AddLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AddLexpr::accept(Visitor *v)
{
  v->visitAddLexpr(this);
}

AddLexpr *AddLexpr::clone() const
{
  return new AddLexpr(*this);
}



/********************   SubtrLexpr    ********************/
SubtrLexpr::SubtrLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

SubtrLexpr::SubtrLexpr(const SubtrLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

SubtrLexpr &SubtrLexpr::operator=(const SubtrLexpr & other)
{
  SubtrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SubtrLexpr::swap(SubtrLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

SubtrLexpr::~SubtrLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void SubtrLexpr::accept(Visitor *v)
{
  v->visitSubtrLexpr(this);
}

SubtrLexpr *SubtrLexpr::clone() const
{
  return new SubtrLexpr(*this);
}



/********************   MultLexpr    ********************/
MultLexpr::MultLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

MultLexpr::MultLexpr(const MultLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

MultLexpr &MultLexpr::operator=(const MultLexpr & other)
{
  MultLexpr tmp(other);
  swap(tmp);
  return *this;
}

void MultLexpr::swap(MultLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

MultLexpr::~MultLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void MultLexpr::accept(Visitor *v)
{
  v->visitMultLexpr(this);
}

MultLexpr *MultLexpr::clone() const
{
  return new MultLexpr(*this);
}



/********************   DivLexpr    ********************/
DivLexpr::DivLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

DivLexpr::DivLexpr(const DivLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

DivLexpr &DivLexpr::operator=(const DivLexpr & other)
{
  DivLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DivLexpr::swap(DivLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

DivLexpr::~DivLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void DivLexpr::accept(Visitor *v)
{
  v->visitDivLexpr(this);
}

DivLexpr *DivLexpr::clone() const
{
  return new DivLexpr(*this);
}



/********************   ModLexpr    ********************/
ModLexpr::ModLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

ModLexpr::ModLexpr(const ModLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

ModLexpr &ModLexpr::operator=(const ModLexpr & other)
{
  ModLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ModLexpr::swap(ModLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

ModLexpr::~ModLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void ModLexpr::accept(Visitor *v)
{
  v->visitModLexpr(this);
}

ModLexpr *ModLexpr::clone() const
{
  return new ModLexpr(*this);
}



/********************   StarHatLexpr    ********************/
StarHatLexpr::StarHatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

StarHatLexpr::StarHatLexpr(const StarHatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

StarHatLexpr &StarHatLexpr::operator=(const StarHatLexpr & other)
{
  StarHatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StarHatLexpr::swap(StarHatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

StarHatLexpr::~StarHatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void StarHatLexpr::accept(Visitor *v)
{
  v->visitStarHatLexpr(this);
}

StarHatLexpr *StarHatLexpr::clone() const
{
  return new StarHatLexpr(*this);
}



/********************   ArrowLexpr    ********************/
ArrowLexpr::ArrowLexpr(Lexpr *p1, IdentifierOrTypenameFull *p2)
{
  lexpr_ = p1;
  identifierortypenamefull_ = p2;

}

ArrowLexpr::ArrowLexpr(const ArrowLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();

}

ArrowLexpr &ArrowLexpr::operator=(const ArrowLexpr & other)
{
  ArrowLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ArrowLexpr::swap(ArrowLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);

}

ArrowLexpr::~ArrowLexpr()
{
  delete(lexpr_);
  delete(identifierortypenamefull_);

}

void ArrowLexpr::accept(Visitor *v)
{
  v->visitArrowLexpr(this);
}

ArrowLexpr *ArrowLexpr::clone() const
{
  return new ArrowLexpr(*this);
}



/********************   DotLexpr    ********************/
DotLexpr::DotLexpr(Lexpr *p1, IdentifierOrTypenameFull *p2)
{
  lexpr_ = p1;
  identifierortypenamefull_ = p2;

}

DotLexpr::DotLexpr(const DotLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();

}

DotLexpr &DotLexpr::operator=(const DotLexpr & other)
{
  DotLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DotLexpr::swap(DotLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);

}

DotLexpr::~DotLexpr()
{
  delete(lexpr_);
  delete(identifierortypenamefull_);

}

void DotLexpr::accept(Visitor *v)
{
  v->visitDotLexpr(this);
}

DotLexpr *DotLexpr::clone() const
{
  return new DotLexpr(*this);
}



/********************   SquaresRangeLexpr    ********************/
SquaresRangeLexpr::SquaresRangeLexpr(Lexpr *p1, Range *p2)
{
  lexpr_ = p1;
  range_ = p2;

}

SquaresRangeLexpr::SquaresRangeLexpr(const SquaresRangeLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  range_ = other.range_->clone();

}

SquaresRangeLexpr &SquaresRangeLexpr::operator=(const SquaresRangeLexpr & other)
{
  SquaresRangeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SquaresRangeLexpr::swap(SquaresRangeLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(range_, other.range_);

}

SquaresRangeLexpr::~SquaresRangeLexpr()
{
  delete(lexpr_);
  delete(range_);

}

void SquaresRangeLexpr::accept(Visitor *v)
{
  v->visitSquaresRangeLexpr(this);
}

SquaresRangeLexpr *SquaresRangeLexpr::clone() const
{
  return new SquaresRangeLexpr(*this);
}



/********************   SquaresLexpr    ********************/
SquaresLexpr::SquaresLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

SquaresLexpr::SquaresLexpr(const SquaresLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

SquaresLexpr &SquaresLexpr::operator=(const SquaresLexpr & other)
{
  SquaresLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SquaresLexpr::swap(SquaresLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

SquaresLexpr::~SquaresLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void SquaresLexpr::accept(Visitor *v)
{
  v->visitSquaresLexpr(this);
}

SquaresLexpr *SquaresLexpr::clone() const
{
  return new SquaresLexpr(*this);
}



/********************   SquaresPipeLexpr    ********************/
SquaresPipeLexpr::SquaresPipeLexpr(LexprList *p1)
{
  lexprlist_ = p1;

}

SquaresPipeLexpr::SquaresPipeLexpr(const SquaresPipeLexpr & other)
{
  lexprlist_ = other.lexprlist_->clone();

}

SquaresPipeLexpr &SquaresPipeLexpr::operator=(const SquaresPipeLexpr & other)
{
  SquaresPipeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SquaresPipeLexpr::swap(SquaresPipeLexpr & other)
{
  std::swap(lexprlist_, other.lexprlist_);

}

SquaresPipeLexpr::~SquaresPipeLexpr()
{
  delete(lexprlist_);

}

void SquaresPipeLexpr::accept(Visitor *v)
{
  v->visitSquaresPipeLexpr(this);
}

SquaresPipeLexpr *SquaresPipeLexpr::clone() const
{
  return new SquaresPipeLexpr(*this);
}



/********************   MinusLexpr    ********************/
MinusLexpr::MinusLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

MinusLexpr::MinusLexpr(const MinusLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

MinusLexpr &MinusLexpr::operator=(const MinusLexpr & other)
{
  MinusLexpr tmp(other);
  swap(tmp);
  return *this;
}

void MinusLexpr::swap(MinusLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

MinusLexpr::~MinusLexpr()
{
  delete(lexpr_);

}

void MinusLexpr::accept(Visitor *v)
{
  v->visitMinusLexpr(this);
}

MinusLexpr *MinusLexpr::clone() const
{
  return new MinusLexpr(*this);
}



/********************   PlusLexpr    ********************/
PlusLexpr::PlusLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

PlusLexpr::PlusLexpr(const PlusLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

PlusLexpr &PlusLexpr::operator=(const PlusLexpr & other)
{
  PlusLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PlusLexpr::swap(PlusLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

PlusLexpr::~PlusLexpr()
{
  delete(lexpr_);

}

void PlusLexpr::accept(Visitor *v)
{
  v->visitPlusLexpr(this);
}

PlusLexpr *PlusLexpr::clone() const
{
  return new PlusLexpr(*this);
}



/********************   TildeLexpr    ********************/
TildeLexpr::TildeLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

TildeLexpr::TildeLexpr(const TildeLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

TildeLexpr &TildeLexpr::operator=(const TildeLexpr & other)
{
  TildeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TildeLexpr::swap(TildeLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

TildeLexpr::~TildeLexpr()
{
  delete(lexpr_);

}

void TildeLexpr::accept(Visitor *v)
{
  v->visitTildeLexpr(this);
}

TildeLexpr *TildeLexpr::clone() const
{
  return new TildeLexpr(*this);
}



/********************   StarLexpr    ********************/
StarLexpr::StarLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

StarLexpr::StarLexpr(const StarLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

StarLexpr &StarLexpr::operator=(const StarLexpr & other)
{
  StarLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StarLexpr::swap(StarLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

StarLexpr::~StarLexpr()
{
  delete(lexpr_);

}

void StarLexpr::accept(Visitor *v)
{
  v->visitStarLexpr(this);
}

StarLexpr *StarLexpr::clone() const
{
  return new StarLexpr(*this);
}



/********************   AmpUnaryLexpr    ********************/
AmpUnaryLexpr::AmpUnaryLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

AmpUnaryLexpr::AmpUnaryLexpr(const AmpUnaryLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

AmpUnaryLexpr &AmpUnaryLexpr::operator=(const AmpUnaryLexpr & other)
{
  AmpUnaryLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AmpUnaryLexpr::swap(AmpUnaryLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AmpUnaryLexpr::~AmpUnaryLexpr()
{
  delete(lexpr_);

}

void AmpUnaryLexpr::accept(Visitor *v)
{
  v->visitAmpUnaryLexpr(this);
}

AmpUnaryLexpr *AmpUnaryLexpr::clone() const
{
  return new AmpUnaryLexpr(*this);
}



/********************   SizeOfLexpr    ********************/
SizeOfLexpr::SizeOfLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

SizeOfLexpr::SizeOfLexpr(const SizeOfLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

SizeOfLexpr &SizeOfLexpr::operator=(const SizeOfLexpr & other)
{
  SizeOfLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SizeOfLexpr::swap(SizeOfLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SizeOfLexpr::~SizeOfLexpr()
{
  delete(lexpr_);

}

void SizeOfLexpr::accept(Visitor *v)
{
  v->visitSizeOfLexpr(this);
}

SizeOfLexpr *SizeOfLexpr::clone() const
{
  return new SizeOfLexpr(*this);
}



/********************   SizeOfLogicTypeLexpr    ********************/
SizeOfLogicTypeLexpr::SizeOfLogicTypeLexpr(CastLogicType *p1)
{
  castlogictype_ = p1;

}

SizeOfLogicTypeLexpr::SizeOfLogicTypeLexpr(const SizeOfLogicTypeLexpr & other)
{
  castlogictype_ = other.castlogictype_->clone();

}

SizeOfLogicTypeLexpr &SizeOfLogicTypeLexpr::operator=(const SizeOfLogicTypeLexpr & other)
{
  SizeOfLogicTypeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SizeOfLogicTypeLexpr::swap(SizeOfLogicTypeLexpr & other)
{
  std::swap(castlogictype_, other.castlogictype_);

}

SizeOfLogicTypeLexpr::~SizeOfLogicTypeLexpr()
{
  delete(castlogictype_);

}

void SizeOfLogicTypeLexpr::accept(Visitor *v)
{
  v->visitSizeOfLogicTypeLexpr(this);
}

SizeOfLogicTypeLexpr *SizeOfLogicTypeLexpr::clone() const
{
  return new SizeOfLogicTypeLexpr(*this);
}



/********************   OldLexpr    ********************/
OldLexpr::OldLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

OldLexpr::OldLexpr(const OldLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

OldLexpr &OldLexpr::operator=(const OldLexpr & other)
{
  OldLexpr tmp(other);
  swap(tmp);
  return *this;
}

void OldLexpr::swap(OldLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

OldLexpr::~OldLexpr()
{
  delete(lexpr_);

}

void OldLexpr::accept(Visitor *v)
{
  v->visitOldLexpr(this);
}

OldLexpr *OldLexpr::clone() const
{
  return new OldLexpr(*this);
}



/********************   AtLexpr    ********************/
AtLexpr::AtLexpr(Lexpr *p1, LabelName *p2)
{
  lexpr_ = p1;
  labelname_ = p2;

}

AtLexpr::AtLexpr(const AtLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  labelname_ = other.labelname_->clone();

}

AtLexpr &AtLexpr::operator=(const AtLexpr & other)
{
  AtLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AtLexpr::swap(AtLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(labelname_, other.labelname_);

}

AtLexpr::~AtLexpr()
{
  delete(lexpr_);
  delete(labelname_);

}

void AtLexpr::accept(Visitor *v)
{
  v->visitAtLexpr(this);
}

AtLexpr *AtLexpr::clone() const
{
  return new AtLexpr(*this);
}



/********************   ResultLexpr    ********************/
ResultLexpr::ResultLexpr()
{

}

ResultLexpr::ResultLexpr(const ResultLexpr & other)
{

}

ResultLexpr &ResultLexpr::operator=(const ResultLexpr & other)
{
  ResultLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ResultLexpr::swap(ResultLexpr & other)
{

}

ResultLexpr::~ResultLexpr()
{

}

void ResultLexpr::accept(Visitor *v)
{
  v->visitResultLexpr(this);
}

ResultLexpr *ResultLexpr::clone() const
{
  return new ResultLexpr(*this);
}



/********************   SeparatedLexpr    ********************/
SeparatedLexpr::SeparatedLexpr(ListLexpr *p1)
{
  listlexpr_ = p1;

}

SeparatedLexpr::SeparatedLexpr(const SeparatedLexpr & other)
{
  listlexpr_ = other.listlexpr_->clone();

}

SeparatedLexpr &SeparatedLexpr::operator=(const SeparatedLexpr & other)
{
  SeparatedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SeparatedLexpr::swap(SeparatedLexpr & other)
{
  std::swap(listlexpr_, other.listlexpr_);

}

SeparatedLexpr::~SeparatedLexpr()
{
  delete(listlexpr_);

}

void SeparatedLexpr::accept(Visitor *v)
{
  v->visitSeparatedLexpr(this);
}

SeparatedLexpr *SeparatedLexpr::clone() const
{
  return new SeparatedLexpr(*this);
}



/********************   FullIdParenLexpr    ********************/
FullIdParenLexpr::FullIdParenLexpr(FullIdentifier *p1, ListLexpr *p2)
{
  fullidentifier_ = p1;
  listlexpr_ = p2;

}

FullIdParenLexpr::FullIdParenLexpr(const FullIdParenLexpr & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listlexpr_ = other.listlexpr_->clone();

}

FullIdParenLexpr &FullIdParenLexpr::operator=(const FullIdParenLexpr & other)
{
  FullIdParenLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FullIdParenLexpr::swap(FullIdParenLexpr & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listlexpr_, other.listlexpr_);

}

FullIdParenLexpr::~FullIdParenLexpr()
{
  delete(fullidentifier_);
  delete(listlexpr_);

}

void FullIdParenLexpr::accept(Visitor *v)
{
  v->visitFullIdParenLexpr(this);
}

FullIdParenLexpr *FullIdParenLexpr::clone() const
{
  return new FullIdParenLexpr(*this);
}



/********************   FullIdBraceParenLexpr    ********************/
FullIdBraceParenLexpr::FullIdBraceParenLexpr(FullIdentifier *p1, ListIdentifierOrTypenameFull *p2, ListLexpr *p3)
{
  fullidentifier_ = p1;
  listidentifierortypenamefull_ = p2;
  listlexpr_ = p3;

}

FullIdBraceParenLexpr::FullIdBraceParenLexpr(const FullIdBraceParenLexpr & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listidentifierortypenamefull_ = other.listidentifierortypenamefull_->clone();
  listlexpr_ = other.listlexpr_->clone();

}

FullIdBraceParenLexpr &FullIdBraceParenLexpr::operator=(const FullIdBraceParenLexpr & other)
{
  FullIdBraceParenLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FullIdBraceParenLexpr::swap(FullIdBraceParenLexpr & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listidentifierortypenamefull_, other.listidentifierortypenamefull_);
  std::swap(listlexpr_, other.listlexpr_);

}

FullIdBraceParenLexpr::~FullIdBraceParenLexpr()
{
  delete(fullidentifier_);
  delete(listidentifierortypenamefull_);
  delete(listlexpr_);

}

void FullIdBraceParenLexpr::accept(Visitor *v)
{
  v->visitFullIdBraceParenLexpr(this);
}

FullIdBraceParenLexpr *FullIdBraceParenLexpr::clone() const
{
  return new FullIdBraceParenLexpr(*this);
}



/********************   FullIdBracesLexpr    ********************/
FullIdBracesLexpr::FullIdBracesLexpr(FullIdentifier *p1, ListIdentifierOrTypenameFull *p2)
{
  fullidentifier_ = p1;
  listidentifierortypenamefull_ = p2;

}

FullIdBracesLexpr::FullIdBracesLexpr(const FullIdBracesLexpr & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listidentifierortypenamefull_ = other.listidentifierortypenamefull_->clone();

}

FullIdBracesLexpr &FullIdBracesLexpr::operator=(const FullIdBracesLexpr & other)
{
  FullIdBracesLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FullIdBracesLexpr::swap(FullIdBracesLexpr & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listidentifierortypenamefull_, other.listidentifierortypenamefull_);

}

FullIdBracesLexpr::~FullIdBracesLexpr()
{
  delete(fullidentifier_);
  delete(listidentifierortypenamefull_);

}

void FullIdBracesLexpr::accept(Visitor *v)
{
  v->visitFullIdBracesLexpr(this);
}

FullIdBracesLexpr *FullIdBracesLexpr::clone() const
{
  return new FullIdBracesLexpr(*this);
}



/********************   FullId    ********************/
FullId::FullId(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

FullId::FullId(const FullId & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

FullId &FullId::operator=(const FullId & other)
{
  FullId tmp(other);
  swap(tmp);
  return *this;
}

void FullId::swap(FullId & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

FullId::~FullId()
{
  delete(fullidentifier_);

}

void FullId::accept(Visitor *v)
{
  v->visitFullId(this);
}

FullId *FullId::clone() const
{
  return new FullId(*this);
}



/********************   PiLexpr    ********************/
PiLexpr::PiLexpr()
{

}

PiLexpr::PiLexpr(const PiLexpr & other)
{

}

PiLexpr &PiLexpr::operator=(const PiLexpr & other)
{
  PiLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PiLexpr::swap(PiLexpr & other)
{

}

PiLexpr::~PiLexpr()
{

}

void PiLexpr::accept(Visitor *v)
{
  v->visitPiLexpr(this);
}

PiLexpr *PiLexpr::clone() const
{
  return new PiLexpr(*this);
}



/********************   LessLessLexpr    ********************/
LessLessLexpr::LessLessLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

LessLessLexpr::LessLessLexpr(const LessLessLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

LessLessLexpr &LessLessLexpr::operator=(const LessLessLexpr & other)
{
  LessLessLexpr tmp(other);
  swap(tmp);
  return *this;
}

void LessLessLexpr::swap(LessLessLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

LessLessLexpr::~LessLessLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void LessLessLexpr::accept(Visitor *v)
{
  v->visitLessLessLexpr(this);
}

LessLessLexpr *LessLessLexpr::clone() const
{
  return new LessLessLexpr(*this);
}



/********************   GreaterGreaterLexpr    ********************/
GreaterGreaterLexpr::GreaterGreaterLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

GreaterGreaterLexpr::GreaterGreaterLexpr(const GreaterGreaterLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

GreaterGreaterLexpr &GreaterGreaterLexpr::operator=(const GreaterGreaterLexpr & other)
{
  GreaterGreaterLexpr tmp(other);
  swap(tmp);
  return *this;
}

void GreaterGreaterLexpr::swap(GreaterGreaterLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

GreaterGreaterLexpr::~GreaterGreaterLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void GreaterGreaterLexpr::accept(Visitor *v)
{
  v->visitGreaterGreaterLexpr(this);
}

GreaterGreaterLexpr *GreaterGreaterLexpr::clone() const
{
  return new GreaterGreaterLexpr(*this);
}



/********************   ParenRangeLexpr    ********************/
ParenRangeLexpr::ParenRangeLexpr(Range *p1)
{
  range_ = p1;

}

ParenRangeLexpr::ParenRangeLexpr(const ParenRangeLexpr & other)
{
  range_ = other.range_->clone();

}

ParenRangeLexpr &ParenRangeLexpr::operator=(const ParenRangeLexpr & other)
{
  ParenRangeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ParenRangeLexpr::swap(ParenRangeLexpr & other)
{
  std::swap(range_, other.range_);

}

ParenRangeLexpr::~ParenRangeLexpr()
{
  delete(range_);

}

void ParenRangeLexpr::accept(Visitor *v)
{
  v->visitParenRangeLexpr(this);
}

ParenRangeLexpr *ParenRangeLexpr::clone() const
{
  return new ParenRangeLexpr(*this);
}



/********************   CastLexpr    ********************/
CastLexpr::CastLexpr(CastLogicType *p1, Lexpr *p2)
{
  castlogictype_ = p1;
  lexpr_ = p2;

}

CastLexpr::CastLexpr(const CastLexpr & other)
{
  castlogictype_ = other.castlogictype_->clone();
  lexpr_ = other.lexpr_->clone();

}

CastLexpr &CastLexpr::operator=(const CastLexpr & other)
{
  CastLexpr tmp(other);
  swap(tmp);
  return *this;
}

void CastLexpr::swap(CastLexpr & other)
{
  std::swap(castlogictype_, other.castlogictype_);
  std::swap(lexpr_, other.lexpr_);

}

CastLexpr::~CastLexpr()
{
  delete(castlogictype_);
  delete(lexpr_);

}

void CastLexpr::accept(Visitor *v)
{
  v->visitCastLexpr(this);
}

CastLexpr *CastLexpr::clone() const
{
  return new CastLexpr(*this);
}



/********************   TypeOfLexpr    ********************/
TypeOfLexpr::TypeOfLexpr(Lexpr *p1)
{
  lexpr_ = p1;

}

TypeOfLexpr::TypeOfLexpr(const TypeOfLexpr & other)
{
  lexpr_ = other.lexpr_->clone();

}

TypeOfLexpr &TypeOfLexpr::operator=(const TypeOfLexpr & other)
{
  TypeOfLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TypeOfLexpr::swap(TypeOfLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);

}

TypeOfLexpr::~TypeOfLexpr()
{
  delete(lexpr_);

}

void TypeOfLexpr::accept(Visitor *v)
{
  v->visitTypeOfLexpr(this);
}

TypeOfLexpr *TypeOfLexpr::clone() const
{
  return new TypeOfLexpr(*this);
}



/********************   TypeLexpr    ********************/
TypeLexpr::TypeLexpr(TypeSpecOFTYPENAME *p1)
{
  typespecoftypename_ = p1;

}

TypeLexpr::TypeLexpr(const TypeLexpr & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();

}

TypeLexpr &TypeLexpr::operator=(const TypeLexpr & other)
{
  TypeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TypeLexpr::swap(TypeLexpr & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);

}

TypeLexpr::~TypeLexpr()
{
  delete(typespecoftypename_);

}

void TypeLexpr::accept(Visitor *v)
{
  v->visitTypeLexpr(this);
}

TypeLexpr *TypeLexpr::clone() const
{
  return new TypeLexpr(*this);
}



/********************   TypeWithStarsLexpr    ********************/
TypeWithStarsLexpr::TypeWithStarsLexpr(TypeSpecOFTYPENAME *p1, ListStars *p2)
{
  typespecoftypename_ = p1;
  liststars_ = p2;

}

TypeWithStarsLexpr::TypeWithStarsLexpr(const TypeWithStarsLexpr & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  liststars_ = other.liststars_->clone();

}

TypeWithStarsLexpr &TypeWithStarsLexpr::operator=(const TypeWithStarsLexpr & other)
{
  TypeWithStarsLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TypeWithStarsLexpr::swap(TypeWithStarsLexpr & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(liststars_, other.liststars_);

}

TypeWithStarsLexpr::~TypeWithStarsLexpr()
{
  delete(typespecoftypename_);
  delete(liststars_);

}

void TypeWithStarsLexpr::accept(Visitor *v)
{
  v->visitTypeWithStarsLexpr(this);
}

TypeWithStarsLexpr *TypeWithStarsLexpr::clone() const
{
  return new TypeWithStarsLexpr(*this);
}



/********************   EmptyLexpr    ********************/
EmptyLexpr::EmptyLexpr()
{

}

EmptyLexpr::EmptyLexpr(const EmptyLexpr & other)
{

}

EmptyLexpr &EmptyLexpr::operator=(const EmptyLexpr & other)
{
  EmptyLexpr tmp(other);
  swap(tmp);
  return *this;
}

void EmptyLexpr::swap(EmptyLexpr & other)
{

}

EmptyLexpr::~EmptyLexpr()
{

}

void EmptyLexpr::accept(Visitor *v)
{
  v->visitEmptyLexpr(this);
}

EmptyLexpr *EmptyLexpr::clone() const
{
  return new EmptyLexpr(*this);
}



/********************   UnionLexpr    ********************/
UnionLexpr::UnionLexpr(LexprList *p1)
{
  lexprlist_ = p1;

}

UnionLexpr::UnionLexpr(const UnionLexpr & other)
{
  lexprlist_ = other.lexprlist_->clone();

}

UnionLexpr &UnionLexpr::operator=(const UnionLexpr & other)
{
  UnionLexpr tmp(other);
  swap(tmp);
  return *this;
}

void UnionLexpr::swap(UnionLexpr & other)
{
  std::swap(lexprlist_, other.lexprlist_);

}

UnionLexpr::~UnionLexpr()
{
  delete(lexprlist_);

}

void UnionLexpr::accept(Visitor *v)
{
  v->visitUnionLexpr(this);
}

UnionLexpr *UnionLexpr::clone() const
{
  return new UnionLexpr(*this);
}



/********************   InterLexpr    ********************/
InterLexpr::InterLexpr(LexprList *p1)
{
  lexprlist_ = p1;

}

InterLexpr::InterLexpr(const InterLexpr & other)
{
  lexprlist_ = other.lexprlist_->clone();

}

InterLexpr &InterLexpr::operator=(const InterLexpr & other)
{
  InterLexpr tmp(other);
  swap(tmp);
  return *this;
}

void InterLexpr::swap(InterLexpr & other)
{
  std::swap(lexprlist_, other.lexprlist_);

}

InterLexpr::~InterLexpr()
{
  delete(lexprlist_);

}

void InterLexpr::accept(Visitor *v)
{
  v->visitInterLexpr(this);
}

InterLexpr *InterLexpr::clone() const
{
  return new InterLexpr(*this);
}



/********************   BraceLexprList    ********************/
BraceLexprList::BraceLexprList(LexprList *p1)
{
  lexprlist_ = p1;

}

BraceLexprList::BraceLexprList(const BraceLexprList & other)
{
  lexprlist_ = other.lexprlist_->clone();

}

BraceLexprList &BraceLexprList::operator=(const BraceLexprList & other)
{
  BraceLexprList tmp(other);
  swap(tmp);
  return *this;
}

void BraceLexprList::swap(BraceLexprList & other)
{
  std::swap(lexprlist_, other.lexprlist_);

}

BraceLexprList::~BraceLexprList()
{
  delete(lexprlist_);

}

void BraceLexprList::accept(Visitor *v)
{
  v->visitBraceLexprList(this);
}

BraceLexprList *BraceLexprList::clone() const
{
  return new BraceLexprList(*this);
}



/********************   BraceBinderLexpr    ********************/
BraceBinderLexpr::BraceBinderLexpr(Lexpr *p1, Binders *p2)
{
  lexpr_ = p1;
  binders_ = p2;

}

BraceBinderLexpr::BraceBinderLexpr(const BraceBinderLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  binders_ = other.binders_->clone();

}

BraceBinderLexpr &BraceBinderLexpr::operator=(const BraceBinderLexpr & other)
{
  BraceBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BraceBinderLexpr::swap(BraceBinderLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(binders_, other.binders_);

}

BraceBinderLexpr::~BraceBinderLexpr()
{
  delete(lexpr_);
  delete(binders_);

}

void BraceBinderLexpr::accept(Visitor *v)
{
  v->visitBraceBinderLexpr(this);
}

BraceBinderLexpr *BraceBinderLexpr::clone() const
{
  return new BraceBinderLexpr(*this);
}



/********************   BraceBinderLexprLexpr    ********************/
BraceBinderLexprLexpr::BraceBinderLexprLexpr(Lexpr *p1, Binders *p2, Lexpr *p3)
{
  lexpr_1 = p1;
  binders_ = p2;
  lexpr_2 = p3;

}

BraceBinderLexprLexpr::BraceBinderLexprLexpr(const BraceBinderLexprLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  binders_ = other.binders_->clone();
  lexpr_2 = other.lexpr_2->clone();

}

BraceBinderLexprLexpr &BraceBinderLexprLexpr::operator=(const BraceBinderLexprLexpr & other)
{
  BraceBinderLexprLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BraceBinderLexprLexpr::swap(BraceBinderLexprLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(binders_, other.binders_);
  std::swap(lexpr_2, other.lexpr_2);

}

BraceBinderLexprLexpr::~BraceBinderLexprLexpr()
{
  delete(lexpr_1);
  delete(binders_);
  delete(lexpr_2);

}

void BraceBinderLexprLexpr::accept(Visitor *v)
{
  v->visitBraceBinderLexprLexpr(this);
}

BraceBinderLexprLexpr *BraceBinderLexprLexpr::clone() const
{
  return new BraceBinderLexprLexpr(*this);
}



/********************   FieldInitLexpr    ********************/
FieldInitLexpr::FieldInitLexpr(ListFieldInitElt *p1)
{
  listfieldinitelt_ = p1;

}

FieldInitLexpr::FieldInitLexpr(const FieldInitLexpr & other)
{
  listfieldinitelt_ = other.listfieldinitelt_->clone();

}

FieldInitLexpr &FieldInitLexpr::operator=(const FieldInitLexpr & other)
{
  FieldInitLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FieldInitLexpr::swap(FieldInitLexpr & other)
{
  std::swap(listfieldinitelt_, other.listfieldinitelt_);

}

FieldInitLexpr::~FieldInitLexpr()
{
  delete(listfieldinitelt_);

}

void FieldInitLexpr::accept(Visitor *v)
{
  v->visitFieldInitLexpr(this);
}

FieldInitLexpr *FieldInitLexpr::clone() const
{
  return new FieldInitLexpr(*this);
}



/********************   ArrayInitLexpr    ********************/
ArrayInitLexpr::ArrayInitLexpr(ListArrayInitElt *p1)
{
  listarrayinitelt_ = p1;

}

ArrayInitLexpr::ArrayInitLexpr(const ArrayInitLexpr & other)
{
  listarrayinitelt_ = other.listarrayinitelt_->clone();

}

ArrayInitLexpr &ArrayInitLexpr::operator=(const ArrayInitLexpr & other)
{
  ArrayInitLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ArrayInitLexpr::swap(ArrayInitLexpr & other)
{
  std::swap(listarrayinitelt_, other.listarrayinitelt_);

}

ArrayInitLexpr::~ArrayInitLexpr()
{
  delete(listarrayinitelt_);

}

void ArrayInitLexpr::accept(Visitor *v)
{
  v->visitArrayInitLexpr(this);
}

ArrayInitLexpr *ArrayInitLexpr::clone() const
{
  return new ArrayInitLexpr(*this);
}



/********************   UpdateBraceLexpr    ********************/
UpdateBraceLexpr::UpdateBraceLexpr(Lexpr *p1, ListUpdateElt *p2)
{
  lexpr_ = p1;
  listupdateelt_ = p2;

}

UpdateBraceLexpr::UpdateBraceLexpr(const UpdateBraceLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  listupdateelt_ = other.listupdateelt_->clone();

}

UpdateBraceLexpr &UpdateBraceLexpr::operator=(const UpdateBraceLexpr & other)
{
  UpdateBraceLexpr tmp(other);
  swap(tmp);
  return *this;
}

void UpdateBraceLexpr::swap(UpdateBraceLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(listupdateelt_, other.listupdateelt_);

}

UpdateBraceLexpr::~UpdateBraceLexpr()
{
  delete(lexpr_);
  delete(listupdateelt_);

}

void UpdateBraceLexpr::accept(Visitor *v)
{
  v->visitUpdateBraceLexpr(this);
}

UpdateBraceLexpr *UpdateBraceLexpr::clone() const
{
  return new UpdateBraceLexpr(*this);
}



/********************   LetBinderLexpr    ********************/
LetBinderLexpr::LetBinderLexpr(BoundedVar *p1, Lexpr *p2, Lexpr *p3)
{
  boundedvar_ = p1;
  lexpr_1 = p2;
  lexpr_2 = p3;

}

LetBinderLexpr::LetBinderLexpr(const LetBinderLexpr & other)
{
  boundedvar_ = other.boundedvar_->clone();
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

LetBinderLexpr &LetBinderLexpr::operator=(const LetBinderLexpr & other)
{
  LetBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void LetBinderLexpr::swap(LetBinderLexpr & other)
{
  std::swap(boundedvar_, other.boundedvar_);
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

LetBinderLexpr::~LetBinderLexpr()
{
  delete(boundedvar_);
  delete(lexpr_1);
  delete(lexpr_2);

}

void LetBinderLexpr::accept(Visitor *v)
{
  v->visitLetBinderLexpr(this);
}

LetBinderLexpr *LetBinderLexpr::clone() const
{
  return new LetBinderLexpr(*this);
}



/********************   ForallBinderLexpr    ********************/
ForallBinderLexpr::ForallBinderLexpr(Binders *p1, Lexpr *p2)
{
  binders_ = p1;
  lexpr_ = p2;

}

ForallBinderLexpr::ForallBinderLexpr(const ForallBinderLexpr & other)
{
  binders_ = other.binders_->clone();
  lexpr_ = other.lexpr_->clone();

}

ForallBinderLexpr &ForallBinderLexpr::operator=(const ForallBinderLexpr & other)
{
  ForallBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ForallBinderLexpr::swap(ForallBinderLexpr & other)
{
  std::swap(binders_, other.binders_);
  std::swap(lexpr_, other.lexpr_);

}

ForallBinderLexpr::~ForallBinderLexpr()
{
  delete(binders_);
  delete(lexpr_);

}

void ForallBinderLexpr::accept(Visitor *v)
{
  v->visitForallBinderLexpr(this);
}

ForallBinderLexpr *ForallBinderLexpr::clone() const
{
  return new ForallBinderLexpr(*this);
}



/********************   ExistBinderLexpr    ********************/
ExistBinderLexpr::ExistBinderLexpr(Binders *p1, Lexpr *p2)
{
  binders_ = p1;
  lexpr_ = p2;

}

ExistBinderLexpr::ExistBinderLexpr(const ExistBinderLexpr & other)
{
  binders_ = other.binders_->clone();
  lexpr_ = other.lexpr_->clone();

}

ExistBinderLexpr &ExistBinderLexpr::operator=(const ExistBinderLexpr & other)
{
  ExistBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ExistBinderLexpr::swap(ExistBinderLexpr & other)
{
  std::swap(binders_, other.binders_);
  std::swap(lexpr_, other.lexpr_);

}

ExistBinderLexpr::~ExistBinderLexpr()
{
  delete(binders_);
  delete(lexpr_);

}

void ExistBinderLexpr::accept(Visitor *v)
{
  v->visitExistBinderLexpr(this);
}

ExistBinderLexpr *ExistBinderLexpr::clone() const
{
  return new ExistBinderLexpr(*this);
}



/********************   LambdaBinderLexpr    ********************/
LambdaBinderLexpr::LambdaBinderLexpr(Binders *p1, Lexpr *p2)
{
  binders_ = p1;
  lexpr_ = p2;

}

LambdaBinderLexpr::LambdaBinderLexpr(const LambdaBinderLexpr & other)
{
  binders_ = other.binders_->clone();
  lexpr_ = other.lexpr_->clone();

}

LambdaBinderLexpr &LambdaBinderLexpr::operator=(const LambdaBinderLexpr & other)
{
  LambdaBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void LambdaBinderLexpr::swap(LambdaBinderLexpr & other)
{
  std::swap(binders_, other.binders_);
  std::swap(lexpr_, other.lexpr_);

}

LambdaBinderLexpr::~LambdaBinderLexpr()
{
  delete(binders_);
  delete(lexpr_);

}

void LambdaBinderLexpr::accept(Visitor *v)
{
  v->visitLambdaBinderLexpr(this);
}

LambdaBinderLexpr *LambdaBinderLexpr::clone() const
{
  return new LambdaBinderLexpr(*this);
}



/********************   RelInnerLexpr    ********************/
RelInnerLexpr::RelInnerLexpr(Relation *p1, Lexpr *p2)
{
  relation_ = p1;
  lexpr_ = p2;

}

RelInnerLexpr::RelInnerLexpr(const RelInnerLexpr & other)
{
  relation_ = other.relation_->clone();
  lexpr_ = other.lexpr_->clone();

}

RelInnerLexpr &RelInnerLexpr::operator=(const RelInnerLexpr & other)
{
  RelInnerLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RelInnerLexpr::swap(RelInnerLexpr & other)
{
  std::swap(relation_, other.relation_);
  std::swap(lexpr_, other.lexpr_);

}

RelInnerLexpr::~RelInnerLexpr()
{
  delete(relation_);
  delete(lexpr_);

}

void RelInnerLexpr::accept(Visitor *v)
{
  v->visitRelInnerLexpr(this);
}

RelInnerLexpr *RelInnerLexpr::clone() const
{
  return new RelInnerLexpr(*this);
}



/********************   LessRel    ********************/
LessRel::LessRel()
{

}

LessRel::LessRel(const LessRel & other)
{

}

LessRel &LessRel::operator=(const LessRel & other)
{
  LessRel tmp(other);
  swap(tmp);
  return *this;
}

void LessRel::swap(LessRel & other)
{

}

LessRel::~LessRel()
{

}

void LessRel::accept(Visitor *v)
{
  v->visitLessRel(this);
}

LessRel *LessRel::clone() const
{
  return new LessRel(*this);
}



/********************   GreaterRel    ********************/
GreaterRel::GreaterRel()
{

}

GreaterRel::GreaterRel(const GreaterRel & other)
{

}

GreaterRel &GreaterRel::operator=(const GreaterRel & other)
{
  GreaterRel tmp(other);
  swap(tmp);
  return *this;
}

void GreaterRel::swap(GreaterRel & other)
{

}

GreaterRel::~GreaterRel()
{

}

void GreaterRel::accept(Visitor *v)
{
  v->visitGreaterRel(this);
}

GreaterRel *GreaterRel::clone() const
{
  return new GreaterRel(*this);
}



/********************   LessEqRel    ********************/
LessEqRel::LessEqRel()
{

}

LessEqRel::LessEqRel(const LessEqRel & other)
{

}

LessEqRel &LessEqRel::operator=(const LessEqRel & other)
{
  LessEqRel tmp(other);
  swap(tmp);
  return *this;
}

void LessEqRel::swap(LessEqRel & other)
{

}

LessEqRel::~LessEqRel()
{

}

void LessEqRel::accept(Visitor *v)
{
  v->visitLessEqRel(this);
}

LessEqRel *LessEqRel::clone() const
{
  return new LessEqRel(*this);
}



/********************   GreaterEqRel    ********************/
GreaterEqRel::GreaterEqRel()
{

}

GreaterEqRel::GreaterEqRel(const GreaterEqRel & other)
{

}

GreaterEqRel &GreaterEqRel::operator=(const GreaterEqRel & other)
{
  GreaterEqRel tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqRel::swap(GreaterEqRel & other)
{

}

GreaterEqRel::~GreaterEqRel()
{

}

void GreaterEqRel::accept(Visitor *v)
{
  v->visitGreaterEqRel(this);
}

GreaterEqRel *GreaterEqRel::clone() const
{
  return new GreaterEqRel(*this);
}



/********************   EqRel    ********************/
EqRel::EqRel()
{

}

EqRel::EqRel(const EqRel & other)
{

}

EqRel &EqRel::operator=(const EqRel & other)
{
  EqRel tmp(other);
  swap(tmp);
  return *this;
}

void EqRel::swap(EqRel & other)
{

}

EqRel::~EqRel()
{

}

void EqRel::accept(Visitor *v)
{
  v->visitEqRel(this);
}

EqRel *EqRel::clone() const
{
  return new EqRel(*this);
}



/********************   NotEqRel    ********************/
NotEqRel::NotEqRel()
{

}

NotEqRel::NotEqRel(const NotEqRel & other)
{

}

NotEqRel &NotEqRel::operator=(const NotEqRel & other)
{
  NotEqRel tmp(other);
  swap(tmp);
  return *this;
}

void NotEqRel::swap(NotEqRel & other)
{

}

NotEqRel::~NotEqRel()
{

}

void NotEqRel::accept(Visitor *v)
{
  v->visitNotEqRel(this);
}

NotEqRel *NotEqRel::clone() const
{
  return new NotEqRel(*this);
}



/********************   EQUALRel    ********************/
EQUALRel::EQUALRel()
{

}

EQUALRel::EQUALRel(const EQUALRel & other)
{

}

EQUALRel &EQUALRel::operator=(const EQUALRel & other)
{
  EQUALRel tmp(other);
  swap(tmp);
  return *this;
}

void EQUALRel::swap(EQUALRel & other)
{

}

EQUALRel::~EQUALRel()
{

}

void EQUALRel::accept(Visitor *v)
{
  v->visitEQUALRel(this);
}

EQUALRel *EQUALRel::clone() const
{
  return new EQUALRel(*this);
}



/********************   LexprRange    ********************/
LexprRange::LexprRange(LexprOption *p1, LexprOption *p2)
{
  lexproption_1 = p1;
  lexproption_2 = p2;

}

LexprRange::LexprRange(const LexprRange & other)
{
  lexproption_1 = other.lexproption_1->clone();
  lexproption_2 = other.lexproption_2->clone();

}

LexprRange &LexprRange::operator=(const LexprRange & other)
{
  LexprRange tmp(other);
  swap(tmp);
  return *this;
}

void LexprRange::swap(LexprRange & other)
{
  std::swap(lexproption_1, other.lexproption_1);
  std::swap(lexproption_2, other.lexproption_2);

}

LexprRange::~LexprRange()
{
  delete(lexproption_1);
  delete(lexproption_2);

}

void LexprRange::accept(Visitor *v)
{
  v->visitLexprRange(this);
}

LexprRange *LexprRange::clone() const
{
  return new LexprRange(*this);
}



/********************   AFieldInitElt    ********************/
AFieldInitElt::AFieldInitElt(IdentifierOrTypenameFull *p1, Lexpr *p2)
{
  identifierortypenamefull_ = p1;
  lexpr_ = p2;

}

AFieldInitElt::AFieldInitElt(const AFieldInitElt & other)
{
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();
  lexpr_ = other.lexpr_->clone();

}

AFieldInitElt &AFieldInitElt::operator=(const AFieldInitElt & other)
{
  AFieldInitElt tmp(other);
  swap(tmp);
  return *this;
}

void AFieldInitElt::swap(AFieldInitElt & other)
{
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);
  std::swap(lexpr_, other.lexpr_);

}

AFieldInitElt::~AFieldInitElt()
{
  delete(identifierortypenamefull_);
  delete(lexpr_);

}

void AFieldInitElt::accept(Visitor *v)
{
  v->visitAFieldInitElt(this);
}

AFieldInitElt *AFieldInitElt::clone() const
{
  return new AFieldInitElt(*this);
}



/********************   AnArrayInitElt    ********************/
AnArrayInitElt::AnArrayInitElt(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AnArrayInitElt::AnArrayInitElt(const AnArrayInitElt & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AnArrayInitElt &AnArrayInitElt::operator=(const AnArrayInitElt & other)
{
  AnArrayInitElt tmp(other);
  swap(tmp);
  return *this;
}

void AnArrayInitElt::swap(AnArrayInitElt & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AnArrayInitElt::~AnArrayInitElt()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AnArrayInitElt::accept(Visitor *v)
{
  v->visitAnArrayInitElt(this);
}

AnArrayInitElt *AnArrayInitElt::clone() const
{
  return new AnArrayInitElt(*this);
}



/********************   ArrayInitRangeElt    ********************/
ArrayInitRangeElt::ArrayInitRangeElt(Range *p1, Lexpr *p2)
{
  range_ = p1;
  lexpr_ = p2;

}

ArrayInitRangeElt::ArrayInitRangeElt(const ArrayInitRangeElt & other)
{
  range_ = other.range_->clone();
  lexpr_ = other.lexpr_->clone();

}

ArrayInitRangeElt &ArrayInitRangeElt::operator=(const ArrayInitRangeElt & other)
{
  ArrayInitRangeElt tmp(other);
  swap(tmp);
  return *this;
}

void ArrayInitRangeElt::swap(ArrayInitRangeElt & other)
{
  std::swap(range_, other.range_);
  std::swap(lexpr_, other.lexpr_);

}

ArrayInitRangeElt::~ArrayInitRangeElt()
{
  delete(range_);
  delete(lexpr_);

}

void ArrayInitRangeElt::accept(Visitor *v)
{
  v->visitArrayInitRangeElt(this);
}

ArrayInitRangeElt *ArrayInitRangeElt::clone() const
{
  return new ArrayInitRangeElt(*this);
}



/********************   AnUpdateElt    ********************/
AnUpdateElt::AnUpdateElt(ListPathElt *p1, Lexpr *p2)
{
  listpathelt_ = p1;
  lexpr_ = p2;

}

AnUpdateElt::AnUpdateElt(const AnUpdateElt & other)
{
  listpathelt_ = other.listpathelt_->clone();
  lexpr_ = other.lexpr_->clone();

}

AnUpdateElt &AnUpdateElt::operator=(const AnUpdateElt & other)
{
  AnUpdateElt tmp(other);
  swap(tmp);
  return *this;
}

void AnUpdateElt::swap(AnUpdateElt & other)
{
  std::swap(listpathelt_, other.listpathelt_);
  std::swap(lexpr_, other.lexpr_);

}

AnUpdateElt::~AnUpdateElt()
{
  delete(listpathelt_);
  delete(lexpr_);

}

void AnUpdateElt::accept(Visitor *v)
{
  v->visitAnUpdateElt(this);
}

AnUpdateElt *AnUpdateElt::clone() const
{
  return new AnUpdateElt(*this);
}



/********************   UpdateEltWith    ********************/
UpdateEltWith::UpdateEltWith(ListPathElt *p1, ListUpdateElt *p2)
{
  listpathelt_ = p1;
  listupdateelt_ = p2;

}

UpdateEltWith::UpdateEltWith(const UpdateEltWith & other)
{
  listpathelt_ = other.listpathelt_->clone();
  listupdateelt_ = other.listupdateelt_->clone();

}

UpdateEltWith &UpdateEltWith::operator=(const UpdateEltWith & other)
{
  UpdateEltWith tmp(other);
  swap(tmp);
  return *this;
}

void UpdateEltWith::swap(UpdateEltWith & other)
{
  std::swap(listpathelt_, other.listpathelt_);
  std::swap(listupdateelt_, other.listupdateelt_);

}

UpdateEltWith::~UpdateEltWith()
{
  delete(listpathelt_);
  delete(listupdateelt_);

}

void UpdateEltWith::accept(Visitor *v)
{
  v->visitUpdateEltWith(this);
}

UpdateEltWith *UpdateEltWith::clone() const
{
  return new UpdateEltWith(*this);
}



/********************   FieldElt    ********************/
FieldElt::FieldElt(IdentifierOrTypenameFull *p1)
{
  identifierortypenamefull_ = p1;

}

FieldElt::FieldElt(const FieldElt & other)
{
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();

}

FieldElt &FieldElt::operator=(const FieldElt & other)
{
  FieldElt tmp(other);
  swap(tmp);
  return *this;
}

void FieldElt::swap(FieldElt & other)
{
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);

}

FieldElt::~FieldElt()
{
  delete(identifierortypenamefull_);

}

void FieldElt::accept(Visitor *v)
{
  v->visitFieldElt(this);
}

FieldElt *FieldElt::clone() const
{
  return new FieldElt(*this);
}



/********************   ArrayElt    ********************/
ArrayElt::ArrayElt(Lexpr *p1)
{
  lexpr_ = p1;

}

ArrayElt::ArrayElt(const ArrayElt & other)
{
  lexpr_ = other.lexpr_->clone();

}

ArrayElt &ArrayElt::operator=(const ArrayElt & other)
{
  ArrayElt tmp(other);
  swap(tmp);
  return *this;
}

void ArrayElt::swap(ArrayElt & other)
{
  std::swap(lexpr_, other.lexpr_);

}

ArrayElt::~ArrayElt()
{
  delete(lexpr_);

}

void ArrayElt::accept(Visitor *v)
{
  v->visitArrayElt(this);
}

ArrayElt *ArrayElt::clone() const
{
  return new ArrayElt(*this);
}



/********************   ArrayRangeElt    ********************/
ArrayRangeElt::ArrayRangeElt(Range *p1)
{
  range_ = p1;

}

ArrayRangeElt::ArrayRangeElt(const ArrayRangeElt & other)
{
  range_ = other.range_->clone();

}

ArrayRangeElt &ArrayRangeElt::operator=(const ArrayRangeElt & other)
{
  ArrayRangeElt tmp(other);
  swap(tmp);
  return *this;
}

void ArrayRangeElt::swap(ArrayRangeElt & other)
{
  std::swap(range_, other.range_);

}

ArrayRangeElt::~ArrayRangeElt()
{
  delete(range_);

}

void ArrayRangeElt::accept(Visitor *v)
{
  v->visitArrayRangeElt(this);
}

ArrayRangeElt *ArrayRangeElt::clone() const
{
  return new ArrayRangeElt(*this);
}



/********************   TheBinders    ********************/
TheBinders::TheBinders(TypeSpecOFTYPENAME *p1, VarSpec *p2, ListBindersReentrance *p3)
{
  typespecoftypename_ = p1;
  varspec_ = p2;
  listbindersreentrance_ = p3;

}

TheBinders::TheBinders(const TheBinders & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  varspec_ = other.varspec_->clone();
  listbindersreentrance_ = other.listbindersreentrance_->clone();

}

TheBinders &TheBinders::operator=(const TheBinders & other)
{
  TheBinders tmp(other);
  swap(tmp);
  return *this;
}

void TheBinders::swap(TheBinders & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(varspec_, other.varspec_);
  std::swap(listbindersreentrance_, other.listbindersreentrance_);

}

TheBinders::~TheBinders()
{
  delete(typespecoftypename_);
  delete(varspec_);
  delete(listbindersreentrance_);

}

void TheBinders::accept(Visitor *v)
{
  v->visitTheBinders(this);
}

TheBinders *TheBinders::clone() const
{
  return new TheBinders(*this);
}



/********************   BindersReentranceDeclSpec    ********************/
BindersReentranceDeclSpec::BindersReentranceDeclSpec(TypeSpecOFTYPENAME *p1, VarSpec *p2)
{
  typespecoftypename_ = p1;
  varspec_ = p2;

}

BindersReentranceDeclSpec::BindersReentranceDeclSpec(const BindersReentranceDeclSpec & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  varspec_ = other.varspec_->clone();

}

BindersReentranceDeclSpec &BindersReentranceDeclSpec::operator=(const BindersReentranceDeclSpec & other)
{
  BindersReentranceDeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void BindersReentranceDeclSpec::swap(BindersReentranceDeclSpec & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(varspec_, other.varspec_);

}

BindersReentranceDeclSpec::~BindersReentranceDeclSpec()
{
  delete(typespecoftypename_);
  delete(varspec_);

}

void BindersReentranceDeclSpec::accept(Visitor *v)
{
  v->visitBindersReentranceDeclSpec(this);
}

BindersReentranceDeclSpec *BindersReentranceDeclSpec::clone() const
{
  return new BindersReentranceDeclSpec(*this);
}



/********************   BindersReentranceVarSpec    ********************/
BindersReentranceVarSpec::BindersReentranceVarSpec(VarSpec *p1)
{
  varspec_ = p1;

}

BindersReentranceVarSpec::BindersReentranceVarSpec(const BindersReentranceVarSpec & other)
{
  varspec_ = other.varspec_->clone();

}

BindersReentranceVarSpec &BindersReentranceVarSpec::operator=(const BindersReentranceVarSpec & other)
{
  BindersReentranceVarSpec tmp(other);
  swap(tmp);
  return *this;
}

void BindersReentranceVarSpec::swap(BindersReentranceVarSpec & other)
{
  std::swap(varspec_, other.varspec_);

}

BindersReentranceVarSpec::~BindersReentranceVarSpec()
{
  delete(varspec_);

}

void BindersReentranceVarSpec::accept(Visitor *v)
{
  v->visitBindersReentranceVarSpec(this);
}

BindersReentranceVarSpec *BindersReentranceVarSpec::clone() const
{
  return new BindersReentranceVarSpec(*this);
}



/********************   StartVarSpec    ********************/
StartVarSpec::StartVarSpec(ListStars *p1, VarSpec *p2)
{
  liststars_ = p1;
  varspec_ = p2;

}

StartVarSpec::StartVarSpec(const StartVarSpec & other)
{
  liststars_ = other.liststars_->clone();
  varspec_ = other.varspec_->clone();

}

StartVarSpec &StartVarSpec::operator=(const StartVarSpec & other)
{
  StartVarSpec tmp(other);
  swap(tmp);
  return *this;
}

void StartVarSpec::swap(StartVarSpec & other)
{
  std::swap(liststars_, other.liststars_);
  std::swap(varspec_, other.varspec_);

}

StartVarSpec::~StartVarSpec()
{
  delete(liststars_);
  delete(varspec_);

}

void StartVarSpec::accept(Visitor *v)
{
  v->visitStartVarSpec(this);
}

StartVarSpec *StartVarSpec::clone() const
{
  return new StartVarSpec(*this);
}



/********************   SimpleSpec    ********************/
SimpleSpec::SimpleSpec(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

SimpleSpec::SimpleSpec(const SimpleSpec & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

SimpleSpec &SimpleSpec::operator=(const SimpleSpec & other)
{
  SimpleSpec tmp(other);
  swap(tmp);
  return *this;
}

void SimpleSpec::swap(SimpleSpec & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

SimpleSpec::~SimpleSpec()
{
  delete(fullidentifier_);

}

void SimpleSpec::accept(Visitor *v)
{
  v->visitSimpleSpec(this);
}

SimpleSpec *SimpleSpec::clone() const
{
  return new SimpleSpec(*this);
}



/********************   ArraySpec    ********************/
ArraySpec::ArraySpec(VarSpec *p1, ArraySize *p2)
{
  varspec_ = p1;
  arraysize_ = p2;

}

ArraySpec::ArraySpec(const ArraySpec & other)
{
  varspec_ = other.varspec_->clone();
  arraysize_ = other.arraysize_->clone();

}

ArraySpec &ArraySpec::operator=(const ArraySpec & other)
{
  ArraySpec tmp(other);
  swap(tmp);
  return *this;
}

void ArraySpec::swap(ArraySpec & other)
{
  std::swap(varspec_, other.varspec_);
  std::swap(arraysize_, other.arraysize_);

}

ArraySpec::~ArraySpec()
{
  delete(varspec_);
  delete(arraysize_);

}

void ArraySpec::accept(Visitor *v)
{
  v->visitArraySpec(this);
}

ArraySpec *ArraySpec::clone() const
{
  return new ArraySpec(*this);
}



/********************   FunctionSpec    ********************/
FunctionSpec::FunctionSpec(VarSpec *p1, AbsParamTypeList *p2)
{
  varspec_ = p1;
  absparamtypelist_ = p2;

}

FunctionSpec::FunctionSpec(const FunctionSpec & other)
{
  varspec_ = other.varspec_->clone();
  absparamtypelist_ = other.absparamtypelist_->clone();

}

FunctionSpec &FunctionSpec::operator=(const FunctionSpec & other)
{
  FunctionSpec tmp(other);
  swap(tmp);
  return *this;
}

void FunctionSpec::swap(FunctionSpec & other)
{
  std::swap(varspec_, other.varspec_);
  std::swap(absparamtypelist_, other.absparamtypelist_);

}

FunctionSpec::~FunctionSpec()
{
  delete(varspec_);
  delete(absparamtypelist_);

}

void FunctionSpec::accept(Visitor *v)
{
  v->visitFunctionSpec(this);
}

FunctionSpec *FunctionSpec::clone() const
{
  return new FunctionSpec(*this);
}



/********************   IntConstArraySize    ********************/
IntConstArraySize::IntConstArraySize(Integer p1)
{
  integer_ = p1;

}

IntConstArraySize::IntConstArraySize(const IntConstArraySize & other)
{
  integer_ = other.integer_;

}

IntConstArraySize &IntConstArraySize::operator=(const IntConstArraySize & other)
{
  IntConstArraySize tmp(other);
  swap(tmp);
  return *this;
}

void IntConstArraySize::swap(IntConstArraySize & other)
{
  std::swap(integer_, other.integer_);

}

IntConstArraySize::~IntConstArraySize()
{

}

void IntConstArraySize::accept(Visitor *v)
{
  v->visitIntConstArraySize(this);
}

IntConstArraySize *IntConstArraySize::clone() const
{
  return new IntConstArraySize(*this);
}



/********************   SomeArraySize    ********************/
SomeArraySize::SomeArraySize(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

SomeArraySize::SomeArraySize(const SomeArraySize & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

SomeArraySize &SomeArraySize::operator=(const SomeArraySize & other)
{
  SomeArraySize tmp(other);
  swap(tmp);
  return *this;
}

void SomeArraySize::swap(SomeArraySize & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

SomeArraySize::~SomeArraySize()
{
  delete(fullidentifier_);

}

void SomeArraySize::accept(Visitor *v)
{
  v->visitSomeArraySize(this);
}

SomeArraySize *SomeArraySize::clone() const
{
  return new SomeArraySize(*this);
}



/********************   NoSize    ********************/
NoSize::NoSize()
{

}

NoSize::NoSize(const NoSize & other)
{

}

NoSize &NoSize::operator=(const NoSize & other)
{
  NoSize tmp(other);
  swap(tmp);
  return *this;
}

void NoSize::swap(NoSize & other)
{

}

NoSize::~NoSize()
{

}

void NoSize::accept(Visitor *v)
{
  v->visitNoSize(this);
}

NoSize *NoSize::clone() const
{
  return new NoSize(*this);
}



/********************   EmptyTypeParam    ********************/
EmptyTypeParam::EmptyTypeParam()
{

}

EmptyTypeParam::EmptyTypeParam(const EmptyTypeParam & other)
{

}

EmptyTypeParam &EmptyTypeParam::operator=(const EmptyTypeParam & other)
{
  EmptyTypeParam tmp(other);
  swap(tmp);
  return *this;
}

void EmptyTypeParam::swap(EmptyTypeParam & other)
{

}

EmptyTypeParam::~EmptyTypeParam()
{

}

void EmptyTypeParam::accept(Visitor *v)
{
  v->visitEmptyTypeParam(this);
}

EmptyTypeParam *EmptyTypeParam::clone() const
{
  return new EmptyTypeParam(*this);
}



/********************   SomeTypeParam    ********************/
SomeTypeParam::SomeTypeParam(ListAbsParam *p1)
{
  listabsparam_ = p1;

}

SomeTypeParam::SomeTypeParam(const SomeTypeParam & other)
{
  listabsparam_ = other.listabsparam_->clone();

}

SomeTypeParam &SomeTypeParam::operator=(const SomeTypeParam & other)
{
  SomeTypeParam tmp(other);
  swap(tmp);
  return *this;
}

void SomeTypeParam::swap(SomeTypeParam & other)
{
  std::swap(listabsparam_, other.listabsparam_);

}

SomeTypeParam::~SomeTypeParam()
{
  delete(listabsparam_);

}

void SomeTypeParam::accept(Visitor *v)
{
  v->visitSomeTypeParam(this);
}

SomeTypeParam *SomeTypeParam::clone() const
{
  return new SomeTypeParam(*this);
}



/********************   InfTypeParam    ********************/
InfTypeParam::InfTypeParam(ListAbsParam *p1)
{
  listabsparam_ = p1;

}

InfTypeParam::InfTypeParam(const InfTypeParam & other)
{
  listabsparam_ = other.listabsparam_->clone();

}

InfTypeParam &InfTypeParam::operator=(const InfTypeParam & other)
{
  InfTypeParam tmp(other);
  swap(tmp);
  return *this;
}

void InfTypeParam::swap(InfTypeParam & other)
{
  std::swap(listabsparam_, other.listabsparam_);

}

InfTypeParam::~InfTypeParam()
{
  delete(listabsparam_);

}

void InfTypeParam::accept(Visitor *v)
{
  v->visitInfTypeParam(this);
}

InfTypeParam *InfTypeParam::clone() const
{
  return new InfTypeParam(*this);
}



/********************   AbsParamsElement    ********************/
AbsParamsElement::AbsParamsElement(LogicTypeGenOFTYPENAME *p1)
{
  logictypegenoftypename_ = p1;

}

AbsParamsElement::AbsParamsElement(const AbsParamsElement & other)
{
  logictypegenoftypename_ = other.logictypegenoftypename_->clone();

}

AbsParamsElement &AbsParamsElement::operator=(const AbsParamsElement & other)
{
  AbsParamsElement tmp(other);
  swap(tmp);
  return *this;
}

void AbsParamsElement::swap(AbsParamsElement & other)
{
  std::swap(logictypegenoftypename_, other.logictypegenoftypename_);

}

AbsParamsElement::~AbsParamsElement()
{
  delete(logictypegenoftypename_);

}

void AbsParamsElement::accept(Visitor *v)
{
  v->visitAbsParamsElement(this);
}

AbsParamsElement *AbsParamsElement::clone() const
{
  return new AbsParamsElement(*this);
}



/********************   Prartemer    ********************/
Prartemer::Prartemer(TypeSpecOFIdentifierOrTypename *p1, VarSpec *p2)
{
  typespecofidentifierortypename_ = p1;
  varspec_ = p2;

}

Prartemer::Prartemer(const Prartemer & other)
{
  typespecofidentifierortypename_ = other.typespecofidentifierortypename_->clone();
  varspec_ = other.varspec_->clone();

}

Prartemer &Prartemer::operator=(const Prartemer & other)
{
  Prartemer tmp(other);
  swap(tmp);
  return *this;
}

void Prartemer::swap(Prartemer & other)
{
  std::swap(typespecofidentifierortypename_, other.typespecofidentifierortypename_);
  std::swap(varspec_, other.varspec_);

}

Prartemer::~Prartemer()
{
  delete(typespecofidentifierortypename_);
  delete(varspec_);

}

void Prartemer::accept(Visitor *v)
{
  v->visitPrartemer(this);
}

Prartemer *Prartemer::clone() const
{
  return new Prartemer(*this);
}



/********************   LogicTypeGenTypemane    ********************/
LogicTypeGenTypemane::LogicTypeGenTypemane(TypeSpecOFTYPENAME *p1, AbsSpecOption *p2)
{
  typespecoftypename_ = p1;
  absspecoption_ = p2;

}

LogicTypeGenTypemane::LogicTypeGenTypemane(const LogicTypeGenTypemane & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  absspecoption_ = other.absspecoption_->clone();

}

LogicTypeGenTypemane &LogicTypeGenTypemane::operator=(const LogicTypeGenTypemane & other)
{
  LogicTypeGenTypemane tmp(other);
  swap(tmp);
  return *this;
}

void LogicTypeGenTypemane::swap(LogicTypeGenTypemane & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(absspecoption_, other.absspecoption_);

}

LogicTypeGenTypemane::~LogicTypeGenTypemane()
{
  delete(typespecoftypename_);
  delete(absspecoption_);

}

void LogicTypeGenTypemane::accept(Visitor *v)
{
  v->visitLogicTypeGenTypemane(this);
}

LogicTypeGenTypemane *LogicTypeGenTypemane::clone() const
{
  return new LogicTypeGenTypemane(*this);
}



/********************   LogicTypeGenIdOrTypename    ********************/
LogicTypeGenIdOrTypename::LogicTypeGenIdOrTypename(TypeSpecOFIdentifierOrTypename *p1, AbsSpecOption *p2)
{
  typespecofidentifierortypename_ = p1;
  absspecoption_ = p2;

}

LogicTypeGenIdOrTypename::LogicTypeGenIdOrTypename(const LogicTypeGenIdOrTypename & other)
{
  typespecofidentifierortypename_ = other.typespecofidentifierortypename_->clone();
  absspecoption_ = other.absspecoption_->clone();

}

LogicTypeGenIdOrTypename &LogicTypeGenIdOrTypename::operator=(const LogicTypeGenIdOrTypename & other)
{
  LogicTypeGenIdOrTypename tmp(other);
  swap(tmp);
  return *this;
}

void LogicTypeGenIdOrTypename::swap(LogicTypeGenIdOrTypename & other)
{
  std::swap(typespecofidentifierortypename_, other.typespecofidentifierortypename_);
  std::swap(absspecoption_, other.absspecoption_);

}

LogicTypeGenIdOrTypename::~LogicTypeGenIdOrTypename()
{
  delete(typespecofidentifierortypename_);
  delete(absspecoption_);

}

void LogicTypeGenIdOrTypename::accept(Visitor *v)
{
  v->visitLogicTypeGenIdOrTypename(this);
}

LogicTypeGenIdOrTypename *LogicTypeGenIdOrTypename::clone() const
{
  return new LogicTypeGenIdOrTypename(*this);
}



/********************   ConstCV    ********************/
ConstCV::ConstCV()
{

}

ConstCV::ConstCV(const ConstCV & other)
{

}

ConstCV &ConstCV::operator=(const ConstCV & other)
{
  ConstCV tmp(other);
  swap(tmp);
  return *this;
}

void ConstCV::swap(ConstCV & other)
{

}

ConstCV::~ConstCV()
{

}

void ConstCV::accept(Visitor *v)
{
  v->visitConstCV(this);
}

ConstCV *ConstCV::clone() const
{
  return new ConstCV(*this);
}



/********************   VolatileCV    ********************/
VolatileCV::VolatileCV()
{

}

VolatileCV::VolatileCV(const VolatileCV & other)
{

}

VolatileCV &VolatileCV::operator=(const VolatileCV & other)
{
  VolatileCV tmp(other);
  swap(tmp);
  return *this;
}

void VolatileCV::swap(VolatileCV & other)
{

}

VolatileCV::~VolatileCV()
{

}

void VolatileCV::accept(Visitor *v)
{
  v->visitVolatileCV(this);
}

VolatileCV *VolatileCV::clone() const
{
  return new VolatileCV(*this);
}



/********************   GhostCV    ********************/
GhostCV::GhostCV()
{

}

GhostCV::GhostCV(const GhostCV & other)
{

}

GhostCV &GhostCV::operator=(const GhostCV & other)
{
  GhostCV tmp(other);
  swap(tmp);
  return *this;
}

void GhostCV::swap(GhostCV & other)
{

}

GhostCV::~GhostCV()
{

}

void GhostCV::accept(Visitor *v)
{
  v->visitGhostCV(this);
}

GhostCV *GhostCV::clone() const
{
  return new GhostCV(*this);
}



/********************   TypeSpecCVTypename    ********************/
TypeSpecCVTypename::TypeSpecCVTypename(ListCV *p1, TypeSpecOFTYPENAME *p2, ListCV *p3)
{
  listcv_1 = p1;
  typespecoftypename_ = p2;
  listcv_2 = p3;

}

TypeSpecCVTypename::TypeSpecCVTypename(const TypeSpecCVTypename & other)
{
  listcv_1 = other.listcv_1->clone();
  typespecoftypename_ = other.typespecoftypename_->clone();
  listcv_2 = other.listcv_2->clone();

}

TypeSpecCVTypename &TypeSpecCVTypename::operator=(const TypeSpecCVTypename & other)
{
  TypeSpecCVTypename tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecCVTypename::swap(TypeSpecCVTypename & other)
{
  std::swap(listcv_1, other.listcv_1);
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(listcv_2, other.listcv_2);

}

TypeSpecCVTypename::~TypeSpecCVTypename()
{
  delete(listcv_1);
  delete(typespecoftypename_);
  delete(listcv_2);

}

void TypeSpecCVTypename::accept(Visitor *v)
{
  v->visitTypeSpecCVTypename(this);
}

TypeSpecCVTypename *TypeSpecCVTypename::clone() const
{
  return new TypeSpecCVTypename(*this);
}



/********************   AnCastLogicType    ********************/
AnCastLogicType::AnCastLogicType(TypeSpecCVOFTYPENAME *p1, AbsSpecCVOption *p2)
{
  typespeccvoftypename_ = p1;
  absspeccvoption_ = p2;

}

AnCastLogicType::AnCastLogicType(const AnCastLogicType & other)
{
  typespeccvoftypename_ = other.typespeccvoftypename_->clone();
  absspeccvoption_ = other.absspeccvoption_->clone();

}

AnCastLogicType &AnCastLogicType::operator=(const AnCastLogicType & other)
{
  AnCastLogicType tmp(other);
  swap(tmp);
  return *this;
}

void AnCastLogicType::swap(AnCastLogicType & other)
{
  std::swap(typespeccvoftypename_, other.typespeccvoftypename_);
  std::swap(absspeccvoption_, other.absspeccvoption_);

}

AnCastLogicType::~AnCastLogicType()
{
  delete(typespeccvoftypename_);
  delete(absspeccvoption_);

}

void AnCastLogicType::accept(Visitor *v)
{
  v->visitAnCastLogicType(this);
}

AnCastLogicType *AnCastLogicType::clone() const
{
  return new AnCastLogicType(*this);
}



/********************   LogicRTType    ********************/
LogicRTType::LogicRTType(LogicTypeGenOFIdentifierOrTypename *p1)
{
  logictypegenofidentifierortypename_ = p1;

}

LogicRTType::LogicRTType(const LogicRTType & other)
{
  logictypegenofidentifierortypename_ = other.logictypegenofidentifierortypename_->clone();

}

LogicRTType &LogicRTType::operator=(const LogicRTType & other)
{
  LogicRTType tmp(other);
  swap(tmp);
  return *this;
}

void LogicRTType::swap(LogicRTType & other)
{
  std::swap(logictypegenofidentifierortypename_, other.logictypegenofidentifierortypename_);

}

LogicRTType::~LogicRTType()
{
  delete(logictypegenofidentifierortypename_);

}

void LogicRTType::accept(Visitor *v)
{
  v->visitLogicRTType(this);
}

LogicRTType *LogicRTType::clone() const
{
  return new LogicRTType(*this);
}



/********************   NoAbsSpec    ********************/
NoAbsSpec::NoAbsSpec()
{

}

NoAbsSpec::NoAbsSpec(const NoAbsSpec & other)
{

}

NoAbsSpec &NoAbsSpec::operator=(const NoAbsSpec & other)
{
  NoAbsSpec tmp(other);
  swap(tmp);
  return *this;
}

void NoAbsSpec::swap(NoAbsSpec & other)
{

}

NoAbsSpec::~NoAbsSpec()
{

}

void NoAbsSpec::accept(Visitor *v)
{
  v->visitNoAbsSpec(this);
}

NoAbsSpec *NoAbsSpec::clone() const
{
  return new NoAbsSpec(*this);
}



/********************   SomeAbsSpec    ********************/
SomeAbsSpec::SomeAbsSpec(AbsSpec *p1)
{
  absspec_ = p1;

}

SomeAbsSpec::SomeAbsSpec(const SomeAbsSpec & other)
{
  absspec_ = other.absspec_->clone();

}

SomeAbsSpec &SomeAbsSpec::operator=(const SomeAbsSpec & other)
{
  SomeAbsSpec tmp(other);
  swap(tmp);
  return *this;
}

void SomeAbsSpec::swap(SomeAbsSpec & other)
{
  std::swap(absspec_, other.absspec_);

}

SomeAbsSpec::~SomeAbsSpec()
{
  delete(absspec_);

}

void SomeAbsSpec::accept(Visitor *v)
{
  v->visitSomeAbsSpec(this);
}

SomeAbsSpec *SomeAbsSpec::clone() const
{
  return new SomeAbsSpec(*this);
}



/********************   NoAbsSpecCV    ********************/
NoAbsSpecCV::NoAbsSpecCV()
{

}

NoAbsSpecCV::NoAbsSpecCV(const NoAbsSpecCV & other)
{

}

NoAbsSpecCV &NoAbsSpecCV::operator=(const NoAbsSpecCV & other)
{
  NoAbsSpecCV tmp(other);
  swap(tmp);
  return *this;
}

void NoAbsSpecCV::swap(NoAbsSpecCV & other)
{

}

NoAbsSpecCV::~NoAbsSpecCV()
{

}

void NoAbsSpecCV::accept(Visitor *v)
{
  v->visitNoAbsSpecCV(this);
}

NoAbsSpecCV *NoAbsSpecCV::clone() const
{
  return new NoAbsSpecCV(*this);
}



/********************   SomeAbsSpecCV    ********************/
SomeAbsSpecCV::SomeAbsSpecCV(AbsSpecCV *p1)
{
  absspeccv_ = p1;

}

SomeAbsSpecCV::SomeAbsSpecCV(const SomeAbsSpecCV & other)
{
  absspeccv_ = other.absspeccv_->clone();

}

SomeAbsSpecCV &SomeAbsSpecCV::operator=(const SomeAbsSpecCV & other)
{
  SomeAbsSpecCV tmp(other);
  swap(tmp);
  return *this;
}

void SomeAbsSpecCV::swap(SomeAbsSpecCV & other)
{
  std::swap(absspeccv_, other.absspeccv_);

}

SomeAbsSpecCV::~SomeAbsSpecCV()
{
  delete(absspeccv_);

}

void SomeAbsSpecCV::accept(Visitor *v)
{
  v->visitSomeAbsSpecCV(this);
}

SomeAbsSpecCV *SomeAbsSpecCV::clone() const
{
  return new SomeAbsSpecCV(*this);
}



/********************   AbsSpecTabs    ********************/
AbsSpecTabs::AbsSpecTabs(ListTabs *p1)
{
  listtabs_ = p1;

}

AbsSpecTabs::AbsSpecTabs(const AbsSpecTabs & other)
{
  listtabs_ = other.listtabs_->clone();

}

AbsSpecTabs &AbsSpecTabs::operator=(const AbsSpecTabs & other)
{
  AbsSpecTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecTabs::swap(AbsSpecTabs & other)
{
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecTabs::~AbsSpecTabs()
{
  delete(listtabs_);

}

void AbsSpecTabs::accept(Visitor *v)
{
  v->visitAbsSpecTabs(this);
}

AbsSpecTabs *AbsSpecTabs::clone() const
{
  return new AbsSpecTabs(*this);
}



/********************   AbsSpecStars    ********************/
AbsSpecStars::AbsSpecStars(ListStars *p1)
{
  liststars_ = p1;

}

AbsSpecStars::AbsSpecStars(const AbsSpecStars & other)
{
  liststars_ = other.liststars_->clone();

}

AbsSpecStars &AbsSpecStars::operator=(const AbsSpecStars & other)
{
  AbsSpecStars tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecStars::swap(AbsSpecStars & other)
{
  std::swap(liststars_, other.liststars_);

}

AbsSpecStars::~AbsSpecStars()
{
  delete(liststars_);

}

void AbsSpecStars::accept(Visitor *v)
{
  v->visitAbsSpecStars(this);
}

AbsSpecStars *AbsSpecStars::clone() const
{
  return new AbsSpecStars(*this);
}



/********************   AbsSpecStarsTabs    ********************/
AbsSpecStarsTabs::AbsSpecStarsTabs(ListStars *p1, ListTabs *p2)
{
  liststars_ = p1;
  listtabs_ = p2;

}

AbsSpecStarsTabs::AbsSpecStarsTabs(const AbsSpecStarsTabs & other)
{
  liststars_ = other.liststars_->clone();
  listtabs_ = other.listtabs_->clone();

}

AbsSpecStarsTabs &AbsSpecStarsTabs::operator=(const AbsSpecStarsTabs & other)
{
  AbsSpecStarsTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecStarsTabs::swap(AbsSpecStarsTabs & other)
{
  std::swap(liststars_, other.liststars_);
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecStarsTabs::~AbsSpecStarsTabs()
{
  delete(liststars_);
  delete(listtabs_);

}

void AbsSpecStarsTabs::accept(Visitor *v)
{
  v->visitAbsSpecStarsTabs(this);
}

AbsSpecStarsTabs *AbsSpecStarsTabs::clone() const
{
  return new AbsSpecStarsTabs(*this);
}



/********************   AbsSpecBitsStars    ********************/
AbsSpecBitsStars::AbsSpecBitsStars(ListStars *p1, AbsSpec *p2)
{
  liststars_ = p1;
  absspec_ = p2;

}

AbsSpecBitsStars::AbsSpecBitsStars(const AbsSpecBitsStars & other)
{
  liststars_ = other.liststars_->clone();
  absspec_ = other.absspec_->clone();

}

AbsSpecBitsStars &AbsSpecBitsStars::operator=(const AbsSpecBitsStars & other)
{
  AbsSpecBitsStars tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecBitsStars::swap(AbsSpecBitsStars & other)
{
  std::swap(liststars_, other.liststars_);
  std::swap(absspec_, other.absspec_);

}

AbsSpecBitsStars::~AbsSpecBitsStars()
{
  delete(liststars_);
  delete(absspec_);

}

void AbsSpecBitsStars::accept(Visitor *v)
{
  v->visitAbsSpecBitsStars(this);
}

AbsSpecBitsStars *AbsSpecBitsStars::clone() const
{
  return new AbsSpecBitsStars(*this);
}



/********************   AbsSpecBitsStarsTabs    ********************/
AbsSpecBitsStarsTabs::AbsSpecBitsStarsTabs(ListStars *p1, AbsSpec *p2, ListTabs *p3)
{
  liststars_ = p1;
  absspec_ = p2;
  listtabs_ = p3;

}

AbsSpecBitsStarsTabs::AbsSpecBitsStarsTabs(const AbsSpecBitsStarsTabs & other)
{
  liststars_ = other.liststars_->clone();
  absspec_ = other.absspec_->clone();
  listtabs_ = other.listtabs_->clone();

}

AbsSpecBitsStarsTabs &AbsSpecBitsStarsTabs::operator=(const AbsSpecBitsStarsTabs & other)
{
  AbsSpecBitsStarsTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecBitsStarsTabs::swap(AbsSpecBitsStarsTabs & other)
{
  std::swap(liststars_, other.liststars_);
  std::swap(absspec_, other.absspec_);
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecBitsStarsTabs::~AbsSpecBitsStarsTabs()
{
  delete(liststars_);
  delete(absspec_);
  delete(listtabs_);

}

void AbsSpecBitsStarsTabs::accept(Visitor *v)
{
  v->visitAbsSpecBitsStarsTabs(this);
}

AbsSpecBitsStarsTabs *AbsSpecBitsStarsTabs::clone() const
{
  return new AbsSpecBitsStarsTabs(*this);
}



/********************   AbsSpecBitsTabs    ********************/
AbsSpecBitsTabs::AbsSpecBitsTabs(AbsSpec *p1, ListTabs *p2)
{
  absspec_ = p1;
  listtabs_ = p2;

}

AbsSpecBitsTabs::AbsSpecBitsTabs(const AbsSpecBitsTabs & other)
{
  absspec_ = other.absspec_->clone();
  listtabs_ = other.listtabs_->clone();

}

AbsSpecBitsTabs &AbsSpecBitsTabs::operator=(const AbsSpecBitsTabs & other)
{
  AbsSpecBitsTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecBitsTabs::swap(AbsSpecBitsTabs & other)
{
  std::swap(absspec_, other.absspec_);
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecBitsTabs::~AbsSpecBitsTabs()
{
  delete(absspec_);
  delete(listtabs_);

}

void AbsSpecBitsTabs::accept(Visitor *v)
{
  v->visitAbsSpecBitsTabs(this);
}

AbsSpecBitsTabs *AbsSpecBitsTabs::clone() const
{
  return new AbsSpecBitsTabs(*this);
}



/********************   AbsSpecBits    ********************/
AbsSpecBits::AbsSpecBits(AbsSpec *p1)
{
  absspec_ = p1;

}

AbsSpecBits::AbsSpecBits(const AbsSpecBits & other)
{
  absspec_ = other.absspec_->clone();

}

AbsSpecBits &AbsSpecBits::operator=(const AbsSpecBits & other)
{
  AbsSpecBits tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecBits::swap(AbsSpecBits & other)
{
  std::swap(absspec_, other.absspec_);

}

AbsSpecBits::~AbsSpecBits()
{
  delete(absspec_);

}

void AbsSpecBits::accept(Visitor *v)
{
  v->visitAbsSpecBits(this);
}

AbsSpecBits *AbsSpecBits::clone() const
{
  return new AbsSpecBits(*this);
}



/********************   AbsSpecBitsParams    ********************/
AbsSpecBitsParams::AbsSpecBitsParams(AbsSpec *p1, AbsParamTypeList *p2)
{
  absspec_ = p1;
  absparamtypelist_ = p2;

}

AbsSpecBitsParams::AbsSpecBitsParams(const AbsSpecBitsParams & other)
{
  absspec_ = other.absspec_->clone();
  absparamtypelist_ = other.absparamtypelist_->clone();

}

AbsSpecBitsParams &AbsSpecBitsParams::operator=(const AbsSpecBitsParams & other)
{
  AbsSpecBitsParams tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecBitsParams::swap(AbsSpecBitsParams & other)
{
  std::swap(absspec_, other.absspec_);
  std::swap(absparamtypelist_, other.absparamtypelist_);

}

AbsSpecBitsParams::~AbsSpecBitsParams()
{
  delete(absspec_);
  delete(absparamtypelist_);

}

void AbsSpecBitsParams::accept(Visitor *v)
{
  v->visitAbsSpecBitsParams(this);
}

AbsSpecBitsParams *AbsSpecBitsParams::clone() const
{
  return new AbsSpecBitsParams(*this);
}



/********************   AbsSpecCVTabs    ********************/
AbsSpecCVTabs::AbsSpecCVTabs(ListTabs *p1)
{
  listtabs_ = p1;

}

AbsSpecCVTabs::AbsSpecCVTabs(const AbsSpecCVTabs & other)
{
  listtabs_ = other.listtabs_->clone();

}

AbsSpecCVTabs &AbsSpecCVTabs::operator=(const AbsSpecCVTabs & other)
{
  AbsSpecCVTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVTabs::swap(AbsSpecCVTabs & other)
{
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecCVTabs::~AbsSpecCVTabs()
{
  delete(listtabs_);

}

void AbsSpecCVTabs::accept(Visitor *v)
{
  v->visitAbsSpecCVTabs(this);
}

AbsSpecCVTabs *AbsSpecCVTabs::clone() const
{
  return new AbsSpecCVTabs(*this);
}



/********************   AbsSpecCVStars    ********************/
AbsSpecCVStars::AbsSpecCVStars(ListStarsCV *p1)
{
  liststarscv_ = p1;

}

AbsSpecCVStars::AbsSpecCVStars(const AbsSpecCVStars & other)
{
  liststarscv_ = other.liststarscv_->clone();

}

AbsSpecCVStars &AbsSpecCVStars::operator=(const AbsSpecCVStars & other)
{
  AbsSpecCVStars tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVStars::swap(AbsSpecCVStars & other)
{
  std::swap(liststarscv_, other.liststarscv_);

}

AbsSpecCVStars::~AbsSpecCVStars()
{
  delete(liststarscv_);

}

void AbsSpecCVStars::accept(Visitor *v)
{
  v->visitAbsSpecCVStars(this);
}

AbsSpecCVStars *AbsSpecCVStars::clone() const
{
  return new AbsSpecCVStars(*this);
}



/********************   AbsSpecCVStarsTabs    ********************/
AbsSpecCVStarsTabs::AbsSpecCVStarsTabs(ListStarsCV *p1, ListTabs *p2)
{
  liststarscv_ = p1;
  listtabs_ = p2;

}

AbsSpecCVStarsTabs::AbsSpecCVStarsTabs(const AbsSpecCVStarsTabs & other)
{
  liststarscv_ = other.liststarscv_->clone();
  listtabs_ = other.listtabs_->clone();

}

AbsSpecCVStarsTabs &AbsSpecCVStarsTabs::operator=(const AbsSpecCVStarsTabs & other)
{
  AbsSpecCVStarsTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVStarsTabs::swap(AbsSpecCVStarsTabs & other)
{
  std::swap(liststarscv_, other.liststarscv_);
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecCVStarsTabs::~AbsSpecCVStarsTabs()
{
  delete(liststarscv_);
  delete(listtabs_);

}

void AbsSpecCVStarsTabs::accept(Visitor *v)
{
  v->visitAbsSpecCVStarsTabs(this);
}

AbsSpecCVStarsTabs *AbsSpecCVStarsTabs::clone() const
{
  return new AbsSpecCVStarsTabs(*this);
}



/********************   AbsSpecCVBitsStars    ********************/
AbsSpecCVBitsStars::AbsSpecCVBitsStars(ListStarsCV *p1, AbsSpecCV *p2)
{
  liststarscv_ = p1;
  absspeccv_ = p2;

}

AbsSpecCVBitsStars::AbsSpecCVBitsStars(const AbsSpecCVBitsStars & other)
{
  liststarscv_ = other.liststarscv_->clone();
  absspeccv_ = other.absspeccv_->clone();

}

AbsSpecCVBitsStars &AbsSpecCVBitsStars::operator=(const AbsSpecCVBitsStars & other)
{
  AbsSpecCVBitsStars tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVBitsStars::swap(AbsSpecCVBitsStars & other)
{
  std::swap(liststarscv_, other.liststarscv_);
  std::swap(absspeccv_, other.absspeccv_);

}

AbsSpecCVBitsStars::~AbsSpecCVBitsStars()
{
  delete(liststarscv_);
  delete(absspeccv_);

}

void AbsSpecCVBitsStars::accept(Visitor *v)
{
  v->visitAbsSpecCVBitsStars(this);
}

AbsSpecCVBitsStars *AbsSpecCVBitsStars::clone() const
{
  return new AbsSpecCVBitsStars(*this);
}



/********************   AbsSpecCVBitsStarsTabs    ********************/
AbsSpecCVBitsStarsTabs::AbsSpecCVBitsStarsTabs(ListStarsCV *p1, AbsSpecCV *p2, ListTabs *p3)
{
  liststarscv_ = p1;
  absspeccv_ = p2;
  listtabs_ = p3;

}

AbsSpecCVBitsStarsTabs::AbsSpecCVBitsStarsTabs(const AbsSpecCVBitsStarsTabs & other)
{
  liststarscv_ = other.liststarscv_->clone();
  absspeccv_ = other.absspeccv_->clone();
  listtabs_ = other.listtabs_->clone();

}

AbsSpecCVBitsStarsTabs &AbsSpecCVBitsStarsTabs::operator=(const AbsSpecCVBitsStarsTabs & other)
{
  AbsSpecCVBitsStarsTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVBitsStarsTabs::swap(AbsSpecCVBitsStarsTabs & other)
{
  std::swap(liststarscv_, other.liststarscv_);
  std::swap(absspeccv_, other.absspeccv_);
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecCVBitsStarsTabs::~AbsSpecCVBitsStarsTabs()
{
  delete(liststarscv_);
  delete(absspeccv_);
  delete(listtabs_);

}

void AbsSpecCVBitsStarsTabs::accept(Visitor *v)
{
  v->visitAbsSpecCVBitsStarsTabs(this);
}

AbsSpecCVBitsStarsTabs *AbsSpecCVBitsStarsTabs::clone() const
{
  return new AbsSpecCVBitsStarsTabs(*this);
}



/********************   AbsSpecCVBitsTabs    ********************/
AbsSpecCVBitsTabs::AbsSpecCVBitsTabs(AbsSpecCV *p1, ListTabs *p2)
{
  absspeccv_ = p1;
  listtabs_ = p2;

}

AbsSpecCVBitsTabs::AbsSpecCVBitsTabs(const AbsSpecCVBitsTabs & other)
{
  absspeccv_ = other.absspeccv_->clone();
  listtabs_ = other.listtabs_->clone();

}

AbsSpecCVBitsTabs &AbsSpecCVBitsTabs::operator=(const AbsSpecCVBitsTabs & other)
{
  AbsSpecCVBitsTabs tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVBitsTabs::swap(AbsSpecCVBitsTabs & other)
{
  std::swap(absspeccv_, other.absspeccv_);
  std::swap(listtabs_, other.listtabs_);

}

AbsSpecCVBitsTabs::~AbsSpecCVBitsTabs()
{
  delete(absspeccv_);
  delete(listtabs_);

}

void AbsSpecCVBitsTabs::accept(Visitor *v)
{
  v->visitAbsSpecCVBitsTabs(this);
}

AbsSpecCVBitsTabs *AbsSpecCVBitsTabs::clone() const
{
  return new AbsSpecCVBitsTabs(*this);
}



/********************   AbsSpecCVBits    ********************/
AbsSpecCVBits::AbsSpecCVBits(AbsSpecCV *p1)
{
  absspeccv_ = p1;

}

AbsSpecCVBits::AbsSpecCVBits(const AbsSpecCVBits & other)
{
  absspeccv_ = other.absspeccv_->clone();

}

AbsSpecCVBits &AbsSpecCVBits::operator=(const AbsSpecCVBits & other)
{
  AbsSpecCVBits tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecCVBits::swap(AbsSpecCVBits & other)
{
  std::swap(absspeccv_, other.absspeccv_);

}

AbsSpecCVBits::~AbsSpecCVBits()
{
  delete(absspeccv_);

}

void AbsSpecCVBits::accept(Visitor *v)
{
  v->visitAbsSpecCVBits(this);
}

AbsSpecCVBits *AbsSpecCVBits::clone() const
{
  return new AbsSpecCVBits(*this);
}



/********************   AbsSpecBitsCVParams    ********************/
AbsSpecBitsCVParams::AbsSpecBitsCVParams(AbsSpecCV *p1, AbsParamTypeList *p2)
{
  absspeccv_ = p1;
  absparamtypelist_ = p2;

}

AbsSpecBitsCVParams::AbsSpecBitsCVParams(const AbsSpecBitsCVParams & other)
{
  absspeccv_ = other.absspeccv_->clone();
  absparamtypelist_ = other.absparamtypelist_->clone();

}

AbsSpecBitsCVParams &AbsSpecBitsCVParams::operator=(const AbsSpecBitsCVParams & other)
{
  AbsSpecBitsCVParams tmp(other);
  swap(tmp);
  return *this;
}

void AbsSpecBitsCVParams::swap(AbsSpecBitsCVParams & other)
{
  std::swap(absspeccv_, other.absspeccv_);
  std::swap(absparamtypelist_, other.absparamtypelist_);

}

AbsSpecBitsCVParams::~AbsSpecBitsCVParams()
{
  delete(absspeccv_);
  delete(absparamtypelist_);

}

void AbsSpecBitsCVParams::accept(Visitor *v)
{
  v->visitAbsSpecBitsCVParams(this);
}

AbsSpecBitsCVParams *AbsSpecBitsCVParams::clone() const
{
  return new AbsSpecBitsCVParams(*this);
}



/********************   Star    ********************/
Star::Star()
{

}

Star::Star(const Star & other)
{

}

Star &Star::operator=(const Star & other)
{
  Star tmp(other);
  swap(tmp);
  return *this;
}

void Star::swap(Star & other)
{

}

Star::~Star()
{

}

void Star::accept(Visitor *v)
{
  v->visitStar(this);
}

Star *Star::clone() const
{
  return new Star(*this);
}



/********************   StarCV    ********************/
StarCV::StarCV()
{

}

StarCV::StarCV(const StarCV & other)
{

}

StarCV &StarCV::operator=(const StarCV & other)
{
  StarCV tmp(other);
  swap(tmp);
  return *this;
}

void StarCV::swap(StarCV & other)
{

}

StarCV::~StarCV()
{

}

void StarCV::accept(Visitor *v)
{
  v->visitStarCV(this);
}

StarCV *StarCV::clone() const
{
  return new StarCV(*this);
}



/********************   StarCVWithCV    ********************/
StarCVWithCV::StarCVWithCV(CV *p1)
{
  cv_ = p1;

}

StarCVWithCV::StarCVWithCV(const StarCVWithCV & other)
{
  cv_ = other.cv_->clone();

}

StarCVWithCV &StarCVWithCV::operator=(const StarCVWithCV & other)
{
  StarCVWithCV tmp(other);
  swap(tmp);
  return *this;
}

void StarCVWithCV::swap(StarCVWithCV & other)
{
  std::swap(cv_, other.cv_);

}

StarCVWithCV::~StarCVWithCV()
{
  delete(cv_);

}

void StarCVWithCV::accept(Visitor *v)
{
  v->visitStarCVWithCV(this);
}

StarCVWithCV *StarCVWithCV::clone() const
{
  return new StarCVWithCV(*this);
}



/********************   Tab    ********************/
Tab::Tab(ArraySize *p1)
{
  arraysize_ = p1;

}

Tab::Tab(const Tab & other)
{
  arraysize_ = other.arraysize_->clone();

}

Tab &Tab::operator=(const Tab & other)
{
  Tab tmp(other);
  swap(tmp);
  return *this;
}

void Tab::swap(Tab & other)
{
  std::swap(arraysize_, other.arraysize_);

}

Tab::~Tab()
{
  delete(arraysize_);

}

void Tab::accept(Visitor *v)
{
  v->visitTab(this);
}

Tab *Tab::clone() const
{
  return new Tab(*this);
}



/********************   TypeSpecSimpleIntegerKeyWord    ********************/
TypeSpecSimpleIntegerKeyWord::TypeSpecSimpleIntegerKeyWord()
{

}

TypeSpecSimpleIntegerKeyWord::TypeSpecSimpleIntegerKeyWord(const TypeSpecSimpleIntegerKeyWord & other)
{

}

TypeSpecSimpleIntegerKeyWord &TypeSpecSimpleIntegerKeyWord::operator=(const TypeSpecSimpleIntegerKeyWord & other)
{
  TypeSpecSimpleIntegerKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleIntegerKeyWord::swap(TypeSpecSimpleIntegerKeyWord & other)
{

}

TypeSpecSimpleIntegerKeyWord::~TypeSpecSimpleIntegerKeyWord()
{

}

void TypeSpecSimpleIntegerKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleIntegerKeyWord(this);
}

TypeSpecSimpleIntegerKeyWord *TypeSpecSimpleIntegerKeyWord::clone() const
{
  return new TypeSpecSimpleIntegerKeyWord(*this);
}



/********************   TypeSpecSimpleRealKeyWord    ********************/
TypeSpecSimpleRealKeyWord::TypeSpecSimpleRealKeyWord()
{

}

TypeSpecSimpleRealKeyWord::TypeSpecSimpleRealKeyWord(const TypeSpecSimpleRealKeyWord & other)
{

}

TypeSpecSimpleRealKeyWord &TypeSpecSimpleRealKeyWord::operator=(const TypeSpecSimpleRealKeyWord & other)
{
  TypeSpecSimpleRealKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleRealKeyWord::swap(TypeSpecSimpleRealKeyWord & other)
{

}

TypeSpecSimpleRealKeyWord::~TypeSpecSimpleRealKeyWord()
{

}

void TypeSpecSimpleRealKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleRealKeyWord(this);
}

TypeSpecSimpleRealKeyWord *TypeSpecSimpleRealKeyWord::clone() const
{
  return new TypeSpecSimpleRealKeyWord(*this);
}



/********************   TypeSpecSimpleBooleanKeyWord    ********************/
TypeSpecSimpleBooleanKeyWord::TypeSpecSimpleBooleanKeyWord()
{

}

TypeSpecSimpleBooleanKeyWord::TypeSpecSimpleBooleanKeyWord(const TypeSpecSimpleBooleanKeyWord & other)
{

}

TypeSpecSimpleBooleanKeyWord &TypeSpecSimpleBooleanKeyWord::operator=(const TypeSpecSimpleBooleanKeyWord & other)
{
  TypeSpecSimpleBooleanKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleBooleanKeyWord::swap(TypeSpecSimpleBooleanKeyWord & other)
{

}

TypeSpecSimpleBooleanKeyWord::~TypeSpecSimpleBooleanKeyWord()
{

}

void TypeSpecSimpleBooleanKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleBooleanKeyWord(this);
}

TypeSpecSimpleBooleanKeyWord *TypeSpecSimpleBooleanKeyWord::clone() const
{
  return new TypeSpecSimpleBooleanKeyWord(*this);
}



/********************   TypeSpecSimpleVoidKeyWord    ********************/
TypeSpecSimpleVoidKeyWord::TypeSpecSimpleVoidKeyWord()
{

}

TypeSpecSimpleVoidKeyWord::TypeSpecSimpleVoidKeyWord(const TypeSpecSimpleVoidKeyWord & other)
{

}

TypeSpecSimpleVoidKeyWord &TypeSpecSimpleVoidKeyWord::operator=(const TypeSpecSimpleVoidKeyWord & other)
{
  TypeSpecSimpleVoidKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleVoidKeyWord::swap(TypeSpecSimpleVoidKeyWord & other)
{

}

TypeSpecSimpleVoidKeyWord::~TypeSpecSimpleVoidKeyWord()
{

}

void TypeSpecSimpleVoidKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleVoidKeyWord(this);
}

TypeSpecSimpleVoidKeyWord *TypeSpecSimpleVoidKeyWord::clone() const
{
  return new TypeSpecSimpleVoidKeyWord(*this);
}



/********************   TypeSpecSimpleBoolKeyWord    ********************/
TypeSpecSimpleBoolKeyWord::TypeSpecSimpleBoolKeyWord()
{

}

TypeSpecSimpleBoolKeyWord::TypeSpecSimpleBoolKeyWord(const TypeSpecSimpleBoolKeyWord & other)
{

}

TypeSpecSimpleBoolKeyWord &TypeSpecSimpleBoolKeyWord::operator=(const TypeSpecSimpleBoolKeyWord & other)
{
  TypeSpecSimpleBoolKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleBoolKeyWord::swap(TypeSpecSimpleBoolKeyWord & other)
{

}

TypeSpecSimpleBoolKeyWord::~TypeSpecSimpleBoolKeyWord()
{

}

void TypeSpecSimpleBoolKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleBoolKeyWord(this);
}

TypeSpecSimpleBoolKeyWord *TypeSpecSimpleBoolKeyWord::clone() const
{
  return new TypeSpecSimpleBoolKeyWord(*this);
}



/********************   TypeSpecSimpleCharKeyWord    ********************/
TypeSpecSimpleCharKeyWord::TypeSpecSimpleCharKeyWord()
{

}

TypeSpecSimpleCharKeyWord::TypeSpecSimpleCharKeyWord(const TypeSpecSimpleCharKeyWord & other)
{

}

TypeSpecSimpleCharKeyWord &TypeSpecSimpleCharKeyWord::operator=(const TypeSpecSimpleCharKeyWord & other)
{
  TypeSpecSimpleCharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleCharKeyWord::swap(TypeSpecSimpleCharKeyWord & other)
{

}

TypeSpecSimpleCharKeyWord::~TypeSpecSimpleCharKeyWord()
{

}

void TypeSpecSimpleCharKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleCharKeyWord(this);
}

TypeSpecSimpleCharKeyWord *TypeSpecSimpleCharKeyWord::clone() const
{
  return new TypeSpecSimpleCharKeyWord(*this);
}



/********************   TypeSpecSimpleSignedCharKeyWord    ********************/
TypeSpecSimpleSignedCharKeyWord::TypeSpecSimpleSignedCharKeyWord()
{

}

TypeSpecSimpleSignedCharKeyWord::TypeSpecSimpleSignedCharKeyWord(const TypeSpecSimpleSignedCharKeyWord & other)
{

}

TypeSpecSimpleSignedCharKeyWord &TypeSpecSimpleSignedCharKeyWord::operator=(const TypeSpecSimpleSignedCharKeyWord & other)
{
  TypeSpecSimpleSignedCharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedCharKeyWord::swap(TypeSpecSimpleSignedCharKeyWord & other)
{

}

TypeSpecSimpleSignedCharKeyWord::~TypeSpecSimpleSignedCharKeyWord()
{

}

void TypeSpecSimpleSignedCharKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedCharKeyWord(this);
}

TypeSpecSimpleSignedCharKeyWord *TypeSpecSimpleSignedCharKeyWord::clone() const
{
  return new TypeSpecSimpleSignedCharKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedCharKeyWord    ********************/
TypeSpecSimpleUnsignedCharKeyWord::TypeSpecSimpleUnsignedCharKeyWord()
{

}

TypeSpecSimpleUnsignedCharKeyWord::TypeSpecSimpleUnsignedCharKeyWord(const TypeSpecSimpleUnsignedCharKeyWord & other)
{

}

TypeSpecSimpleUnsignedCharKeyWord &TypeSpecSimpleUnsignedCharKeyWord::operator=(const TypeSpecSimpleUnsignedCharKeyWord & other)
{
  TypeSpecSimpleUnsignedCharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedCharKeyWord::swap(TypeSpecSimpleUnsignedCharKeyWord & other)
{

}

TypeSpecSimpleUnsignedCharKeyWord::~TypeSpecSimpleUnsignedCharKeyWord()
{

}

void TypeSpecSimpleUnsignedCharKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedCharKeyWord(this);
}

TypeSpecSimpleUnsignedCharKeyWord *TypeSpecSimpleUnsignedCharKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedCharKeyWord(*this);
}



/********************   TypeSpecSimpleIntKeyWord    ********************/
TypeSpecSimpleIntKeyWord::TypeSpecSimpleIntKeyWord()
{

}

TypeSpecSimpleIntKeyWord::TypeSpecSimpleIntKeyWord(const TypeSpecSimpleIntKeyWord & other)
{

}

TypeSpecSimpleIntKeyWord &TypeSpecSimpleIntKeyWord::operator=(const TypeSpecSimpleIntKeyWord & other)
{
  TypeSpecSimpleIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleIntKeyWord::swap(TypeSpecSimpleIntKeyWord & other)
{

}

TypeSpecSimpleIntKeyWord::~TypeSpecSimpleIntKeyWord()
{

}

void TypeSpecSimpleIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleIntKeyWord(this);
}

TypeSpecSimpleIntKeyWord *TypeSpecSimpleIntKeyWord::clone() const
{
  return new TypeSpecSimpleIntKeyWord(*this);
}



/********************   TypeSpecSimpleSignedIntKeyWord    ********************/
TypeSpecSimpleSignedIntKeyWord::TypeSpecSimpleSignedIntKeyWord()
{

}

TypeSpecSimpleSignedIntKeyWord::TypeSpecSimpleSignedIntKeyWord(const TypeSpecSimpleSignedIntKeyWord & other)
{

}

TypeSpecSimpleSignedIntKeyWord &TypeSpecSimpleSignedIntKeyWord::operator=(const TypeSpecSimpleSignedIntKeyWord & other)
{
  TypeSpecSimpleSignedIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedIntKeyWord::swap(TypeSpecSimpleSignedIntKeyWord & other)
{

}

TypeSpecSimpleSignedIntKeyWord::~TypeSpecSimpleSignedIntKeyWord()
{

}

void TypeSpecSimpleSignedIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedIntKeyWord(this);
}

TypeSpecSimpleSignedIntKeyWord *TypeSpecSimpleSignedIntKeyWord::clone() const
{
  return new TypeSpecSimpleSignedIntKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedIntKeyWord    ********************/
TypeSpecSimpleUnsignedIntKeyWord::TypeSpecSimpleUnsignedIntKeyWord()
{

}

TypeSpecSimpleUnsignedIntKeyWord::TypeSpecSimpleUnsignedIntKeyWord(const TypeSpecSimpleUnsignedIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedIntKeyWord &TypeSpecSimpleUnsignedIntKeyWord::operator=(const TypeSpecSimpleUnsignedIntKeyWord & other)
{
  TypeSpecSimpleUnsignedIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedIntKeyWord::swap(TypeSpecSimpleUnsignedIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedIntKeyWord::~TypeSpecSimpleUnsignedIntKeyWord()
{

}

void TypeSpecSimpleUnsignedIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedIntKeyWord(this);
}

TypeSpecSimpleUnsignedIntKeyWord *TypeSpecSimpleUnsignedIntKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedIntKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedKeyWord    ********************/
TypeSpecSimpleUnsignedKeyWord::TypeSpecSimpleUnsignedKeyWord()
{

}

TypeSpecSimpleUnsignedKeyWord::TypeSpecSimpleUnsignedKeyWord(const TypeSpecSimpleUnsignedKeyWord & other)
{

}

TypeSpecSimpleUnsignedKeyWord &TypeSpecSimpleUnsignedKeyWord::operator=(const TypeSpecSimpleUnsignedKeyWord & other)
{
  TypeSpecSimpleUnsignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedKeyWord::swap(TypeSpecSimpleUnsignedKeyWord & other)
{

}

TypeSpecSimpleUnsignedKeyWord::~TypeSpecSimpleUnsignedKeyWord()
{

}

void TypeSpecSimpleUnsignedKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedKeyWord(this);
}

TypeSpecSimpleUnsignedKeyWord *TypeSpecSimpleUnsignedKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedKeyWord(*this);
}



/********************   TypeSpecSimpleShortKeyWord    ********************/
TypeSpecSimpleShortKeyWord::TypeSpecSimpleShortKeyWord()
{

}

TypeSpecSimpleShortKeyWord::TypeSpecSimpleShortKeyWord(const TypeSpecSimpleShortKeyWord & other)
{

}

TypeSpecSimpleShortKeyWord &TypeSpecSimpleShortKeyWord::operator=(const TypeSpecSimpleShortKeyWord & other)
{
  TypeSpecSimpleShortKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleShortKeyWord::swap(TypeSpecSimpleShortKeyWord & other)
{

}

TypeSpecSimpleShortKeyWord::~TypeSpecSimpleShortKeyWord()
{

}

void TypeSpecSimpleShortKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleShortKeyWord(this);
}

TypeSpecSimpleShortKeyWord *TypeSpecSimpleShortKeyWord::clone() const
{
  return new TypeSpecSimpleShortKeyWord(*this);
}



/********************   TypeSpecSimpleSignedShortKeyWord    ********************/
TypeSpecSimpleSignedShortKeyWord::TypeSpecSimpleSignedShortKeyWord()
{

}

TypeSpecSimpleSignedShortKeyWord::TypeSpecSimpleSignedShortKeyWord(const TypeSpecSimpleSignedShortKeyWord & other)
{

}

TypeSpecSimpleSignedShortKeyWord &TypeSpecSimpleSignedShortKeyWord::operator=(const TypeSpecSimpleSignedShortKeyWord & other)
{
  TypeSpecSimpleSignedShortKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedShortKeyWord::swap(TypeSpecSimpleSignedShortKeyWord & other)
{

}

TypeSpecSimpleSignedShortKeyWord::~TypeSpecSimpleSignedShortKeyWord()
{

}

void TypeSpecSimpleSignedShortKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedShortKeyWord(this);
}

TypeSpecSimpleSignedShortKeyWord *TypeSpecSimpleSignedShortKeyWord::clone() const
{
  return new TypeSpecSimpleSignedShortKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedShortKeyWord    ********************/
TypeSpecSimpleUnsignedShortKeyWord::TypeSpecSimpleUnsignedShortKeyWord()
{

}

TypeSpecSimpleUnsignedShortKeyWord::TypeSpecSimpleUnsignedShortKeyWord(const TypeSpecSimpleUnsignedShortKeyWord & other)
{

}

TypeSpecSimpleUnsignedShortKeyWord &TypeSpecSimpleUnsignedShortKeyWord::operator=(const TypeSpecSimpleUnsignedShortKeyWord & other)
{
  TypeSpecSimpleUnsignedShortKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedShortKeyWord::swap(TypeSpecSimpleUnsignedShortKeyWord & other)
{

}

TypeSpecSimpleUnsignedShortKeyWord::~TypeSpecSimpleUnsignedShortKeyWord()
{

}

void TypeSpecSimpleUnsignedShortKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedShortKeyWord(this);
}

TypeSpecSimpleUnsignedShortKeyWord *TypeSpecSimpleUnsignedShortKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedShortKeyWord(*this);
}



/********************   TypeSpecSimpleShortIntKeyWord    ********************/
TypeSpecSimpleShortIntKeyWord::TypeSpecSimpleShortIntKeyWord()
{

}

TypeSpecSimpleShortIntKeyWord::TypeSpecSimpleShortIntKeyWord(const TypeSpecSimpleShortIntKeyWord & other)
{

}

TypeSpecSimpleShortIntKeyWord &TypeSpecSimpleShortIntKeyWord::operator=(const TypeSpecSimpleShortIntKeyWord & other)
{
  TypeSpecSimpleShortIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleShortIntKeyWord::swap(TypeSpecSimpleShortIntKeyWord & other)
{

}

TypeSpecSimpleShortIntKeyWord::~TypeSpecSimpleShortIntKeyWord()
{

}

void TypeSpecSimpleShortIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleShortIntKeyWord(this);
}

TypeSpecSimpleShortIntKeyWord *TypeSpecSimpleShortIntKeyWord::clone() const
{
  return new TypeSpecSimpleShortIntKeyWord(*this);
}



/********************   TypeSpecSimpleSignedShortIntKeyWord    ********************/
TypeSpecSimpleSignedShortIntKeyWord::TypeSpecSimpleSignedShortIntKeyWord()
{

}

TypeSpecSimpleSignedShortIntKeyWord::TypeSpecSimpleSignedShortIntKeyWord(const TypeSpecSimpleSignedShortIntKeyWord & other)
{

}

TypeSpecSimpleSignedShortIntKeyWord &TypeSpecSimpleSignedShortIntKeyWord::operator=(const TypeSpecSimpleSignedShortIntKeyWord & other)
{
  TypeSpecSimpleSignedShortIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedShortIntKeyWord::swap(TypeSpecSimpleSignedShortIntKeyWord & other)
{

}

TypeSpecSimpleSignedShortIntKeyWord::~TypeSpecSimpleSignedShortIntKeyWord()
{

}

void TypeSpecSimpleSignedShortIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedShortIntKeyWord(this);
}

TypeSpecSimpleSignedShortIntKeyWord *TypeSpecSimpleSignedShortIntKeyWord::clone() const
{
  return new TypeSpecSimpleSignedShortIntKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedShortIntKeyWord    ********************/
TypeSpecSimpleUnsignedShortIntKeyWord::TypeSpecSimpleUnsignedShortIntKeyWord()
{

}

TypeSpecSimpleUnsignedShortIntKeyWord::TypeSpecSimpleUnsignedShortIntKeyWord(const TypeSpecSimpleUnsignedShortIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedShortIntKeyWord &TypeSpecSimpleUnsignedShortIntKeyWord::operator=(const TypeSpecSimpleUnsignedShortIntKeyWord & other)
{
  TypeSpecSimpleUnsignedShortIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedShortIntKeyWord::swap(TypeSpecSimpleUnsignedShortIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedShortIntKeyWord::~TypeSpecSimpleUnsignedShortIntKeyWord()
{

}

void TypeSpecSimpleUnsignedShortIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedShortIntKeyWord(this);
}

TypeSpecSimpleUnsignedShortIntKeyWord *TypeSpecSimpleUnsignedShortIntKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedShortIntKeyWord(*this);
}



/********************   TypeSpecSimpleLongKeyWord    ********************/
TypeSpecSimpleLongKeyWord::TypeSpecSimpleLongKeyWord()
{

}

TypeSpecSimpleLongKeyWord::TypeSpecSimpleLongKeyWord(const TypeSpecSimpleLongKeyWord & other)
{

}

TypeSpecSimpleLongKeyWord &TypeSpecSimpleLongKeyWord::operator=(const TypeSpecSimpleLongKeyWord & other)
{
  TypeSpecSimpleLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleLongKeyWord::swap(TypeSpecSimpleLongKeyWord & other)
{

}

TypeSpecSimpleLongKeyWord::~TypeSpecSimpleLongKeyWord()
{

}

void TypeSpecSimpleLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleLongKeyWord(this);
}

TypeSpecSimpleLongKeyWord *TypeSpecSimpleLongKeyWord::clone() const
{
  return new TypeSpecSimpleLongKeyWord(*this);
}



/********************   TypeSpecSimpleSignedLongKeyWord    ********************/
TypeSpecSimpleSignedLongKeyWord::TypeSpecSimpleSignedLongKeyWord()
{

}

TypeSpecSimpleSignedLongKeyWord::TypeSpecSimpleSignedLongKeyWord(const TypeSpecSimpleSignedLongKeyWord & other)
{

}

TypeSpecSimpleSignedLongKeyWord &TypeSpecSimpleSignedLongKeyWord::operator=(const TypeSpecSimpleSignedLongKeyWord & other)
{
  TypeSpecSimpleSignedLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedLongKeyWord::swap(TypeSpecSimpleSignedLongKeyWord & other)
{

}

TypeSpecSimpleSignedLongKeyWord::~TypeSpecSimpleSignedLongKeyWord()
{

}

void TypeSpecSimpleSignedLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedLongKeyWord(this);
}

TypeSpecSimpleSignedLongKeyWord *TypeSpecSimpleSignedLongKeyWord::clone() const
{
  return new TypeSpecSimpleSignedLongKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedLongKeyWord    ********************/
TypeSpecSimpleUnsignedLongKeyWord::TypeSpecSimpleUnsignedLongKeyWord()
{

}

TypeSpecSimpleUnsignedLongKeyWord::TypeSpecSimpleUnsignedLongKeyWord(const TypeSpecSimpleUnsignedLongKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongKeyWord &TypeSpecSimpleUnsignedLongKeyWord::operator=(const TypeSpecSimpleUnsignedLongKeyWord & other)
{
  TypeSpecSimpleUnsignedLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedLongKeyWord::swap(TypeSpecSimpleUnsignedLongKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongKeyWord::~TypeSpecSimpleUnsignedLongKeyWord()
{

}

void TypeSpecSimpleUnsignedLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedLongKeyWord(this);
}

TypeSpecSimpleUnsignedLongKeyWord *TypeSpecSimpleUnsignedLongKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedLongKeyWord(*this);
}



/********************   TypeSpecSimpleSignedLongIntKeyWord    ********************/
TypeSpecSimpleSignedLongIntKeyWord::TypeSpecSimpleSignedLongIntKeyWord()
{

}

TypeSpecSimpleSignedLongIntKeyWord::TypeSpecSimpleSignedLongIntKeyWord(const TypeSpecSimpleSignedLongIntKeyWord & other)
{

}

TypeSpecSimpleSignedLongIntKeyWord &TypeSpecSimpleSignedLongIntKeyWord::operator=(const TypeSpecSimpleSignedLongIntKeyWord & other)
{
  TypeSpecSimpleSignedLongIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedLongIntKeyWord::swap(TypeSpecSimpleSignedLongIntKeyWord & other)
{

}

TypeSpecSimpleSignedLongIntKeyWord::~TypeSpecSimpleSignedLongIntKeyWord()
{

}

void TypeSpecSimpleSignedLongIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedLongIntKeyWord(this);
}

TypeSpecSimpleSignedLongIntKeyWord *TypeSpecSimpleSignedLongIntKeyWord::clone() const
{
  return new TypeSpecSimpleSignedLongIntKeyWord(*this);
}



/********************   TypeSpecSimpleLongIntKeyWord    ********************/
TypeSpecSimpleLongIntKeyWord::TypeSpecSimpleLongIntKeyWord()
{

}

TypeSpecSimpleLongIntKeyWord::TypeSpecSimpleLongIntKeyWord(const TypeSpecSimpleLongIntKeyWord & other)
{

}

TypeSpecSimpleLongIntKeyWord &TypeSpecSimpleLongIntKeyWord::operator=(const TypeSpecSimpleLongIntKeyWord & other)
{
  TypeSpecSimpleLongIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleLongIntKeyWord::swap(TypeSpecSimpleLongIntKeyWord & other)
{

}

TypeSpecSimpleLongIntKeyWord::~TypeSpecSimpleLongIntKeyWord()
{

}

void TypeSpecSimpleLongIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleLongIntKeyWord(this);
}

TypeSpecSimpleLongIntKeyWord *TypeSpecSimpleLongIntKeyWord::clone() const
{
  return new TypeSpecSimpleLongIntKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedLongIntKeyWord    ********************/
TypeSpecSimpleUnsignedLongIntKeyWord::TypeSpecSimpleUnsignedLongIntKeyWord()
{

}

TypeSpecSimpleUnsignedLongIntKeyWord::TypeSpecSimpleUnsignedLongIntKeyWord(const TypeSpecSimpleUnsignedLongIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongIntKeyWord &TypeSpecSimpleUnsignedLongIntKeyWord::operator=(const TypeSpecSimpleUnsignedLongIntKeyWord & other)
{
  TypeSpecSimpleUnsignedLongIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedLongIntKeyWord::swap(TypeSpecSimpleUnsignedLongIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongIntKeyWord::~TypeSpecSimpleUnsignedLongIntKeyWord()
{

}

void TypeSpecSimpleUnsignedLongIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedLongIntKeyWord(this);
}

TypeSpecSimpleUnsignedLongIntKeyWord *TypeSpecSimpleUnsignedLongIntKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedLongIntKeyWord(*this);
}



/********************   TypeSpecSimpleLongLongKeyWord    ********************/
TypeSpecSimpleLongLongKeyWord::TypeSpecSimpleLongLongKeyWord()
{

}

TypeSpecSimpleLongLongKeyWord::TypeSpecSimpleLongLongKeyWord(const TypeSpecSimpleLongLongKeyWord & other)
{

}

TypeSpecSimpleLongLongKeyWord &TypeSpecSimpleLongLongKeyWord::operator=(const TypeSpecSimpleLongLongKeyWord & other)
{
  TypeSpecSimpleLongLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleLongLongKeyWord::swap(TypeSpecSimpleLongLongKeyWord & other)
{

}

TypeSpecSimpleLongLongKeyWord::~TypeSpecSimpleLongLongKeyWord()
{

}

void TypeSpecSimpleLongLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleLongLongKeyWord(this);
}

TypeSpecSimpleLongLongKeyWord *TypeSpecSimpleLongLongKeyWord::clone() const
{
  return new TypeSpecSimpleLongLongKeyWord(*this);
}



/********************   TypeSpecSimpleSignedLongLongKeyWord    ********************/
TypeSpecSimpleSignedLongLongKeyWord::TypeSpecSimpleSignedLongLongKeyWord()
{

}

TypeSpecSimpleSignedLongLongKeyWord::TypeSpecSimpleSignedLongLongKeyWord(const TypeSpecSimpleSignedLongLongKeyWord & other)
{

}

TypeSpecSimpleSignedLongLongKeyWord &TypeSpecSimpleSignedLongLongKeyWord::operator=(const TypeSpecSimpleSignedLongLongKeyWord & other)
{
  TypeSpecSimpleSignedLongLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedLongLongKeyWord::swap(TypeSpecSimpleSignedLongLongKeyWord & other)
{

}

TypeSpecSimpleSignedLongLongKeyWord::~TypeSpecSimpleSignedLongLongKeyWord()
{

}

void TypeSpecSimpleSignedLongLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedLongLongKeyWord(this);
}

TypeSpecSimpleSignedLongLongKeyWord *TypeSpecSimpleSignedLongLongKeyWord::clone() const
{
  return new TypeSpecSimpleSignedLongLongKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedLongLongKeyWord    ********************/
TypeSpecSimpleUnsignedLongLongKeyWord::TypeSpecSimpleUnsignedLongLongKeyWord()
{

}

TypeSpecSimpleUnsignedLongLongKeyWord::TypeSpecSimpleUnsignedLongLongKeyWord(const TypeSpecSimpleUnsignedLongLongKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongLongKeyWord &TypeSpecSimpleUnsignedLongLongKeyWord::operator=(const TypeSpecSimpleUnsignedLongLongKeyWord & other)
{
  TypeSpecSimpleUnsignedLongLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedLongLongKeyWord::swap(TypeSpecSimpleUnsignedLongLongKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongLongKeyWord::~TypeSpecSimpleUnsignedLongLongKeyWord()
{

}

void TypeSpecSimpleUnsignedLongLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedLongLongKeyWord(this);
}

TypeSpecSimpleUnsignedLongLongKeyWord *TypeSpecSimpleUnsignedLongLongKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedLongLongKeyWord(*this);
}



/********************   TypeSpecSimpleLongLongIntKeyWord    ********************/
TypeSpecSimpleLongLongIntKeyWord::TypeSpecSimpleLongLongIntKeyWord()
{

}

TypeSpecSimpleLongLongIntKeyWord::TypeSpecSimpleLongLongIntKeyWord(const TypeSpecSimpleLongLongIntKeyWord & other)
{

}

TypeSpecSimpleLongLongIntKeyWord &TypeSpecSimpleLongLongIntKeyWord::operator=(const TypeSpecSimpleLongLongIntKeyWord & other)
{
  TypeSpecSimpleLongLongIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleLongLongIntKeyWord::swap(TypeSpecSimpleLongLongIntKeyWord & other)
{

}

TypeSpecSimpleLongLongIntKeyWord::~TypeSpecSimpleLongLongIntKeyWord()
{

}

void TypeSpecSimpleLongLongIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleLongLongIntKeyWord(this);
}

TypeSpecSimpleLongLongIntKeyWord *TypeSpecSimpleLongLongIntKeyWord::clone() const
{
  return new TypeSpecSimpleLongLongIntKeyWord(*this);
}



/********************   TypeSpecSimpleSignedLongLongIntKeyWord    ********************/
TypeSpecSimpleSignedLongLongIntKeyWord::TypeSpecSimpleSignedLongLongIntKeyWord()
{

}

TypeSpecSimpleSignedLongLongIntKeyWord::TypeSpecSimpleSignedLongLongIntKeyWord(const TypeSpecSimpleSignedLongLongIntKeyWord & other)
{

}

TypeSpecSimpleSignedLongLongIntKeyWord &TypeSpecSimpleSignedLongLongIntKeyWord::operator=(const TypeSpecSimpleSignedLongLongIntKeyWord & other)
{
  TypeSpecSimpleSignedLongLongIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleSignedLongLongIntKeyWord::swap(TypeSpecSimpleSignedLongLongIntKeyWord & other)
{

}

TypeSpecSimpleSignedLongLongIntKeyWord::~TypeSpecSimpleSignedLongLongIntKeyWord()
{

}

void TypeSpecSimpleSignedLongLongIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleSignedLongLongIntKeyWord(this);
}

TypeSpecSimpleSignedLongLongIntKeyWord *TypeSpecSimpleSignedLongLongIntKeyWord::clone() const
{
  return new TypeSpecSimpleSignedLongLongIntKeyWord(*this);
}



/********************   TypeSpecSimpleUnsignedLongLongIntKeyWord    ********************/
TypeSpecSimpleUnsignedLongLongIntKeyWord::TypeSpecSimpleUnsignedLongLongIntKeyWord()
{

}

TypeSpecSimpleUnsignedLongLongIntKeyWord::TypeSpecSimpleUnsignedLongLongIntKeyWord(const TypeSpecSimpleUnsignedLongLongIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongLongIntKeyWord &TypeSpecSimpleUnsignedLongLongIntKeyWord::operator=(const TypeSpecSimpleUnsignedLongLongIntKeyWord & other)
{
  TypeSpecSimpleUnsignedLongLongIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnsignedLongLongIntKeyWord::swap(TypeSpecSimpleUnsignedLongLongIntKeyWord & other)
{

}

TypeSpecSimpleUnsignedLongLongIntKeyWord::~TypeSpecSimpleUnsignedLongLongIntKeyWord()
{

}

void TypeSpecSimpleUnsignedLongLongIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnsignedLongLongIntKeyWord(this);
}

TypeSpecSimpleUnsignedLongLongIntKeyWord *TypeSpecSimpleUnsignedLongLongIntKeyWord::clone() const
{
  return new TypeSpecSimpleUnsignedLongLongIntKeyWord(*this);
}



/********************   TypeSpecSimpleFloatKeyWord    ********************/
TypeSpecSimpleFloatKeyWord::TypeSpecSimpleFloatKeyWord()
{

}

TypeSpecSimpleFloatKeyWord::TypeSpecSimpleFloatKeyWord(const TypeSpecSimpleFloatKeyWord & other)
{

}

TypeSpecSimpleFloatKeyWord &TypeSpecSimpleFloatKeyWord::operator=(const TypeSpecSimpleFloatKeyWord & other)
{
  TypeSpecSimpleFloatKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleFloatKeyWord::swap(TypeSpecSimpleFloatKeyWord & other)
{

}

TypeSpecSimpleFloatKeyWord::~TypeSpecSimpleFloatKeyWord()
{

}

void TypeSpecSimpleFloatKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleFloatKeyWord(this);
}

TypeSpecSimpleFloatKeyWord *TypeSpecSimpleFloatKeyWord::clone() const
{
  return new TypeSpecSimpleFloatKeyWord(*this);
}



/********************   TypeSpecSimpleDoubleKeyWord    ********************/
TypeSpecSimpleDoubleKeyWord::TypeSpecSimpleDoubleKeyWord()
{

}

TypeSpecSimpleDoubleKeyWord::TypeSpecSimpleDoubleKeyWord(const TypeSpecSimpleDoubleKeyWord & other)
{

}

TypeSpecSimpleDoubleKeyWord &TypeSpecSimpleDoubleKeyWord::operator=(const TypeSpecSimpleDoubleKeyWord & other)
{
  TypeSpecSimpleDoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleDoubleKeyWord::swap(TypeSpecSimpleDoubleKeyWord & other)
{

}

TypeSpecSimpleDoubleKeyWord::~TypeSpecSimpleDoubleKeyWord()
{

}

void TypeSpecSimpleDoubleKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleDoubleKeyWord(this);
}

TypeSpecSimpleDoubleKeyWord *TypeSpecSimpleDoubleKeyWord::clone() const
{
  return new TypeSpecSimpleDoubleKeyWord(*this);
}



/********************   TypeSpecSimpleLongDoubleKeyWord    ********************/
TypeSpecSimpleLongDoubleKeyWord::TypeSpecSimpleLongDoubleKeyWord()
{

}

TypeSpecSimpleLongDoubleKeyWord::TypeSpecSimpleLongDoubleKeyWord(const TypeSpecSimpleLongDoubleKeyWord & other)
{

}

TypeSpecSimpleLongDoubleKeyWord &TypeSpecSimpleLongDoubleKeyWord::operator=(const TypeSpecSimpleLongDoubleKeyWord & other)
{
  TypeSpecSimpleLongDoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleLongDoubleKeyWord::swap(TypeSpecSimpleLongDoubleKeyWord & other)
{

}

TypeSpecSimpleLongDoubleKeyWord::~TypeSpecSimpleLongDoubleKeyWord()
{

}

void TypeSpecSimpleLongDoubleKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleLongDoubleKeyWord(this);
}

TypeSpecSimpleLongDoubleKeyWord *TypeSpecSimpleLongDoubleKeyWord::clone() const
{
  return new TypeSpecSimpleLongDoubleKeyWord(*this);
}



/********************   TypeSpecSimpleStruct    ********************/
TypeSpecSimpleStruct::TypeSpecSimpleStruct(IdentifierOrTypenameFull *p1)
{
  identifierortypenamefull_ = p1;

}

TypeSpecSimpleStruct::TypeSpecSimpleStruct(const TypeSpecSimpleStruct & other)
{
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();

}

TypeSpecSimpleStruct &TypeSpecSimpleStruct::operator=(const TypeSpecSimpleStruct & other)
{
  TypeSpecSimpleStruct tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleStruct::swap(TypeSpecSimpleStruct & other)
{
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);

}

TypeSpecSimpleStruct::~TypeSpecSimpleStruct()
{
  delete(identifierortypenamefull_);

}

void TypeSpecSimpleStruct::accept(Visitor *v)
{
  v->visitTypeSpecSimpleStruct(this);
}

TypeSpecSimpleStruct *TypeSpecSimpleStruct::clone() const
{
  return new TypeSpecSimpleStruct(*this);
}



/********************   TypeSpecSimpleEnum    ********************/
TypeSpecSimpleEnum::TypeSpecSimpleEnum(IdentifierOrTypenameFull *p1)
{
  identifierortypenamefull_ = p1;

}

TypeSpecSimpleEnum::TypeSpecSimpleEnum(const TypeSpecSimpleEnum & other)
{
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();

}

TypeSpecSimpleEnum &TypeSpecSimpleEnum::operator=(const TypeSpecSimpleEnum & other)
{
  TypeSpecSimpleEnum tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleEnum::swap(TypeSpecSimpleEnum & other)
{
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);

}

TypeSpecSimpleEnum::~TypeSpecSimpleEnum()
{
  delete(identifierortypenamefull_);

}

void TypeSpecSimpleEnum::accept(Visitor *v)
{
  v->visitTypeSpecSimpleEnum(this);
}

TypeSpecSimpleEnum *TypeSpecSimpleEnum::clone() const
{
  return new TypeSpecSimpleEnum(*this);
}



/********************   TypeSpecSimpleUnion    ********************/
TypeSpecSimpleUnion::TypeSpecSimpleUnion(IdentifierOrTypenameFull *p1)
{
  identifierortypenamefull_ = p1;

}

TypeSpecSimpleUnion::TypeSpecSimpleUnion(const TypeSpecSimpleUnion & other)
{
  identifierortypenamefull_ = other.identifierortypenamefull_->clone();

}

TypeSpecSimpleUnion &TypeSpecSimpleUnion::operator=(const TypeSpecSimpleUnion & other)
{
  TypeSpecSimpleUnion tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleUnion::swap(TypeSpecSimpleUnion & other)
{
  std::swap(identifierortypenamefull_, other.identifierortypenamefull_);

}

TypeSpecSimpleUnion::~TypeSpecSimpleUnion()
{
  delete(identifierortypenamefull_);

}

void TypeSpecSimpleUnion::accept(Visitor *v)
{
  v->visitTypeSpecSimpleUnion(this);
}

TypeSpecSimpleUnion *TypeSpecSimpleUnion::clone() const
{
  return new TypeSpecSimpleUnion(*this);
}



/********************   TypeSpecTYPENAME    ********************/
TypeSpecTYPENAME::TypeSpecTYPENAME(TYPENAME p1)
{
  typename_ = p1;

}

TypeSpecTYPENAME::TypeSpecTYPENAME(const TypeSpecTYPENAME & other)
{
  typename_ = other.typename_;

}

TypeSpecTYPENAME &TypeSpecTYPENAME::operator=(const TypeSpecTYPENAME & other)
{
  TypeSpecTYPENAME tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecTYPENAME::swap(TypeSpecTYPENAME & other)
{
  std::swap(typename_, other.typename_);

}

TypeSpecTYPENAME::~TypeSpecTYPENAME()
{

}

void TypeSpecTYPENAME::accept(Visitor *v)
{
  v->visitTypeSpecTYPENAME(this);
}

TypeSpecTYPENAME *TypeSpecTYPENAME::clone() const
{
  return new TypeSpecTYPENAME(*this);
}



/********************   TypeSpecTYPENAMELogicTypeGen    ********************/
TypeSpecTYPENAMELogicTypeGen::TypeSpecTYPENAMELogicTypeGen(TYPENAME p1, ListLogicTypeGenOFTYPENAME *p2)
{
  typename_ = p1;
  listlogictypegenoftypename_ = p2;

}

TypeSpecTYPENAMELogicTypeGen::TypeSpecTYPENAMELogicTypeGen(const TypeSpecTYPENAMELogicTypeGen & other)
{
  typename_ = other.typename_;
  listlogictypegenoftypename_ = other.listlogictypegenoftypename_->clone();

}

TypeSpecTYPENAMELogicTypeGen &TypeSpecTYPENAMELogicTypeGen::operator=(const TypeSpecTYPENAMELogicTypeGen & other)
{
  TypeSpecTYPENAMELogicTypeGen tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecTYPENAMELogicTypeGen::swap(TypeSpecTYPENAMELogicTypeGen & other)
{
  std::swap(typename_, other.typename_);
  std::swap(listlogictypegenoftypename_, other.listlogictypegenoftypename_);

}

TypeSpecTYPENAMELogicTypeGen::~TypeSpecTYPENAMELogicTypeGen()
{
  delete(listlogictypegenoftypename_);

}

void TypeSpecTYPENAMELogicTypeGen::accept(Visitor *v)
{
  v->visitTypeSpecTYPENAMELogicTypeGen(this);
}

TypeSpecTYPENAMELogicTypeGen *TypeSpecTYPENAMELogicTypeGen::clone() const
{
  return new TypeSpecTYPENAMELogicTypeGen(*this);
}



/********************   TypeSpecSimpleFromTypenameTypeSpec    ********************/
TypeSpecSimpleFromTypenameTypeSpec::TypeSpecSimpleFromTypenameTypeSpec(TypeSpecSimple *p1)
{
  typespecsimple_ = p1;

}

TypeSpecSimpleFromTypenameTypeSpec::TypeSpecSimpleFromTypenameTypeSpec(const TypeSpecSimpleFromTypenameTypeSpec & other)
{
  typespecsimple_ = other.typespecsimple_->clone();

}

TypeSpecSimpleFromTypenameTypeSpec &TypeSpecSimpleFromTypenameTypeSpec::operator=(const TypeSpecSimpleFromTypenameTypeSpec & other)
{
  TypeSpecSimpleFromTypenameTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleFromTypenameTypeSpec::swap(TypeSpecSimpleFromTypenameTypeSpec & other)
{
  std::swap(typespecsimple_, other.typespecsimple_);

}

TypeSpecSimpleFromTypenameTypeSpec::~TypeSpecSimpleFromTypenameTypeSpec()
{
  delete(typespecsimple_);

}

void TypeSpecSimpleFromTypenameTypeSpec::accept(Visitor *v)
{
  v->visitTypeSpecSimpleFromTypenameTypeSpec(this);
}

TypeSpecSimpleFromTypenameTypeSpec *TypeSpecSimpleFromTypenameTypeSpec::clone() const
{
  return new TypeSpecSimpleFromTypenameTypeSpec(*this);
}



/********************   TypeSpecIdentifierOrTypename    ********************/
TypeSpecIdentifierOrTypename::TypeSpecIdentifierOrTypename(IdentifierOrTypename *p1)
{
  identifierortypename_ = p1;

}

TypeSpecIdentifierOrTypename::TypeSpecIdentifierOrTypename(const TypeSpecIdentifierOrTypename & other)
{
  identifierortypename_ = other.identifierortypename_->clone();

}

TypeSpecIdentifierOrTypename &TypeSpecIdentifierOrTypename::operator=(const TypeSpecIdentifierOrTypename & other)
{
  TypeSpecIdentifierOrTypename tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecIdentifierOrTypename::swap(TypeSpecIdentifierOrTypename & other)
{
  std::swap(identifierortypename_, other.identifierortypename_);

}

TypeSpecIdentifierOrTypename::~TypeSpecIdentifierOrTypename()
{
  delete(identifierortypename_);

}

void TypeSpecIdentifierOrTypename::accept(Visitor *v)
{
  v->visitTypeSpecIdentifierOrTypename(this);
}

TypeSpecIdentifierOrTypename *TypeSpecIdentifierOrTypename::clone() const
{
  return new TypeSpecIdentifierOrTypename(*this);
}



/********************   TypeSpecIdentifierOrTypenameAngles    ********************/
TypeSpecIdentifierOrTypenameAngles::TypeSpecIdentifierOrTypenameAngles(IdentifierOrTypename *p1, ListLogicTypeGenOFIdentifierOrTypename *p2)
{
  identifierortypename_ = p1;
  listlogictypegenofidentifierortypename_ = p2;

}

TypeSpecIdentifierOrTypenameAngles::TypeSpecIdentifierOrTypenameAngles(const TypeSpecIdentifierOrTypenameAngles & other)
{
  identifierortypename_ = other.identifierortypename_->clone();
  listlogictypegenofidentifierortypename_ = other.listlogictypegenofidentifierortypename_->clone();

}

TypeSpecIdentifierOrTypenameAngles &TypeSpecIdentifierOrTypenameAngles::operator=(const TypeSpecIdentifierOrTypenameAngles & other)
{
  TypeSpecIdentifierOrTypenameAngles tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecIdentifierOrTypenameAngles::swap(TypeSpecIdentifierOrTypenameAngles & other)
{
  std::swap(identifierortypename_, other.identifierortypename_);
  std::swap(listlogictypegenofidentifierortypename_, other.listlogictypegenofidentifierortypename_);

}

TypeSpecIdentifierOrTypenameAngles::~TypeSpecIdentifierOrTypenameAngles()
{
  delete(identifierortypename_);
  delete(listlogictypegenofidentifierortypename_);

}

void TypeSpecIdentifierOrTypenameAngles::accept(Visitor *v)
{
  v->visitTypeSpecIdentifierOrTypenameAngles(this);
}

TypeSpecIdentifierOrTypenameAngles *TypeSpecIdentifierOrTypenameAngles::clone() const
{
  return new TypeSpecIdentifierOrTypenameAngles(*this);
}



/********************   TypeSpecSimpleFromIdTypenameTypeSpec    ********************/
TypeSpecSimpleFromIdTypenameTypeSpec::TypeSpecSimpleFromIdTypenameTypeSpec(TypeSpecSimple *p1)
{
  typespecsimple_ = p1;

}

TypeSpecSimpleFromIdTypenameTypeSpec::TypeSpecSimpleFromIdTypenameTypeSpec(const TypeSpecSimpleFromIdTypenameTypeSpec & other)
{
  typespecsimple_ = other.typespecsimple_->clone();

}

TypeSpecSimpleFromIdTypenameTypeSpec &TypeSpecSimpleFromIdTypenameTypeSpec::operator=(const TypeSpecSimpleFromIdTypenameTypeSpec & other)
{
  TypeSpecSimpleFromIdTypenameTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleFromIdTypenameTypeSpec::swap(TypeSpecSimpleFromIdTypenameTypeSpec & other)
{
  std::swap(typespecsimple_, other.typespecsimple_);

}

TypeSpecSimpleFromIdTypenameTypeSpec::~TypeSpecSimpleFromIdTypenameTypeSpec()
{
  delete(typespecsimple_);

}

void TypeSpecSimpleFromIdTypenameTypeSpec::accept(Visitor *v)
{
  v->visitTypeSpecSimpleFromIdTypenameTypeSpec(this);
}

TypeSpecSimpleFromIdTypenameTypeSpec *TypeSpecSimpleFromIdTypenameTypeSpec::clone() const
{
  return new TypeSpecSimpleFromIdTypenameTypeSpec(*this);
}



/********************   SimpleIdentifierFull    ********************/
SimpleIdentifierFull::SimpleIdentifierFull(Identifier *p1)
{
  identifier_ = p1;

}

SimpleIdentifierFull::SimpleIdentifierFull(const SimpleIdentifierFull & other)
{
  identifier_ = other.identifier_->clone();

}

SimpleIdentifierFull &SimpleIdentifierFull::operator=(const SimpleIdentifierFull & other)
{
  SimpleIdentifierFull tmp(other);
  swap(tmp);
  return *this;
}

void SimpleIdentifierFull::swap(SimpleIdentifierFull & other)
{
  std::swap(identifier_, other.identifier_);

}

SimpleIdentifierFull::~SimpleIdentifierFull()
{
  delete(identifier_);

}

void SimpleIdentifierFull::accept(Visitor *v)
{
  v->visitSimpleIdentifierFull(this);
}

SimpleIdentifierFull *SimpleIdentifierFull::clone() const
{
  return new SimpleIdentifierFull(*this);
}



/********************   AdmitKeyWordFullIdent    ********************/
AdmitKeyWordFullIdent::AdmitKeyWordFullIdent()
{

}

AdmitKeyWordFullIdent::AdmitKeyWordFullIdent(const AdmitKeyWordFullIdent & other)
{

}

AdmitKeyWordFullIdent &AdmitKeyWordFullIdent::operator=(const AdmitKeyWordFullIdent & other)
{
  AdmitKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AdmitKeyWordFullIdent::swap(AdmitKeyWordFullIdent & other)
{

}

AdmitKeyWordFullIdent::~AdmitKeyWordFullIdent()
{

}

void AdmitKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAdmitKeyWordFullIdent(this);
}

AdmitKeyWordFullIdent *AdmitKeyWordFullIdent::clone() const
{
  return new AdmitKeyWordFullIdent(*this);
}



/********************   AllocatesKeyWordFullIdent    ********************/
AllocatesKeyWordFullIdent::AllocatesKeyWordFullIdent()
{

}

AllocatesKeyWordFullIdent::AllocatesKeyWordFullIdent(const AllocatesKeyWordFullIdent & other)
{

}

AllocatesKeyWordFullIdent &AllocatesKeyWordFullIdent::operator=(const AllocatesKeyWordFullIdent & other)
{
  AllocatesKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AllocatesKeyWordFullIdent::swap(AllocatesKeyWordFullIdent & other)
{

}

AllocatesKeyWordFullIdent::~AllocatesKeyWordFullIdent()
{

}

void AllocatesKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAllocatesKeyWordFullIdent(this);
}

AllocatesKeyWordFullIdent *AllocatesKeyWordFullIdent::clone() const
{
  return new AllocatesKeyWordFullIdent(*this);
}



/********************   AssertKeyWordFullIdent    ********************/
AssertKeyWordFullIdent::AssertKeyWordFullIdent()
{

}

AssertKeyWordFullIdent::AssertKeyWordFullIdent(const AssertKeyWordFullIdent & other)
{

}

AssertKeyWordFullIdent &AssertKeyWordFullIdent::operator=(const AssertKeyWordFullIdent & other)
{
  AssertKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AssertKeyWordFullIdent::swap(AssertKeyWordFullIdent & other)
{

}

AssertKeyWordFullIdent::~AssertKeyWordFullIdent()
{

}

void AssertKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAssertKeyWordFullIdent(this);
}

AssertKeyWordFullIdent *AssertKeyWordFullIdent::clone() const
{
  return new AssertKeyWordFullIdent(*this);
}



/********************   AssignsKeyWordFullIdent    ********************/
AssignsKeyWordFullIdent::AssignsKeyWordFullIdent()
{

}

AssignsKeyWordFullIdent::AssignsKeyWordFullIdent(const AssignsKeyWordFullIdent & other)
{

}

AssignsKeyWordFullIdent &AssignsKeyWordFullIdent::operator=(const AssignsKeyWordFullIdent & other)
{
  AssignsKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AssignsKeyWordFullIdent::swap(AssignsKeyWordFullIdent & other)
{

}

AssignsKeyWordFullIdent::~AssignsKeyWordFullIdent()
{

}

void AssignsKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAssignsKeyWordFullIdent(this);
}

AssignsKeyWordFullIdent *AssignsKeyWordFullIdent::clone() const
{
  return new AssignsKeyWordFullIdent(*this);
}



/********************   AssumesKeyWordFullIdent    ********************/
AssumesKeyWordFullIdent::AssumesKeyWordFullIdent()
{

}

AssumesKeyWordFullIdent::AssumesKeyWordFullIdent(const AssumesKeyWordFullIdent & other)
{

}

AssumesKeyWordFullIdent &AssumesKeyWordFullIdent::operator=(const AssumesKeyWordFullIdent & other)
{
  AssumesKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AssumesKeyWordFullIdent::swap(AssumesKeyWordFullIdent & other)
{

}

AssumesKeyWordFullIdent::~AssumesKeyWordFullIdent()
{

}

void AssumesKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAssumesKeyWordFullIdent(this);
}

AssumesKeyWordFullIdent *AssumesKeyWordFullIdent::clone() const
{
  return new AssumesKeyWordFullIdent(*this);
}



/********************   AtKeyWordFullIdent    ********************/
AtKeyWordFullIdent::AtKeyWordFullIdent()
{

}

AtKeyWordFullIdent::AtKeyWordFullIdent(const AtKeyWordFullIdent & other)
{

}

AtKeyWordFullIdent &AtKeyWordFullIdent::operator=(const AtKeyWordFullIdent & other)
{
  AtKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AtKeyWordFullIdent::swap(AtKeyWordFullIdent & other)
{

}

AtKeyWordFullIdent::~AtKeyWordFullIdent()
{

}

void AtKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAtKeyWordFullIdent(this);
}

AtKeyWordFullIdent *AtKeyWordFullIdent::clone() const
{
  return new AtKeyWordFullIdent(*this);
}



/********************   AxiomKeyWordFullIdent    ********************/
AxiomKeyWordFullIdent::AxiomKeyWordFullIdent()
{

}

AxiomKeyWordFullIdent::AxiomKeyWordFullIdent(const AxiomKeyWordFullIdent & other)
{

}

AxiomKeyWordFullIdent &AxiomKeyWordFullIdent::operator=(const AxiomKeyWordFullIdent & other)
{
  AxiomKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AxiomKeyWordFullIdent::swap(AxiomKeyWordFullIdent & other)
{

}

AxiomKeyWordFullIdent::~AxiomKeyWordFullIdent()
{

}

void AxiomKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAxiomKeyWordFullIdent(this);
}

AxiomKeyWordFullIdent *AxiomKeyWordFullIdent::clone() const
{
  return new AxiomKeyWordFullIdent(*this);
}



/********************   AxiomaticKeyWordFullIdent    ********************/
AxiomaticKeyWordFullIdent::AxiomaticKeyWordFullIdent()
{

}

AxiomaticKeyWordFullIdent::AxiomaticKeyWordFullIdent(const AxiomaticKeyWordFullIdent & other)
{

}

AxiomaticKeyWordFullIdent &AxiomaticKeyWordFullIdent::operator=(const AxiomaticKeyWordFullIdent & other)
{
  AxiomaticKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void AxiomaticKeyWordFullIdent::swap(AxiomaticKeyWordFullIdent & other)
{

}

AxiomaticKeyWordFullIdent::~AxiomaticKeyWordFullIdent()
{

}

void AxiomaticKeyWordFullIdent::accept(Visitor *v)
{
  v->visitAxiomaticKeyWordFullIdent(this);
}

AxiomaticKeyWordFullIdent *AxiomaticKeyWordFullIdent::clone() const
{
  return new AxiomaticKeyWordFullIdent(*this);
}



/********************   BehaviorKeyWordFullIdent    ********************/
BehaviorKeyWordFullIdent::BehaviorKeyWordFullIdent()
{

}

BehaviorKeyWordFullIdent::BehaviorKeyWordFullIdent(const BehaviorKeyWordFullIdent & other)
{

}

BehaviorKeyWordFullIdent &BehaviorKeyWordFullIdent::operator=(const BehaviorKeyWordFullIdent & other)
{
  BehaviorKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorKeyWordFullIdent::swap(BehaviorKeyWordFullIdent & other)
{

}

BehaviorKeyWordFullIdent::~BehaviorKeyWordFullIdent()
{

}

void BehaviorKeyWordFullIdent::accept(Visitor *v)
{
  v->visitBehaviorKeyWordFullIdent(this);
}

BehaviorKeyWordFullIdent *BehaviorKeyWordFullIdent::clone() const
{
  return new BehaviorKeyWordFullIdent(*this);
}



/********************   BreaksKeyWordFullIdent    ********************/
BreaksKeyWordFullIdent::BreaksKeyWordFullIdent()
{

}

BreaksKeyWordFullIdent::BreaksKeyWordFullIdent(const BreaksKeyWordFullIdent & other)
{

}

BreaksKeyWordFullIdent &BreaksKeyWordFullIdent::operator=(const BreaksKeyWordFullIdent & other)
{
  BreaksKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void BreaksKeyWordFullIdent::swap(BreaksKeyWordFullIdent & other)
{

}

BreaksKeyWordFullIdent::~BreaksKeyWordFullIdent()
{

}

void BreaksKeyWordFullIdent::accept(Visitor *v)
{
  v->visitBreaksKeyWordFullIdent(this);
}

BreaksKeyWordFullIdent *BreaksKeyWordFullIdent::clone() const
{
  return new BreaksKeyWordFullIdent(*this);
}



/********************   CheckKeyWordFullIdent    ********************/
CheckKeyWordFullIdent::CheckKeyWordFullIdent()
{

}

CheckKeyWordFullIdent::CheckKeyWordFullIdent(const CheckKeyWordFullIdent & other)
{

}

CheckKeyWordFullIdent &CheckKeyWordFullIdent::operator=(const CheckKeyWordFullIdent & other)
{
  CheckKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void CheckKeyWordFullIdent::swap(CheckKeyWordFullIdent & other)
{

}

CheckKeyWordFullIdent::~CheckKeyWordFullIdent()
{

}

void CheckKeyWordFullIdent::accept(Visitor *v)
{
  v->visitCheckKeyWordFullIdent(this);
}

CheckKeyWordFullIdent *CheckKeyWordFullIdent::clone() const
{
  return new CheckKeyWordFullIdent(*this);
}



/********************   CompleteKeyWordFullIdent    ********************/
CompleteKeyWordFullIdent::CompleteKeyWordFullIdent()
{

}

CompleteKeyWordFullIdent::CompleteKeyWordFullIdent(const CompleteKeyWordFullIdent & other)
{

}

CompleteKeyWordFullIdent &CompleteKeyWordFullIdent::operator=(const CompleteKeyWordFullIdent & other)
{
  CompleteKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void CompleteKeyWordFullIdent::swap(CompleteKeyWordFullIdent & other)
{

}

CompleteKeyWordFullIdent::~CompleteKeyWordFullIdent()
{

}

void CompleteKeyWordFullIdent::accept(Visitor *v)
{
  v->visitCompleteKeyWordFullIdent(this);
}

CompleteKeyWordFullIdent *CompleteKeyWordFullIdent::clone() const
{
  return new CompleteKeyWordFullIdent(*this);
}



/********************   ContinuesKeyWordFullIdent    ********************/
ContinuesKeyWordFullIdent::ContinuesKeyWordFullIdent()
{

}

ContinuesKeyWordFullIdent::ContinuesKeyWordFullIdent(const ContinuesKeyWordFullIdent & other)
{

}

ContinuesKeyWordFullIdent &ContinuesKeyWordFullIdent::operator=(const ContinuesKeyWordFullIdent & other)
{
  ContinuesKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ContinuesKeyWordFullIdent::swap(ContinuesKeyWordFullIdent & other)
{

}

ContinuesKeyWordFullIdent::~ContinuesKeyWordFullIdent()
{

}

void ContinuesKeyWordFullIdent::accept(Visitor *v)
{
  v->visitContinuesKeyWordFullIdent(this);
}

ContinuesKeyWordFullIdent *ContinuesKeyWordFullIdent::clone() const
{
  return new ContinuesKeyWordFullIdent(*this);
}



/********************   ContractKeyWordFullIdent    ********************/
ContractKeyWordFullIdent::ContractKeyWordFullIdent()
{

}

ContractKeyWordFullIdent::ContractKeyWordFullIdent(const ContractKeyWordFullIdent & other)
{

}

ContractKeyWordFullIdent &ContractKeyWordFullIdent::operator=(const ContractKeyWordFullIdent & other)
{
  ContractKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ContractKeyWordFullIdent::swap(ContractKeyWordFullIdent & other)
{

}

ContractKeyWordFullIdent::~ContractKeyWordFullIdent()
{

}

void ContractKeyWordFullIdent::accept(Visitor *v)
{
  v->visitContractKeyWordFullIdent(this);
}

ContractKeyWordFullIdent *ContractKeyWordFullIdent::clone() const
{
  return new ContractKeyWordFullIdent(*this);
}



/********************   DecreasesKeyWordFullIdent    ********************/
DecreasesKeyWordFullIdent::DecreasesKeyWordFullIdent()
{

}

DecreasesKeyWordFullIdent::DecreasesKeyWordFullIdent(const DecreasesKeyWordFullIdent & other)
{

}

DecreasesKeyWordFullIdent &DecreasesKeyWordFullIdent::operator=(const DecreasesKeyWordFullIdent & other)
{
  DecreasesKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void DecreasesKeyWordFullIdent::swap(DecreasesKeyWordFullIdent & other)
{

}

DecreasesKeyWordFullIdent::~DecreasesKeyWordFullIdent()
{

}

void DecreasesKeyWordFullIdent::accept(Visitor *v)
{
  v->visitDecreasesKeyWordFullIdent(this);
}

DecreasesKeyWordFullIdent *DecreasesKeyWordFullIdent::clone() const
{
  return new DecreasesKeyWordFullIdent(*this);
}



/********************   DisjointKeyWordFullIdent    ********************/
DisjointKeyWordFullIdent::DisjointKeyWordFullIdent()
{

}

DisjointKeyWordFullIdent::DisjointKeyWordFullIdent(const DisjointKeyWordFullIdent & other)
{

}

DisjointKeyWordFullIdent &DisjointKeyWordFullIdent::operator=(const DisjointKeyWordFullIdent & other)
{
  DisjointKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void DisjointKeyWordFullIdent::swap(DisjointKeyWordFullIdent & other)
{

}

DisjointKeyWordFullIdent::~DisjointKeyWordFullIdent()
{

}

void DisjointKeyWordFullIdent::accept(Visitor *v)
{
  v->visitDisjointKeyWordFullIdent(this);
}

DisjointKeyWordFullIdent *DisjointKeyWordFullIdent::clone() const
{
  return new DisjointKeyWordFullIdent(*this);
}



/********************   EnsuresKeyWordFullIdent    ********************/
EnsuresKeyWordFullIdent::EnsuresKeyWordFullIdent()
{

}

EnsuresKeyWordFullIdent::EnsuresKeyWordFullIdent(const EnsuresKeyWordFullIdent & other)
{

}

EnsuresKeyWordFullIdent &EnsuresKeyWordFullIdent::operator=(const EnsuresKeyWordFullIdent & other)
{
  EnsuresKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void EnsuresKeyWordFullIdent::swap(EnsuresKeyWordFullIdent & other)
{

}

EnsuresKeyWordFullIdent::~EnsuresKeyWordFullIdent()
{

}

void EnsuresKeyWordFullIdent::accept(Visitor *v)
{
  v->visitEnsuresKeyWordFullIdent(this);
}

EnsuresKeyWordFullIdent *EnsuresKeyWordFullIdent::clone() const
{
  return new EnsuresKeyWordFullIdent(*this);
}



/********************   ExitsKeyWordFullIdent    ********************/
ExitsKeyWordFullIdent::ExitsKeyWordFullIdent()
{

}

ExitsKeyWordFullIdent::ExitsKeyWordFullIdent(const ExitsKeyWordFullIdent & other)
{

}

ExitsKeyWordFullIdent &ExitsKeyWordFullIdent::operator=(const ExitsKeyWordFullIdent & other)
{
  ExitsKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ExitsKeyWordFullIdent::swap(ExitsKeyWordFullIdent & other)
{

}

ExitsKeyWordFullIdent::~ExitsKeyWordFullIdent()
{

}

void ExitsKeyWordFullIdent::accept(Visitor *v)
{
  v->visitExitsKeyWordFullIdent(this);
}

ExitsKeyWordFullIdent *ExitsKeyWordFullIdent::clone() const
{
  return new ExitsKeyWordFullIdent(*this);
}



/********************   FreesKeyWordFullIdent    ********************/
FreesKeyWordFullIdent::FreesKeyWordFullIdent()
{

}

FreesKeyWordFullIdent::FreesKeyWordFullIdent(const FreesKeyWordFullIdent & other)
{

}

FreesKeyWordFullIdent &FreesKeyWordFullIdent::operator=(const FreesKeyWordFullIdent & other)
{
  FreesKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void FreesKeyWordFullIdent::swap(FreesKeyWordFullIdent & other)
{

}

FreesKeyWordFullIdent::~FreesKeyWordFullIdent()
{

}

void FreesKeyWordFullIdent::accept(Visitor *v)
{
  v->visitFreesKeyWordFullIdent(this);
}

FreesKeyWordFullIdent *FreesKeyWordFullIdent::clone() const
{
  return new FreesKeyWordFullIdent(*this);
}



/********************   FunctionKeyWordFullIdent    ********************/
FunctionKeyWordFullIdent::FunctionKeyWordFullIdent()
{

}

FunctionKeyWordFullIdent::FunctionKeyWordFullIdent(const FunctionKeyWordFullIdent & other)
{

}

FunctionKeyWordFullIdent &FunctionKeyWordFullIdent::operator=(const FunctionKeyWordFullIdent & other)
{
  FunctionKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void FunctionKeyWordFullIdent::swap(FunctionKeyWordFullIdent & other)
{

}

FunctionKeyWordFullIdent::~FunctionKeyWordFullIdent()
{

}

void FunctionKeyWordFullIdent::accept(Visitor *v)
{
  v->visitFunctionKeyWordFullIdent(this);
}

FunctionKeyWordFullIdent *FunctionKeyWordFullIdent::clone() const
{
  return new FunctionKeyWordFullIdent(*this);
}



/********************   GlobalKeyWordFullIdent    ********************/
GlobalKeyWordFullIdent::GlobalKeyWordFullIdent()
{

}

GlobalKeyWordFullIdent::GlobalKeyWordFullIdent(const GlobalKeyWordFullIdent & other)
{

}

GlobalKeyWordFullIdent &GlobalKeyWordFullIdent::operator=(const GlobalKeyWordFullIdent & other)
{
  GlobalKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void GlobalKeyWordFullIdent::swap(GlobalKeyWordFullIdent & other)
{

}

GlobalKeyWordFullIdent::~GlobalKeyWordFullIdent()
{

}

void GlobalKeyWordFullIdent::accept(Visitor *v)
{
  v->visitGlobalKeyWordFullIdent(this);
}

GlobalKeyWordFullIdent *GlobalKeyWordFullIdent::clone() const
{
  return new GlobalKeyWordFullIdent(*this);
}



/********************   ImpactKeyWordFullIdent    ********************/
ImpactKeyWordFullIdent::ImpactKeyWordFullIdent()
{

}

ImpactKeyWordFullIdent::ImpactKeyWordFullIdent(const ImpactKeyWordFullIdent & other)
{

}

ImpactKeyWordFullIdent &ImpactKeyWordFullIdent::operator=(const ImpactKeyWordFullIdent & other)
{
  ImpactKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ImpactKeyWordFullIdent::swap(ImpactKeyWordFullIdent & other)
{

}

ImpactKeyWordFullIdent::~ImpactKeyWordFullIdent()
{

}

void ImpactKeyWordFullIdent::accept(Visitor *v)
{
  v->visitImpactKeyWordFullIdent(this);
}

ImpactKeyWordFullIdent *ImpactKeyWordFullIdent::clone() const
{
  return new ImpactKeyWordFullIdent(*this);
}



/********************   InductiveKeyWordFullIdent    ********************/
InductiveKeyWordFullIdent::InductiveKeyWordFullIdent()
{

}

InductiveKeyWordFullIdent::InductiveKeyWordFullIdent(const InductiveKeyWordFullIdent & other)
{

}

InductiveKeyWordFullIdent &InductiveKeyWordFullIdent::operator=(const InductiveKeyWordFullIdent & other)
{
  InductiveKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void InductiveKeyWordFullIdent::swap(InductiveKeyWordFullIdent & other)
{

}

InductiveKeyWordFullIdent::~InductiveKeyWordFullIdent()
{

}

void InductiveKeyWordFullIdent::accept(Visitor *v)
{
  v->visitInductiveKeyWordFullIdent(this);
}

InductiveKeyWordFullIdent *InductiveKeyWordFullIdent::clone() const
{
  return new InductiveKeyWordFullIdent(*this);
}



/********************   IncludeKeyWordFullIdent    ********************/
IncludeKeyWordFullIdent::IncludeKeyWordFullIdent()
{

}

IncludeKeyWordFullIdent::IncludeKeyWordFullIdent(const IncludeKeyWordFullIdent & other)
{

}

IncludeKeyWordFullIdent &IncludeKeyWordFullIdent::operator=(const IncludeKeyWordFullIdent & other)
{
  IncludeKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void IncludeKeyWordFullIdent::swap(IncludeKeyWordFullIdent & other)
{

}

IncludeKeyWordFullIdent::~IncludeKeyWordFullIdent()
{

}

void IncludeKeyWordFullIdent::accept(Visitor *v)
{
  v->visitIncludeKeyWordFullIdent(this);
}

IncludeKeyWordFullIdent *IncludeKeyWordFullIdent::clone() const
{
  return new IncludeKeyWordFullIdent(*this);
}



/********************   InvariantKeyWordFullIdent    ********************/
InvariantKeyWordFullIdent::InvariantKeyWordFullIdent()
{

}

InvariantKeyWordFullIdent::InvariantKeyWordFullIdent(const InvariantKeyWordFullIdent & other)
{

}

InvariantKeyWordFullIdent &InvariantKeyWordFullIdent::operator=(const InvariantKeyWordFullIdent & other)
{
  InvariantKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void InvariantKeyWordFullIdent::swap(InvariantKeyWordFullIdent & other)
{

}

InvariantKeyWordFullIdent::~InvariantKeyWordFullIdent()
{

}

void InvariantKeyWordFullIdent::accept(Visitor *v)
{
  v->visitInvariantKeyWordFullIdent(this);
}

InvariantKeyWordFullIdent *InvariantKeyWordFullIdent::clone() const
{
  return new InvariantKeyWordFullIdent(*this);
}



/********************   LemmaKeyWordFullIdent    ********************/
LemmaKeyWordFullIdent::LemmaKeyWordFullIdent()
{

}

LemmaKeyWordFullIdent::LemmaKeyWordFullIdent(const LemmaKeyWordFullIdent & other)
{

}

LemmaKeyWordFullIdent &LemmaKeyWordFullIdent::operator=(const LemmaKeyWordFullIdent & other)
{
  LemmaKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void LemmaKeyWordFullIdent::swap(LemmaKeyWordFullIdent & other)
{

}

LemmaKeyWordFullIdent::~LemmaKeyWordFullIdent()
{

}

void LemmaKeyWordFullIdent::accept(Visitor *v)
{
  v->visitLemmaKeyWordFullIdent(this);
}

LemmaKeyWordFullIdent *LemmaKeyWordFullIdent::clone() const
{
  return new LemmaKeyWordFullIdent(*this);
}



/********************   LetKeyWordFullIdent    ********************/
LetKeyWordFullIdent::LetKeyWordFullIdent()
{

}

LetKeyWordFullIdent::LetKeyWordFullIdent(const LetKeyWordFullIdent & other)
{

}

LetKeyWordFullIdent &LetKeyWordFullIdent::operator=(const LetKeyWordFullIdent & other)
{
  LetKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void LetKeyWordFullIdent::swap(LetKeyWordFullIdent & other)
{

}

LetKeyWordFullIdent::~LetKeyWordFullIdent()
{

}

void LetKeyWordFullIdent::accept(Visitor *v)
{
  v->visitLetKeyWordFullIdent(this);
}

LetKeyWordFullIdent *LetKeyWordFullIdent::clone() const
{
  return new LetKeyWordFullIdent(*this);
}



/********************   LogicKeyWordFullIdent    ********************/
LogicKeyWordFullIdent::LogicKeyWordFullIdent()
{

}

LogicKeyWordFullIdent::LogicKeyWordFullIdent(const LogicKeyWordFullIdent & other)
{

}

LogicKeyWordFullIdent &LogicKeyWordFullIdent::operator=(const LogicKeyWordFullIdent & other)
{
  LogicKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void LogicKeyWordFullIdent::swap(LogicKeyWordFullIdent & other)
{

}

LogicKeyWordFullIdent::~LogicKeyWordFullIdent()
{

}

void LogicKeyWordFullIdent::accept(Visitor *v)
{
  v->visitLogicKeyWordFullIdent(this);
}

LogicKeyWordFullIdent *LogicKeyWordFullIdent::clone() const
{
  return new LogicKeyWordFullIdent(*this);
}



/********************   LoopKeyWordFullIdent    ********************/
LoopKeyWordFullIdent::LoopKeyWordFullIdent()
{

}

LoopKeyWordFullIdent::LoopKeyWordFullIdent(const LoopKeyWordFullIdent & other)
{

}

LoopKeyWordFullIdent &LoopKeyWordFullIdent::operator=(const LoopKeyWordFullIdent & other)
{
  LoopKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void LoopKeyWordFullIdent::swap(LoopKeyWordFullIdent & other)
{

}

LoopKeyWordFullIdent::~LoopKeyWordFullIdent()
{

}

void LoopKeyWordFullIdent::accept(Visitor *v)
{
  v->visitLoopKeyWordFullIdent(this);
}

LoopKeyWordFullIdent *LoopKeyWordFullIdent::clone() const
{
  return new LoopKeyWordFullIdent(*this);
}



/********************   ModelKeyWordFullIdent    ********************/
ModelKeyWordFullIdent::ModelKeyWordFullIdent()
{

}

ModelKeyWordFullIdent::ModelKeyWordFullIdent(const ModelKeyWordFullIdent & other)
{

}

ModelKeyWordFullIdent &ModelKeyWordFullIdent::operator=(const ModelKeyWordFullIdent & other)
{
  ModelKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ModelKeyWordFullIdent::swap(ModelKeyWordFullIdent & other)
{

}

ModelKeyWordFullIdent::~ModelKeyWordFullIdent()
{

}

void ModelKeyWordFullIdent::accept(Visitor *v)
{
  v->visitModelKeyWordFullIdent(this);
}

ModelKeyWordFullIdent *ModelKeyWordFullIdent::clone() const
{
  return new ModelKeyWordFullIdent(*this);
}



/********************   ModuleKeyWordFullIdent    ********************/
ModuleKeyWordFullIdent::ModuleKeyWordFullIdent()
{

}

ModuleKeyWordFullIdent::ModuleKeyWordFullIdent(const ModuleKeyWordFullIdent & other)
{

}

ModuleKeyWordFullIdent &ModuleKeyWordFullIdent::operator=(const ModuleKeyWordFullIdent & other)
{
  ModuleKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ModuleKeyWordFullIdent::swap(ModuleKeyWordFullIdent & other)
{

}

ModuleKeyWordFullIdent::~ModuleKeyWordFullIdent()
{

}

void ModuleKeyWordFullIdent::accept(Visitor *v)
{
  v->visitModuleKeyWordFullIdent(this);
}

ModuleKeyWordFullIdent *ModuleKeyWordFullIdent::clone() const
{
  return new ModuleKeyWordFullIdent(*this);
}



/********************   PragmaKeyWordFullIdent    ********************/
PragmaKeyWordFullIdent::PragmaKeyWordFullIdent()
{

}

PragmaKeyWordFullIdent::PragmaKeyWordFullIdent(const PragmaKeyWordFullIdent & other)
{

}

PragmaKeyWordFullIdent &PragmaKeyWordFullIdent::operator=(const PragmaKeyWordFullIdent & other)
{
  PragmaKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void PragmaKeyWordFullIdent::swap(PragmaKeyWordFullIdent & other)
{

}

PragmaKeyWordFullIdent::~PragmaKeyWordFullIdent()
{

}

void PragmaKeyWordFullIdent::accept(Visitor *v)
{
  v->visitPragmaKeyWordFullIdent(this);
}

PragmaKeyWordFullIdent *PragmaKeyWordFullIdent::clone() const
{
  return new PragmaKeyWordFullIdent(*this);
}



/********************   PredicateKeyWordFullIdent    ********************/
PredicateKeyWordFullIdent::PredicateKeyWordFullIdent()
{

}

PredicateKeyWordFullIdent::PredicateKeyWordFullIdent(const PredicateKeyWordFullIdent & other)
{

}

PredicateKeyWordFullIdent &PredicateKeyWordFullIdent::operator=(const PredicateKeyWordFullIdent & other)
{
  PredicateKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void PredicateKeyWordFullIdent::swap(PredicateKeyWordFullIdent & other)
{

}

PredicateKeyWordFullIdent::~PredicateKeyWordFullIdent()
{

}

void PredicateKeyWordFullIdent::accept(Visitor *v)
{
  v->visitPredicateKeyWordFullIdent(this);
}

PredicateKeyWordFullIdent *PredicateKeyWordFullIdent::clone() const
{
  return new PredicateKeyWordFullIdent(*this);
}



/********************   RequiresKeyWordFullIdent    ********************/
RequiresKeyWordFullIdent::RequiresKeyWordFullIdent()
{

}

RequiresKeyWordFullIdent::RequiresKeyWordFullIdent(const RequiresKeyWordFullIdent & other)
{

}

RequiresKeyWordFullIdent &RequiresKeyWordFullIdent::operator=(const RequiresKeyWordFullIdent & other)
{
  RequiresKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void RequiresKeyWordFullIdent::swap(RequiresKeyWordFullIdent & other)
{

}

RequiresKeyWordFullIdent::~RequiresKeyWordFullIdent()
{

}

void RequiresKeyWordFullIdent::accept(Visitor *v)
{
  v->visitRequiresKeyWordFullIdent(this);
}

RequiresKeyWordFullIdent *RequiresKeyWordFullIdent::clone() const
{
  return new RequiresKeyWordFullIdent(*this);
}



/********************   ReturnsKeyWordFullIdent    ********************/
ReturnsKeyWordFullIdent::ReturnsKeyWordFullIdent()
{

}

ReturnsKeyWordFullIdent::ReturnsKeyWordFullIdent(const ReturnsKeyWordFullIdent & other)
{

}

ReturnsKeyWordFullIdent &ReturnsKeyWordFullIdent::operator=(const ReturnsKeyWordFullIdent & other)
{
  ReturnsKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void ReturnsKeyWordFullIdent::swap(ReturnsKeyWordFullIdent & other)
{

}

ReturnsKeyWordFullIdent::~ReturnsKeyWordFullIdent()
{

}

void ReturnsKeyWordFullIdent::accept(Visitor *v)
{
  v->visitReturnsKeyWordFullIdent(this);
}

ReturnsKeyWordFullIdent *ReturnsKeyWordFullIdent::clone() const
{
  return new ReturnsKeyWordFullIdent(*this);
}



/********************   SliceKeyWordFullIdent    ********************/
SliceKeyWordFullIdent::SliceKeyWordFullIdent()
{

}

SliceKeyWordFullIdent::SliceKeyWordFullIdent(const SliceKeyWordFullIdent & other)
{

}

SliceKeyWordFullIdent &SliceKeyWordFullIdent::operator=(const SliceKeyWordFullIdent & other)
{
  SliceKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void SliceKeyWordFullIdent::swap(SliceKeyWordFullIdent & other)
{

}

SliceKeyWordFullIdent::~SliceKeyWordFullIdent()
{

}

void SliceKeyWordFullIdent::accept(Visitor *v)
{
  v->visitSliceKeyWordFullIdent(this);
}

SliceKeyWordFullIdent *SliceKeyWordFullIdent::clone() const
{
  return new SliceKeyWordFullIdent(*this);
}



/********************   TerminatesKeyWordFullIdent    ********************/
TerminatesKeyWordFullIdent::TerminatesKeyWordFullIdent()
{

}

TerminatesKeyWordFullIdent::TerminatesKeyWordFullIdent(const TerminatesKeyWordFullIdent & other)
{

}

TerminatesKeyWordFullIdent &TerminatesKeyWordFullIdent::operator=(const TerminatesKeyWordFullIdent & other)
{
  TerminatesKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void TerminatesKeyWordFullIdent::swap(TerminatesKeyWordFullIdent & other)
{

}

TerminatesKeyWordFullIdent::~TerminatesKeyWordFullIdent()
{

}

void TerminatesKeyWordFullIdent::accept(Visitor *v)
{
  v->visitTerminatesKeyWordFullIdent(this);
}

TerminatesKeyWordFullIdent *TerminatesKeyWordFullIdent::clone() const
{
  return new TerminatesKeyWordFullIdent(*this);
}



/********************   TypeKeyWordFullIdent    ********************/
TypeKeyWordFullIdent::TypeKeyWordFullIdent()
{

}

TypeKeyWordFullIdent::TypeKeyWordFullIdent(const TypeKeyWordFullIdent & other)
{

}

TypeKeyWordFullIdent &TypeKeyWordFullIdent::operator=(const TypeKeyWordFullIdent & other)
{
  TypeKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void TypeKeyWordFullIdent::swap(TypeKeyWordFullIdent & other)
{

}

TypeKeyWordFullIdent::~TypeKeyWordFullIdent()
{

}

void TypeKeyWordFullIdent::accept(Visitor *v)
{
  v->visitTypeKeyWordFullIdent(this);
}

TypeKeyWordFullIdent *TypeKeyWordFullIdent::clone() const
{
  return new TypeKeyWordFullIdent(*this);
}



/********************   VariantKeyWordFullIdent    ********************/
VariantKeyWordFullIdent::VariantKeyWordFullIdent()
{

}

VariantKeyWordFullIdent::VariantKeyWordFullIdent(const VariantKeyWordFullIdent & other)
{

}

VariantKeyWordFullIdent &VariantKeyWordFullIdent::operator=(const VariantKeyWordFullIdent & other)
{
  VariantKeyWordFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void VariantKeyWordFullIdent::swap(VariantKeyWordFullIdent & other)
{

}

VariantKeyWordFullIdent::~VariantKeyWordFullIdent()
{

}

void VariantKeyWordFullIdent::accept(Visitor *v)
{
  v->visitVariantKeyWordFullIdent(this);
}

VariantKeyWordFullIdent *VariantKeyWordFullIdent::clone() const
{
  return new VariantKeyWordFullIdent(*this);
}



/********************   IdentExtCodeAnnotFullIdent    ********************/
IdentExtCodeAnnotFullIdent::IdentExtCodeAnnotFullIdent(EXT_CODE_ANNOT p1)
{
  ext_code_annot_ = p1;

}

IdentExtCodeAnnotFullIdent::IdentExtCodeAnnotFullIdent(const IdentExtCodeAnnotFullIdent & other)
{
  ext_code_annot_ = other.ext_code_annot_;

}

IdentExtCodeAnnotFullIdent &IdentExtCodeAnnotFullIdent::operator=(const IdentExtCodeAnnotFullIdent & other)
{
  IdentExtCodeAnnotFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentExtCodeAnnotFullIdent::swap(IdentExtCodeAnnotFullIdent & other)
{
  std::swap(ext_code_annot_, other.ext_code_annot_);

}

IdentExtCodeAnnotFullIdent::~IdentExtCodeAnnotFullIdent()
{

}

void IdentExtCodeAnnotFullIdent::accept(Visitor *v)
{
  v->visitIdentExtCodeAnnotFullIdent(this);
}

IdentExtCodeAnnotFullIdent *IdentExtCodeAnnotFullIdent::clone() const
{
  return new IdentExtCodeAnnotFullIdent(*this);
}



/********************   IdentExtContractFullIdent    ********************/
IdentExtContractFullIdent::IdentExtContractFullIdent(EXT_CONTRACT p1)
{
  ext_contract_ = p1;

}

IdentExtContractFullIdent::IdentExtContractFullIdent(const IdentExtContractFullIdent & other)
{
  ext_contract_ = other.ext_contract_;

}

IdentExtContractFullIdent &IdentExtContractFullIdent::operator=(const IdentExtContractFullIdent & other)
{
  IdentExtContractFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentExtContractFullIdent::swap(IdentExtContractFullIdent & other)
{
  std::swap(ext_contract_, other.ext_contract_);

}

IdentExtContractFullIdent::~IdentExtContractFullIdent()
{

}

void IdentExtContractFullIdent::accept(Visitor *v)
{
  v->visitIdentExtContractFullIdent(this);
}

IdentExtContractFullIdent *IdentExtContractFullIdent::clone() const
{
  return new IdentExtContractFullIdent(*this);
}



/********************   IdentExtGlobalFullIdent    ********************/
IdentExtGlobalFullIdent::IdentExtGlobalFullIdent(EXT_GLOBAL p1)
{
  ext_global_ = p1;

}

IdentExtGlobalFullIdent::IdentExtGlobalFullIdent(const IdentExtGlobalFullIdent & other)
{
  ext_global_ = other.ext_global_;

}

IdentExtGlobalFullIdent &IdentExtGlobalFullIdent::operator=(const IdentExtGlobalFullIdent & other)
{
  IdentExtGlobalFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentExtGlobalFullIdent::swap(IdentExtGlobalFullIdent & other)
{
  std::swap(ext_global_, other.ext_global_);

}

IdentExtGlobalFullIdent::~IdentExtGlobalFullIdent()
{

}

void IdentExtGlobalFullIdent::accept(Visitor *v)
{
  v->visitIdentExtGlobalFullIdent(this);
}

IdentExtGlobalFullIdent *IdentExtGlobalFullIdent::clone() const
{
  return new IdentExtGlobalFullIdent(*this);
}



/********************   IdentExtGlobalBlockFullIdent    ********************/
IdentExtGlobalBlockFullIdent::IdentExtGlobalBlockFullIdent(EXT_GLOBAL_BLOCK p1)
{
  ext_global_block_ = p1;

}

IdentExtGlobalBlockFullIdent::IdentExtGlobalBlockFullIdent(const IdentExtGlobalBlockFullIdent & other)
{
  ext_global_block_ = other.ext_global_block_;

}

IdentExtGlobalBlockFullIdent &IdentExtGlobalBlockFullIdent::operator=(const IdentExtGlobalBlockFullIdent & other)
{
  IdentExtGlobalBlockFullIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentExtGlobalBlockFullIdent::swap(IdentExtGlobalBlockFullIdent & other)
{
  std::swap(ext_global_block_, other.ext_global_block_);

}

IdentExtGlobalBlockFullIdent::~IdentExtGlobalBlockFullIdent()
{

}

void IdentExtGlobalBlockFullIdent::accept(Visitor *v)
{
  v->visitIdentExtGlobalBlockFullIdent(this);
}

IdentExtGlobalBlockFullIdent *IdentExtGlobalBlockFullIdent::clone() const
{
  return new IdentExtGlobalBlockFullIdent(*this);
}



/********************   ExrSpec    ********************/
ExrSpec::ExrSpec(ExtGlobalClausesOpt *p1, ExtModuleSpecsOpt *p2, ExtGlobalSpecsOpt *p3)
{
  extglobalclausesopt_ = p1;
  extmodulespecsopt_ = p2;
  extglobalspecsopt_ = p3;

}

ExrSpec::ExrSpec(const ExrSpec & other)
{
  extglobalclausesopt_ = other.extglobalclausesopt_->clone();
  extmodulespecsopt_ = other.extmodulespecsopt_->clone();
  extglobalspecsopt_ = other.extglobalspecsopt_->clone();

}

ExrSpec &ExrSpec::operator=(const ExrSpec & other)
{
  ExrSpec tmp(other);
  swap(tmp);
  return *this;
}

void ExrSpec::swap(ExrSpec & other)
{
  std::swap(extglobalclausesopt_, other.extglobalclausesopt_);
  std::swap(extmodulespecsopt_, other.extmodulespecsopt_);
  std::swap(extglobalspecsopt_, other.extglobalspecsopt_);

}

ExrSpec::~ExrSpec()
{
  delete(extglobalclausesopt_);
  delete(extmodulespecsopt_);
  delete(extglobalspecsopt_);

}

void ExrSpec::accept(Visitor *v)
{
  v->visitExrSpec(this);
}

ExrSpec *ExrSpec::clone() const
{
  return new ExrSpec(*this);
}



/********************   EmptyExtGlobalClauses    ********************/
EmptyExtGlobalClauses::EmptyExtGlobalClauses()
{

}

EmptyExtGlobalClauses::EmptyExtGlobalClauses(const EmptyExtGlobalClauses & other)
{

}

EmptyExtGlobalClauses &EmptyExtGlobalClauses::operator=(const EmptyExtGlobalClauses & other)
{
  EmptyExtGlobalClauses tmp(other);
  swap(tmp);
  return *this;
}

void EmptyExtGlobalClauses::swap(EmptyExtGlobalClauses & other)
{

}

EmptyExtGlobalClauses::~EmptyExtGlobalClauses()
{

}

void EmptyExtGlobalClauses::accept(Visitor *v)
{
  v->visitEmptyExtGlobalClauses(this);
}

EmptyExtGlobalClauses *EmptyExtGlobalClauses::clone() const
{
  return new EmptyExtGlobalClauses(*this);
}



/********************   SomeExtGlobalClauses    ********************/
SomeExtGlobalClauses::SomeExtGlobalClauses(ListExtGlobalClause *p1)
{
  listextglobalclause_ = p1;

}

SomeExtGlobalClauses::SomeExtGlobalClauses(const SomeExtGlobalClauses & other)
{
  listextglobalclause_ = other.listextglobalclause_->clone();

}

SomeExtGlobalClauses &SomeExtGlobalClauses::operator=(const SomeExtGlobalClauses & other)
{
  SomeExtGlobalClauses tmp(other);
  swap(tmp);
  return *this;
}

void SomeExtGlobalClauses::swap(SomeExtGlobalClauses & other)
{
  std::swap(listextglobalclause_, other.listextglobalclause_);

}

SomeExtGlobalClauses::~SomeExtGlobalClauses()
{
  delete(listextglobalclause_);

}

void SomeExtGlobalClauses::accept(Visitor *v)
{
  v->visitSomeExtGlobalClauses(this);
}

SomeExtGlobalClauses *SomeExtGlobalClauses::clone() const
{
  return new SomeExtGlobalClauses(*this);
}



/********************   DeclClause    ********************/
DeclClause::DeclClause(Decl *p1)
{
  decl_ = p1;

}

DeclClause::DeclClause(const DeclClause & other)
{
  decl_ = other.decl_->clone();

}

DeclClause &DeclClause::operator=(const DeclClause & other)
{
  DeclClause tmp(other);
  swap(tmp);
  return *this;
}

void DeclClause::swap(DeclClause & other)
{
  std::swap(decl_, other.decl_);

}

DeclClause::~DeclClause()
{
  delete(decl_);

}

void DeclClause::accept(Visitor *v)
{
  v->visitDeclClause(this);
}

DeclClause *DeclClause::clone() const
{
  return new DeclClause(*this);
}



/********************   LetClause    ********************/
LetClause::LetClause(AnyIdentifier *p1, Lexpr *p2)
{
  anyidentifier_ = p1;
  lexpr_ = p2;

}

LetClause::LetClause(const LetClause & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  lexpr_ = other.lexpr_->clone();

}

LetClause &LetClause::operator=(const LetClause & other)
{
  LetClause tmp(other);
  swap(tmp);
  return *this;
}

void LetClause::swap(LetClause & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(lexpr_, other.lexpr_);

}

LetClause::~LetClause()
{
  delete(anyidentifier_);
  delete(lexpr_);

}

void LetClause::accept(Visitor *v)
{
  v->visitLetClause(this);
}

LetClause *LetClause::clone() const
{
  return new LetClause(*this);
}



/********************   GlobalLetClause    ********************/
GlobalLetClause::GlobalLetClause(AnyIdentifier *p1, Lexpr *p2)
{
  anyidentifier_ = p1;
  lexpr_ = p2;

}

GlobalLetClause::GlobalLetClause(const GlobalLetClause & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  lexpr_ = other.lexpr_->clone();

}

GlobalLetClause &GlobalLetClause::operator=(const GlobalLetClause & other)
{
  GlobalLetClause tmp(other);
  swap(tmp);
  return *this;
}

void GlobalLetClause::swap(GlobalLetClause & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(lexpr_, other.lexpr_);

}

GlobalLetClause::~GlobalLetClause()
{
  delete(anyidentifier_);
  delete(lexpr_);

}

void GlobalLetClause::accept(Visitor *v)
{
  v->visitGlobalLetClause(this);
}

GlobalLetClause *GlobalLetClause::clone() const
{
  return new GlobalLetClause(*this);
}



/********************   IncludeClause    ********************/
IncludeClause::IncludeClause(ListSTRING_LITERAL *p1)
{
  liststring_literal_ = p1;

}

IncludeClause::IncludeClause(const IncludeClause & other)
{
  liststring_literal_ = other.liststring_literal_->clone();

}

IncludeClause &IncludeClause::operator=(const IncludeClause & other)
{
  IncludeClause tmp(other);
  swap(tmp);
  return *this;
}

void IncludeClause::swap(IncludeClause & other)
{
  std::swap(liststring_literal_, other.liststring_literal_);

}

IncludeClause::~IncludeClause()
{
  delete(liststring_literal_);

}

void IncludeClause::accept(Visitor *v)
{
  v->visitIncludeClause(this);
}

IncludeClause *IncludeClause::clone() const
{
  return new IncludeClause(*this);
}



/********************   EmptyExtGlobalSpecs    ********************/
EmptyExtGlobalSpecs::EmptyExtGlobalSpecs()
{

}

EmptyExtGlobalSpecs::EmptyExtGlobalSpecs(const EmptyExtGlobalSpecs & other)
{

}

EmptyExtGlobalSpecs &EmptyExtGlobalSpecs::operator=(const EmptyExtGlobalSpecs & other)
{
  EmptyExtGlobalSpecs tmp(other);
  swap(tmp);
  return *this;
}

void EmptyExtGlobalSpecs::swap(EmptyExtGlobalSpecs & other)
{

}

EmptyExtGlobalSpecs::~EmptyExtGlobalSpecs()
{

}

void EmptyExtGlobalSpecs::accept(Visitor *v)
{
  v->visitEmptyExtGlobalSpecs(this);
}

EmptyExtGlobalSpecs *EmptyExtGlobalSpecs::clone() const
{
  return new EmptyExtGlobalSpecs(*this);
}



/********************   SomeExtGlobalSpecs    ********************/
SomeExtGlobalSpecs::SomeExtGlobalSpecs(ListExtGlobalSpec *p1)
{
  listextglobalspec_ = p1;

}

SomeExtGlobalSpecs::SomeExtGlobalSpecs(const SomeExtGlobalSpecs & other)
{
  listextglobalspec_ = other.listextglobalspec_->clone();

}

SomeExtGlobalSpecs &SomeExtGlobalSpecs::operator=(const SomeExtGlobalSpecs & other)
{
  SomeExtGlobalSpecs tmp(other);
  swap(tmp);
  return *this;
}

void SomeExtGlobalSpecs::swap(SomeExtGlobalSpecs & other)
{
  std::swap(listextglobalspec_, other.listextglobalspec_);

}

SomeExtGlobalSpecs::~SomeExtGlobalSpecs()
{
  delete(listextglobalspec_);

}

void SomeExtGlobalSpecs::accept(Visitor *v)
{
  v->visitSomeExtGlobalSpecs(this);
}

SomeExtGlobalSpecs *SomeExtGlobalSpecs::clone() const
{
  return new SomeExtGlobalSpecs(*this);
}



/********************   ExtGlobalSpecClauseModule    ********************/
ExtGlobalSpecClauseModule::ExtGlobalSpecClauseModule(AnyIdentifier *p1, ListExtGlobalClause *p2, ListExtModuleSpec *p3)
{
  anyidentifier_ = p1;
  listextglobalclause_ = p2;
  listextmodulespec_ = p3;

}

ExtGlobalSpecClauseModule::ExtGlobalSpecClauseModule(const ExtGlobalSpecClauseModule & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  listextglobalclause_ = other.listextglobalclause_->clone();
  listextmodulespec_ = other.listextmodulespec_->clone();

}

ExtGlobalSpecClauseModule &ExtGlobalSpecClauseModule::operator=(const ExtGlobalSpecClauseModule & other)
{
  ExtGlobalSpecClauseModule tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalSpecClauseModule::swap(ExtGlobalSpecClauseModule & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(listextglobalclause_, other.listextglobalclause_);
  std::swap(listextmodulespec_, other.listextmodulespec_);

}

ExtGlobalSpecClauseModule::~ExtGlobalSpecClauseModule()
{
  delete(anyidentifier_);
  delete(listextglobalclause_);
  delete(listextmodulespec_);

}

void ExtGlobalSpecClauseModule::accept(Visitor *v)
{
  v->visitExtGlobalSpecClauseModule(this);
}

ExtGlobalSpecClauseModule *ExtGlobalSpecClauseModule::clone() const
{
  return new ExtGlobalSpecClauseModule(*this);
}



/********************   ExtGlobalSpecModule    ********************/
ExtGlobalSpecModule::ExtGlobalSpecModule(AnyIdentifier *p1, ListExtModuleSpec *p2)
{
  anyidentifier_ = p1;
  listextmodulespec_ = p2;

}

ExtGlobalSpecModule::ExtGlobalSpecModule(const ExtGlobalSpecModule & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  listextmodulespec_ = other.listextmodulespec_->clone();

}

ExtGlobalSpecModule &ExtGlobalSpecModule::operator=(const ExtGlobalSpecModule & other)
{
  ExtGlobalSpecModule tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalSpecModule::swap(ExtGlobalSpecModule & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(listextmodulespec_, other.listextmodulespec_);

}

ExtGlobalSpecModule::~ExtGlobalSpecModule()
{
  delete(anyidentifier_);
  delete(listextmodulespec_);

}

void ExtGlobalSpecModule::accept(Visitor *v)
{
  v->visitExtGlobalSpecModule(this);
}

ExtGlobalSpecModule *ExtGlobalSpecModule::clone() const
{
  return new ExtGlobalSpecModule(*this);
}



/********************   ExtGlobalSpecClause    ********************/
ExtGlobalSpecClause::ExtGlobalSpecClause(AnyIdentifier *p1, ListExtGlobalClause *p2)
{
  anyidentifier_ = p1;
  listextglobalclause_ = p2;

}

ExtGlobalSpecClause::ExtGlobalSpecClause(const ExtGlobalSpecClause & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  listextglobalclause_ = other.listextglobalclause_->clone();

}

ExtGlobalSpecClause &ExtGlobalSpecClause::operator=(const ExtGlobalSpecClause & other)
{
  ExtGlobalSpecClause tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalSpecClause::swap(ExtGlobalSpecClause & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(listextglobalclause_, other.listextglobalclause_);

}

ExtGlobalSpecClause::~ExtGlobalSpecClause()
{
  delete(anyidentifier_);
  delete(listextglobalclause_);

}

void ExtGlobalSpecClause::accept(Visitor *v)
{
  v->visitExtGlobalSpecClause(this);
}

ExtGlobalSpecClause *ExtGlobalSpecClause::clone() const
{
  return new ExtGlobalSpecClause(*this);
}



/********************   ExtGlobalSpecSimple    ********************/
ExtGlobalSpecSimple::ExtGlobalSpecSimple(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

ExtGlobalSpecSimple::ExtGlobalSpecSimple(const ExtGlobalSpecSimple & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

ExtGlobalSpecSimple &ExtGlobalSpecSimple::operator=(const ExtGlobalSpecSimple & other)
{
  ExtGlobalSpecSimple tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalSpecSimple::swap(ExtGlobalSpecSimple & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

ExtGlobalSpecSimple::~ExtGlobalSpecSimple()
{
  delete(anyidentifier_);

}

void ExtGlobalSpecSimple::accept(Visitor *v)
{
  v->visitExtGlobalSpecSimple(this);
}

ExtGlobalSpecSimple *ExtGlobalSpecSimple::clone() const
{
  return new ExtGlobalSpecSimple(*this);
}



/********************   EmptyExtModuleSpecs    ********************/
EmptyExtModuleSpecs::EmptyExtModuleSpecs()
{

}

EmptyExtModuleSpecs::EmptyExtModuleSpecs(const EmptyExtModuleSpecs & other)
{

}

EmptyExtModuleSpecs &EmptyExtModuleSpecs::operator=(const EmptyExtModuleSpecs & other)
{
  EmptyExtModuleSpecs tmp(other);
  swap(tmp);
  return *this;
}

void EmptyExtModuleSpecs::swap(EmptyExtModuleSpecs & other)
{

}

EmptyExtModuleSpecs::~EmptyExtModuleSpecs()
{

}

void EmptyExtModuleSpecs::accept(Visitor *v)
{
  v->visitEmptyExtModuleSpecs(this);
}

EmptyExtModuleSpecs *EmptyExtModuleSpecs::clone() const
{
  return new EmptyExtModuleSpecs(*this);
}



/********************   ListExtModuleSpecs    ********************/
ListExtModuleSpecs::ListExtModuleSpecs(ListExtModuleSpec *p1)
{
  listextmodulespec_ = p1;

}

ListExtModuleSpecs::ListExtModuleSpecs(const ListExtModuleSpecs & other)
{
  listextmodulespec_ = other.listextmodulespec_->clone();

}

ListExtModuleSpecs &ListExtModuleSpecs::operator=(const ListExtModuleSpecs & other)
{
  ListExtModuleSpecs tmp(other);
  swap(tmp);
  return *this;
}

void ListExtModuleSpecs::swap(ListExtModuleSpecs & other)
{
  std::swap(listextmodulespec_, other.listextmodulespec_);

}

ListExtModuleSpecs::~ListExtModuleSpecs()
{
  delete(listextmodulespec_);

}

void ListExtModuleSpecs::accept(Visitor *v)
{
  v->visitListExtModuleSpecs(this);
}

ListExtModuleSpecs *ListExtModuleSpecs::clone() const
{
  return new ListExtModuleSpecs(*this);
}



/********************   FunSpecExtModuleSpecs    ********************/
FunSpecExtModuleSpecs::FunSpecExtModuleSpecs(ListExtFunSpec *p1)
{
  listextfunspec_ = p1;

}

FunSpecExtModuleSpecs::FunSpecExtModuleSpecs(const FunSpecExtModuleSpecs & other)
{
  listextfunspec_ = other.listextfunspec_->clone();

}

FunSpecExtModuleSpecs &FunSpecExtModuleSpecs::operator=(const FunSpecExtModuleSpecs & other)
{
  FunSpecExtModuleSpecs tmp(other);
  swap(tmp);
  return *this;
}

void FunSpecExtModuleSpecs::swap(FunSpecExtModuleSpecs & other)
{
  std::swap(listextfunspec_, other.listextfunspec_);

}

FunSpecExtModuleSpecs::~FunSpecExtModuleSpecs()
{
  delete(listextfunspec_);

}

void FunSpecExtModuleSpecs::accept(Visitor *v)
{
  v->visitFunSpecExtModuleSpecs(this);
}

FunSpecExtModuleSpecs *FunSpecExtModuleSpecs::clone() const
{
  return new FunSpecExtModuleSpecs(*this);
}



/********************   FunSpecWithListModules    ********************/
FunSpecWithListModules::FunSpecWithListModules(ListExtFunSpec *p1, ListExtModuleSpec *p2)
{
  listextfunspec_ = p1;
  listextmodulespec_ = p2;

}

FunSpecWithListModules::FunSpecWithListModules(const FunSpecWithListModules & other)
{
  listextfunspec_ = other.listextfunspec_->clone();
  listextmodulespec_ = other.listextmodulespec_->clone();

}

FunSpecWithListModules &FunSpecWithListModules::operator=(const FunSpecWithListModules & other)
{
  FunSpecWithListModules tmp(other);
  swap(tmp);
  return *this;
}

void FunSpecWithListModules::swap(FunSpecWithListModules & other)
{
  std::swap(listextfunspec_, other.listextfunspec_);
  std::swap(listextmodulespec_, other.listextmodulespec_);

}

FunSpecWithListModules::~FunSpecWithListModules()
{
  delete(listextfunspec_);
  delete(listextmodulespec_);

}

void FunSpecWithListModules::accept(Visitor *v)
{
  v->visitFunSpecWithListModules(this);
}

FunSpecWithListModules *FunSpecWithListModules::clone() const
{
  return new FunSpecWithListModules(*this);
}



/********************   AnExtModuleSpec    ********************/
AnExtModuleSpec::AnExtModuleSpec(AnyIdentifier *p1, ExtFunctionSpecsOpt *p2)
{
  anyidentifier_ = p1;
  extfunctionspecsopt_ = p2;

}

AnExtModuleSpec::AnExtModuleSpec(const AnExtModuleSpec & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  extfunctionspecsopt_ = other.extfunctionspecsopt_->clone();

}

AnExtModuleSpec &AnExtModuleSpec::operator=(const AnExtModuleSpec & other)
{
  AnExtModuleSpec tmp(other);
  swap(tmp);
  return *this;
}

void AnExtModuleSpec::swap(AnExtModuleSpec & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(extfunctionspecsopt_, other.extfunctionspecsopt_);

}

AnExtModuleSpec::~AnExtModuleSpec()
{
  delete(anyidentifier_);
  delete(extfunctionspecsopt_);

}

void AnExtModuleSpec::accept(Visitor *v)
{
  v->visitAnExtModuleSpec(this);
}

AnExtModuleSpec *AnExtModuleSpec::clone() const
{
  return new AnExtModuleSpec(*this);
}



/********************   NoExtFunctionSpecs    ********************/
NoExtFunctionSpecs::NoExtFunctionSpecs()
{

}

NoExtFunctionSpecs::NoExtFunctionSpecs(const NoExtFunctionSpecs & other)
{

}

NoExtFunctionSpecs &NoExtFunctionSpecs::operator=(const NoExtFunctionSpecs & other)
{
  NoExtFunctionSpecs tmp(other);
  swap(tmp);
  return *this;
}

void NoExtFunctionSpecs::swap(NoExtFunctionSpecs & other)
{

}

NoExtFunctionSpecs::~NoExtFunctionSpecs()
{

}

void NoExtFunctionSpecs::accept(Visitor *v)
{
  v->visitNoExtFunctionSpecs(this);
}

NoExtFunctionSpecs *NoExtFunctionSpecs::clone() const
{
  return new NoExtFunctionSpecs(*this);
}



/********************   SomeExtFunctionSpecs    ********************/
SomeExtFunctionSpecs::SomeExtFunctionSpecs(ExtFunctionSpecs *p1)
{
  extfunctionspecs_ = p1;

}

SomeExtFunctionSpecs::SomeExtFunctionSpecs(const SomeExtFunctionSpecs & other)
{
  extfunctionspecs_ = other.extfunctionspecs_->clone();

}

SomeExtFunctionSpecs &SomeExtFunctionSpecs::operator=(const SomeExtFunctionSpecs & other)
{
  SomeExtFunctionSpecs tmp(other);
  swap(tmp);
  return *this;
}

void SomeExtFunctionSpecs::swap(SomeExtFunctionSpecs & other)
{
  std::swap(extfunctionspecs_, other.extfunctionspecs_);

}

SomeExtFunctionSpecs::~SomeExtFunctionSpecs()
{
  delete(extfunctionspecs_);

}

void SomeExtFunctionSpecs::accept(Visitor *v)
{
  v->visitSomeExtFunctionSpecs(this);
}

SomeExtFunctionSpecs *SomeExtFunctionSpecs::clone() const
{
  return new SomeExtFunctionSpecs(*this);
}



/********************   AtMarkup    ********************/
AtMarkup::AtMarkup(ListStmtMarkup *p1)
{
  liststmtmarkup_ = p1;

}

AtMarkup::AtMarkup(const AtMarkup & other)
{
  liststmtmarkup_ = other.liststmtmarkup_->clone();

}

AtMarkup &AtMarkup::operator=(const AtMarkup & other)
{
  AtMarkup tmp(other);
  swap(tmp);
  return *this;
}

void AtMarkup::swap(AtMarkup & other)
{
  std::swap(liststmtmarkup_, other.liststmtmarkup_);

}

AtMarkup::~AtMarkup()
{
  delete(liststmtmarkup_);

}

void AtMarkup::accept(Visitor *v)
{
  v->visitAtMarkup(this);
}

AtMarkup *AtMarkup::clone() const
{
  return new AtMarkup(*this);
}



/********************   ListFunctionSpecs    ********************/
ListFunctionSpecs::ListFunctionSpecs(ListExtFunctionSpec *p1)
{
  listextfunctionspec_ = p1;

}

ListFunctionSpecs::ListFunctionSpecs(const ListFunctionSpecs & other)
{
  listextfunctionspec_ = other.listextfunctionspec_->clone();

}

ListFunctionSpecs &ListFunctionSpecs::operator=(const ListFunctionSpecs & other)
{
  ListFunctionSpecs tmp(other);
  swap(tmp);
  return *this;
}

void ListFunctionSpecs::swap(ListFunctionSpecs & other)
{
  std::swap(listextfunctionspec_, other.listextfunctionspec_);

}

ListFunctionSpecs::~ListFunctionSpecs()
{
  delete(listextfunctionspec_);

}

void ListFunctionSpecs::accept(Visitor *v)
{
  v->visitListFunctionSpecs(this);
}

ListFunctionSpecs *ListFunctionSpecs::clone() const
{
  return new ListFunctionSpecs(*this);
}



/********************   ListFunctionSpecsAtMarkup    ********************/
ListFunctionSpecsAtMarkup::ListFunctionSpecsAtMarkup(ListExtFunctionSpec *p1, ListStmtMarkup *p2)
{
  listextfunctionspec_ = p1;
  liststmtmarkup_ = p2;

}

ListFunctionSpecsAtMarkup::ListFunctionSpecsAtMarkup(const ListFunctionSpecsAtMarkup & other)
{
  listextfunctionspec_ = other.listextfunctionspec_->clone();
  liststmtmarkup_ = other.liststmtmarkup_->clone();

}

ListFunctionSpecsAtMarkup &ListFunctionSpecsAtMarkup::operator=(const ListFunctionSpecsAtMarkup & other)
{
  ListFunctionSpecsAtMarkup tmp(other);
  swap(tmp);
  return *this;
}

void ListFunctionSpecsAtMarkup::swap(ListFunctionSpecsAtMarkup & other)
{
  std::swap(listextfunctionspec_, other.listextfunctionspec_);
  std::swap(liststmtmarkup_, other.liststmtmarkup_);

}

ListFunctionSpecsAtMarkup::~ListFunctionSpecsAtMarkup()
{
  delete(listextfunctionspec_);
  delete(liststmtmarkup_);

}

void ListFunctionSpecsAtMarkup::accept(Visitor *v)
{
  v->visitListFunctionSpecsAtMarkup(this);
}

ListFunctionSpecsAtMarkup *ListFunctionSpecsAtMarkup::clone() const
{
  return new ListFunctionSpecsAtMarkup(*this);
}



/********************   AnExtGlobalClause    ********************/
AnExtGlobalClause::AnExtGlobalClause(ExtGlobalClause *p1)
{
  extglobalclause_ = p1;

}

AnExtGlobalClause::AnExtGlobalClause(const AnExtGlobalClause & other)
{
  extglobalclause_ = other.extglobalclause_->clone();

}

AnExtGlobalClause &AnExtGlobalClause::operator=(const AnExtGlobalClause & other)
{
  AnExtGlobalClause tmp(other);
  swap(tmp);
  return *this;
}

void AnExtGlobalClause::swap(AnExtGlobalClause & other)
{
  std::swap(extglobalclause_, other.extglobalclause_);

}

AnExtGlobalClause::~AnExtGlobalClause()
{
  delete(extglobalclause_);

}

void AnExtGlobalClause::accept(Visitor *v)
{
  v->visitAnExtGlobalClause(this);
}

AnExtGlobalClause *AnExtGlobalClause::clone() const
{
  return new AnExtGlobalClause(*this);
}



/********************   AnExtFunSpec    ********************/
AnExtFunSpec::AnExtFunSpec(ExtFunSpec *p1)
{
  extfunspec_ = p1;

}

AnExtFunSpec::AnExtFunSpec(const AnExtFunSpec & other)
{
  extfunspec_ = other.extfunspec_->clone();

}

AnExtFunSpec &AnExtFunSpec::operator=(const AnExtFunSpec & other)
{
  AnExtFunSpec tmp(other);
  swap(tmp);
  return *this;
}

void AnExtFunSpec::swap(AnExtFunSpec & other)
{
  std::swap(extfunspec_, other.extfunspec_);

}

AnExtFunSpec::~AnExtFunSpec()
{
  delete(extfunspec_);

}

void AnExtFunSpec::accept(Visitor *v)
{
  v->visitAnExtFunSpec(this);
}

AnExtFunSpec *AnExtFunSpec::clone() const
{
  return new AnExtFunSpec(*this);
}



/********************   FunSpecAtAnnotation    ********************/
FunSpecAtAnnotation::FunSpecAtAnnotation(ListStmtMarkup *p1, Annotation *p2)
{
  liststmtmarkup_ = p1;
  annotation_ = p2;

}

FunSpecAtAnnotation::FunSpecAtAnnotation(const FunSpecAtAnnotation & other)
{
  liststmtmarkup_ = other.liststmtmarkup_->clone();
  annotation_ = other.annotation_->clone();

}

FunSpecAtAnnotation &FunSpecAtAnnotation::operator=(const FunSpecAtAnnotation & other)
{
  FunSpecAtAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void FunSpecAtAnnotation::swap(FunSpecAtAnnotation & other)
{
  std::swap(liststmtmarkup_, other.liststmtmarkup_);
  std::swap(annotation_, other.annotation_);

}

FunSpecAtAnnotation::~FunSpecAtAnnotation()
{
  delete(liststmtmarkup_);
  delete(annotation_);

}

void FunSpecAtAnnotation::accept(Visitor *v)
{
  v->visitFunSpecAtAnnotation(this);
}

FunSpecAtAnnotation *FunSpecAtAnnotation::clone() const
{
  return new FunSpecAtAnnotation(*this);
}



/********************   FunSpecAtContract    ********************/
FunSpecAtContract::FunSpecAtContract(ListStmtMarkup *p1, ExtIdentifierOpt *p2, Contract *p3)
{
  liststmtmarkup_ = p1;
  extidentifieropt_ = p2;
  contract_ = p3;

}

FunSpecAtContract::FunSpecAtContract(const FunSpecAtContract & other)
{
  liststmtmarkup_ = other.liststmtmarkup_->clone();
  extidentifieropt_ = other.extidentifieropt_->clone();
  contract_ = other.contract_->clone();

}

FunSpecAtContract &FunSpecAtContract::operator=(const FunSpecAtContract & other)
{
  FunSpecAtContract tmp(other);
  swap(tmp);
  return *this;
}

void FunSpecAtContract::swap(FunSpecAtContract & other)
{
  std::swap(liststmtmarkup_, other.liststmtmarkup_);
  std::swap(extidentifieropt_, other.extidentifieropt_);
  std::swap(contract_, other.contract_);

}

FunSpecAtContract::~FunSpecAtContract()
{
  delete(liststmtmarkup_);
  delete(extidentifieropt_);
  delete(contract_);

}

void FunSpecAtContract::accept(Visitor *v)
{
  v->visitFunSpecAtContract(this);
}

FunSpecAtContract *FunSpecAtContract::clone() const
{
  return new FunSpecAtContract(*this);
}



/********************   FunSpecContract    ********************/
FunSpecContract::FunSpecContract(ExtIdentifierOpt *p1, Contract *p2)
{
  extidentifieropt_ = p1;
  contract_ = p2;

}

FunSpecContract::FunSpecContract(const FunSpecContract & other)
{
  extidentifieropt_ = other.extidentifieropt_->clone();
  contract_ = other.contract_->clone();

}

FunSpecContract &FunSpecContract::operator=(const FunSpecContract & other)
{
  FunSpecContract tmp(other);
  swap(tmp);
  return *this;
}

void FunSpecContract::swap(FunSpecContract & other)
{
  std::swap(extidentifieropt_, other.extidentifieropt_);
  std::swap(contract_, other.contract_);

}

FunSpecContract::~FunSpecContract()
{
  delete(extidentifieropt_);
  delete(contract_);

}

void FunSpecContract::accept(Visitor *v)
{
  v->visitFunSpecContract(this);
}

FunSpecContract *FunSpecContract::clone() const
{
  return new FunSpecContract(*this);
}



/********************   ExtIdentifierEmpty    ********************/
ExtIdentifierEmpty::ExtIdentifierEmpty()
{

}

ExtIdentifierEmpty::ExtIdentifierEmpty(const ExtIdentifierEmpty & other)
{

}

ExtIdentifierEmpty &ExtIdentifierEmpty::operator=(const ExtIdentifierEmpty & other)
{
  ExtIdentifierEmpty tmp(other);
  swap(tmp);
  return *this;
}

void ExtIdentifierEmpty::swap(ExtIdentifierEmpty & other)
{

}

ExtIdentifierEmpty::~ExtIdentifierEmpty()
{

}

void ExtIdentifierEmpty::accept(Visitor *v)
{
  v->visitExtIdentifierEmpty(this);
}

ExtIdentifierEmpty *ExtIdentifierEmpty::clone() const
{
  return new ExtIdentifierEmpty(*this);
}



/********************   ExtIdentifierSome    ********************/
ExtIdentifierSome::ExtIdentifierSome(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

ExtIdentifierSome::ExtIdentifierSome(const ExtIdentifierSome & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

ExtIdentifierSome &ExtIdentifierSome::operator=(const ExtIdentifierSome & other)
{
  ExtIdentifierSome tmp(other);
  swap(tmp);
  return *this;
}

void ExtIdentifierSome::swap(ExtIdentifierSome & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

ExtIdentifierSome::~ExtIdentifierSome()
{
  delete(anyidentifier_);

}

void ExtIdentifierSome::accept(Visitor *v)
{
  v->visitExtIdentifierSome(this);
}

ExtIdentifierSome *ExtIdentifierSome::clone() const
{
  return new ExtIdentifierSome(*this);
}



/********************   MarkupStmtIdentifier    ********************/
MarkupStmtIdentifier::MarkupStmtIdentifier(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

MarkupStmtIdentifier::MarkupStmtIdentifier(const MarkupStmtIdentifier & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

MarkupStmtIdentifier &MarkupStmtIdentifier::operator=(const MarkupStmtIdentifier & other)
{
  MarkupStmtIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void MarkupStmtIdentifier::swap(MarkupStmtIdentifier & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

MarkupStmtIdentifier::~MarkupStmtIdentifier()
{
  delete(anyidentifier_);

}

void MarkupStmtIdentifier::accept(Visitor *v)
{
  v->visitMarkupStmtIdentifier(this);
}

MarkupStmtIdentifier *MarkupStmtIdentifier::clone() const
{
  return new MarkupStmtIdentifier(*this);
}



/********************   MarkupIntConstant    ********************/
MarkupIntConstant::MarkupIntConstant(Integer p1)
{
  integer_ = p1;

}

MarkupIntConstant::MarkupIntConstant(const MarkupIntConstant & other)
{
  integer_ = other.integer_;

}

MarkupIntConstant &MarkupIntConstant::operator=(const MarkupIntConstant & other)
{
  MarkupIntConstant tmp(other);
  swap(tmp);
  return *this;
}

void MarkupIntConstant::swap(MarkupIntConstant & other)
{
  std::swap(integer_, other.integer_);

}

MarkupIntConstant::~MarkupIntConstant()
{

}

void MarkupIntConstant::accept(Visitor *v)
{
  v->visitMarkupIntConstant(this);
}

MarkupIntConstant *MarkupIntConstant::clone() const
{
  return new MarkupIntConstant(*this);
}



/********************   SpecConstract    ********************/
SpecConstract::SpecConstract(Contract *p1)
{
  contract_ = p1;

}

SpecConstract::SpecConstract(const SpecConstract & other)
{
  contract_ = other.contract_->clone();

}

SpecConstract &SpecConstract::operator=(const SpecConstract & other)
{
  SpecConstract tmp(other);
  swap(tmp);
  return *this;
}

void SpecConstract::swap(SpecConstract & other)
{
  std::swap(contract_, other.contract_);

}

SpecConstract::~SpecConstract()
{
  delete(contract_);

}

void SpecConstract::accept(Visitor *v)
{
  v->visitSpecConstract(this);
}

SpecConstract *SpecConstract::clone() const
{
  return new SpecConstract(*this);
}



/********************   SimpleContract    ********************/
SimpleContract::SimpleContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, CompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  completeordisjoint_ = p6;

}

SimpleContract::SimpleContract(const SimpleContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  completeordisjoint_ = other.completeordisjoint_->clone();

}

SimpleContract &SimpleContract::operator=(const SimpleContract & other)
{
  SimpleContract tmp(other);
  swap(tmp);
  return *this;
}

void SimpleContract::swap(SimpleContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(completeordisjoint_, other.completeordisjoint_);

}

SimpleContract::~SimpleContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(completeordisjoint_);

}

void SimpleContract::accept(Visitor *v)
{
  v->visitSimpleContract(this);
}

SimpleContract *SimpleContract::clone() const
{
  return new SimpleContract(*this);
}



/********************   TerminatesRequiresContract    ********************/
TerminatesRequiresContract::TerminatesRequiresContract(Requires *p1, NETerminates *p2)
{
  requires_ = p1;
  neterminates_ = p2;

}

TerminatesRequiresContract::TerminatesRequiresContract(const TerminatesRequiresContract & other)
{
  requires_ = other.requires_->clone();
  neterminates_ = other.neterminates_->clone();

}

TerminatesRequiresContract &TerminatesRequiresContract::operator=(const TerminatesRequiresContract & other)
{
  TerminatesRequiresContract tmp(other);
  swap(tmp);
  return *this;
}

void TerminatesRequiresContract::swap(TerminatesRequiresContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(neterminates_, other.neterminates_);

}

TerminatesRequiresContract::~TerminatesRequiresContract()
{
  delete(requires_);
  delete(neterminates_);

}

void TerminatesRequiresContract::accept(Visitor *v)
{
  v->visitTerminatesRequiresContract(this);
}

TerminatesRequiresContract *TerminatesRequiresContract::clone() const
{
  return new TerminatesRequiresContract(*this);
}



/********************   DecreasesRequiresContract    ********************/
DecreasesRequiresContract::DecreasesRequiresContract(Requires *p1, Terminates *p2, NEDecreases *p3)
{
  requires_ = p1;
  terminates_ = p2;
  nedecreases_ = p3;

}

DecreasesRequiresContract::DecreasesRequiresContract(const DecreasesRequiresContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  nedecreases_ = other.nedecreases_->clone();

}

DecreasesRequiresContract &DecreasesRequiresContract::operator=(const DecreasesRequiresContract & other)
{
  DecreasesRequiresContract tmp(other);
  swap(tmp);
  return *this;
}

void DecreasesRequiresContract::swap(DecreasesRequiresContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(nedecreases_, other.nedecreases_);

}

DecreasesRequiresContract::~DecreasesRequiresContract()
{
  delete(requires_);
  delete(terminates_);
  delete(nedecreases_);

}

void DecreasesRequiresContract::accept(Visitor *v)
{
  v->visitDecreasesRequiresContract(this);
}

DecreasesRequiresContract *DecreasesRequiresContract::clone() const
{
  return new DecreasesRequiresContract(*this);
}



/********************   DecreasesTerminatesContract    ********************/
DecreasesTerminatesContract::DecreasesTerminatesContract(Requires *p1, Terminates *p2, NEDecreases *p3)
{
  requires_ = p1;
  terminates_ = p2;
  nedecreases_ = p3;

}

DecreasesTerminatesContract::DecreasesTerminatesContract(const DecreasesTerminatesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  nedecreases_ = other.nedecreases_->clone();

}

DecreasesTerminatesContract &DecreasesTerminatesContract::operator=(const DecreasesTerminatesContract & other)
{
  DecreasesTerminatesContract tmp(other);
  swap(tmp);
  return *this;
}

void DecreasesTerminatesContract::swap(DecreasesTerminatesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(nedecreases_, other.nedecreases_);

}

DecreasesTerminatesContract::~DecreasesTerminatesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(nedecreases_);

}

void DecreasesTerminatesContract::accept(Visitor *v)
{
  v->visitDecreasesTerminatesContract(this);
}

DecreasesTerminatesContract *DecreasesTerminatesContract::clone() const
{
  return new DecreasesTerminatesContract(*this);
}



/********************   ClausesRequiresContract    ********************/
ClausesRequiresContract::ClausesRequiresContract(Requires *p1, Terminates *p2, Decreases *p3, NESimpleClauses *p4)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  nesimpleclauses_ = p4;

}

ClausesRequiresContract::ClausesRequiresContract(const ClausesRequiresContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

ClausesRequiresContract &ClausesRequiresContract::operator=(const ClausesRequiresContract & other)
{
  ClausesRequiresContract tmp(other);
  swap(tmp);
  return *this;
}

void ClausesRequiresContract::swap(ClausesRequiresContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

ClausesRequiresContract::~ClausesRequiresContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(nesimpleclauses_);

}

void ClausesRequiresContract::accept(Visitor *v)
{
  v->visitClausesRequiresContract(this);
}

ClausesRequiresContract *ClausesRequiresContract::clone() const
{
  return new ClausesRequiresContract(*this);
}



/********************   ClausesTerminatesContract    ********************/
ClausesTerminatesContract::ClausesTerminatesContract(Requires *p1, Terminates *p2, Decreases *p3, NESimpleClauses *p4)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  nesimpleclauses_ = p4;

}

ClausesTerminatesContract::ClausesTerminatesContract(const ClausesTerminatesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

ClausesTerminatesContract &ClausesTerminatesContract::operator=(const ClausesTerminatesContract & other)
{
  ClausesTerminatesContract tmp(other);
  swap(tmp);
  return *this;
}

void ClausesTerminatesContract::swap(ClausesTerminatesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

ClausesTerminatesContract::~ClausesTerminatesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(nesimpleclauses_);

}

void ClausesTerminatesContract::accept(Visitor *v)
{
  v->visitClausesTerminatesContract(this);
}

ClausesTerminatesContract *ClausesTerminatesContract::clone() const
{
  return new ClausesTerminatesContract(*this);
}



/********************   ClausesDecreasesContract    ********************/
ClausesDecreasesContract::ClausesDecreasesContract(Requires *p1, Terminates *p2, Decreases *p3, NESimpleClauses *p4)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  nesimpleclauses_ = p4;

}

ClausesDecreasesContract::ClausesDecreasesContract(const ClausesDecreasesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

ClausesDecreasesContract &ClausesDecreasesContract::operator=(const ClausesDecreasesContract & other)
{
  ClausesDecreasesContract tmp(other);
  swap(tmp);
  return *this;
}

void ClausesDecreasesContract::swap(ClausesDecreasesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

ClausesDecreasesContract::~ClausesDecreasesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(nesimpleclauses_);

}

void ClausesDecreasesContract::accept(Visitor *v)
{
  v->visitClausesDecreasesContract(this);
}

ClausesDecreasesContract *ClausesDecreasesContract::clone() const
{
  return new ClausesDecreasesContract(*this);
}



/********************   BehaviorsTerminatesContract    ********************/
BehaviorsTerminatesContract::BehaviorsTerminatesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, NEBehaviors *p5)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  nebehaviors_ = p5;

}

BehaviorsTerminatesContract::BehaviorsTerminatesContract(const BehaviorsTerminatesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  nebehaviors_ = other.nebehaviors_->clone();

}

BehaviorsTerminatesContract &BehaviorsTerminatesContract::operator=(const BehaviorsTerminatesContract & other)
{
  BehaviorsTerminatesContract tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorsTerminatesContract::swap(BehaviorsTerminatesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(nebehaviors_, other.nebehaviors_);

}

BehaviorsTerminatesContract::~BehaviorsTerminatesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(nebehaviors_);

}

void BehaviorsTerminatesContract::accept(Visitor *v)
{
  v->visitBehaviorsTerminatesContract(this);
}

BehaviorsTerminatesContract *BehaviorsTerminatesContract::clone() const
{
  return new BehaviorsTerminatesContract(*this);
}



/********************   BehaviorsDecreasesContract    ********************/
BehaviorsDecreasesContract::BehaviorsDecreasesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, NEBehaviors *p5)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  nebehaviors_ = p5;

}

BehaviorsDecreasesContract::BehaviorsDecreasesContract(const BehaviorsDecreasesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  nebehaviors_ = other.nebehaviors_->clone();

}

BehaviorsDecreasesContract &BehaviorsDecreasesContract::operator=(const BehaviorsDecreasesContract & other)
{
  BehaviorsDecreasesContract tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorsDecreasesContract::swap(BehaviorsDecreasesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(nebehaviors_, other.nebehaviors_);

}

BehaviorsDecreasesContract::~BehaviorsDecreasesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(nebehaviors_);

}

void BehaviorsDecreasesContract::accept(Visitor *v)
{
  v->visitBehaviorsDecreasesContract(this);
}

BehaviorsDecreasesContract *BehaviorsDecreasesContract::clone() const
{
  return new BehaviorsDecreasesContract(*this);
}



/********************   ComplDisjRequiresContract    ********************/
ComplDisjRequiresContract::ComplDisjRequiresContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjRequiresContract::ComplDisjRequiresContract(const ComplDisjRequiresContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjRequiresContract &ComplDisjRequiresContract::operator=(const ComplDisjRequiresContract & other)
{
  ComplDisjRequiresContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjRequiresContract::swap(ComplDisjRequiresContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjRequiresContract::~ComplDisjRequiresContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjRequiresContract::accept(Visitor *v)
{
  v->visitComplDisjRequiresContract(this);
}

ComplDisjRequiresContract *ComplDisjRequiresContract::clone() const
{
  return new ComplDisjRequiresContract(*this);
}



/********************   ComplDisjTerminatesContract    ********************/
ComplDisjTerminatesContract::ComplDisjTerminatesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjTerminatesContract::ComplDisjTerminatesContract(const ComplDisjTerminatesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjTerminatesContract &ComplDisjTerminatesContract::operator=(const ComplDisjTerminatesContract & other)
{
  ComplDisjTerminatesContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjTerminatesContract::swap(ComplDisjTerminatesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjTerminatesContract::~ComplDisjTerminatesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjTerminatesContract::accept(Visitor *v)
{
  v->visitComplDisjTerminatesContract(this);
}

ComplDisjTerminatesContract *ComplDisjTerminatesContract::clone() const
{
  return new ComplDisjTerminatesContract(*this);
}



/********************   ComplDisjDecreasesContract    ********************/
ComplDisjDecreasesContract::ComplDisjDecreasesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjDecreasesContract::ComplDisjDecreasesContract(const ComplDisjDecreasesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjDecreasesContract &ComplDisjDecreasesContract::operator=(const ComplDisjDecreasesContract & other)
{
  ComplDisjDecreasesContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjDecreasesContract::swap(ComplDisjDecreasesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjDecreasesContract::~ComplDisjDecreasesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjDecreasesContract::accept(Visitor *v)
{
  v->visitComplDisjDecreasesContract(this);
}

ComplDisjDecreasesContract *ComplDisjDecreasesContract::clone() const
{
  return new ComplDisjDecreasesContract(*this);
}



/********************   ComplDisjBehaviorContract    ********************/
ComplDisjBehaviorContract::ComplDisjBehaviorContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjBehaviorContract::ComplDisjBehaviorContract(const ComplDisjBehaviorContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjBehaviorContract &ComplDisjBehaviorContract::operator=(const ComplDisjBehaviorContract & other)
{
  ComplDisjBehaviorContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjBehaviorContract::swap(ComplDisjBehaviorContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjBehaviorContract::~ComplDisjBehaviorContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjBehaviorContract::accept(Visitor *v)
{
  v->visitComplDisjBehaviorContract(this);
}

ComplDisjBehaviorContract *ComplDisjBehaviorContract::clone() const
{
  return new ComplDisjBehaviorContract(*this);
}



/********************   ComplDisjAssignsContract    ********************/
ComplDisjAssignsContract::ComplDisjAssignsContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjAssignsContract::ComplDisjAssignsContract(const ComplDisjAssignsContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjAssignsContract &ComplDisjAssignsContract::operator=(const ComplDisjAssignsContract & other)
{
  ComplDisjAssignsContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjAssignsContract::swap(ComplDisjAssignsContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjAssignsContract::~ComplDisjAssignsContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjAssignsContract::accept(Visitor *v)
{
  v->visitComplDisjAssignsContract(this);
}

ComplDisjAssignsContract *ComplDisjAssignsContract::clone() const
{
  return new ComplDisjAssignsContract(*this);
}



/********************   ComplDisjAllocatesContract    ********************/
ComplDisjAllocatesContract::ComplDisjAllocatesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjAllocatesContract::ComplDisjAllocatesContract(const ComplDisjAllocatesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjAllocatesContract &ComplDisjAllocatesContract::operator=(const ComplDisjAllocatesContract & other)
{
  ComplDisjAllocatesContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjAllocatesContract::swap(ComplDisjAllocatesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjAllocatesContract::~ComplDisjAllocatesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjAllocatesContract::accept(Visitor *v)
{
  v->visitComplDisjAllocatesContract(this);
}

ComplDisjAllocatesContract *ComplDisjAllocatesContract::clone() const
{
  return new ComplDisjAllocatesContract(*this);
}



/********************   ComplDisjFreesContract    ********************/
ComplDisjFreesContract::ComplDisjFreesContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;

}

ComplDisjFreesContract::ComplDisjFreesContract(const ComplDisjFreesContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

ComplDisjFreesContract &ComplDisjFreesContract::operator=(const ComplDisjFreesContract & other)
{
  ComplDisjFreesContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjFreesContract::swap(ComplDisjFreesContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

ComplDisjFreesContract::~ComplDisjFreesContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);

}

void ComplDisjFreesContract::accept(Visitor *v)
{
  v->visitComplDisjFreesContract(this);
}

ComplDisjFreesContract *ComplDisjFreesContract::clone() const
{
  return new ComplDisjFreesContract(*this);
}



/********************   ComplDisjPostCondContract    ********************/
ComplDisjPostCondContract::ComplDisjPostCondContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, NECompleteOrDisjoint *p6, PostCond *p7)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  necompleteordisjoint_ = p6;
  postcond_ = p7;

}

ComplDisjPostCondContract::ComplDisjPostCondContract(const ComplDisjPostCondContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();
  postcond_ = other.postcond_->clone();

}

ComplDisjPostCondContract &ComplDisjPostCondContract::operator=(const ComplDisjPostCondContract & other)
{
  ComplDisjPostCondContract tmp(other);
  swap(tmp);
  return *this;
}

void ComplDisjPostCondContract::swap(ComplDisjPostCondContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);
  std::swap(postcond_, other.postcond_);

}

ComplDisjPostCondContract::~ComplDisjPostCondContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(necompleteordisjoint_);
  delete(postcond_);

}

void ComplDisjPostCondContract::accept(Visitor *v)
{
  v->visitComplDisjPostCondContract(this);
}

ComplDisjPostCondContract *ComplDisjPostCondContract::clone() const
{
  return new ComplDisjPostCondContract(*this);
}



/********************   AdmitRequiresClause    ********************/
AdmitRequiresClause::AdmitRequiresClause()
{

}

AdmitRequiresClause::AdmitRequiresClause(const AdmitRequiresClause & other)
{

}

AdmitRequiresClause &AdmitRequiresClause::operator=(const AdmitRequiresClause & other)
{
  AdmitRequiresClause tmp(other);
  swap(tmp);
  return *this;
}

void AdmitRequiresClause::swap(AdmitRequiresClause & other)
{

}

AdmitRequiresClause::~AdmitRequiresClause()
{

}

void AdmitRequiresClause::accept(Visitor *v)
{
  v->visitAdmitRequiresClause(this);
}

AdmitRequiresClause *AdmitRequiresClause::clone() const
{
  return new AdmitRequiresClause(*this);
}



/********************   AdmitInvariantClause    ********************/
AdmitInvariantClause::AdmitInvariantClause()
{

}

AdmitInvariantClause::AdmitInvariantClause(const AdmitInvariantClause & other)
{

}

AdmitInvariantClause &AdmitInvariantClause::operator=(const AdmitInvariantClause & other)
{
  AdmitInvariantClause tmp(other);
  swap(tmp);
  return *this;
}

void AdmitInvariantClause::swap(AdmitInvariantClause & other)
{

}

AdmitInvariantClause::~AdmitInvariantClause()
{

}

void AdmitInvariantClause::accept(Visitor *v)
{
  v->visitAdmitInvariantClause(this);
}

AdmitInvariantClause *AdmitInvariantClause::clone() const
{
  return new AdmitInvariantClause(*this);
}



/********************   AdmitLemmaClause    ********************/
AdmitLemmaClause::AdmitLemmaClause()
{

}

AdmitLemmaClause::AdmitLemmaClause(const AdmitLemmaClause & other)
{

}

AdmitLemmaClause &AdmitLemmaClause::operator=(const AdmitLemmaClause & other)
{
  AdmitLemmaClause tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLemmaClause::swap(AdmitLemmaClause & other)
{

}

AdmitLemmaClause::~AdmitLemmaClause()
{

}

void AdmitLemmaClause::accept(Visitor *v)
{
  v->visitAdmitLemmaClause(this);
}

AdmitLemmaClause *AdmitLemmaClause::clone() const
{
  return new AdmitLemmaClause(*this);
}



/********************   AdmitLoopClause    ********************/
AdmitLoopClause::AdmitLoopClause()
{

}

AdmitLoopClause::AdmitLoopClause(const AdmitLoopClause & other)
{

}

AdmitLoopClause &AdmitLoopClause::operator=(const AdmitLoopClause & other)
{
  AdmitLoopClause tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLoopClause::swap(AdmitLoopClause & other)
{

}

AdmitLoopClause::~AdmitLoopClause()
{

}

void AdmitLoopClause::accept(Visitor *v)
{
  v->visitAdmitLoopClause(this);
}

AdmitLoopClause *AdmitLoopClause::clone() const
{
  return new AdmitLoopClause(*this);
}



/********************   CheckRequiresClause    ********************/
CheckRequiresClause::CheckRequiresClause()
{

}

CheckRequiresClause::CheckRequiresClause(const CheckRequiresClause & other)
{

}

CheckRequiresClause &CheckRequiresClause::operator=(const CheckRequiresClause & other)
{
  CheckRequiresClause tmp(other);
  swap(tmp);
  return *this;
}

void CheckRequiresClause::swap(CheckRequiresClause & other)
{

}

CheckRequiresClause::~CheckRequiresClause()
{

}

void CheckRequiresClause::accept(Visitor *v)
{
  v->visitCheckRequiresClause(this);
}

CheckRequiresClause *CheckRequiresClause::clone() const
{
  return new CheckRequiresClause(*this);
}



/********************   CheckInvariantClause    ********************/
CheckInvariantClause::CheckInvariantClause()
{

}

CheckInvariantClause::CheckInvariantClause(const CheckInvariantClause & other)
{

}

CheckInvariantClause &CheckInvariantClause::operator=(const CheckInvariantClause & other)
{
  CheckInvariantClause tmp(other);
  swap(tmp);
  return *this;
}

void CheckInvariantClause::swap(CheckInvariantClause & other)
{

}

CheckInvariantClause::~CheckInvariantClause()
{

}

void CheckInvariantClause::accept(Visitor *v)
{
  v->visitCheckInvariantClause(this);
}

CheckInvariantClause *CheckInvariantClause::clone() const
{
  return new CheckInvariantClause(*this);
}



/********************   CheckLemmaClause    ********************/
CheckLemmaClause::CheckLemmaClause()
{

}

CheckLemmaClause::CheckLemmaClause(const CheckLemmaClause & other)
{

}

CheckLemmaClause &CheckLemmaClause::operator=(const CheckLemmaClause & other)
{
  CheckLemmaClause tmp(other);
  swap(tmp);
  return *this;
}

void CheckLemmaClause::swap(CheckLemmaClause & other)
{

}

CheckLemmaClause::~CheckLemmaClause()
{

}

void CheckLemmaClause::accept(Visitor *v)
{
  v->visitCheckLemmaClause(this);
}

CheckLemmaClause *CheckLemmaClause::clone() const
{
  return new CheckLemmaClause(*this);
}



/********************   CheckLoopClause    ********************/
CheckLoopClause::CheckLoopClause()
{

}

CheckLoopClause::CheckLoopClause(const CheckLoopClause & other)
{

}

CheckLoopClause &CheckLoopClause::operator=(const CheckLoopClause & other)
{
  CheckLoopClause tmp(other);
  swap(tmp);
  return *this;
}

void CheckLoopClause::swap(CheckLoopClause & other)
{

}

CheckLoopClause::~CheckLoopClause()
{

}

void CheckLoopClause::accept(Visitor *v)
{
  v->visitCheckLoopClause(this);
}

CheckLoopClause *CheckLoopClause::clone() const
{
  return new CheckLoopClause(*this);
}



/********************   RequiresClause    ********************/
RequiresClause::RequiresClause()
{

}

RequiresClause::RequiresClause(const RequiresClause & other)
{

}

RequiresClause &RequiresClause::operator=(const RequiresClause & other)
{
  RequiresClause tmp(other);
  swap(tmp);
  return *this;
}

void RequiresClause::swap(RequiresClause & other)
{

}

RequiresClause::~RequiresClause()
{

}

void RequiresClause::accept(Visitor *v)
{
  v->visitRequiresClause(this);
}

RequiresClause *RequiresClause::clone() const
{
  return new RequiresClause(*this);
}



/********************   AssumesClause    ********************/
AssumesClause::AssumesClause()
{

}

AssumesClause::AssumesClause(const AssumesClause & other)
{

}

AssumesClause &AssumesClause::operator=(const AssumesClause & other)
{
  AssumesClause tmp(other);
  swap(tmp);
  return *this;
}

void AssumesClause::swap(AssumesClause & other)
{

}

AssumesClause::~AssumesClause()
{

}

void AssumesClause::accept(Visitor *v)
{
  v->visitAssumesClause(this);
}

AssumesClause *AssumesClause::clone() const
{
  return new AssumesClause(*this);
}



/********************   AssignsClause    ********************/
AssignsClause::AssignsClause()
{

}

AssignsClause::AssignsClause(const AssignsClause & other)
{

}

AssignsClause &AssignsClause::operator=(const AssignsClause & other)
{
  AssignsClause tmp(other);
  swap(tmp);
  return *this;
}

void AssignsClause::swap(AssignsClause & other)
{

}

AssignsClause::~AssignsClause()
{

}

void AssignsClause::accept(Visitor *v)
{
  v->visitAssignsClause(this);
}

AssignsClause *AssignsClause::clone() const
{
  return new AssignsClause(*this);
}



/********************   PostCondClause    ********************/
PostCondClause::PostCondClause(PostCond *p1)
{
  postcond_ = p1;

}

PostCondClause::PostCondClause(const PostCondClause & other)
{
  postcond_ = other.postcond_->clone();

}

PostCondClause &PostCondClause::operator=(const PostCondClause & other)
{
  PostCondClause tmp(other);
  swap(tmp);
  return *this;
}

void PostCondClause::swap(PostCondClause & other)
{
  std::swap(postcond_, other.postcond_);

}

PostCondClause::~PostCondClause()
{
  delete(postcond_);

}

void PostCondClause::accept(Visitor *v)
{
  v->visitPostCondClause(this);
}

PostCondClause *PostCondClause::clone() const
{
  return new PostCondClause(*this);
}



/********************   DecreasesClause    ********************/
DecreasesClause::DecreasesClause()
{

}

DecreasesClause::DecreasesClause(const DecreasesClause & other)
{

}

DecreasesClause &DecreasesClause::operator=(const DecreasesClause & other)
{
  DecreasesClause tmp(other);
  swap(tmp);
  return *this;
}

void DecreasesClause::swap(DecreasesClause & other)
{

}

DecreasesClause::~DecreasesClause()
{

}

void DecreasesClause::accept(Visitor *v)
{
  v->visitDecreasesClause(this);
}

DecreasesClause *DecreasesClause::clone() const
{
  return new DecreasesClause(*this);
}



/********************   BehaviorClause    ********************/
BehaviorClause::BehaviorClause()
{

}

BehaviorClause::BehaviorClause(const BehaviorClause & other)
{

}

BehaviorClause &BehaviorClause::operator=(const BehaviorClause & other)
{
  BehaviorClause tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorClause::swap(BehaviorClause & other)
{

}

BehaviorClause::~BehaviorClause()
{

}

void BehaviorClause::accept(Visitor *v)
{
  v->visitBehaviorClause(this);
}

BehaviorClause *BehaviorClause::clone() const
{
  return new BehaviorClause(*this);
}



/********************   AllocatesClause    ********************/
AllocatesClause::AllocatesClause()
{

}

AllocatesClause::AllocatesClause(const AllocatesClause & other)
{

}

AllocatesClause &AllocatesClause::operator=(const AllocatesClause & other)
{
  AllocatesClause tmp(other);
  swap(tmp);
  return *this;
}

void AllocatesClause::swap(AllocatesClause & other)
{

}

AllocatesClause::~AllocatesClause()
{

}

void AllocatesClause::accept(Visitor *v)
{
  v->visitAllocatesClause(this);
}

AllocatesClause *AllocatesClause::clone() const
{
  return new AllocatesClause(*this);
}



/********************   FreesClause    ********************/
FreesClause::FreesClause()
{

}

FreesClause::FreesClause(const FreesClause & other)
{

}

FreesClause &FreesClause::operator=(const FreesClause & other)
{
  FreesClause tmp(other);
  swap(tmp);
  return *this;
}

void FreesClause::swap(FreesClause & other)
{

}

FreesClause::~FreesClause()
{

}

void FreesClause::accept(Visitor *v)
{
  v->visitFreesClause(this);
}

FreesClause *FreesClause::clone() const
{
  return new FreesClause(*this);
}



/********************   CompleteClause    ********************/
CompleteClause::CompleteClause()
{

}

CompleteClause::CompleteClause(const CompleteClause & other)
{

}

CompleteClause &CompleteClause::operator=(const CompleteClause & other)
{
  CompleteClause tmp(other);
  swap(tmp);
  return *this;
}

void CompleteClause::swap(CompleteClause & other)
{

}

CompleteClause::~CompleteClause()
{

}

void CompleteClause::accept(Visitor *v)
{
  v->visitCompleteClause(this);
}

CompleteClause *CompleteClause::clone() const
{
  return new CompleteClause(*this);
}



/********************   DisjointClause    ********************/
DisjointClause::DisjointClause()
{

}

DisjointClause::DisjointClause(const DisjointClause & other)
{

}

DisjointClause &DisjointClause::operator=(const DisjointClause & other)
{
  DisjointClause tmp(other);
  swap(tmp);
  return *this;
}

void DisjointClause::swap(DisjointClause & other)
{

}

DisjointClause::~DisjointClause()
{

}

void DisjointClause::accept(Visitor *v)
{
  v->visitDisjointClause(this);
}

DisjointClause *DisjointClause::clone() const
{
  return new DisjointClause(*this);
}



/********************   ClauseExtConstract    ********************/
ClauseExtConstract::ClauseExtConstract(EXT_CONTRACT p1)
{
  ext_contract_ = p1;

}

ClauseExtConstract::ClauseExtConstract(const ClauseExtConstract & other)
{
  ext_contract_ = other.ext_contract_;

}

ClauseExtConstract &ClauseExtConstract::operator=(const ClauseExtConstract & other)
{
  ClauseExtConstract tmp(other);
  swap(tmp);
  return *this;
}

void ClauseExtConstract::swap(ClauseExtConstract & other)
{
  std::swap(ext_contract_, other.ext_contract_);

}

ClauseExtConstract::~ClauseExtConstract()
{

}

void ClauseExtConstract::accept(Visitor *v)
{
  v->visitClauseExtConstract(this);
}

ClauseExtConstract *ClauseExtConstract::clone() const
{
  return new ClauseExtConstract(*this);
}



/********************   EmptyClauseKW    ********************/
EmptyClauseKW::EmptyClauseKW()
{

}

EmptyClauseKW::EmptyClauseKW(const EmptyClauseKW & other)
{

}

EmptyClauseKW &EmptyClauseKW::operator=(const EmptyClauseKW & other)
{
  EmptyClauseKW tmp(other);
  swap(tmp);
  return *this;
}

void EmptyClauseKW::swap(EmptyClauseKW & other)
{

}

EmptyClauseKW::~EmptyClauseKW()
{

}

void EmptyClauseKW::accept(Visitor *v)
{
  v->visitEmptyClauseKW(this);
}

EmptyClauseKW *EmptyClauseKW::clone() const
{
  return new EmptyClauseKW(*this);
}



/********************   NoRequires    ********************/
NoRequires::NoRequires()
{

}

NoRequires::NoRequires(const NoRequires & other)
{

}

NoRequires &NoRequires::operator=(const NoRequires & other)
{
  NoRequires tmp(other);
  swap(tmp);
  return *this;
}

void NoRequires::swap(NoRequires & other)
{

}

NoRequires::~NoRequires()
{

}

void NoRequires::accept(Visitor *v)
{
  v->visitNoRequires(this);
}

NoRequires *NoRequires::clone() const
{
  return new NoRequires(*this);
}



/********************   SomeRequires    ********************/
SomeRequires::SomeRequires(NERequires *p1)
{
  nerequires_ = p1;

}

SomeRequires::SomeRequires(const SomeRequires & other)
{
  nerequires_ = other.nerequires_->clone();

}

SomeRequires &SomeRequires::operator=(const SomeRequires & other)
{
  SomeRequires tmp(other);
  swap(tmp);
  return *this;
}

void SomeRequires::swap(SomeRequires & other)
{
  std::swap(nerequires_, other.nerequires_);

}

SomeRequires::~SomeRequires()
{
  delete(nerequires_);

}

void SomeRequires::accept(Visitor *v)
{
  v->visitSomeRequires(this);
}

SomeRequires *SomeRequires::clone() const
{
  return new SomeRequires(*this);
}



/********************   SimpleRequires    ********************/
SimpleRequires::SimpleRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

SimpleRequires::SimpleRequires(const SimpleRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

SimpleRequires &SimpleRequires::operator=(const SimpleRequires & other)
{
  SimpleRequires tmp(other);
  swap(tmp);
  return *this;
}

void SimpleRequires::swap(SimpleRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

SimpleRequires::~SimpleRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void SimpleRequires::accept(Visitor *v)
{
  v->visitSimpleRequires(this);
}

SimpleRequires *SimpleRequires::clone() const
{
  return new SimpleRequires(*this);
}



/********************   CheckRequires    ********************/
CheckRequires::CheckRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

CheckRequires::CheckRequires(const CheckRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

CheckRequires &CheckRequires::operator=(const CheckRequires & other)
{
  CheckRequires tmp(other);
  swap(tmp);
  return *this;
}

void CheckRequires::swap(CheckRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

CheckRequires::~CheckRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void CheckRequires::accept(Visitor *v)
{
  v->visitCheckRequires(this);
}

CheckRequires *CheckRequires::clone() const
{
  return new CheckRequires(*this);
}



/********************   AdimtRequires    ********************/
AdimtRequires::AdimtRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

AdimtRequires::AdimtRequires(const AdimtRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

AdimtRequires &AdimtRequires::operator=(const AdimtRequires & other)
{
  AdimtRequires tmp(other);
  swap(tmp);
  return *this;
}

void AdimtRequires::swap(AdimtRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

AdimtRequires::~AdimtRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void AdimtRequires::accept(Visitor *v)
{
  v->visitAdimtRequires(this);
}

AdimtRequires *AdimtRequires::clone() const
{
  return new AdimtRequires(*this);
}



/********************   ClauseSimpleRequires    ********************/
ClauseSimpleRequires::ClauseSimpleRequires(Lexpr *p1, ClauseKW *p2)
{
  lexpr_ = p1;
  clausekw_ = p2;

}

ClauseSimpleRequires::ClauseSimpleRequires(const ClauseSimpleRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClauseSimpleRequires &ClauseSimpleRequires::operator=(const ClauseSimpleRequires & other)
{
  ClauseSimpleRequires tmp(other);
  swap(tmp);
  return *this;
}

void ClauseSimpleRequires::swap(ClauseSimpleRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(clausekw_, other.clausekw_);

}

ClauseSimpleRequires::~ClauseSimpleRequires()
{
  delete(lexpr_);
  delete(clausekw_);

}

void ClauseSimpleRequires::accept(Visitor *v)
{
  v->visitClauseSimpleRequires(this);
}

ClauseSimpleRequires *ClauseSimpleRequires::clone() const
{
  return new ClauseSimpleRequires(*this);
}



/********************   ClauseCheckRequires    ********************/
ClauseCheckRequires::ClauseCheckRequires(Lexpr *p1, ClauseKW *p2)
{
  lexpr_ = p1;
  clausekw_ = p2;

}

ClauseCheckRequires::ClauseCheckRequires(const ClauseCheckRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClauseCheckRequires &ClauseCheckRequires::operator=(const ClauseCheckRequires & other)
{
  ClauseCheckRequires tmp(other);
  swap(tmp);
  return *this;
}

void ClauseCheckRequires::swap(ClauseCheckRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(clausekw_, other.clausekw_);

}

ClauseCheckRequires::~ClauseCheckRequires()
{
  delete(lexpr_);
  delete(clausekw_);

}

void ClauseCheckRequires::accept(Visitor *v)
{
  v->visitClauseCheckRequires(this);
}

ClauseCheckRequires *ClauseCheckRequires::clone() const
{
  return new ClauseCheckRequires(*this);
}



/********************   ClauseAdimtRequires    ********************/
ClauseAdimtRequires::ClauseAdimtRequires(Lexpr *p1, ClauseKW *p2)
{
  lexpr_ = p1;
  clausekw_ = p2;

}

ClauseAdimtRequires::ClauseAdimtRequires(const ClauseAdimtRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClauseAdimtRequires &ClauseAdimtRequires::operator=(const ClauseAdimtRequires & other)
{
  ClauseAdimtRequires tmp(other);
  swap(tmp);
  return *this;
}

void ClauseAdimtRequires::swap(ClauseAdimtRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(clausekw_, other.clausekw_);

}

ClauseAdimtRequires::~ClauseAdimtRequires()
{
  delete(lexpr_);
  delete(clausekw_);

}

void ClauseAdimtRequires::accept(Visitor *v)
{
  v->visitClauseAdimtRequires(this);
}

ClauseAdimtRequires *ClauseAdimtRequires::clone() const
{
  return new ClauseAdimtRequires(*this);
}



/********************   NoTerminate    ********************/
NoTerminate::NoTerminate()
{

}

NoTerminate::NoTerminate(const NoTerminate & other)
{

}

NoTerminate &NoTerminate::operator=(const NoTerminate & other)
{
  NoTerminate tmp(other);
  swap(tmp);
  return *this;
}

void NoTerminate::swap(NoTerminate & other)
{

}

NoTerminate::~NoTerminate()
{

}

void NoTerminate::accept(Visitor *v)
{
  v->visitNoTerminate(this);
}

NoTerminate *NoTerminate::clone() const
{
  return new NoTerminate(*this);
}



/********************   SomeTerminate    ********************/
SomeTerminate::SomeTerminate(NETerminates *p1)
{
  neterminates_ = p1;

}

SomeTerminate::SomeTerminate(const SomeTerminate & other)
{
  neterminates_ = other.neterminates_->clone();

}

SomeTerminate &SomeTerminate::operator=(const SomeTerminate & other)
{
  SomeTerminate tmp(other);
  swap(tmp);
  return *this;
}

void SomeTerminate::swap(SomeTerminate & other)
{
  std::swap(neterminates_, other.neterminates_);

}

SomeTerminate::~SomeTerminate()
{
  delete(neterminates_);

}

void SomeTerminate::accept(Visitor *v)
{
  v->visitSomeTerminate(this);
}

SomeTerminate *SomeTerminate::clone() const
{
  return new SomeTerminate(*this);
}



/********************   SimpleTerminates    ********************/
SimpleTerminates::SimpleTerminates(Lexpr *p1)
{
  lexpr_ = p1;

}

SimpleTerminates::SimpleTerminates(const SimpleTerminates & other)
{
  lexpr_ = other.lexpr_->clone();

}

SimpleTerminates &SimpleTerminates::operator=(const SimpleTerminates & other)
{
  SimpleTerminates tmp(other);
  swap(tmp);
  return *this;
}

void SimpleTerminates::swap(SimpleTerminates & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SimpleTerminates::~SimpleTerminates()
{
  delete(lexpr_);

}

void SimpleTerminates::accept(Visitor *v)
{
  v->visitSimpleTerminates(this);
}

SimpleTerminates *SimpleTerminates::clone() const
{
  return new SimpleTerminates(*this);
}



/********************   ClauseTerminates    ********************/
ClauseTerminates::ClauseTerminates(Lexpr *p1, ClauseKW *p2)
{
  lexpr_ = p1;
  clausekw_ = p2;

}

ClauseTerminates::ClauseTerminates(const ClauseTerminates & other)
{
  lexpr_ = other.lexpr_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClauseTerminates &ClauseTerminates::operator=(const ClauseTerminates & other)
{
  ClauseTerminates tmp(other);
  swap(tmp);
  return *this;
}

void ClauseTerminates::swap(ClauseTerminates & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(clausekw_, other.clausekw_);

}

ClauseTerminates::~ClauseTerminates()
{
  delete(lexpr_);
  delete(clausekw_);

}

void ClauseTerminates::accept(Visitor *v)
{
  v->visitClauseTerminates(this);
}

ClauseTerminates *ClauseTerminates::clone() const
{
  return new ClauseTerminates(*this);
}



/********************   NoDecreases    ********************/
NoDecreases::NoDecreases()
{

}

NoDecreases::NoDecreases(const NoDecreases & other)
{

}

NoDecreases &NoDecreases::operator=(const NoDecreases & other)
{
  NoDecreases tmp(other);
  swap(tmp);
  return *this;
}

void NoDecreases::swap(NoDecreases & other)
{

}

NoDecreases::~NoDecreases()
{

}

void NoDecreases::accept(Visitor *v)
{
  v->visitNoDecreases(this);
}

NoDecreases *NoDecreases::clone() const
{
  return new NoDecreases(*this);
}



/********************   SomeDecreases    ********************/
SomeDecreases::SomeDecreases(NEDecreases *p1)
{
  nedecreases_ = p1;

}

SomeDecreases::SomeDecreases(const SomeDecreases & other)
{
  nedecreases_ = other.nedecreases_->clone();

}

SomeDecreases &SomeDecreases::operator=(const SomeDecreases & other)
{
  SomeDecreases tmp(other);
  swap(tmp);
  return *this;
}

void SomeDecreases::swap(SomeDecreases & other)
{
  std::swap(nedecreases_, other.nedecreases_);

}

SomeDecreases::~SomeDecreases()
{
  delete(nedecreases_);

}

void SomeDecreases::accept(Visitor *v)
{
  v->visitSomeDecreases(this);
}

SomeDecreases *SomeDecreases::clone() const
{
  return new SomeDecreases(*this);
}



/********************   SimpleDecreases    ********************/
SimpleDecreases::SimpleDecreases(Variant *p1)
{
  variant_ = p1;

}

SimpleDecreases::SimpleDecreases(const SimpleDecreases & other)
{
  variant_ = other.variant_->clone();

}

SimpleDecreases &SimpleDecreases::operator=(const SimpleDecreases & other)
{
  SimpleDecreases tmp(other);
  swap(tmp);
  return *this;
}

void SimpleDecreases::swap(SimpleDecreases & other)
{
  std::swap(variant_, other.variant_);

}

SimpleDecreases::~SimpleDecreases()
{
  delete(variant_);

}

void SimpleDecreases::accept(Visitor *v)
{
  v->visitSimpleDecreases(this);
}

SimpleDecreases *SimpleDecreases::clone() const
{
  return new SimpleDecreases(*this);
}



/********************   ClauseDecreases    ********************/
ClauseDecreases::ClauseDecreases(Variant *p1, ClauseKW *p2)
{
  variant_ = p1;
  clausekw_ = p2;

}

ClauseDecreases::ClauseDecreases(const ClauseDecreases & other)
{
  variant_ = other.variant_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClauseDecreases &ClauseDecreases::operator=(const ClauseDecreases & other)
{
  ClauseDecreases tmp(other);
  swap(tmp);
  return *this;
}

void ClauseDecreases::swap(ClauseDecreases & other)
{
  std::swap(variant_, other.variant_);
  std::swap(clausekw_, other.clausekw_);

}

ClauseDecreases::~ClauseDecreases()
{
  delete(variant_);
  delete(clausekw_);

}

void ClauseDecreases::accept(Visitor *v)
{
  v->visitClauseDecreases(this);
}

ClauseDecreases *ClauseDecreases::clone() const
{
  return new ClauseDecreases(*this);
}



/********************   ForVariant    ********************/
ForVariant::ForVariant(Lexpr *p1, AnyIdentifier *p2)
{
  lexpr_ = p1;
  anyidentifier_ = p2;

}

ForVariant::ForVariant(const ForVariant & other)
{
  lexpr_ = other.lexpr_->clone();
  anyidentifier_ = other.anyidentifier_->clone();

}

ForVariant &ForVariant::operator=(const ForVariant & other)
{
  ForVariant tmp(other);
  swap(tmp);
  return *this;
}

void ForVariant::swap(ForVariant & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(anyidentifier_, other.anyidentifier_);

}

ForVariant::~ForVariant()
{
  delete(lexpr_);
  delete(anyidentifier_);

}

void ForVariant::accept(Visitor *v)
{
  v->visitForVariant(this);
}

ForVariant *ForVariant::clone() const
{
  return new ForVariant(*this);
}



/********************   LexprVariant    ********************/
LexprVariant::LexprVariant(Lexpr *p1)
{
  lexpr_ = p1;

}

LexprVariant::LexprVariant(const LexprVariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

LexprVariant &LexprVariant::operator=(const LexprVariant & other)
{
  LexprVariant tmp(other);
  swap(tmp);
  return *this;
}

void LexprVariant::swap(LexprVariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

LexprVariant::~LexprVariant()
{
  delete(lexpr_);

}

void LexprVariant::accept(Visitor *v)
{
  v->visitLexprVariant(this);
}

LexprVariant *LexprVariant::clone() const
{
  return new LexprVariant(*this);
}



/********************   NoSimpleClauses    ********************/
NoSimpleClauses::NoSimpleClauses()
{

}

NoSimpleClauses::NoSimpleClauses(const NoSimpleClauses & other)
{

}

NoSimpleClauses &NoSimpleClauses::operator=(const NoSimpleClauses & other)
{
  NoSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void NoSimpleClauses::swap(NoSimpleClauses & other)
{

}

NoSimpleClauses::~NoSimpleClauses()
{

}

void NoSimpleClauses::accept(Visitor *v)
{
  v->visitNoSimpleClauses(this);
}

NoSimpleClauses *NoSimpleClauses::clone() const
{
  return new NoSimpleClauses(*this);
}



/********************   SomeSimpleClauses    ********************/
SomeSimpleClauses::SomeSimpleClauses(NESimpleClauses *p1)
{
  nesimpleclauses_ = p1;

}

SomeSimpleClauses::SomeSimpleClauses(const SomeSimpleClauses & other)
{
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

SomeSimpleClauses &SomeSimpleClauses::operator=(const SomeSimpleClauses & other)
{
  SomeSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void SomeSimpleClauses::swap(SomeSimpleClauses & other)
{
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

SomeSimpleClauses::~SomeSimpleClauses()
{
  delete(nesimpleclauses_);

}

void SomeSimpleClauses::accept(Visitor *v)
{
  v->visitSomeSimpleClauses(this);
}

SomeSimpleClauses *SomeSimpleClauses::clone() const
{
  return new SomeSimpleClauses(*this);
}



/********************   AllocatesZones    ********************/
AllocatesZones::AllocatesZones(Zones *p1)
{
  zones_ = p1;

}

AllocatesZones::AllocatesZones(const AllocatesZones & other)
{
  zones_ = other.zones_->clone();

}

AllocatesZones &AllocatesZones::operator=(const AllocatesZones & other)
{
  AllocatesZones tmp(other);
  swap(tmp);
  return *this;
}

void AllocatesZones::swap(AllocatesZones & other)
{
  std::swap(zones_, other.zones_);

}

AllocatesZones::~AllocatesZones()
{
  delete(zones_);

}

void AllocatesZones::accept(Visitor *v)
{
  v->visitAllocatesZones(this);
}

AllocatesZones *AllocatesZones::clone() const
{
  return new AllocatesZones(*this);
}



/********************   FreesZones    ********************/
FreesZones::FreesZones(Zones *p1)
{
  zones_ = p1;

}

FreesZones::FreesZones(const FreesZones & other)
{
  zones_ = other.zones_->clone();

}

FreesZones &FreesZones::operator=(const FreesZones & other)
{
  FreesZones tmp(other);
  swap(tmp);
  return *this;
}

void FreesZones::swap(FreesZones & other)
{
  std::swap(zones_, other.zones_);

}

FreesZones::~FreesZones()
{
  delete(zones_);

}

void FreesZones::accept(Visitor *v)
{
  v->visitFreesZones(this);
}

FreesZones *FreesZones::clone() const
{
  return new FreesZones(*this);
}



/********************   PostCondSimpleClauses    ********************/
PostCondSimpleClauses::PostCondSimpleClauses(PostCond *p1, Lexpr *p2, SimpleClauses *p3)
{
  postcond_ = p1;
  lexpr_ = p2;
  simpleclauses_ = p3;

}

PostCondSimpleClauses::PostCondSimpleClauses(const PostCondSimpleClauses & other)
{
  postcond_ = other.postcond_->clone();
  lexpr_ = other.lexpr_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

PostCondSimpleClauses &PostCondSimpleClauses::operator=(const PostCondSimpleClauses & other)
{
  PostCondSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void PostCondSimpleClauses::swap(PostCondSimpleClauses & other)
{
  std::swap(postcond_, other.postcond_);
  std::swap(lexpr_, other.lexpr_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

PostCondSimpleClauses::~PostCondSimpleClauses()
{
  delete(postcond_);
  delete(lexpr_);
  delete(simpleclauses_);

}

void PostCondSimpleClauses::accept(Visitor *v)
{
  v->visitPostCondSimpleClauses(this);
}

PostCondSimpleClauses *PostCondSimpleClauses::clone() const
{
  return new PostCondSimpleClauses(*this);
}



/********************   AllocationSimpleClauses    ********************/
AllocationSimpleClauses::AllocationSimpleClauses(Allocation *p1, SimpleClauses *p2)
{
  allocation_ = p1;
  simpleclauses_ = p2;

}

AllocationSimpleClauses::AllocationSimpleClauses(const AllocationSimpleClauses & other)
{
  allocation_ = other.allocation_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

AllocationSimpleClauses &AllocationSimpleClauses::operator=(const AllocationSimpleClauses & other)
{
  AllocationSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void AllocationSimpleClauses::swap(AllocationSimpleClauses & other)
{
  std::swap(allocation_, other.allocation_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

AllocationSimpleClauses::~AllocationSimpleClauses()
{
  delete(allocation_);
  delete(simpleclauses_);

}

void AllocationSimpleClauses::accept(Visitor *v)
{
  v->visitAllocationSimpleClauses(this);
}

AllocationSimpleClauses *AllocationSimpleClauses::clone() const
{
  return new AllocationSimpleClauses(*this);
}



/********************   AssignsSimpleClauses    ********************/
AssignsSimpleClauses::AssignsSimpleClauses(Assigns *p1, SimpleClauses *p2)
{
  assigns_ = p1;
  simpleclauses_ = p2;

}

AssignsSimpleClauses::AssignsSimpleClauses(const AssignsSimpleClauses & other)
{
  assigns_ = other.assigns_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

AssignsSimpleClauses &AssignsSimpleClauses::operator=(const AssignsSimpleClauses & other)
{
  AssignsSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void AssignsSimpleClauses::swap(AssignsSimpleClauses & other)
{
  std::swap(assigns_, other.assigns_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

AssignsSimpleClauses::~AssignsSimpleClauses()
{
  delete(assigns_);
  delete(simpleclauses_);

}

void AssignsSimpleClauses::accept(Visitor *v)
{
  v->visitAssignsSimpleClauses(this);
}

AssignsSimpleClauses *AssignsSimpleClauses::clone() const
{
  return new AssignsSimpleClauses(*this);
}



/********************   ExtContractSimpleClauses    ********************/
ExtContractSimpleClauses::ExtContractSimpleClauses(EXT_CONTRACT p1, ExtensionContent *p2, SimpleClauses *p3)
{
  ext_contract_ = p1;
  extensioncontent_ = p2;
  simpleclauses_ = p3;

}

ExtContractSimpleClauses::ExtContractSimpleClauses(const ExtContractSimpleClauses & other)
{
  ext_contract_ = other.ext_contract_;
  extensioncontent_ = other.extensioncontent_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

ExtContractSimpleClauses &ExtContractSimpleClauses::operator=(const ExtContractSimpleClauses & other)
{
  ExtContractSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void ExtContractSimpleClauses::swap(ExtContractSimpleClauses & other)
{
  std::swap(ext_contract_, other.ext_contract_);
  std::swap(extensioncontent_, other.extensioncontent_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

ExtContractSimpleClauses::~ExtContractSimpleClauses()
{
  delete(extensioncontent_);
  delete(simpleclauses_);

}

void ExtContractSimpleClauses::accept(Visitor *v)
{
  v->visitExtContractSimpleClauses(this);
}

ExtContractSimpleClauses *ExtContractSimpleClauses::clone() const
{
  return new ExtContractSimpleClauses(*this);
}



/********************   ClausesPostCondSimpleClauses    ********************/
ClausesPostCondSimpleClauses::ClausesPostCondSimpleClauses(PostCond *p1, Lexpr *p2, ClauseKW *p3)
{
  postcond_ = p1;
  lexpr_ = p2;
  clausekw_ = p3;

}

ClausesPostCondSimpleClauses::ClausesPostCondSimpleClauses(const ClausesPostCondSimpleClauses & other)
{
  postcond_ = other.postcond_->clone();
  lexpr_ = other.lexpr_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClausesPostCondSimpleClauses &ClausesPostCondSimpleClauses::operator=(const ClausesPostCondSimpleClauses & other)
{
  ClausesPostCondSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void ClausesPostCondSimpleClauses::swap(ClausesPostCondSimpleClauses & other)
{
  std::swap(postcond_, other.postcond_);
  std::swap(lexpr_, other.lexpr_);
  std::swap(clausekw_, other.clausekw_);

}

ClausesPostCondSimpleClauses::~ClausesPostCondSimpleClauses()
{
  delete(postcond_);
  delete(lexpr_);
  delete(clausekw_);

}

void ClausesPostCondSimpleClauses::accept(Visitor *v)
{
  v->visitClausesPostCondSimpleClauses(this);
}

ClausesPostCondSimpleClauses *ClausesPostCondSimpleClauses::clone() const
{
  return new ClausesPostCondSimpleClauses(*this);
}



/********************   ClausesAllocationSimpleClauses    ********************/
ClausesAllocationSimpleClauses::ClausesAllocationSimpleClauses(Allocation *p1, ClauseKW *p2)
{
  allocation_ = p1;
  clausekw_ = p2;

}

ClausesAllocationSimpleClauses::ClausesAllocationSimpleClauses(const ClausesAllocationSimpleClauses & other)
{
  allocation_ = other.allocation_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClausesAllocationSimpleClauses &ClausesAllocationSimpleClauses::operator=(const ClausesAllocationSimpleClauses & other)
{
  ClausesAllocationSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void ClausesAllocationSimpleClauses::swap(ClausesAllocationSimpleClauses & other)
{
  std::swap(allocation_, other.allocation_);
  std::swap(clausekw_, other.clausekw_);

}

ClausesAllocationSimpleClauses::~ClausesAllocationSimpleClauses()
{
  delete(allocation_);
  delete(clausekw_);

}

void ClausesAllocationSimpleClauses::accept(Visitor *v)
{
  v->visitClausesAllocationSimpleClauses(this);
}

ClausesAllocationSimpleClauses *ClausesAllocationSimpleClauses::clone() const
{
  return new ClausesAllocationSimpleClauses(*this);
}



/********************   ClausesAssignsSimpleClauses    ********************/
ClausesAssignsSimpleClauses::ClausesAssignsSimpleClauses(Assigns *p1, ClauseKW *p2)
{
  assigns_ = p1;
  clausekw_ = p2;

}

ClausesAssignsSimpleClauses::ClausesAssignsSimpleClauses(const ClausesAssignsSimpleClauses & other)
{
  assigns_ = other.assigns_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClausesAssignsSimpleClauses &ClausesAssignsSimpleClauses::operator=(const ClausesAssignsSimpleClauses & other)
{
  ClausesAssignsSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void ClausesAssignsSimpleClauses::swap(ClausesAssignsSimpleClauses & other)
{
  std::swap(assigns_, other.assigns_);
  std::swap(clausekw_, other.clausekw_);

}

ClausesAssignsSimpleClauses::~ClausesAssignsSimpleClauses()
{
  delete(assigns_);
  delete(clausekw_);

}

void ClausesAssignsSimpleClauses::accept(Visitor *v)
{
  v->visitClausesAssignsSimpleClauses(this);
}

ClausesAssignsSimpleClauses *ClausesAssignsSimpleClauses::clone() const
{
  return new ClausesAssignsSimpleClauses(*this);
}



/********************   ExtConClausestractSimpleClauses    ********************/
ExtConClausestractSimpleClauses::ExtConClausestractSimpleClauses(EXT_CONTRACT p1, Zones *p2, ClauseKW *p3)
{
  ext_contract_ = p1;
  zones_ = p2;
  clausekw_ = p3;

}

ExtConClausestractSimpleClauses::ExtConClausestractSimpleClauses(const ExtConClausestractSimpleClauses & other)
{
  ext_contract_ = other.ext_contract_;
  zones_ = other.zones_->clone();
  clausekw_ = other.clausekw_->clone();

}

ExtConClausestractSimpleClauses &ExtConClausestractSimpleClauses::operator=(const ExtConClausestractSimpleClauses & other)
{
  ExtConClausestractSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void ExtConClausestractSimpleClauses::swap(ExtConClausestractSimpleClauses & other)
{
  std::swap(ext_contract_, other.ext_contract_);
  std::swap(zones_, other.zones_);
  std::swap(clausekw_, other.clausekw_);

}

ExtConClausestractSimpleClauses::~ExtConClausestractSimpleClauses()
{
  delete(zones_);
  delete(clausekw_);

}

void ExtConClausestractSimpleClauses::accept(Visitor *v)
{
  v->visitExtConClausestractSimpleClauses(this);
}

ExtConClausestractSimpleClauses *ExtConClausestractSimpleClauses::clone() const
{
  return new ExtConClausestractSimpleClauses(*this);
}



/********************   NoExtensionContent    ********************/
NoExtensionContent::NoExtensionContent()
{

}

NoExtensionContent::NoExtensionContent(const NoExtensionContent & other)
{

}

NoExtensionContent &NoExtensionContent::operator=(const NoExtensionContent & other)
{
  NoExtensionContent tmp(other);
  swap(tmp);
  return *this;
}

void NoExtensionContent::swap(NoExtensionContent & other)
{

}

NoExtensionContent::~NoExtensionContent()
{

}

void NoExtensionContent::accept(Visitor *v)
{
  v->visitNoExtensionContent(this);
}

NoExtensionContent *NoExtensionContent::clone() const
{
  return new NoExtensionContent(*this);
}



/********************   SomeExtensionContent    ********************/
SomeExtensionContent::SomeExtensionContent(Zones *p1)
{
  zones_ = p1;

}

SomeExtensionContent::SomeExtensionContent(const SomeExtensionContent & other)
{
  zones_ = other.zones_->clone();

}

SomeExtensionContent &SomeExtensionContent::operator=(const SomeExtensionContent & other)
{
  SomeExtensionContent tmp(other);
  swap(tmp);
  return *this;
}

void SomeExtensionContent::swap(SomeExtensionContent & other)
{
  std::swap(zones_, other.zones_);

}

SomeExtensionContent::~SomeExtensionContent()
{
  delete(zones_);

}

void SomeExtensionContent::accept(Visitor *v)
{
  v->visitSomeExtensionContent(this);
}

SomeExtensionContent *SomeExtensionContent::clone() const
{
  return new SomeExtensionContent(*this);
}



/********************   NoBehaviors    ********************/
NoBehaviors::NoBehaviors()
{

}

NoBehaviors::NoBehaviors(const NoBehaviors & other)
{

}

NoBehaviors &NoBehaviors::operator=(const NoBehaviors & other)
{
  NoBehaviors tmp(other);
  swap(tmp);
  return *this;
}

void NoBehaviors::swap(NoBehaviors & other)
{

}

NoBehaviors::~NoBehaviors()
{

}

void NoBehaviors::accept(Visitor *v)
{
  v->visitNoBehaviors(this);
}

NoBehaviors *NoBehaviors::clone() const
{
  return new NoBehaviors(*this);
}



/********************   SomeBehaviors    ********************/
SomeBehaviors::SomeBehaviors(NEBehaviors *p1)
{
  nebehaviors_ = p1;

}

SomeBehaviors::SomeBehaviors(const SomeBehaviors & other)
{
  nebehaviors_ = other.nebehaviors_->clone();

}

SomeBehaviors &SomeBehaviors::operator=(const SomeBehaviors & other)
{
  SomeBehaviors tmp(other);
  swap(tmp);
  return *this;
}

void SomeBehaviors::swap(SomeBehaviors & other)
{
  std::swap(nebehaviors_, other.nebehaviors_);

}

SomeBehaviors::~SomeBehaviors()
{
  delete(nebehaviors_);

}

void SomeBehaviors::accept(Visitor *v)
{
  v->visitSomeBehaviors(this);
}

SomeBehaviors *SomeBehaviors::clone() const
{
  return new SomeBehaviors(*this);
}



/********************   TheBehaviors    ********************/
TheBehaviors::TheBehaviors(BehaviorName *p1, BehaviorBody *p2, Behaviors *p3)
{
  behaviorname_ = p1;
  behaviorbody_ = p2;
  behaviors_ = p3;

}

TheBehaviors::TheBehaviors(const TheBehaviors & other)
{
  behaviorname_ = other.behaviorname_->clone();
  behaviorbody_ = other.behaviorbody_->clone();
  behaviors_ = other.behaviors_->clone();

}

TheBehaviors &TheBehaviors::operator=(const TheBehaviors & other)
{
  TheBehaviors tmp(other);
  swap(tmp);
  return *this;
}

void TheBehaviors::swap(TheBehaviors & other)
{
  std::swap(behaviorname_, other.behaviorname_);
  std::swap(behaviorbody_, other.behaviorbody_);
  std::swap(behaviors_, other.behaviors_);

}

TheBehaviors::~TheBehaviors()
{
  delete(behaviorname_);
  delete(behaviorbody_);
  delete(behaviors_);

}

void TheBehaviors::accept(Visitor *v)
{
  v->visitTheBehaviors(this);
}

TheBehaviors *TheBehaviors::clone() const
{
  return new TheBehaviors(*this);
}



/********************   SimpleClausesBehavior    ********************/
SimpleClausesBehavior::SimpleClausesBehavior(Assumes *p1, Requires *p2, SimpleClauses *p3)
{
  assumes_ = p1;
  requires_ = p2;
  simpleclauses_ = p3;

}

SimpleClausesBehavior::SimpleClausesBehavior(const SimpleClausesBehavior & other)
{
  assumes_ = other.assumes_->clone();
  requires_ = other.requires_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

SimpleClausesBehavior &SimpleClausesBehavior::operator=(const SimpleClausesBehavior & other)
{
  SimpleClausesBehavior tmp(other);
  swap(tmp);
  return *this;
}

void SimpleClausesBehavior::swap(SimpleClausesBehavior & other)
{
  std::swap(assumes_, other.assumes_);
  std::swap(requires_, other.requires_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

SimpleClausesBehavior::~SimpleClausesBehavior()
{
  delete(assumes_);
  delete(requires_);
  delete(simpleclauses_);

}

void SimpleClausesBehavior::accept(Visitor *v)
{
  v->visitSimpleClausesBehavior(this);
}

SimpleClausesBehavior *SimpleClausesBehavior::clone() const
{
  return new SimpleClausesBehavior(*this);
}



/********************   RequiresAssumes    ********************/
RequiresAssumes::RequiresAssumes(Assumes *p1, NERequires *p2)
{
  assumes_ = p1;
  nerequires_ = p2;

}

RequiresAssumes::RequiresAssumes(const RequiresAssumes & other)
{
  assumes_ = other.assumes_->clone();
  nerequires_ = other.nerequires_->clone();

}

RequiresAssumes &RequiresAssumes::operator=(const RequiresAssumes & other)
{
  RequiresAssumes tmp(other);
  swap(tmp);
  return *this;
}

void RequiresAssumes::swap(RequiresAssumes & other)
{
  std::swap(assumes_, other.assumes_);
  std::swap(nerequires_, other.nerequires_);

}

RequiresAssumes::~RequiresAssumes()
{
  delete(assumes_);
  delete(nerequires_);

}

void RequiresAssumes::accept(Visitor *v)
{
  v->visitRequiresAssumes(this);
}

RequiresAssumes *RequiresAssumes::clone() const
{
  return new RequiresAssumes(*this);
}



/********************   SimpleClausesAssumes    ********************/
SimpleClausesAssumes::SimpleClausesAssumes(Assumes *p1, Requires *p2, NESimpleClauses *p3)
{
  assumes_ = p1;
  requires_ = p2;
  nesimpleclauses_ = p3;

}

SimpleClausesAssumes::SimpleClausesAssumes(const SimpleClausesAssumes & other)
{
  assumes_ = other.assumes_->clone();
  requires_ = other.requires_->clone();
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

SimpleClausesAssumes &SimpleClausesAssumes::operator=(const SimpleClausesAssumes & other)
{
  SimpleClausesAssumes tmp(other);
  swap(tmp);
  return *this;
}

void SimpleClausesAssumes::swap(SimpleClausesAssumes & other)
{
  std::swap(assumes_, other.assumes_);
  std::swap(requires_, other.requires_);
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

SimpleClausesAssumes::~SimpleClausesAssumes()
{
  delete(assumes_);
  delete(requires_);
  delete(nesimpleclauses_);

}

void SimpleClausesAssumes::accept(Visitor *v)
{
  v->visitSimpleClausesAssumes(this);
}

SimpleClausesAssumes *SimpleClausesAssumes::clone() const
{
  return new SimpleClausesAssumes(*this);
}



/********************   RequiresRequires    ********************/
RequiresRequires::RequiresRequires(Assumes *p1, Requires *p2, NESimpleClauses *p3)
{
  assumes_ = p1;
  requires_ = p2;
  nesimpleclauses_ = p3;

}

RequiresRequires::RequiresRequires(const RequiresRequires & other)
{
  assumes_ = other.assumes_->clone();
  requires_ = other.requires_->clone();
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

RequiresRequires &RequiresRequires::operator=(const RequiresRequires & other)
{
  RequiresRequires tmp(other);
  swap(tmp);
  return *this;
}

void RequiresRequires::swap(RequiresRequires & other)
{
  std::swap(assumes_, other.assumes_);
  std::swap(requires_, other.requires_);
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

RequiresRequires::~RequiresRequires()
{
  delete(assumes_);
  delete(requires_);
  delete(nesimpleclauses_);

}

void RequiresRequires::accept(Visitor *v)
{
  v->visitRequiresRequires(this);
}

RequiresRequires *RequiresRequires::clone() const
{
  return new RequiresRequires(*this);
}



/********************   NoAssumes    ********************/
NoAssumes::NoAssumes()
{

}

NoAssumes::NoAssumes(const NoAssumes & other)
{

}

NoAssumes &NoAssumes::operator=(const NoAssumes & other)
{
  NoAssumes tmp(other);
  swap(tmp);
  return *this;
}

void NoAssumes::swap(NoAssumes & other)
{

}

NoAssumes::~NoAssumes()
{

}

void NoAssumes::accept(Visitor *v)
{
  v->visitNoAssumes(this);
}

NoAssumes *NoAssumes::clone() const
{
  return new NoAssumes(*this);
}



/********************   SimpleAssumes    ********************/
SimpleAssumes::SimpleAssumes(Lexpr *p1, Assumes *p2)
{
  lexpr_ = p1;
  assumes_ = p2;

}

SimpleAssumes::SimpleAssumes(const SimpleAssumes & other)
{
  lexpr_ = other.lexpr_->clone();
  assumes_ = other.assumes_->clone();

}

SimpleAssumes &SimpleAssumes::operator=(const SimpleAssumes & other)
{
  SimpleAssumes tmp(other);
  swap(tmp);
  return *this;
}

void SimpleAssumes::swap(SimpleAssumes & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(assumes_, other.assumes_);

}

SimpleAssumes::~SimpleAssumes()
{
  delete(lexpr_);
  delete(assumes_);

}

void SimpleAssumes::accept(Visitor *v)
{
  v->visitSimpleAssumes(this);
}

SimpleAssumes *SimpleAssumes::clone() const
{
  return new SimpleAssumes(*this);
}



/********************   ClauseAssumes    ********************/
ClauseAssumes::ClauseAssumes(Lexpr *p1, ClauseKW *p2)
{
  lexpr_ = p1;
  clausekw_ = p2;

}

ClauseAssumes::ClauseAssumes(const ClauseAssumes & other)
{
  lexpr_ = other.lexpr_->clone();
  clausekw_ = other.clausekw_->clone();

}

ClauseAssumes &ClauseAssumes::operator=(const ClauseAssumes & other)
{
  ClauseAssumes tmp(other);
  swap(tmp);
  return *this;
}

void ClauseAssumes::swap(ClauseAssumes & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(clausekw_, other.clausekw_);

}

ClauseAssumes::~ClauseAssumes()
{
  delete(lexpr_);
  delete(clausekw_);

}

void ClauseAssumes::accept(Visitor *v)
{
  v->visitClauseAssumes(this);
}

ClauseAssumes *ClauseAssumes::clone() const
{
  return new ClauseAssumes(*this);
}



/********************   NoComplDisj    ********************/
NoComplDisj::NoComplDisj()
{

}

NoComplDisj::NoComplDisj(const NoComplDisj & other)
{

}

NoComplDisj &NoComplDisj::operator=(const NoComplDisj & other)
{
  NoComplDisj tmp(other);
  swap(tmp);
  return *this;
}

void NoComplDisj::swap(NoComplDisj & other)
{

}

NoComplDisj::~NoComplDisj()
{

}

void NoComplDisj::accept(Visitor *v)
{
  v->visitNoComplDisj(this);
}

NoComplDisj *NoComplDisj::clone() const
{
  return new NoComplDisj(*this);
}



/********************   SomeComplDisj    ********************/
SomeComplDisj::SomeComplDisj(NECompleteOrDisjoint *p1)
{
  necompleteordisjoint_ = p1;

}

SomeComplDisj::SomeComplDisj(const SomeComplDisj & other)
{
  necompleteordisjoint_ = other.necompleteordisjoint_->clone();

}

SomeComplDisj &SomeComplDisj::operator=(const SomeComplDisj & other)
{
  SomeComplDisj tmp(other);
  swap(tmp);
  return *this;
}

void SomeComplDisj::swap(SomeComplDisj & other)
{
  std::swap(necompleteordisjoint_, other.necompleteordisjoint_);

}

SomeComplDisj::~SomeComplDisj()
{
  delete(necompleteordisjoint_);

}

void SomeComplDisj::accept(Visitor *v)
{
  v->visitSomeComplDisj(this);
}

SomeComplDisj *SomeComplDisj::clone() const
{
  return new SomeComplDisj(*this);
}



/********************   CompleteBehavior    ********************/
CompleteBehavior::CompleteBehavior(BehaviorNameList *p1, CompleteOrDisjoint *p2)
{
  behaviornamelist_ = p1;
  completeordisjoint_ = p2;

}

CompleteBehavior::CompleteBehavior(const CompleteBehavior & other)
{
  behaviornamelist_ = other.behaviornamelist_->clone();
  completeordisjoint_ = other.completeordisjoint_->clone();

}

CompleteBehavior &CompleteBehavior::operator=(const CompleteBehavior & other)
{
  CompleteBehavior tmp(other);
  swap(tmp);
  return *this;
}

void CompleteBehavior::swap(CompleteBehavior & other)
{
  std::swap(behaviornamelist_, other.behaviornamelist_);
  std::swap(completeordisjoint_, other.completeordisjoint_);

}

CompleteBehavior::~CompleteBehavior()
{
  delete(behaviornamelist_);
  delete(completeordisjoint_);

}

void CompleteBehavior::accept(Visitor *v)
{
  v->visitCompleteBehavior(this);
}

CompleteBehavior *CompleteBehavior::clone() const
{
  return new CompleteBehavior(*this);
}



/********************   DisjointBehavior    ********************/
DisjointBehavior::DisjointBehavior(BehaviorNameList *p1, CompleteOrDisjoint *p2)
{
  behaviornamelist_ = p1;
  completeordisjoint_ = p2;

}

DisjointBehavior::DisjointBehavior(const DisjointBehavior & other)
{
  behaviornamelist_ = other.behaviornamelist_->clone();
  completeordisjoint_ = other.completeordisjoint_->clone();

}

DisjointBehavior &DisjointBehavior::operator=(const DisjointBehavior & other)
{
  DisjointBehavior tmp(other);
  swap(tmp);
  return *this;
}

void DisjointBehavior::swap(DisjointBehavior & other)
{
  std::swap(behaviornamelist_, other.behaviornamelist_);
  std::swap(completeordisjoint_, other.completeordisjoint_);

}

DisjointBehavior::~DisjointBehavior()
{
  delete(behaviornamelist_);
  delete(completeordisjoint_);

}

void DisjointBehavior::accept(Visitor *v)
{
  v->visitDisjointBehavior(this);
}

DisjointBehavior *DisjointBehavior::clone() const
{
  return new DisjointBehavior(*this);
}



/********************   CompleteBehaviorClause    ********************/
CompleteBehaviorClause::CompleteBehaviorClause(ListBehaviorName *p1, ClauseKW *p2)
{
  listbehaviorname_ = p1;
  clausekw_ = p2;

}

CompleteBehaviorClause::CompleteBehaviorClause(const CompleteBehaviorClause & other)
{
  listbehaviorname_ = other.listbehaviorname_->clone();
  clausekw_ = other.clausekw_->clone();

}

CompleteBehaviorClause &CompleteBehaviorClause::operator=(const CompleteBehaviorClause & other)
{
  CompleteBehaviorClause tmp(other);
  swap(tmp);
  return *this;
}

void CompleteBehaviorClause::swap(CompleteBehaviorClause & other)
{
  std::swap(listbehaviorname_, other.listbehaviorname_);
  std::swap(clausekw_, other.clausekw_);

}

CompleteBehaviorClause::~CompleteBehaviorClause()
{
  delete(listbehaviorname_);
  delete(clausekw_);

}

void CompleteBehaviorClause::accept(Visitor *v)
{
  v->visitCompleteBehaviorClause(this);
}

CompleteBehaviorClause *CompleteBehaviorClause::clone() const
{
  return new CompleteBehaviorClause(*this);
}



/********************   DisjointBehaviorClause    ********************/
DisjointBehaviorClause::DisjointBehaviorClause(ListBehaviorName *p1, ClauseKW *p2)
{
  listbehaviorname_ = p1;
  clausekw_ = p2;

}

DisjointBehaviorClause::DisjointBehaviorClause(const DisjointBehaviorClause & other)
{
  listbehaviorname_ = other.listbehaviorname_->clone();
  clausekw_ = other.clausekw_->clone();

}

DisjointBehaviorClause &DisjointBehaviorClause::operator=(const DisjointBehaviorClause & other)
{
  DisjointBehaviorClause tmp(other);
  swap(tmp);
  return *this;
}

void DisjointBehaviorClause::swap(DisjointBehaviorClause & other)
{
  std::swap(listbehaviorname_, other.listbehaviorname_);
  std::swap(clausekw_, other.clausekw_);

}

DisjointBehaviorClause::~DisjointBehaviorClause()
{
  delete(listbehaviorname_);
  delete(clausekw_);

}

void DisjointBehaviorClause::accept(Visitor *v)
{
  v->visitDisjointBehaviorClause(this);
}

DisjointBehaviorClause *DisjointBehaviorClause::clone() const
{
  return new DisjointBehaviorClause(*this);
}



/********************   AssignZone    ********************/
AssignZone::AssignZone(Zones *p1)
{
  zones_ = p1;

}

AssignZone::AssignZone(const AssignZone & other)
{
  zones_ = other.zones_->clone();

}

AssignZone &AssignZone::operator=(const AssignZone & other)
{
  AssignZone tmp(other);
  swap(tmp);
  return *this;
}

void AssignZone::swap(AssignZone & other)
{
  std::swap(zones_, other.zones_);

}

AssignZone::~AssignZone()
{
  delete(zones_);

}

void AssignZone::accept(Visitor *v)
{
  v->visitAssignZone(this);
}

AssignZone *AssignZone::clone() const
{
  return new AssignZone(*this);
}



/********************   AssignZoneFromZone    ********************/
AssignZoneFromZone::AssignZoneFromZone(ListLexpr *p1, Zones *p2)
{
  listlexpr_ = p1;
  zones_ = p2;

}

AssignZoneFromZone::AssignZoneFromZone(const AssignZoneFromZone & other)
{
  listlexpr_ = other.listlexpr_->clone();
  zones_ = other.zones_->clone();

}

AssignZoneFromZone &AssignZoneFromZone::operator=(const AssignZoneFromZone & other)
{
  AssignZoneFromZone tmp(other);
  swap(tmp);
  return *this;
}

void AssignZoneFromZone::swap(AssignZoneFromZone & other)
{
  std::swap(listlexpr_, other.listlexpr_);
  std::swap(zones_, other.zones_);

}

AssignZoneFromZone::~AssignZoneFromZone()
{
  delete(listlexpr_);
  delete(zones_);

}

void AssignZoneFromZone::accept(Visitor *v)
{
  v->visitAssignZoneFromZone(this);
}

AssignZoneFromZone *AssignZoneFromZone::clone() const
{
  return new AssignZoneFromZone(*this);
}



/********************   SomeZone    ********************/
SomeZone::SomeZone(ListLexpr *p1)
{
  listlexpr_ = p1;

}

SomeZone::SomeZone(const SomeZone & other)
{
  listlexpr_ = other.listlexpr_->clone();

}

SomeZone &SomeZone::operator=(const SomeZone & other)
{
  SomeZone tmp(other);
  swap(tmp);
  return *this;
}

void SomeZone::swap(SomeZone & other)
{
  std::swap(listlexpr_, other.listlexpr_);

}

SomeZone::~SomeZone()
{
  delete(listlexpr_);

}

void SomeZone::accept(Visitor *v)
{
  v->visitSomeZone(this);
}

SomeZone *SomeZone::clone() const
{
  return new SomeZone(*this);
}



/********************   NoZone    ********************/
NoZone::NoZone()
{

}

NoZone::NoZone(const NoZone & other)
{

}

NoZone &NoZone::operator=(const NoZone & other)
{
  NoZone tmp(other);
  swap(tmp);
  return *this;
}

void NoZone::swap(NoZone & other)
{

}

NoZone::~NoZone()
{

}

void NoZone::accept(Visitor *v)
{
  v->visitNoZone(this);
}

NoZone *NoZone::clone() const
{
  return new NoZone(*this);
}



/********************   AnAnnotation    ********************/
AnAnnotation::AnAnnotation(Annotation *p1)
{
  annotation_ = p1;

}

AnAnnotation::AnAnnotation(const AnAnnotation & other)
{
  annotation_ = other.annotation_->clone();

}

AnAnnotation &AnAnnotation::operator=(const AnAnnotation & other)
{
  AnAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void AnAnnotation::swap(AnAnnotation & other)
{
  std::swap(annotation_, other.annotation_);

}

AnAnnotation::~AnAnnotation()
{
  delete(annotation_);

}

void AnAnnotation::accept(Visitor *v)
{
  v->visitAnAnnotation(this);
}

AnAnnotation *AnAnnotation::clone() const
{
  return new AnAnnotation(*this);
}



/********************   ACSLSpec    ********************/
ACSLSpec::ACSLSpec(IsACSLSpec *p1, ListWildcard *p2)
{
  isacslspec_ = p1;
  listwildcard_ = p2;

}

ACSLSpec::ACSLSpec(const ACSLSpec & other)
{
  isacslspec_ = other.isacslspec_->clone();
  listwildcard_ = other.listwildcard_->clone();

}

ACSLSpec &ACSLSpec::operator=(const ACSLSpec & other)
{
  ACSLSpec tmp(other);
  swap(tmp);
  return *this;
}

void ACSLSpec::swap(ACSLSpec & other)
{
  std::swap(isacslspec_, other.isacslspec_);
  std::swap(listwildcard_, other.listwildcard_);

}

ACSLSpec::~ACSLSpec()
{
  delete(isacslspec_);
  delete(listwildcard_);

}

void ACSLSpec::accept(Visitor *v)
{
  v->visitACSLSpec(this);
}

ACSLSpec *ACSLSpec::clone() const
{
  return new ACSLSpec(*this);
}



/********************   AnnotDecl    ********************/
AnnotDecl::AnnotDecl(ListDecl *p1)
{
  listdecl_ = p1;

}

AnnotDecl::AnnotDecl(const AnnotDecl & other)
{
  listdecl_ = other.listdecl_->clone();

}

AnnotDecl &AnnotDecl::operator=(const AnnotDecl & other)
{
  AnnotDecl tmp(other);
  swap(tmp);
  return *this;
}

void AnnotDecl::swap(AnnotDecl & other)
{
  std::swap(listdecl_, other.listdecl_);

}

AnnotDecl::~AnnotDecl()
{
  delete(listdecl_);

}

void AnnotDecl::accept(Visitor *v)
{
  v->visitAnnotDecl(this);
}

AnnotDecl *AnnotDecl::clone() const
{
  return new AnnotDecl(*this);
}



/********************   LoopAnnotation    ********************/
LoopAnnotation::LoopAnnotation(LoopAnnotStack *p1)
{
  loopannotstack_ = p1;

}

LoopAnnotation::LoopAnnotation(const LoopAnnotation & other)
{
  loopannotstack_ = other.loopannotstack_->clone();

}

LoopAnnotation &LoopAnnotation::operator=(const LoopAnnotation & other)
{
  LoopAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotation::swap(LoopAnnotation & other)
{
  std::swap(loopannotstack_, other.loopannotstack_);

}

LoopAnnotation::~LoopAnnotation()
{
  delete(loopannotstack_);

}

void LoopAnnotation::accept(Visitor *v)
{
  v->visitLoopAnnotation(this);
}

LoopAnnotation *LoopAnnotation::clone() const
{
  return new LoopAnnotation(*this);
}



/********************   ForContractAnnotation    ********************/
ForContractAnnotation::ForContractAnnotation(ListBehaviorName *p1, Contract *p2)
{
  listbehaviorname_ = p1;
  contract_ = p2;

}

ForContractAnnotation::ForContractAnnotation(const ForContractAnnotation & other)
{
  listbehaviorname_ = other.listbehaviorname_->clone();
  contract_ = other.contract_->clone();

}

ForContractAnnotation &ForContractAnnotation::operator=(const ForContractAnnotation & other)
{
  ForContractAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void ForContractAnnotation::swap(ForContractAnnotation & other)
{
  std::swap(listbehaviorname_, other.listbehaviorname_);
  std::swap(contract_, other.contract_);

}

ForContractAnnotation::~ForContractAnnotation()
{
  delete(listbehaviorname_);
  delete(contract_);

}

void ForContractAnnotation::accept(Visitor *v)
{
  v->visitForContractAnnotation(this);
}

ForContractAnnotation *ForContractAnnotation::clone() const
{
  return new ForContractAnnotation(*this);
}



/********************   ForCodeAnnotation    ********************/
ForCodeAnnotation::ForCodeAnnotation(ListBehaviorName *p1, CodeAnnotation *p2)
{
  listbehaviorname_ = p1;
  codeannotation_ = p2;

}

ForCodeAnnotation::ForCodeAnnotation(const ForCodeAnnotation & other)
{
  listbehaviorname_ = other.listbehaviorname_->clone();
  codeannotation_ = other.codeannotation_->clone();

}

ForCodeAnnotation &ForCodeAnnotation::operator=(const ForCodeAnnotation & other)
{
  ForCodeAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void ForCodeAnnotation::swap(ForCodeAnnotation & other)
{
  std::swap(listbehaviorname_, other.listbehaviorname_);
  std::swap(codeannotation_, other.codeannotation_);

}

ForCodeAnnotation::~ForCodeAnnotation()
{
  delete(listbehaviorname_);
  delete(codeannotation_);

}

void ForCodeAnnotation::accept(Visitor *v)
{
  v->visitForCodeAnnotation(this);
}

ForCodeAnnotation *ForCodeAnnotation::clone() const
{
  return new ForCodeAnnotation(*this);
}



/********************   SimplePragmaOrCodeAnnotation    ********************/
SimplePragmaOrCodeAnnotation::SimplePragmaOrCodeAnnotation(PragmaOrCodeAnnotation *p1)
{
  pragmaorcodeannotation_ = p1;

}

SimplePragmaOrCodeAnnotation::SimplePragmaOrCodeAnnotation(const SimplePragmaOrCodeAnnotation & other)
{
  pragmaorcodeannotation_ = other.pragmaorcodeannotation_->clone();

}

SimplePragmaOrCodeAnnotation &SimplePragmaOrCodeAnnotation::operator=(const SimplePragmaOrCodeAnnotation & other)
{
  SimplePragmaOrCodeAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void SimplePragmaOrCodeAnnotation::swap(SimplePragmaOrCodeAnnotation & other)
{
  std::swap(pragmaorcodeannotation_, other.pragmaorcodeannotation_);

}

SimplePragmaOrCodeAnnotation::~SimplePragmaOrCodeAnnotation()
{
  delete(pragmaorcodeannotation_);

}

void SimplePragmaOrCodeAnnotation::accept(Visitor *v)
{
  v->visitSimplePragmaOrCodeAnnotation(this);
}

SimplePragmaOrCodeAnnotation *SimplePragmaOrCodeAnnotation::clone() const
{
  return new SimplePragmaOrCodeAnnotation(*this);
}



/********************   PragmaOrCodeAnnotationBeg    ********************/
PragmaOrCodeAnnotationBeg::PragmaOrCodeAnnotationBeg(PragmaOrCodeAnnotation *p1, BegPragmaOrCodeAnnotation *p2)
{
  pragmaorcodeannotation_ = p1;
  begpragmaorcodeannotation_ = p2;

}

PragmaOrCodeAnnotationBeg::PragmaOrCodeAnnotationBeg(const PragmaOrCodeAnnotationBeg & other)
{
  pragmaorcodeannotation_ = other.pragmaorcodeannotation_->clone();
  begpragmaorcodeannotation_ = other.begpragmaorcodeannotation_->clone();

}

PragmaOrCodeAnnotationBeg &PragmaOrCodeAnnotationBeg::operator=(const PragmaOrCodeAnnotationBeg & other)
{
  PragmaOrCodeAnnotationBeg tmp(other);
  swap(tmp);
  return *this;
}

void PragmaOrCodeAnnotationBeg::swap(PragmaOrCodeAnnotationBeg & other)
{
  std::swap(pragmaorcodeannotation_, other.pragmaorcodeannotation_);
  std::swap(begpragmaorcodeannotation_, other.begpragmaorcodeannotation_);

}

PragmaOrCodeAnnotationBeg::~PragmaOrCodeAnnotationBeg()
{
  delete(pragmaorcodeannotation_);
  delete(begpragmaorcodeannotation_);

}

void PragmaOrCodeAnnotationBeg::accept(Visitor *v)
{
  v->visitPragmaOrCodeAnnotationBeg(this);
}

PragmaOrCodeAnnotationBeg *PragmaOrCodeAnnotationBeg::clone() const
{
  return new PragmaOrCodeAnnotationBeg(*this);
}



/********************   IdentifierAnnotation    ********************/
IdentifierAnnotation::IdentifierAnnotation(Identifier *p1)
{
  identifier_ = p1;

}

IdentifierAnnotation::IdentifierAnnotation(const IdentifierAnnotation & other)
{
  identifier_ = other.identifier_->clone();

}

IdentifierAnnotation &IdentifierAnnotation::operator=(const IdentifierAnnotation & other)
{
  IdentifierAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierAnnotation::swap(IdentifierAnnotation & other)
{
  std::swap(identifier_, other.identifier_);

}

IdentifierAnnotation::~IdentifierAnnotation()
{
  delete(identifier_);

}

void IdentifierAnnotation::accept(Visitor *v)
{
  v->visitIdentifierAnnotation(this);
}

IdentifierAnnotation *IdentifierAnnotation::clone() const
{
  return new IdentifierAnnotation(*this);
}



/********************   GhostAnnotation    ********************/
GhostAnnotation::GhostAnnotation()
{

}

GhostAnnotation::GhostAnnotation(const GhostAnnotation & other)
{

}

GhostAnnotation &GhostAnnotation::operator=(const GhostAnnotation & other)
{
  GhostAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void GhostAnnotation::swap(GhostAnnotation & other)
{

}

GhostAnnotation::~GhostAnnotation()
{

}

void GhostAnnotation::accept(Visitor *v)
{
  v->visitGhostAnnotation(this);
}

GhostAnnotation *GhostAnnotation::clone() const
{
  return new GhostAnnotation(*this);
}



/********************   LoopAnnotStackInvariant    ********************/
LoopAnnotStackInvariant::LoopAnnotStackInvariant(LoopInvariant *p1, LoopAnnotOpt *p2)
{
  loopinvariant_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackInvariant::LoopAnnotStackInvariant(const LoopAnnotStackInvariant & other)
{
  loopinvariant_ = other.loopinvariant_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackInvariant &LoopAnnotStackInvariant::operator=(const LoopAnnotStackInvariant & other)
{
  LoopAnnotStackInvariant tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackInvariant::swap(LoopAnnotStackInvariant & other)
{
  std::swap(loopinvariant_, other.loopinvariant_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackInvariant::~LoopAnnotStackInvariant()
{
  delete(loopinvariant_);
  delete(loopannotopt_);

}

void LoopAnnotStackInvariant::accept(Visitor *v)
{
  v->visitLoopAnnotStackInvariant(this);
}

LoopAnnotStackInvariant *LoopAnnotStackInvariant::clone() const
{
  return new LoopAnnotStackInvariant(*this);
}



/********************   LoopAnnotStackEffects    ********************/
LoopAnnotStackEffects::LoopAnnotStackEffects(LoopEffects *p1, LoopAnnotOpt *p2)
{
  loopeffects_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackEffects::LoopAnnotStackEffects(const LoopAnnotStackEffects & other)
{
  loopeffects_ = other.loopeffects_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackEffects &LoopAnnotStackEffects::operator=(const LoopAnnotStackEffects & other)
{
  LoopAnnotStackEffects tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackEffects::swap(LoopAnnotStackEffects & other)
{
  std::swap(loopeffects_, other.loopeffects_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackEffects::~LoopAnnotStackEffects()
{
  delete(loopeffects_);
  delete(loopannotopt_);

}

void LoopAnnotStackEffects::accept(Visitor *v)
{
  v->visitLoopAnnotStackEffects(this);
}

LoopAnnotStackEffects *LoopAnnotStackEffects::clone() const
{
  return new LoopAnnotStackEffects(*this);
}



/********************   LoopAnnotStackAllocation    ********************/
LoopAnnotStackAllocation::LoopAnnotStackAllocation(LoopAllocation *p1, LoopAnnotOpt *p2)
{
  loopallocation_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackAllocation::LoopAnnotStackAllocation(const LoopAnnotStackAllocation & other)
{
  loopallocation_ = other.loopallocation_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackAllocation &LoopAnnotStackAllocation::operator=(const LoopAnnotStackAllocation & other)
{
  LoopAnnotStackAllocation tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackAllocation::swap(LoopAnnotStackAllocation & other)
{
  std::swap(loopallocation_, other.loopallocation_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackAllocation::~LoopAnnotStackAllocation()
{
  delete(loopallocation_);
  delete(loopannotopt_);

}

void LoopAnnotStackAllocation::accept(Visitor *v)
{
  v->visitLoopAnnotStackAllocation(this);
}

LoopAnnotStackAllocation *LoopAnnotStackAllocation::clone() const
{
  return new LoopAnnotStackAllocation(*this);
}



/********************   LoopAnnotStackForBehavior    ********************/
LoopAnnotStackForBehavior::LoopAnnotStackForBehavior(ListBehaviorName *p1, LoopAnnotStack *p2)
{
  listbehaviorname_ = p1;
  loopannotstack_ = p2;

}

LoopAnnotStackForBehavior::LoopAnnotStackForBehavior(const LoopAnnotStackForBehavior & other)
{
  listbehaviorname_ = other.listbehaviorname_->clone();
  loopannotstack_ = other.loopannotstack_->clone();

}

LoopAnnotStackForBehavior &LoopAnnotStackForBehavior::operator=(const LoopAnnotStackForBehavior & other)
{
  LoopAnnotStackForBehavior tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackForBehavior::swap(LoopAnnotStackForBehavior & other)
{
  std::swap(listbehaviorname_, other.listbehaviorname_);
  std::swap(loopannotstack_, other.loopannotstack_);

}

LoopAnnotStackForBehavior::~LoopAnnotStackForBehavior()
{
  delete(listbehaviorname_);
  delete(loopannotstack_);

}

void LoopAnnotStackForBehavior::accept(Visitor *v)
{
  v->visitLoopAnnotStackForBehavior(this);
}

LoopAnnotStackForBehavior *LoopAnnotStackForBehavior::clone() const
{
  return new LoopAnnotStackForBehavior(*this);
}



/********************   LoopAnnotStackVariant    ********************/
LoopAnnotStackVariant::LoopAnnotStackVariant(LoopVariant *p1, LoopAnnotOpt *p2)
{
  loopvariant_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackVariant::LoopAnnotStackVariant(const LoopAnnotStackVariant & other)
{
  loopvariant_ = other.loopvariant_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackVariant &LoopAnnotStackVariant::operator=(const LoopAnnotStackVariant & other)
{
  LoopAnnotStackVariant tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackVariant::swap(LoopAnnotStackVariant & other)
{
  std::swap(loopvariant_, other.loopvariant_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackVariant::~LoopAnnotStackVariant()
{
  delete(loopvariant_);
  delete(loopannotopt_);

}

void LoopAnnotStackVariant::accept(Visitor *v)
{
  v->visitLoopAnnotStackVariant(this);
}

LoopAnnotStackVariant *LoopAnnotStackVariant::clone() const
{
  return new LoopAnnotStackVariant(*this);
}



/********************   LoopAnnotStackPragma    ********************/
LoopAnnotStackPragma::LoopAnnotStackPragma(LoopPragma *p1, LoopAnnotOpt *p2)
{
  looppragma_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackPragma::LoopAnnotStackPragma(const LoopAnnotStackPragma & other)
{
  looppragma_ = other.looppragma_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackPragma &LoopAnnotStackPragma::operator=(const LoopAnnotStackPragma & other)
{
  LoopAnnotStackPragma tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackPragma::swap(LoopAnnotStackPragma & other)
{
  std::swap(looppragma_, other.looppragma_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackPragma::~LoopAnnotStackPragma()
{
  delete(looppragma_);
  delete(loopannotopt_);

}

void LoopAnnotStackPragma::accept(Visitor *v)
{
  v->visitLoopAnnotStackPragma(this);
}

LoopAnnotStackPragma *LoopAnnotStackPragma::clone() const
{
  return new LoopAnnotStackPragma(*this);
}



/********************   LoopAnnotStackGrammarExten    ********************/
LoopAnnotStackGrammarExten::LoopAnnotStackGrammarExten(LoopGrammarExtension *p1, LoopAnnotOpt *p2)
{
  loopgrammarextension_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackGrammarExten::LoopAnnotStackGrammarExten(const LoopAnnotStackGrammarExten & other)
{
  loopgrammarextension_ = other.loopgrammarextension_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackGrammarExten &LoopAnnotStackGrammarExten::operator=(const LoopAnnotStackGrammarExten & other)
{
  LoopAnnotStackGrammarExten tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackGrammarExten::swap(LoopAnnotStackGrammarExten & other)
{
  std::swap(loopgrammarextension_, other.loopgrammarextension_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackGrammarExten::~LoopAnnotStackGrammarExten()
{
  delete(loopgrammarextension_);
  delete(loopannotopt_);

}

void LoopAnnotStackGrammarExten::accept(Visitor *v)
{
  v->visitLoopAnnotStackGrammarExten(this);
}

LoopAnnotStackGrammarExten *LoopAnnotStackGrammarExten::clone() const
{
  return new LoopAnnotStackGrammarExten(*this);
}



/********************   NoLoopAnnot    ********************/
NoLoopAnnot::NoLoopAnnot()
{

}

NoLoopAnnot::NoLoopAnnot(const NoLoopAnnot & other)
{

}

NoLoopAnnot &NoLoopAnnot::operator=(const NoLoopAnnot & other)
{
  NoLoopAnnot tmp(other);
  swap(tmp);
  return *this;
}

void NoLoopAnnot::swap(NoLoopAnnot & other)
{

}

NoLoopAnnot::~NoLoopAnnot()
{

}

void NoLoopAnnot::accept(Visitor *v)
{
  v->visitNoLoopAnnot(this);
}

NoLoopAnnot *NoLoopAnnot::clone() const
{
  return new NoLoopAnnot(*this);
}



/********************   SomeLoopAnnot    ********************/
SomeLoopAnnot::SomeLoopAnnot(LoopAnnotStack *p1)
{
  loopannotstack_ = p1;

}

SomeLoopAnnot::SomeLoopAnnot(const SomeLoopAnnot & other)
{
  loopannotstack_ = other.loopannotstack_->clone();

}

SomeLoopAnnot &SomeLoopAnnot::operator=(const SomeLoopAnnot & other)
{
  SomeLoopAnnot tmp(other);
  swap(tmp);
  return *this;
}

void SomeLoopAnnot::swap(SomeLoopAnnot & other)
{
  std::swap(loopannotstack_, other.loopannotstack_);

}

SomeLoopAnnot::~SomeLoopAnnot()
{
  delete(loopannotstack_);

}

void SomeLoopAnnot::accept(Visitor *v)
{
  v->visitSomeLoopAnnot(this);
}

SomeLoopAnnot *SomeLoopAnnot::clone() const
{
  return new SomeLoopAnnot(*this);
}



/********************   LoopAssigns    ********************/
LoopAssigns::LoopAssigns(Assigns *p1)
{
  assigns_ = p1;

}

LoopAssigns::LoopAssigns(const LoopAssigns & other)
{
  assigns_ = other.assigns_->clone();

}

LoopAssigns &LoopAssigns::operator=(const LoopAssigns & other)
{
  LoopAssigns tmp(other);
  swap(tmp);
  return *this;
}

void LoopAssigns::swap(LoopAssigns & other)
{
  std::swap(assigns_, other.assigns_);

}

LoopAssigns::~LoopAssigns()
{
  delete(assigns_);

}

void LoopAssigns::accept(Visitor *v)
{
  v->visitLoopAssigns(this);
}

LoopAssigns *LoopAssigns::clone() const
{
  return new LoopAssigns(*this);
}



/********************   SimpleLoopAllocation    ********************/
SimpleLoopAllocation::SimpleLoopAllocation(Allocation *p1)
{
  allocation_ = p1;

}

SimpleLoopAllocation::SimpleLoopAllocation(const SimpleLoopAllocation & other)
{
  allocation_ = other.allocation_->clone();

}

SimpleLoopAllocation &SimpleLoopAllocation::operator=(const SimpleLoopAllocation & other)
{
  SimpleLoopAllocation tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLoopAllocation::swap(SimpleLoopAllocation & other)
{
  std::swap(allocation_, other.allocation_);

}

SimpleLoopAllocation::~SimpleLoopAllocation()
{
  delete(allocation_);

}

void SimpleLoopAllocation::accept(Visitor *v)
{
  v->visitSimpleLoopAllocation(this);
}

SimpleLoopAllocation *SimpleLoopAllocation::clone() const
{
  return new SimpleLoopAllocation(*this);
}



/********************   SimpleLoopInvariant    ********************/
SimpleLoopInvariant::SimpleLoopInvariant(Lexpr *p1)
{
  lexpr_ = p1;

}

SimpleLoopInvariant::SimpleLoopInvariant(const SimpleLoopInvariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

SimpleLoopInvariant &SimpleLoopInvariant::operator=(const SimpleLoopInvariant & other)
{
  SimpleLoopInvariant tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLoopInvariant::swap(SimpleLoopInvariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SimpleLoopInvariant::~SimpleLoopInvariant()
{
  delete(lexpr_);

}

void SimpleLoopInvariant::accept(Visitor *v)
{
  v->visitSimpleLoopInvariant(this);
}

SimpleLoopInvariant *SimpleLoopInvariant::clone() const
{
  return new SimpleLoopInvariant(*this);
}



/********************   CheckLoopInvariant    ********************/
CheckLoopInvariant::CheckLoopInvariant(Lexpr *p1)
{
  lexpr_ = p1;

}

CheckLoopInvariant::CheckLoopInvariant(const CheckLoopInvariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

CheckLoopInvariant &CheckLoopInvariant::operator=(const CheckLoopInvariant & other)
{
  CheckLoopInvariant tmp(other);
  swap(tmp);
  return *this;
}

void CheckLoopInvariant::swap(CheckLoopInvariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

CheckLoopInvariant::~CheckLoopInvariant()
{
  delete(lexpr_);

}

void CheckLoopInvariant::accept(Visitor *v)
{
  v->visitCheckLoopInvariant(this);
}

CheckLoopInvariant *CheckLoopInvariant::clone() const
{
  return new CheckLoopInvariant(*this);
}



/********************   AdmitLoopInvariant    ********************/
AdmitLoopInvariant::AdmitLoopInvariant(Lexpr *p1)
{
  lexpr_ = p1;

}

AdmitLoopInvariant::AdmitLoopInvariant(const AdmitLoopInvariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

AdmitLoopInvariant &AdmitLoopInvariant::operator=(const AdmitLoopInvariant & other)
{
  AdmitLoopInvariant tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLoopInvariant::swap(AdmitLoopInvariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AdmitLoopInvariant::~AdmitLoopInvariant()
{
  delete(lexpr_);

}

void AdmitLoopInvariant::accept(Visitor *v)
{
  v->visitAdmitLoopInvariant(this);
}

AdmitLoopInvariant *AdmitLoopInvariant::clone() const
{
  return new AdmitLoopInvariant(*this);
}



/********************   SimpleLoopVariant    ********************/
SimpleLoopVariant::SimpleLoopVariant(Variant *p1)
{
  variant_ = p1;

}

SimpleLoopVariant::SimpleLoopVariant(const SimpleLoopVariant & other)
{
  variant_ = other.variant_->clone();

}

SimpleLoopVariant &SimpleLoopVariant::operator=(const SimpleLoopVariant & other)
{
  SimpleLoopVariant tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLoopVariant::swap(SimpleLoopVariant & other)
{
  std::swap(variant_, other.variant_);

}

SimpleLoopVariant::~SimpleLoopVariant()
{
  delete(variant_);

}

void SimpleLoopVariant::accept(Visitor *v)
{
  v->visitSimpleLoopVariant(this);
}

SimpleLoopVariant *SimpleLoopVariant::clone() const
{
  return new SimpleLoopVariant(*this);
}



/********************   SimpleLoopGrammarExten    ********************/
SimpleLoopGrammarExten::SimpleLoopGrammarExten(EXT_CODE_ANNOT p1, ExtensionContent *p2)
{
  ext_code_annot_ = p1;
  extensioncontent_ = p2;

}

SimpleLoopGrammarExten::SimpleLoopGrammarExten(const SimpleLoopGrammarExten & other)
{
  ext_code_annot_ = other.ext_code_annot_;
  extensioncontent_ = other.extensioncontent_->clone();

}

SimpleLoopGrammarExten &SimpleLoopGrammarExten::operator=(const SimpleLoopGrammarExten & other)
{
  SimpleLoopGrammarExten tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLoopGrammarExten::swap(SimpleLoopGrammarExten & other)
{
  std::swap(ext_code_annot_, other.ext_code_annot_);
  std::swap(extensioncontent_, other.extensioncontent_);

}

SimpleLoopGrammarExten::~SimpleLoopGrammarExten()
{
  delete(extensioncontent_);

}

void SimpleLoopGrammarExten::accept(Visitor *v)
{
  v->visitSimpleLoopGrammarExten(this);
}

SimpleLoopGrammarExten *SimpleLoopGrammarExten::clone() const
{
  return new SimpleLoopGrammarExten(*this);
}



/********************   PragmaLoop    ********************/
PragmaLoop::PragmaLoop(AnyIdentifier *p1, ListLexpr *p2)
{
  anyidentifier_ = p1;
  listlexpr_ = p2;

}

PragmaLoop::PragmaLoop(const PragmaLoop & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  listlexpr_ = other.listlexpr_->clone();

}

PragmaLoop &PragmaLoop::operator=(const PragmaLoop & other)
{
  PragmaLoop tmp(other);
  swap(tmp);
  return *this;
}

void PragmaLoop::swap(PragmaLoop & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(listlexpr_, other.listlexpr_);

}

PragmaLoop::~PragmaLoop()
{
  delete(anyidentifier_);
  delete(listlexpr_);

}

void PragmaLoop::accept(Visitor *v)
{
  v->visitPragmaLoop(this);
}

PragmaLoop *PragmaLoop::clone() const
{
  return new PragmaLoop(*this);
}



/********************   ImpactKeyWordBegPragma    ********************/
ImpactKeyWordBegPragma::ImpactKeyWordBegPragma()
{

}

ImpactKeyWordBegPragma::ImpactKeyWordBegPragma(const ImpactKeyWordBegPragma & other)
{

}

ImpactKeyWordBegPragma &ImpactKeyWordBegPragma::operator=(const ImpactKeyWordBegPragma & other)
{
  ImpactKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void ImpactKeyWordBegPragma::swap(ImpactKeyWordBegPragma & other)
{

}

ImpactKeyWordBegPragma::~ImpactKeyWordBegPragma()
{

}

void ImpactKeyWordBegPragma::accept(Visitor *v)
{
  v->visitImpactKeyWordBegPragma(this);
}

ImpactKeyWordBegPragma *ImpactKeyWordBegPragma::clone() const
{
  return new ImpactKeyWordBegPragma(*this);
}



/********************   SliceKeyWordBegPragma    ********************/
SliceKeyWordBegPragma::SliceKeyWordBegPragma()
{

}

SliceKeyWordBegPragma::SliceKeyWordBegPragma(const SliceKeyWordBegPragma & other)
{

}

SliceKeyWordBegPragma &SliceKeyWordBegPragma::operator=(const SliceKeyWordBegPragma & other)
{
  SliceKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void SliceKeyWordBegPragma::swap(SliceKeyWordBegPragma & other)
{

}

SliceKeyWordBegPragma::~SliceKeyWordBegPragma()
{

}

void SliceKeyWordBegPragma::accept(Visitor *v)
{
  v->visitSliceKeyWordBegPragma(this);
}

SliceKeyWordBegPragma *SliceKeyWordBegPragma::clone() const
{
  return new SliceKeyWordBegPragma(*this);
}



/********************   ForKeyWordBegPragma    ********************/
ForKeyWordBegPragma::ForKeyWordBegPragma()
{

}

ForKeyWordBegPragma::ForKeyWordBegPragma(const ForKeyWordBegPragma & other)
{

}

ForKeyWordBegPragma &ForKeyWordBegPragma::operator=(const ForKeyWordBegPragma & other)
{
  ForKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void ForKeyWordBegPragma::swap(ForKeyWordBegPragma & other)
{

}

ForKeyWordBegPragma::~ForKeyWordBegPragma()
{

}

void ForKeyWordBegPragma::accept(Visitor *v)
{
  v->visitForKeyWordBegPragma(this);
}

ForKeyWordBegPragma *ForKeyWordBegPragma::clone() const
{
  return new ForKeyWordBegPragma(*this);
}



/********************   AssertKeyWordBegPragma    ********************/
AssertKeyWordBegPragma::AssertKeyWordBegPragma()
{

}

AssertKeyWordBegPragma::AssertKeyWordBegPragma(const AssertKeyWordBegPragma & other)
{

}

AssertKeyWordBegPragma &AssertKeyWordBegPragma::operator=(const AssertKeyWordBegPragma & other)
{
  AssertKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void AssertKeyWordBegPragma::swap(AssertKeyWordBegPragma & other)
{

}

AssertKeyWordBegPragma::~AssertKeyWordBegPragma()
{

}

void AssertKeyWordBegPragma::accept(Visitor *v)
{
  v->visitAssertKeyWordBegPragma(this);
}

AssertKeyWordBegPragma *AssertKeyWordBegPragma::clone() const
{
  return new AssertKeyWordBegPragma(*this);
}



/********************   CheckKeyWordBegPragma    ********************/
CheckKeyWordBegPragma::CheckKeyWordBegPragma()
{

}

CheckKeyWordBegPragma::CheckKeyWordBegPragma(const CheckKeyWordBegPragma & other)
{

}

CheckKeyWordBegPragma &CheckKeyWordBegPragma::operator=(const CheckKeyWordBegPragma & other)
{
  CheckKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void CheckKeyWordBegPragma::swap(CheckKeyWordBegPragma & other)
{

}

CheckKeyWordBegPragma::~CheckKeyWordBegPragma()
{

}

void CheckKeyWordBegPragma::accept(Visitor *v)
{
  v->visitCheckKeyWordBegPragma(this);
}

CheckKeyWordBegPragma *CheckKeyWordBegPragma::clone() const
{
  return new CheckKeyWordBegPragma(*this);
}



/********************   AdmitKeyWordBegPragma    ********************/
AdmitKeyWordBegPragma::AdmitKeyWordBegPragma()
{

}

AdmitKeyWordBegPragma::AdmitKeyWordBegPragma(const AdmitKeyWordBegPragma & other)
{

}

AdmitKeyWordBegPragma &AdmitKeyWordBegPragma::operator=(const AdmitKeyWordBegPragma & other)
{
  AdmitKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void AdmitKeyWordBegPragma::swap(AdmitKeyWordBegPragma & other)
{

}

AdmitKeyWordBegPragma::~AdmitKeyWordBegPragma()
{

}

void AdmitKeyWordBegPragma::accept(Visitor *v)
{
  v->visitAdmitKeyWordBegPragma(this);
}

AdmitKeyWordBegPragma *AdmitKeyWordBegPragma::clone() const
{
  return new AdmitKeyWordBegPragma(*this);
}



/********************   InvariantKeyWordBegPragma    ********************/
InvariantKeyWordBegPragma::InvariantKeyWordBegPragma()
{

}

InvariantKeyWordBegPragma::InvariantKeyWordBegPragma(const InvariantKeyWordBegPragma & other)
{

}

InvariantKeyWordBegPragma &InvariantKeyWordBegPragma::operator=(const InvariantKeyWordBegPragma & other)
{
  InvariantKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void InvariantKeyWordBegPragma::swap(InvariantKeyWordBegPragma & other)
{

}

InvariantKeyWordBegPragma::~InvariantKeyWordBegPragma()
{

}

void InvariantKeyWordBegPragma::accept(Visitor *v)
{
  v->visitInvariantKeyWordBegPragma(this);
}

InvariantKeyWordBegPragma *InvariantKeyWordBegPragma::clone() const
{
  return new InvariantKeyWordBegPragma(*this);
}



/********************   CheckInvariantKeyWordBegPragma    ********************/
CheckInvariantKeyWordBegPragma::CheckInvariantKeyWordBegPragma()
{

}

CheckInvariantKeyWordBegPragma::CheckInvariantKeyWordBegPragma(const CheckInvariantKeyWordBegPragma & other)
{

}

CheckInvariantKeyWordBegPragma &CheckInvariantKeyWordBegPragma::operator=(const CheckInvariantKeyWordBegPragma & other)
{
  CheckInvariantKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void CheckInvariantKeyWordBegPragma::swap(CheckInvariantKeyWordBegPragma & other)
{

}

CheckInvariantKeyWordBegPragma::~CheckInvariantKeyWordBegPragma()
{

}

void CheckInvariantKeyWordBegPragma::accept(Visitor *v)
{
  v->visitCheckInvariantKeyWordBegPragma(this);
}

CheckInvariantKeyWordBegPragma *CheckInvariantKeyWordBegPragma::clone() const
{
  return new CheckInvariantKeyWordBegPragma(*this);
}



/********************   AdmitInvariantKeyWordBegPragma    ********************/
AdmitInvariantKeyWordBegPragma::AdmitInvariantKeyWordBegPragma()
{

}

AdmitInvariantKeyWordBegPragma::AdmitInvariantKeyWordBegPragma(const AdmitInvariantKeyWordBegPragma & other)
{

}

AdmitInvariantKeyWordBegPragma &AdmitInvariantKeyWordBegPragma::operator=(const AdmitInvariantKeyWordBegPragma & other)
{
  AdmitInvariantKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void AdmitInvariantKeyWordBegPragma::swap(AdmitInvariantKeyWordBegPragma & other)
{

}

AdmitInvariantKeyWordBegPragma::~AdmitInvariantKeyWordBegPragma()
{

}

void AdmitInvariantKeyWordBegPragma::accept(Visitor *v)
{
  v->visitAdmitInvariantKeyWordBegPragma(this);
}

AdmitInvariantKeyWordBegPragma *AdmitInvariantKeyWordBegPragma::clone() const
{
  return new AdmitInvariantKeyWordBegPragma(*this);
}



/********************   CheckLoopKeyWordBegPragma    ********************/
CheckLoopKeyWordBegPragma::CheckLoopKeyWordBegPragma()
{

}

CheckLoopKeyWordBegPragma::CheckLoopKeyWordBegPragma(const CheckLoopKeyWordBegPragma & other)
{

}

CheckLoopKeyWordBegPragma &CheckLoopKeyWordBegPragma::operator=(const CheckLoopKeyWordBegPragma & other)
{
  CheckLoopKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void CheckLoopKeyWordBegPragma::swap(CheckLoopKeyWordBegPragma & other)
{

}

CheckLoopKeyWordBegPragma::~CheckLoopKeyWordBegPragma()
{

}

void CheckLoopKeyWordBegPragma::accept(Visitor *v)
{
  v->visitCheckLoopKeyWordBegPragma(this);
}

CheckLoopKeyWordBegPragma *CheckLoopKeyWordBegPragma::clone() const
{
  return new CheckLoopKeyWordBegPragma(*this);
}



/********************   AdmitLoopKeyWordBegPragma    ********************/
AdmitLoopKeyWordBegPragma::AdmitLoopKeyWordBegPragma()
{

}

AdmitLoopKeyWordBegPragma::AdmitLoopKeyWordBegPragma(const AdmitLoopKeyWordBegPragma & other)
{

}

AdmitLoopKeyWordBegPragma &AdmitLoopKeyWordBegPragma::operator=(const AdmitLoopKeyWordBegPragma & other)
{
  AdmitLoopKeyWordBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLoopKeyWordBegPragma::swap(AdmitLoopKeyWordBegPragma & other)
{

}

AdmitLoopKeyWordBegPragma::~AdmitLoopKeyWordBegPragma()
{

}

void AdmitLoopKeyWordBegPragma::accept(Visitor *v)
{
  v->visitAdmitLoopKeyWordBegPragma(this);
}

AdmitLoopKeyWordBegPragma *AdmitLoopKeyWordBegPragma::clone() const
{
  return new AdmitLoopKeyWordBegPragma(*this);
}



/********************   BegExtCodeAnnotBegPragma    ********************/
BegExtCodeAnnotBegPragma::BegExtCodeAnnotBegPragma(EXT_CODE_ANNOT p1)
{
  ext_code_annot_ = p1;

}

BegExtCodeAnnotBegPragma::BegExtCodeAnnotBegPragma(const BegExtCodeAnnotBegPragma & other)
{
  ext_code_annot_ = other.ext_code_annot_;

}

BegExtCodeAnnotBegPragma &BegExtCodeAnnotBegPragma::operator=(const BegExtCodeAnnotBegPragma & other)
{
  BegExtCodeAnnotBegPragma tmp(other);
  swap(tmp);
  return *this;
}

void BegExtCodeAnnotBegPragma::swap(BegExtCodeAnnotBegPragma & other)
{
  std::swap(ext_code_annot_, other.ext_code_annot_);

}

BegExtCodeAnnotBegPragma::~BegExtCodeAnnotBegPragma()
{

}

void BegExtCodeAnnotBegPragma::accept(Visitor *v)
{
  v->visitBegExtCodeAnnotBegPragma(this);
}

BegExtCodeAnnotBegPragma *BegExtCodeAnnotBegPragma::clone() const
{
  return new BegExtCodeAnnotBegPragma(*this);
}



/********************   PragmaCodeAnnotSlice    ********************/
PragmaCodeAnnotSlice::PragmaCodeAnnotSlice(SlicePragma *p1)
{
  slicepragma_ = p1;

}

PragmaCodeAnnotSlice::PragmaCodeAnnotSlice(const PragmaCodeAnnotSlice & other)
{
  slicepragma_ = other.slicepragma_->clone();

}

PragmaCodeAnnotSlice &PragmaCodeAnnotSlice::operator=(const PragmaCodeAnnotSlice & other)
{
  PragmaCodeAnnotSlice tmp(other);
  swap(tmp);
  return *this;
}

void PragmaCodeAnnotSlice::swap(PragmaCodeAnnotSlice & other)
{
  std::swap(slicepragma_, other.slicepragma_);

}

PragmaCodeAnnotSlice::~PragmaCodeAnnotSlice()
{
  delete(slicepragma_);

}

void PragmaCodeAnnotSlice::accept(Visitor *v)
{
  v->visitPragmaCodeAnnotSlice(this);
}

PragmaCodeAnnotSlice *PragmaCodeAnnotSlice::clone() const
{
  return new PragmaCodeAnnotSlice(*this);
}



/********************   PragmaCodeAnnotImpact    ********************/
PragmaCodeAnnotImpact::PragmaCodeAnnotImpact(ImpactPragma *p1)
{
  impactpragma_ = p1;

}

PragmaCodeAnnotImpact::PragmaCodeAnnotImpact(const PragmaCodeAnnotImpact & other)
{
  impactpragma_ = other.impactpragma_->clone();

}

PragmaCodeAnnotImpact &PragmaCodeAnnotImpact::operator=(const PragmaCodeAnnotImpact & other)
{
  PragmaCodeAnnotImpact tmp(other);
  swap(tmp);
  return *this;
}

void PragmaCodeAnnotImpact::swap(PragmaCodeAnnotImpact & other)
{
  std::swap(impactpragma_, other.impactpragma_);

}

PragmaCodeAnnotImpact::~PragmaCodeAnnotImpact()
{
  delete(impactpragma_);

}

void PragmaCodeAnnotImpact::accept(Visitor *v)
{
  v->visitPragmaCodeAnnotImpact(this);
}

PragmaCodeAnnotImpact *PragmaCodeAnnotImpact::clone() const
{
  return new PragmaCodeAnnotImpact(*this);
}



/********************   PragmaOrCodeAnnotCodeAnnot    ********************/
PragmaOrCodeAnnotCodeAnnot::PragmaOrCodeAnnotCodeAnnot(CodeAnnotation *p1)
{
  codeannotation_ = p1;

}

PragmaOrCodeAnnotCodeAnnot::PragmaOrCodeAnnotCodeAnnot(const PragmaOrCodeAnnotCodeAnnot & other)
{
  codeannotation_ = other.codeannotation_->clone();

}

PragmaOrCodeAnnotCodeAnnot &PragmaOrCodeAnnotCodeAnnot::operator=(const PragmaOrCodeAnnotCodeAnnot & other)
{
  PragmaOrCodeAnnotCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void PragmaOrCodeAnnotCodeAnnot::swap(PragmaOrCodeAnnotCodeAnnot & other)
{
  std::swap(codeannotation_, other.codeannotation_);

}

PragmaOrCodeAnnotCodeAnnot::~PragmaOrCodeAnnotCodeAnnot()
{
  delete(codeannotation_);

}

void PragmaOrCodeAnnotCodeAnnot::accept(Visitor *v)
{
  v->visitPragmaOrCodeAnnotCodeAnnot(this);
}

PragmaOrCodeAnnotCodeAnnot *PragmaOrCodeAnnotCodeAnnot::clone() const
{
  return new PragmaOrCodeAnnotCodeAnnot(*this);
}



/********************   AssertCodeAnnot    ********************/
AssertCodeAnnot::AssertCodeAnnot(Lexpr *p1)
{
  lexpr_ = p1;

}

AssertCodeAnnot::AssertCodeAnnot(const AssertCodeAnnot & other)
{
  lexpr_ = other.lexpr_->clone();

}

AssertCodeAnnot &AssertCodeAnnot::operator=(const AssertCodeAnnot & other)
{
  AssertCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void AssertCodeAnnot::swap(AssertCodeAnnot & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AssertCodeAnnot::~AssertCodeAnnot()
{
  delete(lexpr_);

}

void AssertCodeAnnot::accept(Visitor *v)
{
  v->visitAssertCodeAnnot(this);
}

AssertCodeAnnot *AssertCodeAnnot::clone() const
{
  return new AssertCodeAnnot(*this);
}



/********************   CheckCodeAnnot    ********************/
CheckCodeAnnot::CheckCodeAnnot(Lexpr *p1)
{
  lexpr_ = p1;

}

CheckCodeAnnot::CheckCodeAnnot(const CheckCodeAnnot & other)
{
  lexpr_ = other.lexpr_->clone();

}

CheckCodeAnnot &CheckCodeAnnot::operator=(const CheckCodeAnnot & other)
{
  CheckCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void CheckCodeAnnot::swap(CheckCodeAnnot & other)
{
  std::swap(lexpr_, other.lexpr_);

}

CheckCodeAnnot::~CheckCodeAnnot()
{
  delete(lexpr_);

}

void CheckCodeAnnot::accept(Visitor *v)
{
  v->visitCheckCodeAnnot(this);
}

CheckCodeAnnot *CheckCodeAnnot::clone() const
{
  return new CheckCodeAnnot(*this);
}



/********************   AdmitCodeAnnot    ********************/
AdmitCodeAnnot::AdmitCodeAnnot(Lexpr *p1)
{
  lexpr_ = p1;

}

AdmitCodeAnnot::AdmitCodeAnnot(const AdmitCodeAnnot & other)
{
  lexpr_ = other.lexpr_->clone();

}

AdmitCodeAnnot &AdmitCodeAnnot::operator=(const AdmitCodeAnnot & other)
{
  AdmitCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void AdmitCodeAnnot::swap(AdmitCodeAnnot & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AdmitCodeAnnot::~AdmitCodeAnnot()
{
  delete(lexpr_);

}

void AdmitCodeAnnot::accept(Visitor *v)
{
  v->visitAdmitCodeAnnot(this);
}

AdmitCodeAnnot *AdmitCodeAnnot::clone() const
{
  return new AdmitCodeAnnot(*this);
}



/********************   InvariantCodeAnnot    ********************/
InvariantCodeAnnot::InvariantCodeAnnot(Lexpr *p1)
{
  lexpr_ = p1;

}

InvariantCodeAnnot::InvariantCodeAnnot(const InvariantCodeAnnot & other)
{
  lexpr_ = other.lexpr_->clone();

}

InvariantCodeAnnot &InvariantCodeAnnot::operator=(const InvariantCodeAnnot & other)
{
  InvariantCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void InvariantCodeAnnot::swap(InvariantCodeAnnot & other)
{
  std::swap(lexpr_, other.lexpr_);

}

InvariantCodeAnnot::~InvariantCodeAnnot()
{
  delete(lexpr_);

}

void InvariantCodeAnnot::accept(Visitor *v)
{
  v->visitInvariantCodeAnnot(this);
}

InvariantCodeAnnot *InvariantCodeAnnot::clone() const
{
  return new InvariantCodeAnnot(*this);
}



/********************   CheckInvariantCodeAnnot    ********************/
CheckInvariantCodeAnnot::CheckInvariantCodeAnnot(Lexpr *p1)
{
  lexpr_ = p1;

}

CheckInvariantCodeAnnot::CheckInvariantCodeAnnot(const CheckInvariantCodeAnnot & other)
{
  lexpr_ = other.lexpr_->clone();

}

CheckInvariantCodeAnnot &CheckInvariantCodeAnnot::operator=(const CheckInvariantCodeAnnot & other)
{
  CheckInvariantCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void CheckInvariantCodeAnnot::swap(CheckInvariantCodeAnnot & other)
{
  std::swap(lexpr_, other.lexpr_);

}

CheckInvariantCodeAnnot::~CheckInvariantCodeAnnot()
{
  delete(lexpr_);

}

void CheckInvariantCodeAnnot::accept(Visitor *v)
{
  v->visitCheckInvariantCodeAnnot(this);
}

CheckInvariantCodeAnnot *CheckInvariantCodeAnnot::clone() const
{
  return new CheckInvariantCodeAnnot(*this);
}



/********************   AdmitInvariantCodeAnnot    ********************/
AdmitInvariantCodeAnnot::AdmitInvariantCodeAnnot(Lexpr *p1)
{
  lexpr_ = p1;

}

AdmitInvariantCodeAnnot::AdmitInvariantCodeAnnot(const AdmitInvariantCodeAnnot & other)
{
  lexpr_ = other.lexpr_->clone();

}

AdmitInvariantCodeAnnot &AdmitInvariantCodeAnnot::operator=(const AdmitInvariantCodeAnnot & other)
{
  AdmitInvariantCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void AdmitInvariantCodeAnnot::swap(AdmitInvariantCodeAnnot & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AdmitInvariantCodeAnnot::~AdmitInvariantCodeAnnot()
{
  delete(lexpr_);

}

void AdmitInvariantCodeAnnot::accept(Visitor *v)
{
  v->visitAdmitInvariantCodeAnnot(this);
}

AdmitInvariantCodeAnnot *AdmitInvariantCodeAnnot::clone() const
{
  return new AdmitInvariantCodeAnnot(*this);
}



/********************   ExtCodeAnnotCodeAnnot    ********************/
ExtCodeAnnotCodeAnnot::ExtCodeAnnotCodeAnnot(EXT_CODE_ANNOT p1, ExtensionContent *p2)
{
  ext_code_annot_ = p1;
  extensioncontent_ = p2;

}

ExtCodeAnnotCodeAnnot::ExtCodeAnnotCodeAnnot(const ExtCodeAnnotCodeAnnot & other)
{
  ext_code_annot_ = other.ext_code_annot_;
  extensioncontent_ = other.extensioncontent_->clone();

}

ExtCodeAnnotCodeAnnot &ExtCodeAnnotCodeAnnot::operator=(const ExtCodeAnnotCodeAnnot & other)
{
  ExtCodeAnnotCodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void ExtCodeAnnotCodeAnnot::swap(ExtCodeAnnotCodeAnnot & other)
{
  std::swap(ext_code_annot_, other.ext_code_annot_);
  std::swap(extensioncontent_, other.extensioncontent_);

}

ExtCodeAnnotCodeAnnot::~ExtCodeAnnotCodeAnnot()
{
  delete(extensioncontent_);

}

void ExtCodeAnnotCodeAnnot::accept(Visitor *v)
{
  v->visitExtCodeAnnotCodeAnnot(this);
}

ExtCodeAnnotCodeAnnot *ExtCodeAnnotCodeAnnot::clone() const
{
  return new ExtCodeAnnotCodeAnnot(*this);
}



/********************   PragmaSliceLexpr    ********************/
PragmaSliceLexpr::PragmaSliceLexpr(AnyIdentifier *p1, Lexpr *p2)
{
  anyidentifier_ = p1;
  lexpr_ = p2;

}

PragmaSliceLexpr::PragmaSliceLexpr(const PragmaSliceLexpr & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  lexpr_ = other.lexpr_->clone();

}

PragmaSliceLexpr &PragmaSliceLexpr::operator=(const PragmaSliceLexpr & other)
{
  PragmaSliceLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PragmaSliceLexpr::swap(PragmaSliceLexpr & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(lexpr_, other.lexpr_);

}

PragmaSliceLexpr::~PragmaSliceLexpr()
{
  delete(anyidentifier_);
  delete(lexpr_);

}

void PragmaSliceLexpr::accept(Visitor *v)
{
  v->visitPragmaSliceLexpr(this);
}

PragmaSliceLexpr *PragmaSliceLexpr::clone() const
{
  return new PragmaSliceLexpr(*this);
}



/********************   PragmaSlice    ********************/
PragmaSlice::PragmaSlice(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

PragmaSlice::PragmaSlice(const PragmaSlice & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

PragmaSlice &PragmaSlice::operator=(const PragmaSlice & other)
{
  PragmaSlice tmp(other);
  swap(tmp);
  return *this;
}

void PragmaSlice::swap(PragmaSlice & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

PragmaSlice::~PragmaSlice()
{
  delete(anyidentifier_);

}

void PragmaSlice::accept(Visitor *v)
{
  v->visitPragmaSlice(this);
}

PragmaSlice *PragmaSlice::clone() const
{
  return new PragmaSlice(*this);
}



/********************   ImpactPragmaLexpr    ********************/
ImpactPragmaLexpr::ImpactPragmaLexpr(AnyIdentifier *p1, Lexpr *p2)
{
  anyidentifier_ = p1;
  lexpr_ = p2;

}

ImpactPragmaLexpr::ImpactPragmaLexpr(const ImpactPragmaLexpr & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  lexpr_ = other.lexpr_->clone();

}

ImpactPragmaLexpr &ImpactPragmaLexpr::operator=(const ImpactPragmaLexpr & other)
{
  ImpactPragmaLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ImpactPragmaLexpr::swap(ImpactPragmaLexpr & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(lexpr_, other.lexpr_);

}

ImpactPragmaLexpr::~ImpactPragmaLexpr()
{
  delete(anyidentifier_);
  delete(lexpr_);

}

void ImpactPragmaLexpr::accept(Visitor *v)
{
  v->visitImpactPragmaLexpr(this);
}

ImpactPragmaLexpr *ImpactPragmaLexpr::clone() const
{
  return new ImpactPragmaLexpr(*this);
}



/********************   AnImpactPragma    ********************/
AnImpactPragma::AnImpactPragma(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

AnImpactPragma::AnImpactPragma(const AnImpactPragma & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

AnImpactPragma &AnImpactPragma::operator=(const AnImpactPragma & other)
{
  AnImpactPragma tmp(other);
  swap(tmp);
  return *this;
}

void AnImpactPragma::swap(AnImpactPragma & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

AnImpactPragma::~AnImpactPragma()
{
  delete(anyidentifier_);

}

void AnImpactPragma::accept(Visitor *v)
{
  v->visitAnImpactPragma(this);
}

AnImpactPragma *AnImpactPragma::clone() const
{
  return new AnImpactPragma(*this);
}



/********************   DeclGlobalInvariant    ********************/
DeclGlobalInvariant::DeclGlobalInvariant(AnyIdentifier *p1, Lexpr *p2)
{
  anyidentifier_ = p1;
  lexpr_ = p2;

}

DeclGlobalInvariant::DeclGlobalInvariant(const DeclGlobalInvariant & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  lexpr_ = other.lexpr_->clone();

}

DeclGlobalInvariant &DeclGlobalInvariant::operator=(const DeclGlobalInvariant & other)
{
  DeclGlobalInvariant tmp(other);
  swap(tmp);
  return *this;
}

void DeclGlobalInvariant::swap(DeclGlobalInvariant & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(lexpr_, other.lexpr_);

}

DeclGlobalInvariant::~DeclGlobalInvariant()
{
  delete(anyidentifier_);
  delete(lexpr_);

}

void DeclGlobalInvariant::accept(Visitor *v)
{
  v->visitDeclGlobalInvariant(this);
}

DeclGlobalInvariant *DeclGlobalInvariant::clone() const
{
  return new DeclGlobalInvariant(*this);
}



/********************   DeclVolatile    ********************/
DeclVolatile::DeclVolatile(ListLexpr *p1, ListVolatileOpt *p2)
{
  listlexpr_ = p1;
  listvolatileopt_ = p2;

}

DeclVolatile::DeclVolatile(const DeclVolatile & other)
{
  listlexpr_ = other.listlexpr_->clone();
  listvolatileopt_ = other.listvolatileopt_->clone();

}

DeclVolatile &DeclVolatile::operator=(const DeclVolatile & other)
{
  DeclVolatile tmp(other);
  swap(tmp);
  return *this;
}

void DeclVolatile::swap(DeclVolatile & other)
{
  std::swap(listlexpr_, other.listlexpr_);
  std::swap(listvolatileopt_, other.listvolatileopt_);

}

DeclVolatile::~DeclVolatile()
{
  delete(listlexpr_);
  delete(listvolatileopt_);

}

void DeclVolatile::accept(Visitor *v)
{
  v->visitDeclVolatile(this);
}

DeclVolatile *DeclVolatile::clone() const
{
  return new DeclVolatile(*this);
}



/********************   DeclTypeAnnot    ********************/
DeclTypeAnnot::DeclTypeAnnot(TypeAnnot *p1)
{
  typeannot_ = p1;

}

DeclTypeAnnot::DeclTypeAnnot(const DeclTypeAnnot & other)
{
  typeannot_ = other.typeannot_->clone();

}

DeclTypeAnnot &DeclTypeAnnot::operator=(const DeclTypeAnnot & other)
{
  DeclTypeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void DeclTypeAnnot::swap(DeclTypeAnnot & other)
{
  std::swap(typeannot_, other.typeannot_);

}

DeclTypeAnnot::~DeclTypeAnnot()
{
  delete(typeannot_);

}

void DeclTypeAnnot::accept(Visitor *v)
{
  v->visitDeclTypeAnnot(this);
}

DeclTypeAnnot *DeclTypeAnnot::clone() const
{
  return new DeclTypeAnnot(*this);
}



/********************   DeclModelAnnot    ********************/
DeclModelAnnot::DeclModelAnnot(ModelAnnot *p1)
{
  modelannot_ = p1;

}

DeclModelAnnot::DeclModelAnnot(const DeclModelAnnot & other)
{
  modelannot_ = other.modelannot_->clone();

}

DeclModelAnnot &DeclModelAnnot::operator=(const DeclModelAnnot & other)
{
  DeclModelAnnot tmp(other);
  swap(tmp);
  return *this;
}

void DeclModelAnnot::swap(DeclModelAnnot & other)
{
  std::swap(modelannot_, other.modelannot_);

}

DeclModelAnnot::~DeclModelAnnot()
{
  delete(modelannot_);

}

void DeclModelAnnot::accept(Visitor *v)
{
  v->visitDeclModelAnnot(this);
}

DeclModelAnnot *DeclModelAnnot::clone() const
{
  return new DeclModelAnnot(*this);
}



/********************   DeclLogicDef    ********************/
DeclLogicDef::DeclLogicDef(LogicDef *p1)
{
  logicdef_ = p1;

}

DeclLogicDef::DeclLogicDef(const DeclLogicDef & other)
{
  logicdef_ = other.logicdef_->clone();

}

DeclLogicDef &DeclLogicDef::operator=(const DeclLogicDef & other)
{
  DeclLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void DeclLogicDef::swap(DeclLogicDef & other)
{
  std::swap(logicdef_, other.logicdef_);

}

DeclLogicDef::~DeclLogicDef()
{
  delete(logicdef_);

}

void DeclLogicDef::accept(Visitor *v)
{
  v->visitDeclLogicDef(this);
}

DeclLogicDef *DeclLogicDef::clone() const
{
  return new DeclLogicDef(*this);
}



/********************   DeclExt    ********************/
DeclExt::DeclExt(ExtDecl *p1)
{
  extdecl_ = p1;

}

DeclExt::DeclExt(const DeclExt & other)
{
  extdecl_ = other.extdecl_->clone();

}

DeclExt &DeclExt::operator=(const DeclExt & other)
{
  DeclExt tmp(other);
  swap(tmp);
  return *this;
}

void DeclExt::swap(DeclExt & other)
{
  std::swap(extdecl_, other.extdecl_);

}

DeclExt::~DeclExt()
{
  delete(extdecl_);

}

void DeclExt::accept(Visitor *v)
{
  v->visitDeclExt(this);
}

DeclExt *DeclExt::clone() const
{
  return new DeclExt(*this);
}



/********************   DeclDeprecatedLogic    ********************/
DeclDeprecatedLogic::DeclDeprecatedLogic(DeprecatedLogicDecl *p1)
{
  deprecatedlogicdecl_ = p1;

}

DeclDeprecatedLogic::DeclDeprecatedLogic(const DeclDeprecatedLogic & other)
{
  deprecatedlogicdecl_ = other.deprecatedlogicdecl_->clone();

}

DeclDeprecatedLogic &DeclDeprecatedLogic::operator=(const DeclDeprecatedLogic & other)
{
  DeclDeprecatedLogic tmp(other);
  swap(tmp);
  return *this;
}

void DeclDeprecatedLogic::swap(DeclDeprecatedLogic & other)
{
  std::swap(deprecatedlogicdecl_, other.deprecatedlogicdecl_);

}

DeclDeprecatedLogic::~DeclDeprecatedLogic()
{
  delete(deprecatedlogicdecl_);

}

void DeclDeprecatedLogic::accept(Visitor *v)
{
  v->visitDeclDeprecatedLogic(this);
}

DeclDeprecatedLogic *DeclDeprecatedLogic::clone() const
{
  return new DeclDeprecatedLogic(*this);
}



/********************   ExtGlobalDecl    ********************/
ExtGlobalDecl::ExtGlobalDecl(EXT_GLOBAL p1, ExtensionContent *p2)
{
  ext_global_ = p1;
  extensioncontent_ = p2;

}

ExtGlobalDecl::ExtGlobalDecl(const ExtGlobalDecl & other)
{
  ext_global_ = other.ext_global_;
  extensioncontent_ = other.extensioncontent_->clone();

}

ExtGlobalDecl &ExtGlobalDecl::operator=(const ExtGlobalDecl & other)
{
  ExtGlobalDecl tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalDecl::swap(ExtGlobalDecl & other)
{
  std::swap(ext_global_, other.ext_global_);
  std::swap(extensioncontent_, other.extensioncontent_);

}

ExtGlobalDecl::~ExtGlobalDecl()
{
  delete(extensioncontent_);

}

void ExtGlobalDecl::accept(Visitor *v)
{
  v->visitExtGlobalDecl(this);
}

ExtGlobalDecl *ExtGlobalDecl::clone() const
{
  return new ExtGlobalDecl(*this);
}



/********************   ExtGlobalBlockDecl    ********************/
ExtGlobalBlockDecl::ExtGlobalBlockDecl(EXT_GLOBAL_BLOCK p1, AnyIdentifier *p2, ListExtDecl *p3)
{
  ext_global_block_ = p1;
  anyidentifier_ = p2;
  listextdecl_ = p3;

}

ExtGlobalBlockDecl::ExtGlobalBlockDecl(const ExtGlobalBlockDecl & other)
{
  ext_global_block_ = other.ext_global_block_;
  anyidentifier_ = other.anyidentifier_->clone();
  listextdecl_ = other.listextdecl_->clone();

}

ExtGlobalBlockDecl &ExtGlobalBlockDecl::operator=(const ExtGlobalBlockDecl & other)
{
  ExtGlobalBlockDecl tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalBlockDecl::swap(ExtGlobalBlockDecl & other)
{
  std::swap(ext_global_block_, other.ext_global_block_);
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(listextdecl_, other.listextdecl_);

}

ExtGlobalBlockDecl::~ExtGlobalBlockDecl()
{
  delete(anyidentifier_);
  delete(listextdecl_);

}

void ExtGlobalBlockDecl::accept(Visitor *v)
{
  v->visitExtGlobalBlockDecl(this);
}

ExtGlobalBlockDecl *ExtGlobalBlockDecl::clone() const
{
  return new ExtGlobalBlockDecl(*this);
}



/********************   ReadVolotile    ********************/
ReadVolotile::ReadVolotile(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

ReadVolotile::ReadVolotile(const ReadVolotile & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

ReadVolotile &ReadVolotile::operator=(const ReadVolotile & other)
{
  ReadVolotile tmp(other);
  swap(tmp);
  return *this;
}

void ReadVolotile::swap(ReadVolotile & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

ReadVolotile::~ReadVolotile()
{
  delete(anyidentifier_);

}

void ReadVolotile::accept(Visitor *v)
{
  v->visitReadVolotile(this);
}

ReadVolotile *ReadVolotile::clone() const
{
  return new ReadVolotile(*this);
}



/********************   WriteVolotile    ********************/
WriteVolotile::WriteVolotile(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

WriteVolotile::WriteVolotile(const WriteVolotile & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

WriteVolotile &WriteVolotile::operator=(const WriteVolotile & other)
{
  WriteVolotile tmp(other);
  swap(tmp);
  return *this;
}

void WriteVolotile::swap(WriteVolotile & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

WriteVolotile::~WriteVolotile()
{
  delete(anyidentifier_);

}

void WriteVolotile::accept(Visitor *v)
{
  v->visitWriteVolotile(this);
}

WriteVolotile *WriteVolotile::clone() const
{
  return new WriteVolotile(*this);
}



/********************   TypeInvariant    ********************/
TypeInvariant::TypeInvariant(AnyIdentifier *p1, Parameter *p2, Lexpr *p3)
{
  anyidentifier_ = p1;
  parameter_ = p2;
  lexpr_ = p3;

}

TypeInvariant::TypeInvariant(const TypeInvariant & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  parameter_ = other.parameter_->clone();
  lexpr_ = other.lexpr_->clone();

}

TypeInvariant &TypeInvariant::operator=(const TypeInvariant & other)
{
  TypeInvariant tmp(other);
  swap(tmp);
  return *this;
}

void TypeInvariant::swap(TypeInvariant & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(parameter_, other.parameter_);
  std::swap(lexpr_, other.lexpr_);

}

TypeInvariant::~TypeInvariant()
{
  delete(anyidentifier_);
  delete(parameter_);
  delete(lexpr_);

}

void TypeInvariant::accept(Visitor *v)
{
  v->visitTypeInvariant(this);
}

TypeInvariant *TypeInvariant::clone() const
{
  return new TypeInvariant(*this);
}



/********************   NoSemicolon    ********************/
NoSemicolon::NoSemicolon()
{

}

NoSemicolon::NoSemicolon(const NoSemicolon & other)
{

}

NoSemicolon &NoSemicolon::operator=(const NoSemicolon & other)
{
  NoSemicolon tmp(other);
  swap(tmp);
  return *this;
}

void NoSemicolon::swap(NoSemicolon & other)
{

}

NoSemicolon::~NoSemicolon()
{

}

void NoSemicolon::accept(Visitor *v)
{
  v->visitNoSemicolon(this);
}

NoSemicolon *NoSemicolon::clone() const
{
  return new NoSemicolon(*this);
}



/********************   Semicolon    ********************/
Semicolon::Semicolon()
{

}

Semicolon::Semicolon(const Semicolon & other)
{

}

Semicolon &Semicolon::operator=(const Semicolon & other)
{
  Semicolon tmp(other);
  swap(tmp);
  return *this;
}

void Semicolon::swap(Semicolon & other)
{

}

Semicolon::~Semicolon()
{

}

void Semicolon::accept(Visitor *v)
{
  v->visitSemicolon(this);
}

Semicolon *Semicolon::clone() const
{
  return new Semicolon(*this);
}



/********************   ModelAnnotation    ********************/
ModelAnnotation::ModelAnnotation(TypeSpecOFTYPENAME *p1, Parameter *p2, OptSemicolon *p3)
{
  typespecoftypename_ = p1;
  parameter_ = p2;
  optsemicolon_ = p3;

}

ModelAnnotation::ModelAnnotation(const ModelAnnotation & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  parameter_ = other.parameter_->clone();
  optsemicolon_ = other.optsemicolon_->clone();

}

ModelAnnotation &ModelAnnotation::operator=(const ModelAnnotation & other)
{
  ModelAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void ModelAnnotation::swap(ModelAnnotation & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(parameter_, other.parameter_);
  std::swap(optsemicolon_, other.optsemicolon_);

}

ModelAnnotation::~ModelAnnotation()
{
  delete(typespecoftypename_);
  delete(parameter_);
  delete(optsemicolon_);

}

void ModelAnnotation::accept(Visitor *v)
{
  v->visitModelAnnotation(this);
}

ModelAnnotation *ModelAnnotation::clone() const
{
  return new ModelAnnotation(*this);
}



/********************   SimplePolyIdType    ********************/
SimplePolyIdType::SimplePolyIdType(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

SimplePolyIdType::SimplePolyIdType(const SimplePolyIdType & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

SimplePolyIdType &SimplePolyIdType::operator=(const SimplePolyIdType & other)
{
  SimplePolyIdType tmp(other);
  swap(tmp);
  return *this;
}

void SimplePolyIdType::swap(SimplePolyIdType & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

SimplePolyIdType::~SimplePolyIdType()
{
  delete(fullidentifier_);

}

void SimplePolyIdType::accept(Visitor *v)
{
  v->visitSimplePolyIdType(this);
}

SimplePolyIdType *SimplePolyIdType::clone() const
{
  return new SimplePolyIdType(*this);
}



/********************   PolyIdTypeAngles    ********************/
PolyIdTypeAngles::PolyIdTypeAngles(FullIdentifier *p1, ListFullIdentifier *p2)
{
  fullidentifier_ = p1;
  listfullidentifier_ = p2;

}

PolyIdTypeAngles::PolyIdTypeAngles(const PolyIdTypeAngles & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listfullidentifier_ = other.listfullidentifier_->clone();

}

PolyIdTypeAngles &PolyIdTypeAngles::operator=(const PolyIdTypeAngles & other)
{
  PolyIdTypeAngles tmp(other);
  swap(tmp);
  return *this;
}

void PolyIdTypeAngles::swap(PolyIdTypeAngles & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listfullidentifier_, other.listfullidentifier_);

}

PolyIdTypeAngles::~PolyIdTypeAngles()
{
  delete(fullidentifier_);
  delete(listfullidentifier_);

}

void PolyIdTypeAngles::accept(Visitor *v)
{
  v->visitPolyIdTypeAngles(this);
}

PolyIdTypeAngles *PolyIdTypeAngles::clone() const
{
  return new PolyIdTypeAngles(*this);
}



/********************   PolyTypeId    ********************/
PolyTypeId::PolyTypeId(PolyIdType *p1)
{
  polyidtype_ = p1;

}

PolyTypeId::PolyTypeId(const PolyTypeId & other)
{
  polyidtype_ = other.polyidtype_->clone();

}

PolyTypeId &PolyTypeId::operator=(const PolyTypeId & other)
{
  PolyTypeId tmp(other);
  swap(tmp);
  return *this;
}

void PolyTypeId::swap(PolyTypeId & other)
{
  std::swap(polyidtype_, other.polyidtype_);

}

PolyTypeId::~PolyTypeId()
{
  delete(polyidtype_);

}

void PolyTypeId::accept(Visitor *v)
{
  v->visitPolyTypeId(this);
}

PolyTypeId *PolyTypeId::clone() const
{
  return new PolyTypeId(*this);
}



/********************   PolyIdTypeSquares    ********************/
PolyIdTypeSquares::PolyIdTypeSquares(FullIdentifier *p1, ListLabelName *p2)
{
  fullidentifier_ = p1;
  listlabelname_ = p2;

}

PolyIdTypeSquares::PolyIdTypeSquares(const PolyIdTypeSquares & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listlabelname_ = other.listlabelname_->clone();

}

PolyIdTypeSquares &PolyIdTypeSquares::operator=(const PolyIdTypeSquares & other)
{
  PolyIdTypeSquares tmp(other);
  swap(tmp);
  return *this;
}

void PolyIdTypeSquares::swap(PolyIdTypeSquares & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listlabelname_, other.listlabelname_);

}

PolyIdTypeSquares::~PolyIdTypeSquares()
{
  delete(fullidentifier_);
  delete(listlabelname_);

}

void PolyIdTypeSquares::accept(Visitor *v)
{
  v->visitPolyIdTypeSquares(this);
}

PolyIdTypeSquares *PolyIdTypeSquares::clone() const
{
  return new PolyIdTypeSquares(*this);
}



/********************   PolyIdTypeSquaresAngles    ********************/
PolyIdTypeSquaresAngles::PolyIdTypeSquaresAngles(FullIdentifier *p1, ListLabelName *p2, ListFullIdentifier *p3)
{
  fullidentifier_ = p1;
  listlabelname_ = p2;
  listfullidentifier_ = p3;

}

PolyIdTypeSquaresAngles::PolyIdTypeSquaresAngles(const PolyIdTypeSquaresAngles & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listlabelname_ = other.listlabelname_->clone();
  listfullidentifier_ = other.listfullidentifier_->clone();

}

PolyIdTypeSquaresAngles &PolyIdTypeSquaresAngles::operator=(const PolyIdTypeSquaresAngles & other)
{
  PolyIdTypeSquaresAngles tmp(other);
  swap(tmp);
  return *this;
}

void PolyIdTypeSquaresAngles::swap(PolyIdTypeSquaresAngles & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listlabelname_, other.listlabelname_);
  std::swap(listfullidentifier_, other.listfullidentifier_);

}

PolyIdTypeSquaresAngles::~PolyIdTypeSquaresAngles()
{
  delete(fullidentifier_);
  delete(listlabelname_);
  delete(listfullidentifier_);

}

void PolyIdTypeSquaresAngles::accept(Visitor *v)
{
  v->visitPolyIdTypeSquaresAngles(this);
}

PolyIdTypeSquaresAngles *PolyIdTypeSquaresAngles::clone() const
{
  return new PolyIdTypeSquaresAngles(*this);
}



/********************   NoParameters    ********************/
NoParameters::NoParameters()
{

}

NoParameters::NoParameters(const NoParameters & other)
{

}

NoParameters &NoParameters::operator=(const NoParameters & other)
{
  NoParameters tmp(other);
  swap(tmp);
  return *this;
}

void NoParameters::swap(NoParameters & other)
{

}

NoParameters::~NoParameters()
{

}

void NoParameters::accept(Visitor *v)
{
  v->visitNoParameters(this);
}

NoParameters *NoParameters::clone() const
{
  return new NoParameters(*this);
}



/********************   SomeParameters    ********************/
SomeParameters::SomeParameters(Parameters *p1)
{
  parameters_ = p1;

}

SomeParameters::SomeParameters(const SomeParameters & other)
{
  parameters_ = other.parameters_->clone();

}

SomeParameters &SomeParameters::operator=(const SomeParameters & other)
{
  SomeParameters tmp(other);
  swap(tmp);
  return *this;
}

void SomeParameters::swap(SomeParameters & other)
{
  std::swap(parameters_, other.parameters_);

}

SomeParameters::~SomeParameters()
{
  delete(parameters_);

}

void SomeParameters::accept(Visitor *v)
{
  v->visitSomeParameters(this);
}

SomeParameters *SomeParameters::clone() const
{
  return new SomeParameters(*this);
}



/********************   AParameters    ********************/
AParameters::AParameters(ListParameter *p1)
{
  listparameter_ = p1;

}

AParameters::AParameters(const AParameters & other)
{
  listparameter_ = other.listparameter_->clone();

}

AParameters &AParameters::operator=(const AParameters & other)
{
  AParameters tmp(other);
  swap(tmp);
  return *this;
}

void AParameters::swap(AParameters & other)
{
  std::swap(listparameter_, other.listparameter_);

}

AParameters::~AParameters()
{
  delete(listparameter_);

}

void AParameters::accept(Visitor *v)
{
  v->visitAParameters(this);
}

AParameters *AParameters::clone() const
{
  return new AParameters(*this);
}



/********************   SimpleLogicDef    ********************/
SimpleLogicDef::SimpleLogicDef(LogicRtType *p1, PolyId *p2, OptParameters *p3, Lexpr *p4)
{
  logicrttype_ = p1;
  polyid_ = p2;
  optparameters_ = p3;
  lexpr_ = p4;

}

SimpleLogicDef::SimpleLogicDef(const SimpleLogicDef & other)
{
  logicrttype_ = other.logicrttype_->clone();
  polyid_ = other.polyid_->clone();
  optparameters_ = other.optparameters_->clone();
  lexpr_ = other.lexpr_->clone();

}

SimpleLogicDef &SimpleLogicDef::operator=(const SimpleLogicDef & other)
{
  SimpleLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLogicDef::swap(SimpleLogicDef & other)
{
  std::swap(logicrttype_, other.logicrttype_);
  std::swap(polyid_, other.polyid_);
  std::swap(optparameters_, other.optparameters_);
  std::swap(lexpr_, other.lexpr_);

}

SimpleLogicDef::~SimpleLogicDef()
{
  delete(logicrttype_);
  delete(polyid_);
  delete(optparameters_);
  delete(lexpr_);

}

void SimpleLogicDef::accept(Visitor *v)
{
  v->visitSimpleLogicDef(this);
}

SimpleLogicDef *SimpleLogicDef::clone() const
{
  return new SimpleLogicDef(*this);
}



/********************   PredicateLogicDef    ********************/
PredicateLogicDef::PredicateLogicDef(PolyId *p1, OptParameters *p2, Lexpr *p3)
{
  polyid_ = p1;
  optparameters_ = p2;
  lexpr_ = p3;

}

PredicateLogicDef::PredicateLogicDef(const PredicateLogicDef & other)
{
  polyid_ = other.polyid_->clone();
  optparameters_ = other.optparameters_->clone();
  lexpr_ = other.lexpr_->clone();

}

PredicateLogicDef &PredicateLogicDef::operator=(const PredicateLogicDef & other)
{
  PredicateLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void PredicateLogicDef::swap(PredicateLogicDef & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(optparameters_, other.optparameters_);
  std::swap(lexpr_, other.lexpr_);

}

PredicateLogicDef::~PredicateLogicDef()
{
  delete(polyid_);
  delete(optparameters_);
  delete(lexpr_);

}

void PredicateLogicDef::accept(Visitor *v)
{
  v->visitPredicateLogicDef(this);
}

PredicateLogicDef *PredicateLogicDef::clone() const
{
  return new PredicateLogicDef(*this);
}



/********************   InductiveLogicDef    ********************/
InductiveLogicDef::InductiveLogicDef(PolyId *p1, Parameters *p2, ListIndcase *p3)
{
  polyid_ = p1;
  parameters_ = p2;
  listindcase_ = p3;

}

InductiveLogicDef::InductiveLogicDef(const InductiveLogicDef & other)
{
  polyid_ = other.polyid_->clone();
  parameters_ = other.parameters_->clone();
  listindcase_ = other.listindcase_->clone();

}

InductiveLogicDef &InductiveLogicDef::operator=(const InductiveLogicDef & other)
{
  InductiveLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void InductiveLogicDef::swap(InductiveLogicDef & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(parameters_, other.parameters_);
  std::swap(listindcase_, other.listindcase_);

}

InductiveLogicDef::~InductiveLogicDef()
{
  delete(polyid_);
  delete(parameters_);
  delete(listindcase_);

}

void InductiveLogicDef::accept(Visitor *v)
{
  v->visitInductiveLogicDef(this);
}

InductiveLogicDef *InductiveLogicDef::clone() const
{
  return new InductiveLogicDef(*this);
}



/********************   LemmaLogicDef    ********************/
LemmaLogicDef::LemmaLogicDef(PolyId *p1, Lexpr *p2)
{
  polyid_ = p1;
  lexpr_ = p2;

}

LemmaLogicDef::LemmaLogicDef(const LemmaLogicDef & other)
{
  polyid_ = other.polyid_->clone();
  lexpr_ = other.lexpr_->clone();

}

LemmaLogicDef &LemmaLogicDef::operator=(const LemmaLogicDef & other)
{
  LemmaLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void LemmaLogicDef::swap(LemmaLogicDef & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(lexpr_, other.lexpr_);

}

LemmaLogicDef::~LemmaLogicDef()
{
  delete(polyid_);
  delete(lexpr_);

}

void LemmaLogicDef::accept(Visitor *v)
{
  v->visitLemmaLogicDef(this);
}

LemmaLogicDef *LemmaLogicDef::clone() const
{
  return new LemmaLogicDef(*this);
}



/********************   CheckLemmaLogicDef    ********************/
CheckLemmaLogicDef::CheckLemmaLogicDef(PolyId *p1, Lexpr *p2)
{
  polyid_ = p1;
  lexpr_ = p2;

}

CheckLemmaLogicDef::CheckLemmaLogicDef(const CheckLemmaLogicDef & other)
{
  polyid_ = other.polyid_->clone();
  lexpr_ = other.lexpr_->clone();

}

CheckLemmaLogicDef &CheckLemmaLogicDef::operator=(const CheckLemmaLogicDef & other)
{
  CheckLemmaLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void CheckLemmaLogicDef::swap(CheckLemmaLogicDef & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(lexpr_, other.lexpr_);

}

CheckLemmaLogicDef::~CheckLemmaLogicDef()
{
  delete(polyid_);
  delete(lexpr_);

}

void CheckLemmaLogicDef::accept(Visitor *v)
{
  v->visitCheckLemmaLogicDef(this);
}

CheckLemmaLogicDef *CheckLemmaLogicDef::clone() const
{
  return new CheckLemmaLogicDef(*this);
}



/********************   AdmitLemmaLogicDef    ********************/
AdmitLemmaLogicDef::AdmitLemmaLogicDef(PolyId *p1, Lexpr *p2)
{
  polyid_ = p1;
  lexpr_ = p2;

}

AdmitLemmaLogicDef::AdmitLemmaLogicDef(const AdmitLemmaLogicDef & other)
{
  polyid_ = other.polyid_->clone();
  lexpr_ = other.lexpr_->clone();

}

AdmitLemmaLogicDef &AdmitLemmaLogicDef::operator=(const AdmitLemmaLogicDef & other)
{
  AdmitLemmaLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLemmaLogicDef::swap(AdmitLemmaLogicDef & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(lexpr_, other.lexpr_);

}

AdmitLemmaLogicDef::~AdmitLemmaLogicDef()
{
  delete(polyid_);
  delete(lexpr_);

}

void AdmitLemmaLogicDef::accept(Visitor *v)
{
  v->visitAdmitLemmaLogicDef(this);
}

AdmitLemmaLogicDef *AdmitLemmaLogicDef::clone() const
{
  return new AdmitLemmaLogicDef(*this);
}



/********************   AxiomaticLogicDef    ********************/
AxiomaticLogicDef::AxiomaticLogicDef(AnyIdentifier *p1, ListLogicDecl *p2)
{
  anyidentifier_ = p1;
  listlogicdecl_ = p2;

}

AxiomaticLogicDef::AxiomaticLogicDef(const AxiomaticLogicDef & other)
{
  anyidentifier_ = other.anyidentifier_->clone();
  listlogicdecl_ = other.listlogicdecl_->clone();

}

AxiomaticLogicDef &AxiomaticLogicDef::operator=(const AxiomaticLogicDef & other)
{
  AxiomaticLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void AxiomaticLogicDef::swap(AxiomaticLogicDef & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);
  std::swap(listlogicdecl_, other.listlogicdecl_);

}

AxiomaticLogicDef::~AxiomaticLogicDef()
{
  delete(anyidentifier_);
  delete(listlogicdecl_);

}

void AxiomaticLogicDef::accept(Visitor *v)
{
  v->visitAxiomaticLogicDef(this);
}

AxiomaticLogicDef *AxiomaticLogicDef::clone() const
{
  return new AxiomaticLogicDef(*this);
}



/********************   TypeLogicDef    ********************/
TypeLogicDef::TypeLogicDef(PolyIdType *p1, Typedef *p2)
{
  polyidtype_ = p1;
  typedef_ = p2;

}

TypeLogicDef::TypeLogicDef(const TypeLogicDef & other)
{
  polyidtype_ = other.polyidtype_->clone();
  typedef_ = other.typedef_->clone();

}

TypeLogicDef &TypeLogicDef::operator=(const TypeLogicDef & other)
{
  TypeLogicDef tmp(other);
  swap(tmp);
  return *this;
}

void TypeLogicDef::swap(TypeLogicDef & other)
{
  std::swap(polyidtype_, other.polyidtype_);
  std::swap(typedef_, other.typedef_);

}

TypeLogicDef::~TypeLogicDef()
{
  delete(polyidtype_);
  delete(typedef_);

}

void TypeLogicDef::accept(Visitor *v)
{
  v->visitTypeLogicDef(this);
}

TypeLogicDef *TypeLogicDef::clone() const
{
  return new TypeLogicDef(*this);
}



/********************   SimpleDeprecatedLogicDecl    ********************/
SimpleDeprecatedLogicDecl::SimpleDeprecatedLogicDecl(LogicRtType *p1, PolyId *p2, OptParameters *p3)
{
  logicrttype_ = p1;
  polyid_ = p2;
  optparameters_ = p3;

}

SimpleDeprecatedLogicDecl::SimpleDeprecatedLogicDecl(const SimpleDeprecatedLogicDecl & other)
{
  logicrttype_ = other.logicrttype_->clone();
  polyid_ = other.polyid_->clone();
  optparameters_ = other.optparameters_->clone();

}

SimpleDeprecatedLogicDecl &SimpleDeprecatedLogicDecl::operator=(const SimpleDeprecatedLogicDecl & other)
{
  SimpleDeprecatedLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void SimpleDeprecatedLogicDecl::swap(SimpleDeprecatedLogicDecl & other)
{
  std::swap(logicrttype_, other.logicrttype_);
  std::swap(polyid_, other.polyid_);
  std::swap(optparameters_, other.optparameters_);

}

SimpleDeprecatedLogicDecl::~SimpleDeprecatedLogicDecl()
{
  delete(logicrttype_);
  delete(polyid_);
  delete(optparameters_);

}

void SimpleDeprecatedLogicDecl::accept(Visitor *v)
{
  v->visitSimpleDeprecatedLogicDecl(this);
}

SimpleDeprecatedLogicDecl *SimpleDeprecatedLogicDecl::clone() const
{
  return new SimpleDeprecatedLogicDecl(*this);
}



/********************   PredicateDeprecatedLogicDecl    ********************/
PredicateDeprecatedLogicDecl::PredicateDeprecatedLogicDecl(PolyId *p1, OptParameters *p2)
{
  polyid_ = p1;
  optparameters_ = p2;

}

PredicateDeprecatedLogicDecl::PredicateDeprecatedLogicDecl(const PredicateDeprecatedLogicDecl & other)
{
  polyid_ = other.polyid_->clone();
  optparameters_ = other.optparameters_->clone();

}

PredicateDeprecatedLogicDecl &PredicateDeprecatedLogicDecl::operator=(const PredicateDeprecatedLogicDecl & other)
{
  PredicateDeprecatedLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void PredicateDeprecatedLogicDecl::swap(PredicateDeprecatedLogicDecl & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(optparameters_, other.optparameters_);

}

PredicateDeprecatedLogicDecl::~PredicateDeprecatedLogicDecl()
{
  delete(polyid_);
  delete(optparameters_);

}

void PredicateDeprecatedLogicDecl::accept(Visitor *v)
{
  v->visitPredicateDeprecatedLogicDecl(this);
}

PredicateDeprecatedLogicDecl *PredicateDeprecatedLogicDecl::clone() const
{
  return new PredicateDeprecatedLogicDecl(*this);
}



/********************   TypeDeprecatedLogicDecl    ********************/
TypeDeprecatedLogicDecl::TypeDeprecatedLogicDecl(PolyIdType *p1)
{
  polyidtype_ = p1;

}

TypeDeprecatedLogicDecl::TypeDeprecatedLogicDecl(const TypeDeprecatedLogicDecl & other)
{
  polyidtype_ = other.polyidtype_->clone();

}

TypeDeprecatedLogicDecl &TypeDeprecatedLogicDecl::operator=(const TypeDeprecatedLogicDecl & other)
{
  TypeDeprecatedLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void TypeDeprecatedLogicDecl::swap(TypeDeprecatedLogicDecl & other)
{
  std::swap(polyidtype_, other.polyidtype_);

}

TypeDeprecatedLogicDecl::~TypeDeprecatedLogicDecl()
{
  delete(polyidtype_);

}

void TypeDeprecatedLogicDecl::accept(Visitor *v)
{
  v->visitTypeDeprecatedLogicDecl(this);
}

TypeDeprecatedLogicDecl *TypeDeprecatedLogicDecl::clone() const
{
  return new TypeDeprecatedLogicDecl(*this);
}



/********************   AxiomDeprecatedLogicDecl    ********************/
AxiomDeprecatedLogicDecl::AxiomDeprecatedLogicDecl(PolyId *p1, Lexpr *p2)
{
  polyid_ = p1;
  lexpr_ = p2;

}

AxiomDeprecatedLogicDecl::AxiomDeprecatedLogicDecl(const AxiomDeprecatedLogicDecl & other)
{
  polyid_ = other.polyid_->clone();
  lexpr_ = other.lexpr_->clone();

}

AxiomDeprecatedLogicDecl &AxiomDeprecatedLogicDecl::operator=(const AxiomDeprecatedLogicDecl & other)
{
  AxiomDeprecatedLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void AxiomDeprecatedLogicDecl::swap(AxiomDeprecatedLogicDecl & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(lexpr_, other.lexpr_);

}

AxiomDeprecatedLogicDecl::~AxiomDeprecatedLogicDecl()
{
  delete(polyid_);
  delete(lexpr_);

}

void AxiomDeprecatedLogicDecl::accept(Visitor *v)
{
  v->visitAxiomDeprecatedLogicDecl(this);
}

AxiomDeprecatedLogicDecl *AxiomDeprecatedLogicDecl::clone() const
{
  return new AxiomDeprecatedLogicDecl(*this);
}



/********************   LocidDeclDef    ********************/
LocidDeclDef::LocidDeclDef(LogicDef *p1)
{
  logicdef_ = p1;

}

LocidDeclDef::LocidDeclDef(const LocidDeclDef & other)
{
  logicdef_ = other.logicdef_->clone();

}

LocidDeclDef &LocidDeclDef::operator=(const LocidDeclDef & other)
{
  LocidDeclDef tmp(other);
  swap(tmp);
  return *this;
}

void LocidDeclDef::swap(LocidDeclDef & other)
{
  std::swap(logicdef_, other.logicdef_);

}

LocidDeclDef::~LocidDeclDef()
{
  delete(logicdef_);

}

void LocidDeclDef::accept(Visitor *v)
{
  v->visitLocidDeclDef(this);
}

LocidDeclDef *LocidDeclDef::clone() const
{
  return new LocidDeclDef(*this);
}



/********************   SimpleLogicDecl    ********************/
SimpleLogicDecl::SimpleLogicDecl(LogicRtType *p1, PolyId *p2, OptParameters *p3, ReadsClause *p4)
{
  logicrttype_ = p1;
  polyid_ = p2;
  optparameters_ = p3;
  readsclause_ = p4;

}

SimpleLogicDecl::SimpleLogicDecl(const SimpleLogicDecl & other)
{
  logicrttype_ = other.logicrttype_->clone();
  polyid_ = other.polyid_->clone();
  optparameters_ = other.optparameters_->clone();
  readsclause_ = other.readsclause_->clone();

}

SimpleLogicDecl &SimpleLogicDecl::operator=(const SimpleLogicDecl & other)
{
  SimpleLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLogicDecl::swap(SimpleLogicDecl & other)
{
  std::swap(logicrttype_, other.logicrttype_);
  std::swap(polyid_, other.polyid_);
  std::swap(optparameters_, other.optparameters_);
  std::swap(readsclause_, other.readsclause_);

}

SimpleLogicDecl::~SimpleLogicDecl()
{
  delete(logicrttype_);
  delete(polyid_);
  delete(optparameters_);
  delete(readsclause_);

}

void SimpleLogicDecl::accept(Visitor *v)
{
  v->visitSimpleLogicDecl(this);
}

SimpleLogicDecl *SimpleLogicDecl::clone() const
{
  return new SimpleLogicDecl(*this);
}



/********************   PredicateLogicDecl    ********************/
PredicateLogicDecl::PredicateLogicDecl(PolyId *p1, OptParameters *p2, ReadsClause *p3)
{
  polyid_ = p1;
  optparameters_ = p2;
  readsclause_ = p3;

}

PredicateLogicDecl::PredicateLogicDecl(const PredicateLogicDecl & other)
{
  polyid_ = other.polyid_->clone();
  optparameters_ = other.optparameters_->clone();
  readsclause_ = other.readsclause_->clone();

}

PredicateLogicDecl &PredicateLogicDecl::operator=(const PredicateLogicDecl & other)
{
  PredicateLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void PredicateLogicDecl::swap(PredicateLogicDecl & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(optparameters_, other.optparameters_);
  std::swap(readsclause_, other.readsclause_);

}

PredicateLogicDecl::~PredicateLogicDecl()
{
  delete(polyid_);
  delete(optparameters_);
  delete(readsclause_);

}

void PredicateLogicDecl::accept(Visitor *v)
{
  v->visitPredicateLogicDecl(this);
}

PredicateLogicDecl *PredicateLogicDecl::clone() const
{
  return new PredicateLogicDecl(*this);
}



/********************   TypeLogicDecl    ********************/
TypeLogicDecl::TypeLogicDecl(PolyIdType *p1)
{
  polyidtype_ = p1;

}

TypeLogicDecl::TypeLogicDecl(const TypeLogicDecl & other)
{
  polyidtype_ = other.polyidtype_->clone();

}

TypeLogicDecl &TypeLogicDecl::operator=(const TypeLogicDecl & other)
{
  TypeLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void TypeLogicDecl::swap(TypeLogicDecl & other)
{
  std::swap(polyidtype_, other.polyidtype_);

}

TypeLogicDecl::~TypeLogicDecl()
{
  delete(polyidtype_);

}

void TypeLogicDecl::accept(Visitor *v)
{
  v->visitTypeLogicDecl(this);
}

TypeLogicDecl *TypeLogicDecl::clone() const
{
  return new TypeLogicDecl(*this);
}



/********************   AxiomLogicDecl    ********************/
AxiomLogicDecl::AxiomLogicDecl(PolyId *p1, Lexpr *p2)
{
  polyid_ = p1;
  lexpr_ = p2;

}

AxiomLogicDecl::AxiomLogicDecl(const AxiomLogicDecl & other)
{
  polyid_ = other.polyid_->clone();
  lexpr_ = other.lexpr_->clone();

}

AxiomLogicDecl &AxiomLogicDecl::operator=(const AxiomLogicDecl & other)
{
  AxiomLogicDecl tmp(other);
  swap(tmp);
  return *this;
}

void AxiomLogicDecl::swap(AxiomLogicDecl & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(lexpr_, other.lexpr_);

}

AxiomLogicDecl::~AxiomLogicDecl()
{
  delete(polyid_);
  delete(lexpr_);

}

void AxiomLogicDecl::accept(Visitor *v)
{
  v->visitAxiomLogicDecl(this);
}

AxiomLogicDecl *AxiomLogicDecl::clone() const
{
  return new AxiomLogicDecl(*this);
}



/********************   NoReadsClause    ********************/
NoReadsClause::NoReadsClause()
{

}

NoReadsClause::NoReadsClause(const NoReadsClause & other)
{

}

NoReadsClause &NoReadsClause::operator=(const NoReadsClause & other)
{
  NoReadsClause tmp(other);
  swap(tmp);
  return *this;
}

void NoReadsClause::swap(NoReadsClause & other)
{

}

NoReadsClause::~NoReadsClause()
{

}

void NoReadsClause::accept(Visitor *v)
{
  v->visitNoReadsClause(this);
}

NoReadsClause *NoReadsClause::clone() const
{
  return new NoReadsClause(*this);
}



/********************   SomeReadsClause    ********************/
SomeReadsClause::SomeReadsClause(Zones *p1)
{
  zones_ = p1;

}

SomeReadsClause::SomeReadsClause(const SomeReadsClause & other)
{
  zones_ = other.zones_->clone();

}

SomeReadsClause &SomeReadsClause::operator=(const SomeReadsClause & other)
{
  SomeReadsClause tmp(other);
  swap(tmp);
  return *this;
}

void SomeReadsClause::swap(SomeReadsClause & other)
{
  std::swap(zones_, other.zones_);

}

SomeReadsClause::~SomeReadsClause()
{
  delete(zones_);

}

void SomeReadsClause::accept(Visitor *v)
{
  v->visitSomeReadsClause(this);
}

SomeReadsClause *SomeReadsClause::clone() const
{
  return new SomeReadsClause(*this);
}



/********************   ListOfDatacons    ********************/
ListOfDatacons::ListOfDatacons(ListDataconsWithSeparator *p1)
{
  listdataconswithseparator_ = p1;

}

ListOfDatacons::ListOfDatacons(const ListOfDatacons & other)
{
  listdataconswithseparator_ = other.listdataconswithseparator_->clone();

}

ListOfDatacons &ListOfDatacons::operator=(const ListOfDatacons & other)
{
  ListOfDatacons tmp(other);
  swap(tmp);
  return *this;
}

void ListOfDatacons::swap(ListOfDatacons & other)
{
  std::swap(listdataconswithseparator_, other.listdataconswithseparator_);

}

ListOfDatacons::~ListOfDatacons()
{
  delete(listdataconswithseparator_);

}

void ListOfDatacons::accept(Visitor *v)
{
  v->visitListOfDatacons(this);
}

ListOfDatacons *ListOfDatacons::clone() const
{
  return new ListOfDatacons(*this);
}



/********************   TypedefLogicTypeGen    ********************/
TypedefLogicTypeGen::TypedefLogicTypeGen(LogicTypeGenOFTYPENAME *p1)
{
  logictypegenoftypename_ = p1;

}

TypedefLogicTypeGen::TypedefLogicTypeGen(const TypedefLogicTypeGen & other)
{
  logictypegenoftypename_ = other.logictypegenoftypename_->clone();

}

TypedefLogicTypeGen &TypedefLogicTypeGen::operator=(const TypedefLogicTypeGen & other)
{
  TypedefLogicTypeGen tmp(other);
  swap(tmp);
  return *this;
}

void TypedefLogicTypeGen::swap(TypedefLogicTypeGen & other)
{
  std::swap(logictypegenoftypename_, other.logictypegenoftypename_);

}

TypedefLogicTypeGen::~TypedefLogicTypeGen()
{
  delete(logictypegenoftypename_);

}

void TypedefLogicTypeGen::accept(Visitor *v)
{
  v->visitTypedefLogicTypeGen(this);
}

TypedefLogicTypeGen *TypedefLogicTypeGen::clone() const
{
  return new TypedefLogicTypeGen(*this);
}



/********************   SimpleDataCons    ********************/
SimpleDataCons::SimpleDataCons(Datacons *p1)
{
  datacons_ = p1;

}

SimpleDataCons::SimpleDataCons(const SimpleDataCons & other)
{
  datacons_ = other.datacons_->clone();

}

SimpleDataCons &SimpleDataCons::operator=(const SimpleDataCons & other)
{
  SimpleDataCons tmp(other);
  swap(tmp);
  return *this;
}

void SimpleDataCons::swap(SimpleDataCons & other)
{
  std::swap(datacons_, other.datacons_);

}

SimpleDataCons::~SimpleDataCons()
{
  delete(datacons_);

}

void SimpleDataCons::accept(Visitor *v)
{
  v->visitSimpleDataCons(this);
}

SimpleDataCons *SimpleDataCons::clone() const
{
  return new SimpleDataCons(*this);
}



/********************   DataConsWithPipe    ********************/
DataConsWithPipe::DataConsWithPipe(Datacons *p1)
{
  datacons_ = p1;

}

DataConsWithPipe::DataConsWithPipe(const DataConsWithPipe & other)
{
  datacons_ = other.datacons_->clone();

}

DataConsWithPipe &DataConsWithPipe::operator=(const DataConsWithPipe & other)
{
  DataConsWithPipe tmp(other);
  swap(tmp);
  return *this;
}

void DataConsWithPipe::swap(DataConsWithPipe & other)
{
  std::swap(datacons_, other.datacons_);

}

DataConsWithPipe::~DataConsWithPipe()
{
  delete(datacons_);

}

void DataConsWithPipe::accept(Visitor *v)
{
  v->visitDataConsWithPipe(this);
}

DataConsWithPipe *DataConsWithPipe::clone() const
{
  return new DataConsWithPipe(*this);
}



/********************   DataConsFullIdentifier    ********************/
DataConsFullIdentifier::DataConsFullIdentifier(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

DataConsFullIdentifier::DataConsFullIdentifier(const DataConsFullIdentifier & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

DataConsFullIdentifier &DataConsFullIdentifier::operator=(const DataConsFullIdentifier & other)
{
  DataConsFullIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void DataConsFullIdentifier::swap(DataConsFullIdentifier & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

DataConsFullIdentifier::~DataConsFullIdentifier()
{
  delete(fullidentifier_);

}

void DataConsFullIdentifier::accept(Visitor *v)
{
  v->visitDataConsFullIdentifier(this);
}

DataConsFullIdentifier *DataConsFullIdentifier::clone() const
{
  return new DataConsFullIdentifier(*this);
}



/********************   DataConsFullIdentifierFun    ********************/
DataConsFullIdentifierFun::DataConsFullIdentifierFun(FullIdentifier *p1, ListLogicTypeGenOFTYPENAME *p2)
{
  fullidentifier_ = p1;
  listlogictypegenoftypename_ = p2;

}

DataConsFullIdentifierFun::DataConsFullIdentifierFun(const DataConsFullIdentifierFun & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listlogictypegenoftypename_ = other.listlogictypegenoftypename_->clone();

}

DataConsFullIdentifierFun &DataConsFullIdentifierFun::operator=(const DataConsFullIdentifierFun & other)
{
  DataConsFullIdentifierFun tmp(other);
  swap(tmp);
  return *this;
}

void DataConsFullIdentifierFun::swap(DataConsFullIdentifierFun & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listlogictypegenoftypename_, other.listlogictypegenoftypename_);

}

DataConsFullIdentifierFun::~DataConsFullIdentifierFun()
{
  delete(fullidentifier_);
  delete(listlogictypegenoftypename_);

}

void DataConsFullIdentifierFun::accept(Visitor *v)
{
  v->visitDataConsFullIdentifierFun(this);
}

DataConsFullIdentifierFun *DataConsFullIdentifierFun::clone() const
{
  return new DataConsFullIdentifierFun(*this);
}



/********************   IndCase    ********************/
IndCase::IndCase(PolyId *p1, Lexpr *p2)
{
  polyid_ = p1;
  lexpr_ = p2;

}

IndCase::IndCase(const IndCase & other)
{
  polyid_ = other.polyid_->clone();
  lexpr_ = other.lexpr_->clone();

}

IndCase &IndCase::operator=(const IndCase & other)
{
  IndCase tmp(other);
  swap(tmp);
  return *this;
}

void IndCase::swap(IndCase & other)
{
  std::swap(polyid_, other.polyid_);
  std::swap(lexpr_, other.lexpr_);

}

IndCase::~IndCase()
{
  delete(polyid_);
  delete(lexpr_);

}

void IndCase::accept(Visitor *v)
{
  v->visitIndCase(this);
}

IndCase *IndCase::clone() const
{
  return new IndCase(*this);
}



/********************   OptLabelOne    ********************/
OptLabelOne::OptLabelOne(OptLabelList *p1)
{
  optlabellist_ = p1;

}

OptLabelOne::OptLabelOne(const OptLabelOne & other)
{
  optlabellist_ = other.optlabellist_->clone();

}

OptLabelOne &OptLabelOne::operator=(const OptLabelOne & other)
{
  OptLabelOne tmp(other);
  swap(tmp);
  return *this;
}

void OptLabelOne::swap(OptLabelOne & other)
{
  std::swap(optlabellist_, other.optlabellist_);

}

OptLabelOne::~OptLabelOne()
{
  delete(optlabellist_);

}

void OptLabelOne::accept(Visitor *v)
{
  v->visitOptLabelOne(this);
}

OptLabelOne *OptLabelOne::clone() const
{
  return new OptLabelOne(*this);
}



/********************   OptLabelTwo    ********************/
OptLabelTwo::OptLabelTwo(OptLabelList *p1)
{
  optlabellist_ = p1;

}

OptLabelTwo::OptLabelTwo(const OptLabelTwo & other)
{
  optlabellist_ = other.optlabellist_->clone();

}

OptLabelTwo &OptLabelTwo::operator=(const OptLabelTwo & other)
{
  OptLabelTwo tmp(other);
  swap(tmp);
  return *this;
}

void OptLabelTwo::swap(OptLabelTwo & other)
{
  std::swap(optlabellist_, other.optlabellist_);

}

OptLabelTwo::~OptLabelTwo()
{
  delete(optlabellist_);

}

void OptLabelTwo::accept(Visitor *v)
{
  v->visitOptLabelTwo(this);
}

OptLabelTwo *OptLabelTwo::clone() const
{
  return new OptLabelTwo(*this);
}



/********************   NoLableList    ********************/
NoLableList::NoLableList()
{

}

NoLableList::NoLableList(const NoLableList & other)
{

}

NoLableList &NoLableList::operator=(const NoLableList & other)
{
  NoLableList tmp(other);
  swap(tmp);
  return *this;
}

void NoLableList::swap(NoLableList & other)
{

}

NoLableList::~NoLableList()
{

}

void NoLableList::accept(Visitor *v)
{
  v->visitNoLableList(this);
}

NoLableList *NoLableList::clone() const
{
  return new NoLableList(*this);
}



/********************   LableList    ********************/
LableList::LableList(ListLabelName *p1)
{
  listlabelname_ = p1;

}

LableList::LableList(const LableList & other)
{
  listlabelname_ = other.listlabelname_->clone();

}

LableList &LableList::operator=(const LableList & other)
{
  LableList tmp(other);
  swap(tmp);
  return *this;
}

void LableList::swap(LableList & other)
{
  std::swap(listlabelname_, other.listlabelname_);

}

LableList::~LableList()
{
  delete(listlabelname_);

}

void LableList::accept(Visitor *v)
{
  v->visitLableList(this);
}

LableList *LableList::clone() const
{
  return new LableList(*this);
}



/********************   LableName    ********************/
LableName::LableName(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

LableName::LableName(const LableName & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

LableName &LableName::operator=(const LableName & other)
{
  LableName tmp(other);
  swap(tmp);
  return *this;
}

void LableName::swap(LableName & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

LableName::~LableName()
{
  delete(anyidentifier_);

}

void LableName::accept(Visitor *v)
{
  v->visitLableName(this);
}

LableName *LableName::clone() const
{
  return new LableName(*this);
}



/********************   EmptyBehaviorNameList    ********************/
EmptyBehaviorNameList::EmptyBehaviorNameList()
{

}

EmptyBehaviorNameList::EmptyBehaviorNameList(const EmptyBehaviorNameList & other)
{

}

EmptyBehaviorNameList &EmptyBehaviorNameList::operator=(const EmptyBehaviorNameList & other)
{
  EmptyBehaviorNameList tmp(other);
  swap(tmp);
  return *this;
}

void EmptyBehaviorNameList::swap(EmptyBehaviorNameList & other)
{

}

EmptyBehaviorNameList::~EmptyBehaviorNameList()
{

}

void EmptyBehaviorNameList::accept(Visitor *v)
{
  v->visitEmptyBehaviorNameList(this);
}

EmptyBehaviorNameList *EmptyBehaviorNameList::clone() const
{
  return new EmptyBehaviorNameList(*this);
}



/********************   AnBehaviorNameList    ********************/
AnBehaviorNameList::AnBehaviorNameList(ListBehaviorName *p1)
{
  listbehaviorname_ = p1;

}

AnBehaviorNameList::AnBehaviorNameList(const AnBehaviorNameList & other)
{
  listbehaviorname_ = other.listbehaviorname_->clone();

}

AnBehaviorNameList &AnBehaviorNameList::operator=(const AnBehaviorNameList & other)
{
  AnBehaviorNameList tmp(other);
  swap(tmp);
  return *this;
}

void AnBehaviorNameList::swap(AnBehaviorNameList & other)
{
  std::swap(listbehaviorname_, other.listbehaviorname_);

}

AnBehaviorNameList::~AnBehaviorNameList()
{
  delete(listbehaviorname_);

}

void AnBehaviorNameList::accept(Visitor *v)
{
  v->visitAnBehaviorNameList(this);
}

AnBehaviorNameList *AnBehaviorNameList::clone() const
{
  return new AnBehaviorNameList(*this);
}



/********************   BehaviorNameAnyIdent    ********************/
BehaviorNameAnyIdent::BehaviorNameAnyIdent(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

BehaviorNameAnyIdent::BehaviorNameAnyIdent(const BehaviorNameAnyIdent & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

BehaviorNameAnyIdent &BehaviorNameAnyIdent::operator=(const BehaviorNameAnyIdent & other)
{
  BehaviorNameAnyIdent tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorNameAnyIdent::swap(BehaviorNameAnyIdent & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

BehaviorNameAnyIdent::~BehaviorNameAnyIdent()
{
  delete(anyidentifier_);

}

void BehaviorNameAnyIdent::accept(Visitor *v)
{
  v->visitBehaviorNameAnyIdent(this);
}

BehaviorNameAnyIdent *BehaviorNameAnyIdent::clone() const
{
  return new BehaviorNameAnyIdent(*this);
}



/********************   SimpleIdentifierAny    ********************/
SimpleIdentifierAny::SimpleIdentifierAny(Identifier *p1)
{
  identifier_ = p1;

}

SimpleIdentifierAny::SimpleIdentifierAny(const SimpleIdentifierAny & other)
{
  identifier_ = other.identifier_->clone();

}

SimpleIdentifierAny &SimpleIdentifierAny::operator=(const SimpleIdentifierAny & other)
{
  SimpleIdentifierAny tmp(other);
  swap(tmp);
  return *this;
}

void SimpleIdentifierAny::swap(SimpleIdentifierAny & other)
{
  std::swap(identifier_, other.identifier_);

}

SimpleIdentifierAny::~SimpleIdentifierAny()
{
  delete(identifier_);

}

void SimpleIdentifierAny::accept(Visitor *v)
{
  v->visitSimpleIdentifierAny(this);
}

SimpleIdentifierAny *SimpleIdentifierAny::clone() const
{
  return new SimpleIdentifierAny(*this);
}



/********************   ACSLTypenameIdentifier    ********************/
ACSLTypenameIdentifier::ACSLTypenameIdentifier(IsACSLTypename *p1)
{
  isacsltypename_ = p1;

}

ACSLTypenameIdentifier::ACSLTypenameIdentifier(const ACSLTypenameIdentifier & other)
{
  isacsltypename_ = other.isacsltypename_->clone();

}

ACSLTypenameIdentifier &ACSLTypenameIdentifier::operator=(const ACSLTypenameIdentifier & other)
{
  ACSLTypenameIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void ACSLTypenameIdentifier::swap(ACSLTypenameIdentifier & other)
{
  std::swap(isacsltypename_, other.isacsltypename_);

}

ACSLTypenameIdentifier::~ACSLTypenameIdentifier()
{
  delete(isacsltypename_);

}

void ACSLTypenameIdentifier::accept(Visitor *v)
{
  v->visitACSLTypenameIdentifier(this);
}

ACSLTypenameIdentifier *ACSLTypenameIdentifier::clone() const
{
  return new ACSLTypenameIdentifier(*this);
}



/********************   TypenameIdentifier    ********************/
TypenameIdentifier::TypenameIdentifier(TYPENAME p1)
{
  typename_ = p1;

}

TypenameIdentifier::TypenameIdentifier(const TypenameIdentifier & other)
{
  typename_ = other.typename_;

}

TypenameIdentifier &TypenameIdentifier::operator=(const TypenameIdentifier & other)
{
  TypenameIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void TypenameIdentifier::swap(TypenameIdentifier & other)
{
  std::swap(typename_, other.typename_);

}

TypenameIdentifier::~TypenameIdentifier()
{

}

void TypenameIdentifier::accept(Visitor *v)
{
  v->visitTypenameIdentifier(this);
}

TypenameIdentifier *TypenameIdentifier::clone() const
{
  return new TypenameIdentifier(*this);
}



/********************   KeywordIdentifier    ********************/
KeywordIdentifier::KeywordIdentifier(Keyword *p1)
{
  keyword_ = p1;

}

KeywordIdentifier::KeywordIdentifier(const KeywordIdentifier & other)
{
  keyword_ = other.keyword_->clone();

}

KeywordIdentifier &KeywordIdentifier::operator=(const KeywordIdentifier & other)
{
  KeywordIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void KeywordIdentifier::swap(KeywordIdentifier & other)
{
  std::swap(keyword_, other.keyword_);

}

KeywordIdentifier::~KeywordIdentifier()
{
  delete(keyword_);

}

void KeywordIdentifier::accept(Visitor *v)
{
  v->visitKeywordIdentifier(this);
}

KeywordIdentifier *KeywordIdentifier::clone() const
{
  return new KeywordIdentifier(*this);
}



/********************   Typename    ********************/
Typename::Typename(TYPENAME p1)
{
  typename_ = p1;

}

Typename::Typename(const Typename & other)
{
  typename_ = other.typename_;

}

Typename &Typename::operator=(const Typename & other)
{
  Typename tmp(other);
  swap(tmp);
  return *this;
}

void Typename::swap(Typename & other)
{
  std::swap(typename_, other.typename_);

}

Typename::~Typename()
{

}

void Typename::accept(Visitor *v)
{
  v->visitTypename(this);
}

Typename *Typename::clone() const
{
  return new Typename(*this);
}



/********************   AnFullIdentifier    ********************/
AnFullIdentifier::AnFullIdentifier(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

AnFullIdentifier::AnFullIdentifier(const AnFullIdentifier & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

AnFullIdentifier &AnFullIdentifier::operator=(const AnFullIdentifier & other)
{
  AnFullIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void AnFullIdentifier::swap(AnFullIdentifier & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

AnFullIdentifier::~AnFullIdentifier()
{
  delete(fullidentifier_);

}

void AnFullIdentifier::accept(Visitor *v)
{
  v->visitAnFullIdentifier(this);
}

AnFullIdentifier *AnFullIdentifier::clone() const
{
  return new AnFullIdentifier(*this);
}



/********************   ACSLTypename    ********************/
ACSLTypename::ACSLTypename(IsACSLTypename *p1)
{
  isacsltypename_ = p1;

}

ACSLTypename::ACSLTypename(const ACSLTypename & other)
{
  isacsltypename_ = other.isacsltypename_->clone();

}

ACSLTypename &ACSLTypename::operator=(const ACSLTypename & other)
{
  ACSLTypename tmp(other);
  swap(tmp);
  return *this;
}

void ACSLTypename::swap(ACSLTypename & other)
{
  std::swap(isacsltypename_, other.isacsltypename_);

}

ACSLTypename::~ACSLTypename()
{
  delete(isacsltypename_);

}

void ACSLTypename::accept(Visitor *v)
{
  v->visitACSLTypename(this);
}

ACSLTypename *ACSLTypename::clone() const
{
  return new ACSLTypename(*this);
}



/********************   AnIdentifierOrTypename    ********************/
AnIdentifierOrTypename::AnIdentifierOrTypename(IdentifierOrTypename *p1)
{
  identifierortypename_ = p1;

}

AnIdentifierOrTypename::AnIdentifierOrTypename(const AnIdentifierOrTypename & other)
{
  identifierortypename_ = other.identifierortypename_->clone();

}

AnIdentifierOrTypename &AnIdentifierOrTypename::operator=(const AnIdentifierOrTypename & other)
{
  AnIdentifierOrTypename tmp(other);
  swap(tmp);
  return *this;
}

void AnIdentifierOrTypename::swap(AnIdentifierOrTypename & other)
{
  std::swap(identifierortypename_, other.identifierortypename_);

}

AnIdentifierOrTypename::~AnIdentifierOrTypename()
{
  delete(identifierortypename_);

}

void AnIdentifierOrTypename::accept(Visitor *v)
{
  v->visitAnIdentifierOrTypename(this);
}

AnIdentifierOrTypename *AnIdentifierOrTypename::clone() const
{
  return new AnIdentifierOrTypename(*this);
}



/********************   IdentifierIdent    ********************/
IdentifierIdent::IdentifierIdent(Ident p1)
{
  ident_ = p1;

}

IdentifierIdent::IdentifierIdent(const IdentifierIdent & other)
{
  ident_ = other.ident_;

}

IdentifierIdent &IdentifierIdent::operator=(const IdentifierIdent & other)
{
  IdentifierIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierIdent::swap(IdentifierIdent & other)
{
  std::swap(ident_, other.ident_);

}

IdentifierIdent::~IdentifierIdent()
{

}

void IdentifierIdent::accept(Visitor *v)
{
  v->visitIdentifierIdent(this);
}

IdentifierIdent *IdentifierIdent::clone() const
{
  return new IdentifierIdent(*this);
}



/********************   BehaviorsKeyWord    ********************/
BehaviorsKeyWord::BehaviorsKeyWord()
{

}

BehaviorsKeyWord::BehaviorsKeyWord(const BehaviorsKeyWord & other)
{

}

BehaviorsKeyWord &BehaviorsKeyWord::operator=(const BehaviorsKeyWord & other)
{
  BehaviorsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorsKeyWord::swap(BehaviorsKeyWord & other)
{

}

BehaviorsKeyWord::~BehaviorsKeyWord()
{

}

void BehaviorsKeyWord::accept(Visitor *v)
{
  v->visitBehaviorsKeyWord(this);
}

BehaviorsKeyWord *BehaviorsKeyWord::clone() const
{
  return new BehaviorsKeyWord(*this);
}



/********************   LabelKeyWord    ********************/
LabelKeyWord::LabelKeyWord()
{

}

LabelKeyWord::LabelKeyWord(const LabelKeyWord & other)
{

}

LabelKeyWord &LabelKeyWord::operator=(const LabelKeyWord & other)
{
  LabelKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void LabelKeyWord::swap(LabelKeyWord & other)
{

}

LabelKeyWord::~LabelKeyWord()
{

}

void LabelKeyWord::accept(Visitor *v)
{
  v->visitLabelKeyWord(this);
}

LabelKeyWord *LabelKeyWord::clone() const
{
  return new LabelKeyWord(*this);
}



/********************   ReadsKeyWord    ********************/
ReadsKeyWord::ReadsKeyWord()
{

}

ReadsKeyWord::ReadsKeyWord(const ReadsKeyWord & other)
{

}

ReadsKeyWord &ReadsKeyWord::operator=(const ReadsKeyWord & other)
{
  ReadsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ReadsKeyWord::swap(ReadsKeyWord & other)
{

}

ReadsKeyWord::~ReadsKeyWord()
{

}

void ReadsKeyWord::accept(Visitor *v)
{
  v->visitReadsKeyWord(this);
}

ReadsKeyWord *ReadsKeyWord::clone() const
{
  return new ReadsKeyWord(*this);
}



/********************   WritesKeyWord    ********************/
WritesKeyWord::WritesKeyWord()
{

}

WritesKeyWord::WritesKeyWord(const WritesKeyWord & other)
{

}

WritesKeyWord &WritesKeyWord::operator=(const WritesKeyWord & other)
{
  WritesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WritesKeyWord::swap(WritesKeyWord & other)
{

}

WritesKeyWord::~WritesKeyWord()
{

}

void WritesKeyWord::accept(Visitor *v)
{
  v->visitWritesKeyWord(this);
}

WritesKeyWord *WritesKeyWord::clone() const
{
  return new WritesKeyWord(*this);
}



/********************   BoendedVarFullIdentifier    ********************/
BoendedVarFullIdentifier::BoendedVarFullIdentifier(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

BoendedVarFullIdentifier::BoendedVarFullIdentifier(const BoendedVarFullIdentifier & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

BoendedVarFullIdentifier &BoendedVarFullIdentifier::operator=(const BoendedVarFullIdentifier & other)
{
  BoendedVarFullIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void BoendedVarFullIdentifier::swap(BoendedVarFullIdentifier & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

BoendedVarFullIdentifier::~BoendedVarFullIdentifier()
{
  delete(fullidentifier_);

}

void BoendedVarFullIdentifier::accept(Visitor *v)
{
  v->visitBoendedVarFullIdentifier(this);
}

BoendedVarFullIdentifier *BoendedVarFullIdentifier::clone() const
{
  return new BoendedVarFullIdentifier(*this);
}



/********************   BoendedVarACSLTypename    ********************/
BoendedVarACSLTypename::BoendedVarACSLTypename(IsACSLTypename *p1)
{
  isacsltypename_ = p1;

}

BoendedVarACSLTypename::BoendedVarACSLTypename(const BoendedVarACSLTypename & other)
{
  isacsltypename_ = other.isacsltypename_->clone();

}

BoendedVarACSLTypename &BoendedVarACSLTypename::operator=(const BoendedVarACSLTypename & other)
{
  BoendedVarACSLTypename tmp(other);
  swap(tmp);
  return *this;
}

void BoendedVarACSLTypename::swap(BoendedVarACSLTypename & other)
{
  std::swap(isacsltypename_, other.isacsltypename_);

}

BoendedVarACSLTypename::~BoendedVarACSLTypename()
{
  delete(isacsltypename_);

}

void BoendedVarACSLTypename::accept(Visitor *v)
{
  v->visitBoendedVarACSLTypename(this);
}

BoendedVarACSLTypename *BoendedVarACSLTypename::clone() const
{
  return new BoendedVarACSLTypename(*this);
}



/********************   BoendedVarTypename    ********************/
BoendedVarTypename::BoendedVarTypename(TYPENAME p1)
{
  typename_ = p1;

}

BoendedVarTypename::BoendedVarTypename(const BoendedVarTypename & other)
{
  typename_ = other.typename_;

}

BoendedVarTypename &BoendedVarTypename::operator=(const BoendedVarTypename & other)
{
  BoendedVarTypename tmp(other);
  swap(tmp);
  return *this;
}

void BoendedVarTypename::swap(BoendedVarTypename & other)
{
  std::swap(typename_, other.typename_);

}

BoendedVarTypename::~BoendedVarTypename()
{

}

void BoendedVarTypename::accept(Visitor *v)
{
  v->visitBoendedVarTypename(this);
}

BoendedVarTypename *BoendedVarTypename::clone() const
{
  return new BoendedVarTypename(*this);
}



/********************   CharKeyWord    ********************/
CharKeyWord::CharKeyWord()
{

}

CharKeyWord::CharKeyWord(const CharKeyWord & other)
{

}

CharKeyWord &CharKeyWord::operator=(const CharKeyWord & other)
{
  CharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CharKeyWord::swap(CharKeyWord & other)
{

}

CharKeyWord::~CharKeyWord()
{

}

void CharKeyWord::accept(Visitor *v)
{
  v->visitCharKeyWord(this);
}

CharKeyWord *CharKeyWord::clone() const
{
  return new CharKeyWord(*this);
}



/********************   BooleanKeyWord    ********************/
BooleanKeyWord::BooleanKeyWord()
{

}

BooleanKeyWord::BooleanKeyWord(const BooleanKeyWord & other)
{

}

BooleanKeyWord &BooleanKeyWord::operator=(const BooleanKeyWord & other)
{
  BooleanKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BooleanKeyWord::swap(BooleanKeyWord & other)
{

}

BooleanKeyWord::~BooleanKeyWord()
{

}

void BooleanKeyWord::accept(Visitor *v)
{
  v->visitBooleanKeyWord(this);
}

BooleanKeyWord *BooleanKeyWord::clone() const
{
  return new BooleanKeyWord(*this);
}



/********************   BoolKeyWord    ********************/
BoolKeyWord::BoolKeyWord()
{

}

BoolKeyWord::BoolKeyWord(const BoolKeyWord & other)
{

}

BoolKeyWord &BoolKeyWord::operator=(const BoolKeyWord & other)
{
  BoolKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BoolKeyWord::swap(BoolKeyWord & other)
{

}

BoolKeyWord::~BoolKeyWord()
{

}

void BoolKeyWord::accept(Visitor *v)
{
  v->visitBoolKeyWord(this);
}

BoolKeyWord *BoolKeyWord::clone() const
{
  return new BoolKeyWord(*this);
}



/********************   ConstKeyWord    ********************/
ConstKeyWord::ConstKeyWord()
{

}

ConstKeyWord::ConstKeyWord(const ConstKeyWord & other)
{

}

ConstKeyWord &ConstKeyWord::operator=(const ConstKeyWord & other)
{
  ConstKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ConstKeyWord::swap(ConstKeyWord & other)
{

}

ConstKeyWord::~ConstKeyWord()
{

}

void ConstKeyWord::accept(Visitor *v)
{
  v->visitConstKeyWord(this);
}

ConstKeyWord *ConstKeyWord::clone() const
{
  return new ConstKeyWord(*this);
}



/********************   DoubleKeyWord    ********************/
DoubleKeyWord::DoubleKeyWord()
{

}

DoubleKeyWord::DoubleKeyWord(const DoubleKeyWord & other)
{

}

DoubleKeyWord &DoubleKeyWord::operator=(const DoubleKeyWord & other)
{
  DoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DoubleKeyWord::swap(DoubleKeyWord & other)
{

}

DoubleKeyWord::~DoubleKeyWord()
{

}

void DoubleKeyWord::accept(Visitor *v)
{
  v->visitDoubleKeyWord(this);
}

DoubleKeyWord *DoubleKeyWord::clone() const
{
  return new DoubleKeyWord(*this);
}



/********************   EnumKeyWord    ********************/
EnumKeyWord::EnumKeyWord()
{

}

EnumKeyWord::EnumKeyWord(const EnumKeyWord & other)
{

}

EnumKeyWord &EnumKeyWord::operator=(const EnumKeyWord & other)
{
  EnumKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void EnumKeyWord::swap(EnumKeyWord & other)
{

}

EnumKeyWord::~EnumKeyWord()
{

}

void EnumKeyWord::accept(Visitor *v)
{
  v->visitEnumKeyWord(this);
}

EnumKeyWord *EnumKeyWord::clone() const
{
  return new EnumKeyWord(*this);
}



/********************   ElseKeyWord    ********************/
ElseKeyWord::ElseKeyWord()
{

}

ElseKeyWord::ElseKeyWord(const ElseKeyWord & other)
{

}

ElseKeyWord &ElseKeyWord::operator=(const ElseKeyWord & other)
{
  ElseKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ElseKeyWord::swap(ElseKeyWord & other)
{

}

ElseKeyWord::~ElseKeyWord()
{

}

void ElseKeyWord::accept(Visitor *v)
{
  v->visitElseKeyWord(this);
}

ElseKeyWord *ElseKeyWord::clone() const
{
  return new ElseKeyWord(*this);
}



/********************   FloatKeyWord    ********************/
FloatKeyWord::FloatKeyWord()
{

}

FloatKeyWord::FloatKeyWord(const FloatKeyWord & other)
{

}

FloatKeyWord &FloatKeyWord::operator=(const FloatKeyWord & other)
{
  FloatKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void FloatKeyWord::swap(FloatKeyWord & other)
{

}

FloatKeyWord::~FloatKeyWord()
{

}

void FloatKeyWord::accept(Visitor *v)
{
  v->visitFloatKeyWord(this);
}

FloatKeyWord *FloatKeyWord::clone() const
{
  return new FloatKeyWord(*this);
}



/********************   IfKeyWord    ********************/
IfKeyWord::IfKeyWord()
{

}

IfKeyWord::IfKeyWord(const IfKeyWord & other)
{

}

IfKeyWord &IfKeyWord::operator=(const IfKeyWord & other)
{
  IfKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void IfKeyWord::swap(IfKeyWord & other)
{

}

IfKeyWord::~IfKeyWord()
{

}

void IfKeyWord::accept(Visitor *v)
{
  v->visitIfKeyWord(this);
}

IfKeyWord *IfKeyWord::clone() const
{
  return new IfKeyWord(*this);
}



/********************   IntKeyWord    ********************/
IntKeyWord::IntKeyWord()
{

}

IntKeyWord::IntKeyWord(const IntKeyWord & other)
{

}

IntKeyWord &IntKeyWord::operator=(const IntKeyWord & other)
{
  IntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void IntKeyWord::swap(IntKeyWord & other)
{

}

IntKeyWord::~IntKeyWord()
{

}

void IntKeyWord::accept(Visitor *v)
{
  v->visitIntKeyWord(this);
}

IntKeyWord *IntKeyWord::clone() const
{
  return new IntKeyWord(*this);
}



/********************   LongKeyWord    ********************/
LongKeyWord::LongKeyWord()
{

}

LongKeyWord::LongKeyWord(const LongKeyWord & other)
{

}

LongKeyWord &LongKeyWord::operator=(const LongKeyWord & other)
{
  LongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void LongKeyWord::swap(LongKeyWord & other)
{

}

LongKeyWord::~LongKeyWord()
{

}

void LongKeyWord::accept(Visitor *v)
{
  v->visitLongKeyWord(this);
}

LongKeyWord *LongKeyWord::clone() const
{
  return new LongKeyWord(*this);
}



/********************   ShortKeyWord    ********************/
ShortKeyWord::ShortKeyWord()
{

}

ShortKeyWord::ShortKeyWord(const ShortKeyWord & other)
{

}

ShortKeyWord &ShortKeyWord::operator=(const ShortKeyWord & other)
{
  ShortKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ShortKeyWord::swap(ShortKeyWord & other)
{

}

ShortKeyWord::~ShortKeyWord()
{

}

void ShortKeyWord::accept(Visitor *v)
{
  v->visitShortKeyWord(this);
}

ShortKeyWord *ShortKeyWord::clone() const
{
  return new ShortKeyWord(*this);
}



/********************   SignedKeyWord    ********************/
SignedKeyWord::SignedKeyWord()
{

}

SignedKeyWord::SignedKeyWord(const SignedKeyWord & other)
{

}

SignedKeyWord &SignedKeyWord::operator=(const SignedKeyWord & other)
{
  SignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SignedKeyWord::swap(SignedKeyWord & other)
{

}

SignedKeyWord::~SignedKeyWord()
{

}

void SignedKeyWord::accept(Visitor *v)
{
  v->visitSignedKeyWord(this);
}

SignedKeyWord *SignedKeyWord::clone() const
{
  return new SignedKeyWord(*this);
}



/********************   SizeofKeyWord    ********************/
SizeofKeyWord::SizeofKeyWord()
{

}

SizeofKeyWord::SizeofKeyWord(const SizeofKeyWord & other)
{

}

SizeofKeyWord &SizeofKeyWord::operator=(const SizeofKeyWord & other)
{
  SizeofKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SizeofKeyWord::swap(SizeofKeyWord & other)
{

}

SizeofKeyWord::~SizeofKeyWord()
{

}

void SizeofKeyWord::accept(Visitor *v)
{
  v->visitSizeofKeyWord(this);
}

SizeofKeyWord *SizeofKeyWord::clone() const
{
  return new SizeofKeyWord(*this);
}



/********************   StaticKeyWord    ********************/
StaticKeyWord::StaticKeyWord()
{

}

StaticKeyWord::StaticKeyWord(const StaticKeyWord & other)
{

}

StaticKeyWord &StaticKeyWord::operator=(const StaticKeyWord & other)
{
  StaticKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void StaticKeyWord::swap(StaticKeyWord & other)
{

}

StaticKeyWord::~StaticKeyWord()
{

}

void StaticKeyWord::accept(Visitor *v)
{
  v->visitStaticKeyWord(this);
}

StaticKeyWord *StaticKeyWord::clone() const
{
  return new StaticKeyWord(*this);
}



/********************   StructKeyWord    ********************/
StructKeyWord::StructKeyWord()
{

}

StructKeyWord::StructKeyWord(const StructKeyWord & other)
{

}

StructKeyWord &StructKeyWord::operator=(const StructKeyWord & other)
{
  StructKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void StructKeyWord::swap(StructKeyWord & other)
{

}

StructKeyWord::~StructKeyWord()
{

}

void StructKeyWord::accept(Visitor *v)
{
  v->visitStructKeyWord(this);
}

StructKeyWord *StructKeyWord::clone() const
{
  return new StructKeyWord(*this);
}



/********************   UnionKeyWord    ********************/
UnionKeyWord::UnionKeyWord()
{

}

UnionKeyWord::UnionKeyWord(const UnionKeyWord & other)
{

}

UnionKeyWord &UnionKeyWord::operator=(const UnionKeyWord & other)
{
  UnionKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void UnionKeyWord::swap(UnionKeyWord & other)
{

}

UnionKeyWord::~UnionKeyWord()
{

}

void UnionKeyWord::accept(Visitor *v)
{
  v->visitUnionKeyWord(this);
}

UnionKeyWord *UnionKeyWord::clone() const
{
  return new UnionKeyWord(*this);
}



/********************   UnsignedKeyWord    ********************/
UnsignedKeyWord::UnsignedKeyWord()
{

}

UnsignedKeyWord::UnsignedKeyWord(const UnsignedKeyWord & other)
{

}

UnsignedKeyWord &UnsignedKeyWord::operator=(const UnsignedKeyWord & other)
{
  UnsignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void UnsignedKeyWord::swap(UnsignedKeyWord & other)
{

}

UnsignedKeyWord::~UnsignedKeyWord()
{

}

void UnsignedKeyWord::accept(Visitor *v)
{
  v->visitUnsignedKeyWord(this);
}

UnsignedKeyWord *UnsignedKeyWord::clone() const
{
  return new UnsignedKeyWord(*this);
}



/********************   VoidKeyWord    ********************/
VoidKeyWord::VoidKeyWord()
{

}

VoidKeyWord::VoidKeyWord(const VoidKeyWord & other)
{

}

VoidKeyWord &VoidKeyWord::operator=(const VoidKeyWord & other)
{
  VoidKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void VoidKeyWord::swap(VoidKeyWord & other)
{

}

VoidKeyWord::~VoidKeyWord()
{

}

void VoidKeyWord::accept(Visitor *v)
{
  v->visitVoidKeyWord(this);
}

VoidKeyWord *VoidKeyWord::clone() const
{
  return new VoidKeyWord(*this);
}



/********************   CaseKeyWord    ********************/
CaseKeyWord::CaseKeyWord()
{

}

CaseKeyWord::CaseKeyWord(const CaseKeyWord & other)
{

}

CaseKeyWord &CaseKeyWord::operator=(const CaseKeyWord & other)
{
  CaseKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CaseKeyWord::swap(CaseKeyWord & other)
{

}

CaseKeyWord::~CaseKeyWord()
{

}

void CaseKeyWord::accept(Visitor *v)
{
  v->visitCaseKeyWord(this);
}

CaseKeyWord *CaseKeyWord::clone() const
{
  return new CaseKeyWord(*this);
}



/********************   ForKeyWord    ********************/
ForKeyWord::ForKeyWord()
{

}

ForKeyWord::ForKeyWord(const ForKeyWord & other)
{

}

ForKeyWord &ForKeyWord::operator=(const ForKeyWord & other)
{
  ForKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ForKeyWord::swap(ForKeyWord & other)
{

}

ForKeyWord::~ForKeyWord()
{

}

void ForKeyWord::accept(Visitor *v)
{
  v->visitForKeyWord(this);
}

ForKeyWord *ForKeyWord::clone() const
{
  return new ForKeyWord(*this);
}



/********************   VolatileKeyWord    ********************/
VolatileKeyWord::VolatileKeyWord()
{

}

VolatileKeyWord::VolatileKeyWord(const VolatileKeyWord & other)
{

}

VolatileKeyWord &VolatileKeyWord::operator=(const VolatileKeyWord & other)
{
  VolatileKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void VolatileKeyWord::swap(VolatileKeyWord & other)
{

}

VolatileKeyWord::~VolatileKeyWord()
{

}

void VolatileKeyWord::accept(Visitor *v)
{
  v->visitVolatileKeyWord(this);
}

VolatileKeyWord *VolatileKeyWord::clone() const
{
  return new VolatileKeyWord(*this);
}



/********************   EnsuresKeyWord    ********************/
EnsuresKeyWord::EnsuresKeyWord()
{

}

EnsuresKeyWord::EnsuresKeyWord(const EnsuresKeyWord & other)
{

}

EnsuresKeyWord &EnsuresKeyWord::operator=(const EnsuresKeyWord & other)
{
  EnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void EnsuresKeyWord::swap(EnsuresKeyWord & other)
{

}

EnsuresKeyWord::~EnsuresKeyWord()
{

}

void EnsuresKeyWord::accept(Visitor *v)
{
  v->visitEnsuresKeyWord(this);
}

EnsuresKeyWord *EnsuresKeyWord::clone() const
{
  return new EnsuresKeyWord(*this);
}



/********************   ExitsKeyWord    ********************/
ExitsKeyWord::ExitsKeyWord()
{

}

ExitsKeyWord::ExitsKeyWord(const ExitsKeyWord & other)
{

}

ExitsKeyWord &ExitsKeyWord::operator=(const ExitsKeyWord & other)
{
  ExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExitsKeyWord::swap(ExitsKeyWord & other)
{

}

ExitsKeyWord::~ExitsKeyWord()
{

}

void ExitsKeyWord::accept(Visitor *v)
{
  v->visitExitsKeyWord(this);
}

ExitsKeyWord *ExitsKeyWord::clone() const
{
  return new ExitsKeyWord(*this);
}



/********************   BreaksKeyWord    ********************/
BreaksKeyWord::BreaksKeyWord()
{

}

BreaksKeyWord::BreaksKeyWord(const BreaksKeyWord & other)
{

}

BreaksKeyWord &BreaksKeyWord::operator=(const BreaksKeyWord & other)
{
  BreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BreaksKeyWord::swap(BreaksKeyWord & other)
{

}

BreaksKeyWord::~BreaksKeyWord()
{

}

void BreaksKeyWord::accept(Visitor *v)
{
  v->visitBreaksKeyWord(this);
}

BreaksKeyWord *BreaksKeyWord::clone() const
{
  return new BreaksKeyWord(*this);
}



/********************   ContinuesKeyWord    ********************/
ContinuesKeyWord::ContinuesKeyWord()
{

}

ContinuesKeyWord::ContinuesKeyWord(const ContinuesKeyWord & other)
{

}

ContinuesKeyWord &ContinuesKeyWord::operator=(const ContinuesKeyWord & other)
{
  ContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ContinuesKeyWord::swap(ContinuesKeyWord & other)
{

}

ContinuesKeyWord::~ContinuesKeyWord()
{

}

void ContinuesKeyWord::accept(Visitor *v)
{
  v->visitContinuesKeyWord(this);
}

ContinuesKeyWord *ContinuesKeyWord::clone() const
{
  return new ContinuesKeyWord(*this);
}



/********************   ReturnsKeyWord    ********************/
ReturnsKeyWord::ReturnsKeyWord()
{

}

ReturnsKeyWord::ReturnsKeyWord(const ReturnsKeyWord & other)
{

}

ReturnsKeyWord &ReturnsKeyWord::operator=(const ReturnsKeyWord & other)
{
  ReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ReturnsKeyWord::swap(ReturnsKeyWord & other)
{

}

ReturnsKeyWord::~ReturnsKeyWord()
{

}

void ReturnsKeyWord::accept(Visitor *v)
{
  v->visitReturnsKeyWord(this);
}

ReturnsKeyWord *ReturnsKeyWord::clone() const
{
  return new ReturnsKeyWord(*this);
}



/********************   CheckEnsuresKeyWord    ********************/
CheckEnsuresKeyWord::CheckEnsuresKeyWord()
{

}

CheckEnsuresKeyWord::CheckEnsuresKeyWord(const CheckEnsuresKeyWord & other)
{

}

CheckEnsuresKeyWord &CheckEnsuresKeyWord::operator=(const CheckEnsuresKeyWord & other)
{
  CheckEnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckEnsuresKeyWord::swap(CheckEnsuresKeyWord & other)
{

}

CheckEnsuresKeyWord::~CheckEnsuresKeyWord()
{

}

void CheckEnsuresKeyWord::accept(Visitor *v)
{
  v->visitCheckEnsuresKeyWord(this);
}

CheckEnsuresKeyWord *CheckEnsuresKeyWord::clone() const
{
  return new CheckEnsuresKeyWord(*this);
}



/********************   CheckExitsKeyWord    ********************/
CheckExitsKeyWord::CheckExitsKeyWord()
{

}

CheckExitsKeyWord::CheckExitsKeyWord(const CheckExitsKeyWord & other)
{

}

CheckExitsKeyWord &CheckExitsKeyWord::operator=(const CheckExitsKeyWord & other)
{
  CheckExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckExitsKeyWord::swap(CheckExitsKeyWord & other)
{

}

CheckExitsKeyWord::~CheckExitsKeyWord()
{

}

void CheckExitsKeyWord::accept(Visitor *v)
{
  v->visitCheckExitsKeyWord(this);
}

CheckExitsKeyWord *CheckExitsKeyWord::clone() const
{
  return new CheckExitsKeyWord(*this);
}



/********************   CheckBreaksKeyWord    ********************/
CheckBreaksKeyWord::CheckBreaksKeyWord()
{

}

CheckBreaksKeyWord::CheckBreaksKeyWord(const CheckBreaksKeyWord & other)
{

}

CheckBreaksKeyWord &CheckBreaksKeyWord::operator=(const CheckBreaksKeyWord & other)
{
  CheckBreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckBreaksKeyWord::swap(CheckBreaksKeyWord & other)
{

}

CheckBreaksKeyWord::~CheckBreaksKeyWord()
{

}

void CheckBreaksKeyWord::accept(Visitor *v)
{
  v->visitCheckBreaksKeyWord(this);
}

CheckBreaksKeyWord *CheckBreaksKeyWord::clone() const
{
  return new CheckBreaksKeyWord(*this);
}



/********************   CheckContinuesKeyWord    ********************/
CheckContinuesKeyWord::CheckContinuesKeyWord()
{

}

CheckContinuesKeyWord::CheckContinuesKeyWord(const CheckContinuesKeyWord & other)
{

}

CheckContinuesKeyWord &CheckContinuesKeyWord::operator=(const CheckContinuesKeyWord & other)
{
  CheckContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckContinuesKeyWord::swap(CheckContinuesKeyWord & other)
{

}

CheckContinuesKeyWord::~CheckContinuesKeyWord()
{

}

void CheckContinuesKeyWord::accept(Visitor *v)
{
  v->visitCheckContinuesKeyWord(this);
}

CheckContinuesKeyWord *CheckContinuesKeyWord::clone() const
{
  return new CheckContinuesKeyWord(*this);
}



/********************   CheckReturnsKeyWord    ********************/
CheckReturnsKeyWord::CheckReturnsKeyWord()
{

}

CheckReturnsKeyWord::CheckReturnsKeyWord(const CheckReturnsKeyWord & other)
{

}

CheckReturnsKeyWord &CheckReturnsKeyWord::operator=(const CheckReturnsKeyWord & other)
{
  CheckReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckReturnsKeyWord::swap(CheckReturnsKeyWord & other)
{

}

CheckReturnsKeyWord::~CheckReturnsKeyWord()
{

}

void CheckReturnsKeyWord::accept(Visitor *v)
{
  v->visitCheckReturnsKeyWord(this);
}

CheckReturnsKeyWord *CheckReturnsKeyWord::clone() const
{
  return new CheckReturnsKeyWord(*this);
}



/********************   AdmitEnsuresKeyWord    ********************/
AdmitEnsuresKeyWord::AdmitEnsuresKeyWord()
{

}

AdmitEnsuresKeyWord::AdmitEnsuresKeyWord(const AdmitEnsuresKeyWord & other)
{

}

AdmitEnsuresKeyWord &AdmitEnsuresKeyWord::operator=(const AdmitEnsuresKeyWord & other)
{
  AdmitEnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitEnsuresKeyWord::swap(AdmitEnsuresKeyWord & other)
{

}

AdmitEnsuresKeyWord::~AdmitEnsuresKeyWord()
{

}

void AdmitEnsuresKeyWord::accept(Visitor *v)
{
  v->visitAdmitEnsuresKeyWord(this);
}

AdmitEnsuresKeyWord *AdmitEnsuresKeyWord::clone() const
{
  return new AdmitEnsuresKeyWord(*this);
}



/********************   AdmitExitsKeyWord    ********************/
AdmitExitsKeyWord::AdmitExitsKeyWord()
{

}

AdmitExitsKeyWord::AdmitExitsKeyWord(const AdmitExitsKeyWord & other)
{

}

AdmitExitsKeyWord &AdmitExitsKeyWord::operator=(const AdmitExitsKeyWord & other)
{
  AdmitExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitExitsKeyWord::swap(AdmitExitsKeyWord & other)
{

}

AdmitExitsKeyWord::~AdmitExitsKeyWord()
{

}

void AdmitExitsKeyWord::accept(Visitor *v)
{
  v->visitAdmitExitsKeyWord(this);
}

AdmitExitsKeyWord *AdmitExitsKeyWord::clone() const
{
  return new AdmitExitsKeyWord(*this);
}



/********************   AdmitBreaksKeyWord    ********************/
AdmitBreaksKeyWord::AdmitBreaksKeyWord()
{

}

AdmitBreaksKeyWord::AdmitBreaksKeyWord(const AdmitBreaksKeyWord & other)
{

}

AdmitBreaksKeyWord &AdmitBreaksKeyWord::operator=(const AdmitBreaksKeyWord & other)
{
  AdmitBreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitBreaksKeyWord::swap(AdmitBreaksKeyWord & other)
{

}

AdmitBreaksKeyWord::~AdmitBreaksKeyWord()
{

}

void AdmitBreaksKeyWord::accept(Visitor *v)
{
  v->visitAdmitBreaksKeyWord(this);
}

AdmitBreaksKeyWord *AdmitBreaksKeyWord::clone() const
{
  return new AdmitBreaksKeyWord(*this);
}



/********************   AdmitContinuesKeyWord    ********************/
AdmitContinuesKeyWord::AdmitContinuesKeyWord()
{

}

AdmitContinuesKeyWord::AdmitContinuesKeyWord(const AdmitContinuesKeyWord & other)
{

}

AdmitContinuesKeyWord &AdmitContinuesKeyWord::operator=(const AdmitContinuesKeyWord & other)
{
  AdmitContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitContinuesKeyWord::swap(AdmitContinuesKeyWord & other)
{

}

AdmitContinuesKeyWord::~AdmitContinuesKeyWord()
{

}

void AdmitContinuesKeyWord::accept(Visitor *v)
{
  v->visitAdmitContinuesKeyWord(this);
}

AdmitContinuesKeyWord *AdmitContinuesKeyWord::clone() const
{
  return new AdmitContinuesKeyWord(*this);
}



/********************   AdmitReturnsKeyWord    ********************/
AdmitReturnsKeyWord::AdmitReturnsKeyWord()
{

}

AdmitReturnsKeyWord::AdmitReturnsKeyWord(const AdmitReturnsKeyWord & other)
{

}

AdmitReturnsKeyWord &AdmitReturnsKeyWord::operator=(const AdmitReturnsKeyWord & other)
{
  AdmitReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitReturnsKeyWord::swap(AdmitReturnsKeyWord & other)
{

}

AdmitReturnsKeyWord::~AdmitReturnsKeyWord()
{

}

void AdmitReturnsKeyWord::accept(Visitor *v)
{
  v->visitAdmitReturnsKeyWord(this);
}

AdmitReturnsKeyWord *AdmitReturnsKeyWord::clone() const
{
  return new AdmitReturnsKeyWord(*this);
}



/********************   PostCondKeyWord    ********************/
PostCondKeyWord::PostCondKeyWord(PostCond *p1)
{
  postcond_ = p1;

}

PostCondKeyWord::PostCondKeyWord(const PostCondKeyWord & other)
{
  postcond_ = other.postcond_->clone();

}

PostCondKeyWord &PostCondKeyWord::operator=(const PostCondKeyWord & other)
{
  PostCondKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void PostCondKeyWord::swap(PostCondKeyWord & other)
{
  std::swap(postcond_, other.postcond_);

}

PostCondKeyWord::~PostCondKeyWord()
{
  delete(postcond_);

}

void PostCondKeyWord::accept(Visitor *v)
{
  v->visitPostCondKeyWord(this);
}

PostCondKeyWord *PostCondKeyWord::clone() const
{
  return new PostCondKeyWord(*this);
}



/********************   ExtContractKeyWord    ********************/
ExtContractKeyWord::ExtContractKeyWord(EXT_CONTRACT p1)
{
  ext_contract_ = p1;

}

ExtContractKeyWord::ExtContractKeyWord(const ExtContractKeyWord & other)
{
  ext_contract_ = other.ext_contract_;

}

ExtContractKeyWord &ExtContractKeyWord::operator=(const ExtContractKeyWord & other)
{
  ExtContractKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExtContractKeyWord::swap(ExtContractKeyWord & other)
{
  std::swap(ext_contract_, other.ext_contract_);

}

ExtContractKeyWord::~ExtContractKeyWord()
{

}

void ExtContractKeyWord::accept(Visitor *v)
{
  v->visitExtContractKeyWord(this);
}

ExtContractKeyWord *ExtContractKeyWord::clone() const
{
  return new ExtContractKeyWord(*this);
}



/********************   AssignsKeyWord    ********************/
AssignsKeyWord::AssignsKeyWord()
{

}

AssignsKeyWord::AssignsKeyWord(const AssignsKeyWord & other)
{

}

AssignsKeyWord &AssignsKeyWord::operator=(const AssignsKeyWord & other)
{
  AssignsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AssignsKeyWord::swap(AssignsKeyWord & other)
{

}

AssignsKeyWord::~AssignsKeyWord()
{

}

void AssignsKeyWord::accept(Visitor *v)
{
  v->visitAssignsKeyWord(this);
}

AssignsKeyWord *AssignsKeyWord::clone() const
{
  return new AssignsKeyWord(*this);
}



/********************   AllocatesKeyWord    ********************/
AllocatesKeyWord::AllocatesKeyWord()
{

}

AllocatesKeyWord::AllocatesKeyWord(const AllocatesKeyWord & other)
{

}

AllocatesKeyWord &AllocatesKeyWord::operator=(const AllocatesKeyWord & other)
{
  AllocatesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AllocatesKeyWord::swap(AllocatesKeyWord & other)
{

}

AllocatesKeyWord::~AllocatesKeyWord()
{

}

void AllocatesKeyWord::accept(Visitor *v)
{
  v->visitAllocatesKeyWord(this);
}

AllocatesKeyWord *AllocatesKeyWord::clone() const
{
  return new AllocatesKeyWord(*this);
}



/********************   FreesKeyWord    ********************/
FreesKeyWord::FreesKeyWord()
{

}

FreesKeyWord::FreesKeyWord(const FreesKeyWord & other)
{

}

FreesKeyWord &FreesKeyWord::operator=(const FreesKeyWord & other)
{
  FreesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void FreesKeyWord::swap(FreesKeyWord & other)
{

}

FreesKeyWord::~FreesKeyWord()
{

}

void FreesKeyWord::accept(Visitor *v)
{
  v->visitFreesKeyWord(this);
}

FreesKeyWord *FreesKeyWord::clone() const
{
  return new FreesKeyWord(*this);
}



/********************   BehaviorKeyWord    ********************/
BehaviorKeyWord::BehaviorKeyWord()
{

}

BehaviorKeyWord::BehaviorKeyWord(const BehaviorKeyWord & other)
{

}

BehaviorKeyWord &BehaviorKeyWord::operator=(const BehaviorKeyWord & other)
{
  BehaviorKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BehaviorKeyWord::swap(BehaviorKeyWord & other)
{

}

BehaviorKeyWord::~BehaviorKeyWord()
{

}

void BehaviorKeyWord::accept(Visitor *v)
{
  v->visitBehaviorKeyWord(this);
}

BehaviorKeyWord *BehaviorKeyWord::clone() const
{
  return new BehaviorKeyWord(*this);
}



/********************   RequiresKeyWord    ********************/
RequiresKeyWord::RequiresKeyWord()
{

}

RequiresKeyWord::RequiresKeyWord(const RequiresKeyWord & other)
{

}

RequiresKeyWord &RequiresKeyWord::operator=(const RequiresKeyWord & other)
{
  RequiresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void RequiresKeyWord::swap(RequiresKeyWord & other)
{

}

RequiresKeyWord::~RequiresKeyWord()
{

}

void RequiresKeyWord::accept(Visitor *v)
{
  v->visitRequiresKeyWord(this);
}

RequiresKeyWord *RequiresKeyWord::clone() const
{
  return new RequiresKeyWord(*this);
}



/********************   CheckRequiresKeyWord    ********************/
CheckRequiresKeyWord::CheckRequiresKeyWord()
{

}

CheckRequiresKeyWord::CheckRequiresKeyWord(const CheckRequiresKeyWord & other)
{

}

CheckRequiresKeyWord &CheckRequiresKeyWord::operator=(const CheckRequiresKeyWord & other)
{
  CheckRequiresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckRequiresKeyWord::swap(CheckRequiresKeyWord & other)
{

}

CheckRequiresKeyWord::~CheckRequiresKeyWord()
{

}

void CheckRequiresKeyWord::accept(Visitor *v)
{
  v->visitCheckRequiresKeyWord(this);
}

CheckRequiresKeyWord *CheckRequiresKeyWord::clone() const
{
  return new CheckRequiresKeyWord(*this);
}



/********************   AdmitRequiresKeyWord    ********************/
AdmitRequiresKeyWord::AdmitRequiresKeyWord()
{

}

AdmitRequiresKeyWord::AdmitRequiresKeyWord(const AdmitRequiresKeyWord & other)
{

}

AdmitRequiresKeyWord &AdmitRequiresKeyWord::operator=(const AdmitRequiresKeyWord & other)
{
  AdmitRequiresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitRequiresKeyWord::swap(AdmitRequiresKeyWord & other)
{

}

AdmitRequiresKeyWord::~AdmitRequiresKeyWord()
{

}

void AdmitRequiresKeyWord::accept(Visitor *v)
{
  v->visitAdmitRequiresKeyWord(this);
}

AdmitRequiresKeyWord *AdmitRequiresKeyWord::clone() const
{
  return new AdmitRequiresKeyWord(*this);
}



/********************   TerminatesKeyWord    ********************/
TerminatesKeyWord::TerminatesKeyWord()
{

}

TerminatesKeyWord::TerminatesKeyWord(const TerminatesKeyWord & other)
{

}

TerminatesKeyWord &TerminatesKeyWord::operator=(const TerminatesKeyWord & other)
{
  TerminatesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TerminatesKeyWord::swap(TerminatesKeyWord & other)
{

}

TerminatesKeyWord::~TerminatesKeyWord()
{

}

void TerminatesKeyWord::accept(Visitor *v)
{
  v->visitTerminatesKeyWord(this);
}

TerminatesKeyWord *TerminatesKeyWord::clone() const
{
  return new TerminatesKeyWord(*this);
}



/********************   CompleteKeyWord    ********************/
CompleteKeyWord::CompleteKeyWord()
{

}

CompleteKeyWord::CompleteKeyWord(const CompleteKeyWord & other)
{

}

CompleteKeyWord &CompleteKeyWord::operator=(const CompleteKeyWord & other)
{
  CompleteKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CompleteKeyWord::swap(CompleteKeyWord & other)
{

}

CompleteKeyWord::~CompleteKeyWord()
{

}

void CompleteKeyWord::accept(Visitor *v)
{
  v->visitCompleteKeyWord(this);
}

CompleteKeyWord *CompleteKeyWord::clone() const
{
  return new CompleteKeyWord(*this);
}



/********************   DecreasesKeyWord    ********************/
DecreasesKeyWord::DecreasesKeyWord()
{

}

DecreasesKeyWord::DecreasesKeyWord(const DecreasesKeyWord & other)
{

}

DecreasesKeyWord &DecreasesKeyWord::operator=(const DecreasesKeyWord & other)
{
  DecreasesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DecreasesKeyWord::swap(DecreasesKeyWord & other)
{

}

DecreasesKeyWord::~DecreasesKeyWord()
{

}

void DecreasesKeyWord::accept(Visitor *v)
{
  v->visitDecreasesKeyWord(this);
}

DecreasesKeyWord *DecreasesKeyWord::clone() const
{
  return new DecreasesKeyWord(*this);
}



/********************   DisjointKeyWord    ********************/
DisjointKeyWord::DisjointKeyWord()
{

}

DisjointKeyWord::DisjointKeyWord(const DisjointKeyWord & other)
{

}

DisjointKeyWord &DisjointKeyWord::operator=(const DisjointKeyWord & other)
{
  DisjointKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void DisjointKeyWord::swap(DisjointKeyWord & other)
{

}

DisjointKeyWord::~DisjointKeyWord()
{

}

void DisjointKeyWord::accept(Visitor *v)
{
  v->visitDisjointKeyWord(this);
}

DisjointKeyWord *DisjointKeyWord::clone() const
{
  return new DisjointKeyWord(*this);
}



/********************   ExtCodeAnnotKeyWord    ********************/
ExtCodeAnnotKeyWord::ExtCodeAnnotKeyWord(EXT_CODE_ANNOT p1)
{
  ext_code_annot_ = p1;

}

ExtCodeAnnotKeyWord::ExtCodeAnnotKeyWord(const ExtCodeAnnotKeyWord & other)
{
  ext_code_annot_ = other.ext_code_annot_;

}

ExtCodeAnnotKeyWord &ExtCodeAnnotKeyWord::operator=(const ExtCodeAnnotKeyWord & other)
{
  ExtCodeAnnotKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExtCodeAnnotKeyWord::swap(ExtCodeAnnotKeyWord & other)
{
  std::swap(ext_code_annot_, other.ext_code_annot_);

}

ExtCodeAnnotKeyWord::~ExtCodeAnnotKeyWord()
{

}

void ExtCodeAnnotKeyWord::accept(Visitor *v)
{
  v->visitExtCodeAnnotKeyWord(this);
}

ExtCodeAnnotKeyWord *ExtCodeAnnotKeyWord::clone() const
{
  return new ExtCodeAnnotKeyWord(*this);
}



/********************   ExtGlobalKeyWord    ********************/
ExtGlobalKeyWord::ExtGlobalKeyWord(EXT_GLOBAL p1)
{
  ext_global_ = p1;

}

ExtGlobalKeyWord::ExtGlobalKeyWord(const ExtGlobalKeyWord & other)
{
  ext_global_ = other.ext_global_;

}

ExtGlobalKeyWord &ExtGlobalKeyWord::operator=(const ExtGlobalKeyWord & other)
{
  ExtGlobalKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalKeyWord::swap(ExtGlobalKeyWord & other)
{
  std::swap(ext_global_, other.ext_global_);

}

ExtGlobalKeyWord::~ExtGlobalKeyWord()
{

}

void ExtGlobalKeyWord::accept(Visitor *v)
{
  v->visitExtGlobalKeyWord(this);
}

ExtGlobalKeyWord *ExtGlobalKeyWord::clone() const
{
  return new ExtGlobalKeyWord(*this);
}



/********************   ExtGlobalBlockKeyWord    ********************/
ExtGlobalBlockKeyWord::ExtGlobalBlockKeyWord(EXT_GLOBAL_BLOCK p1)
{
  ext_global_block_ = p1;

}

ExtGlobalBlockKeyWord::ExtGlobalBlockKeyWord(const ExtGlobalBlockKeyWord & other)
{
  ext_global_block_ = other.ext_global_block_;

}

ExtGlobalBlockKeyWord &ExtGlobalBlockKeyWord::operator=(const ExtGlobalBlockKeyWord & other)
{
  ExtGlobalBlockKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExtGlobalBlockKeyWord::swap(ExtGlobalBlockKeyWord & other)
{
  std::swap(ext_global_block_, other.ext_global_block_);

}

ExtGlobalBlockKeyWord::~ExtGlobalBlockKeyWord()
{

}

void ExtGlobalBlockKeyWord::accept(Visitor *v)
{
  v->visitExtGlobalBlockKeyWord(this);
}

ExtGlobalBlockKeyWord *ExtGlobalBlockKeyWord::clone() const
{
  return new ExtGlobalBlockKeyWord(*this);
}



/********************   AssumesKeyWord    ********************/
AssumesKeyWord::AssumesKeyWord()
{

}

AssumesKeyWord::AssumesKeyWord(const AssumesKeyWord & other)
{

}

AssumesKeyWord &AssumesKeyWord::operator=(const AssumesKeyWord & other)
{
  AssumesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AssumesKeyWord::swap(AssumesKeyWord & other)
{

}

AssumesKeyWord::~AssumesKeyWord()
{

}

void AssumesKeyWord::accept(Visitor *v)
{
  v->visitAssumesKeyWord(this);
}

AssumesKeyWord *AssumesKeyWord::clone() const
{
  return new AssumesKeyWord(*this);
}



/********************   AssertKeyWord    ********************/
AssertKeyWord::AssertKeyWord()
{

}

AssertKeyWord::AssertKeyWord(const AssertKeyWord & other)
{

}

AssertKeyWord &AssertKeyWord::operator=(const AssertKeyWord & other)
{
  AssertKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AssertKeyWord::swap(AssertKeyWord & other)
{

}

AssertKeyWord::~AssertKeyWord()
{

}

void AssertKeyWord::accept(Visitor *v)
{
  v->visitAssertKeyWord(this);
}

AssertKeyWord *AssertKeyWord::clone() const
{
  return new AssertKeyWord(*this);
}



/********************   CheckKeyWord    ********************/
CheckKeyWord::CheckKeyWord()
{

}

CheckKeyWord::CheckKeyWord(const CheckKeyWord & other)
{

}

CheckKeyWord &CheckKeyWord::operator=(const CheckKeyWord & other)
{
  CheckKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckKeyWord::swap(CheckKeyWord & other)
{

}

CheckKeyWord::~CheckKeyWord()
{

}

void CheckKeyWord::accept(Visitor *v)
{
  v->visitCheckKeyWord(this);
}

CheckKeyWord *CheckKeyWord::clone() const
{
  return new CheckKeyWord(*this);
}



/********************   AdmitKeyWord    ********************/
AdmitKeyWord::AdmitKeyWord()
{

}

AdmitKeyWord::AdmitKeyWord(const AdmitKeyWord & other)
{

}

AdmitKeyWord &AdmitKeyWord::operator=(const AdmitKeyWord & other)
{
  AdmitKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitKeyWord::swap(AdmitKeyWord & other)
{

}

AdmitKeyWord::~AdmitKeyWord()
{

}

void AdmitKeyWord::accept(Visitor *v)
{
  v->visitAdmitKeyWord(this);
}

AdmitKeyWord *AdmitKeyWord::clone() const
{
  return new AdmitKeyWord(*this);
}



/********************   GlobalKeyWord    ********************/
GlobalKeyWord::GlobalKeyWord()
{

}

GlobalKeyWord::GlobalKeyWord(const GlobalKeyWord & other)
{

}

GlobalKeyWord &GlobalKeyWord::operator=(const GlobalKeyWord & other)
{
  GlobalKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void GlobalKeyWord::swap(GlobalKeyWord & other)
{

}

GlobalKeyWord::~GlobalKeyWord()
{

}

void GlobalKeyWord::accept(Visitor *v)
{
  v->visitGlobalKeyWord(this);
}

GlobalKeyWord *GlobalKeyWord::clone() const
{
  return new GlobalKeyWord(*this);
}



/********************   ImpactKeyWord    ********************/
ImpactKeyWord::ImpactKeyWord()
{

}

ImpactKeyWord::ImpactKeyWord(const ImpactKeyWord & other)
{

}

ImpactKeyWord &ImpactKeyWord::operator=(const ImpactKeyWord & other)
{
  ImpactKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ImpactKeyWord::swap(ImpactKeyWord & other)
{

}

ImpactKeyWord::~ImpactKeyWord()
{

}

void ImpactKeyWord::accept(Visitor *v)
{
  v->visitImpactKeyWord(this);
}

ImpactKeyWord *ImpactKeyWord::clone() const
{
  return new ImpactKeyWord(*this);
}



/********************   InductiveKeyWord    ********************/
InductiveKeyWord::InductiveKeyWord()
{

}

InductiveKeyWord::InductiveKeyWord(const InductiveKeyWord & other)
{

}

InductiveKeyWord &InductiveKeyWord::operator=(const InductiveKeyWord & other)
{
  InductiveKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void InductiveKeyWord::swap(InductiveKeyWord & other)
{

}

InductiveKeyWord::~InductiveKeyWord()
{

}

void InductiveKeyWord::accept(Visitor *v)
{
  v->visitInductiveKeyWord(this);
}

InductiveKeyWord *InductiveKeyWord::clone() const
{
  return new InductiveKeyWord(*this);
}



/********************   InvariantKeyWord    ********************/
InvariantKeyWord::InvariantKeyWord()
{

}

InvariantKeyWord::InvariantKeyWord(const InvariantKeyWord & other)
{

}

InvariantKeyWord &InvariantKeyWord::operator=(const InvariantKeyWord & other)
{
  InvariantKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void InvariantKeyWord::swap(InvariantKeyWord & other)
{

}

InvariantKeyWord::~InvariantKeyWord()
{

}

void InvariantKeyWord::accept(Visitor *v)
{
  v->visitInvariantKeyWord(this);
}

InvariantKeyWord *InvariantKeyWord::clone() const
{
  return new InvariantKeyWord(*this);
}



/********************   AdmitInvariantKeyWord    ********************/
AdmitInvariantKeyWord::AdmitInvariantKeyWord()
{

}

AdmitInvariantKeyWord::AdmitInvariantKeyWord(const AdmitInvariantKeyWord & other)
{

}

AdmitInvariantKeyWord &AdmitInvariantKeyWord::operator=(const AdmitInvariantKeyWord & other)
{
  AdmitInvariantKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitInvariantKeyWord::swap(AdmitInvariantKeyWord & other)
{

}

AdmitInvariantKeyWord::~AdmitInvariantKeyWord()
{

}

void AdmitInvariantKeyWord::accept(Visitor *v)
{
  v->visitAdmitInvariantKeyWord(this);
}

AdmitInvariantKeyWord *AdmitInvariantKeyWord::clone() const
{
  return new AdmitInvariantKeyWord(*this);
}



/********************   CheckInvariantKeyWord    ********************/
CheckInvariantKeyWord::CheckInvariantKeyWord()
{

}

CheckInvariantKeyWord::CheckInvariantKeyWord(const CheckInvariantKeyWord & other)
{

}

CheckInvariantKeyWord &CheckInvariantKeyWord::operator=(const CheckInvariantKeyWord & other)
{
  CheckInvariantKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckInvariantKeyWord::swap(CheckInvariantKeyWord & other)
{

}

CheckInvariantKeyWord::~CheckInvariantKeyWord()
{

}

void CheckInvariantKeyWord::accept(Visitor *v)
{
  v->visitCheckInvariantKeyWord(this);
}

CheckInvariantKeyWord *CheckInvariantKeyWord::clone() const
{
  return new CheckInvariantKeyWord(*this);
}



/********************   LemmaKeyWord    ********************/
LemmaKeyWord::LemmaKeyWord()
{

}

LemmaKeyWord::LemmaKeyWord(const LemmaKeyWord & other)
{

}

LemmaKeyWord &LemmaKeyWord::operator=(const LemmaKeyWord & other)
{
  LemmaKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void LemmaKeyWord::swap(LemmaKeyWord & other)
{

}

LemmaKeyWord::~LemmaKeyWord()
{

}

void LemmaKeyWord::accept(Visitor *v)
{
  v->visitLemmaKeyWord(this);
}

LemmaKeyWord *LemmaKeyWord::clone() const
{
  return new LemmaKeyWord(*this);
}



/********************   AdmitLemmaKeyWord    ********************/
AdmitLemmaKeyWord::AdmitLemmaKeyWord()
{

}

AdmitLemmaKeyWord::AdmitLemmaKeyWord(const AdmitLemmaKeyWord & other)
{

}

AdmitLemmaKeyWord &AdmitLemmaKeyWord::operator=(const AdmitLemmaKeyWord & other)
{
  AdmitLemmaKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLemmaKeyWord::swap(AdmitLemmaKeyWord & other)
{

}

AdmitLemmaKeyWord::~AdmitLemmaKeyWord()
{

}

void AdmitLemmaKeyWord::accept(Visitor *v)
{
  v->visitAdmitLemmaKeyWord(this);
}

AdmitLemmaKeyWord *AdmitLemmaKeyWord::clone() const
{
  return new AdmitLemmaKeyWord(*this);
}



/********************   CheckLemmaKeyWord    ********************/
CheckLemmaKeyWord::CheckLemmaKeyWord()
{

}

CheckLemmaKeyWord::CheckLemmaKeyWord(const CheckLemmaKeyWord & other)
{

}

CheckLemmaKeyWord &CheckLemmaKeyWord::operator=(const CheckLemmaKeyWord & other)
{
  CheckLemmaKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckLemmaKeyWord::swap(CheckLemmaKeyWord & other)
{

}

CheckLemmaKeyWord::~CheckLemmaKeyWord()
{

}

void CheckLemmaKeyWord::accept(Visitor *v)
{
  v->visitCheckLemmaKeyWord(this);
}

CheckLemmaKeyWord *CheckLemmaKeyWord::clone() const
{
  return new CheckLemmaKeyWord(*this);
}



/********************   LoopKeyWord    ********************/
LoopKeyWord::LoopKeyWord()
{

}

LoopKeyWord::LoopKeyWord(const LoopKeyWord & other)
{

}

LoopKeyWord &LoopKeyWord::operator=(const LoopKeyWord & other)
{
  LoopKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void LoopKeyWord::swap(LoopKeyWord & other)
{

}

LoopKeyWord::~LoopKeyWord()
{

}

void LoopKeyWord::accept(Visitor *v)
{
  v->visitLoopKeyWord(this);
}

LoopKeyWord *LoopKeyWord::clone() const
{
  return new LoopKeyWord(*this);
}



/********************   AdmitLoopKeyWord    ********************/
AdmitLoopKeyWord::AdmitLoopKeyWord()
{

}

AdmitLoopKeyWord::AdmitLoopKeyWord(const AdmitLoopKeyWord & other)
{

}

AdmitLoopKeyWord &AdmitLoopKeyWord::operator=(const AdmitLoopKeyWord & other)
{
  AdmitLoopKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLoopKeyWord::swap(AdmitLoopKeyWord & other)
{

}

AdmitLoopKeyWord::~AdmitLoopKeyWord()
{

}

void AdmitLoopKeyWord::accept(Visitor *v)
{
  v->visitAdmitLoopKeyWord(this);
}

AdmitLoopKeyWord *AdmitLoopKeyWord::clone() const
{
  return new AdmitLoopKeyWord(*this);
}



/********************   CheckLoopKeyWord    ********************/
CheckLoopKeyWord::CheckLoopKeyWord()
{

}

CheckLoopKeyWord::CheckLoopKeyWord(const CheckLoopKeyWord & other)
{

}

CheckLoopKeyWord &CheckLoopKeyWord::operator=(const CheckLoopKeyWord & other)
{
  CheckLoopKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckLoopKeyWord::swap(CheckLoopKeyWord & other)
{

}

CheckLoopKeyWord::~CheckLoopKeyWord()
{

}

void CheckLoopKeyWord::accept(Visitor *v)
{
  v->visitCheckLoopKeyWord(this);
}

CheckLoopKeyWord *CheckLoopKeyWord::clone() const
{
  return new CheckLoopKeyWord(*this);
}



/********************   PragmaKeyWord    ********************/
PragmaKeyWord::PragmaKeyWord()
{

}

PragmaKeyWord::PragmaKeyWord(const PragmaKeyWord & other)
{

}

PragmaKeyWord &PragmaKeyWord::operator=(const PragmaKeyWord & other)
{
  PragmaKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void PragmaKeyWord::swap(PragmaKeyWord & other)
{

}

PragmaKeyWord::~PragmaKeyWord()
{

}

void PragmaKeyWord::accept(Visitor *v)
{
  v->visitPragmaKeyWord(this);
}

PragmaKeyWord *PragmaKeyWord::clone() const
{
  return new PragmaKeyWord(*this);
}



/********************   PredicateKeyWord    ********************/
PredicateKeyWord::PredicateKeyWord()
{

}

PredicateKeyWord::PredicateKeyWord(const PredicateKeyWord & other)
{

}

PredicateKeyWord &PredicateKeyWord::operator=(const PredicateKeyWord & other)
{
  PredicateKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void PredicateKeyWord::swap(PredicateKeyWord & other)
{

}

PredicateKeyWord::~PredicateKeyWord()
{

}

void PredicateKeyWord::accept(Visitor *v)
{
  v->visitPredicateKeyWord(this);
}

PredicateKeyWord *PredicateKeyWord::clone() const
{
  return new PredicateKeyWord(*this);
}



/********************   SliceKeyWord    ********************/
SliceKeyWord::SliceKeyWord()
{

}

SliceKeyWord::SliceKeyWord(const SliceKeyWord & other)
{

}

SliceKeyWord &SliceKeyWord::operator=(const SliceKeyWord & other)
{
  SliceKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SliceKeyWord::swap(SliceKeyWord & other)
{

}

SliceKeyWord::~SliceKeyWord()
{

}

void SliceKeyWord::accept(Visitor *v)
{
  v->visitSliceKeyWord(this);
}

SliceKeyWord *SliceKeyWord::clone() const
{
  return new SliceKeyWord(*this);
}



/********************   TypeKeyWord    ********************/
TypeKeyWord::TypeKeyWord()
{

}

TypeKeyWord::TypeKeyWord(const TypeKeyWord & other)
{

}

TypeKeyWord &TypeKeyWord::operator=(const TypeKeyWord & other)
{
  TypeKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeKeyWord::swap(TypeKeyWord & other)
{

}

TypeKeyWord::~TypeKeyWord()
{

}

void TypeKeyWord::accept(Visitor *v)
{
  v->visitTypeKeyWord(this);
}

TypeKeyWord *TypeKeyWord::clone() const
{
  return new TypeKeyWord(*this);
}



/********************   ModelKeyWord    ********************/
ModelKeyWord::ModelKeyWord()
{

}

ModelKeyWord::ModelKeyWord(const ModelKeyWord & other)
{

}

ModelKeyWord &ModelKeyWord::operator=(const ModelKeyWord & other)
{
  ModelKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ModelKeyWord::swap(ModelKeyWord & other)
{

}

ModelKeyWord::~ModelKeyWord()
{

}

void ModelKeyWord::accept(Visitor *v)
{
  v->visitModelKeyWord(this);
}

ModelKeyWord *ModelKeyWord::clone() const
{
  return new ModelKeyWord(*this);
}



/********************   AxiomKeyWord    ********************/
AxiomKeyWord::AxiomKeyWord()
{

}

AxiomKeyWord::AxiomKeyWord(const AxiomKeyWord & other)
{

}

AxiomKeyWord &AxiomKeyWord::operator=(const AxiomKeyWord & other)
{
  AxiomKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AxiomKeyWord::swap(AxiomKeyWord & other)
{

}

AxiomKeyWord::~AxiomKeyWord()
{

}

void AxiomKeyWord::accept(Visitor *v)
{
  v->visitAxiomKeyWord(this);
}

AxiomKeyWord *AxiomKeyWord::clone() const
{
  return new AxiomKeyWord(*this);
}



/********************   VariantKeyWord    ********************/
VariantKeyWord::VariantKeyWord()
{

}

VariantKeyWord::VariantKeyWord(const VariantKeyWord & other)
{

}

VariantKeyWord &VariantKeyWord::operator=(const VariantKeyWord & other)
{
  VariantKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void VariantKeyWord::swap(VariantKeyWord & other)
{

}

VariantKeyWord::~VariantKeyWord()
{

}

void VariantKeyWord::accept(Visitor *v)
{
  v->visitVariantKeyWord(this);
}

VariantKeyWord *VariantKeyWord::clone() const
{
  return new VariantKeyWord(*this);
}



/********************   AxiomaticKeyWord    ********************/
AxiomaticKeyWord::AxiomaticKeyWord()
{

}

AxiomaticKeyWord::AxiomaticKeyWord(const AxiomaticKeyWord & other)
{

}

AxiomaticKeyWord &AxiomaticKeyWord::operator=(const AxiomaticKeyWord & other)
{
  AxiomaticKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AxiomaticKeyWord::swap(AxiomaticKeyWord & other)
{

}

AxiomaticKeyWord::~AxiomaticKeyWord()
{

}

void AxiomaticKeyWord::accept(Visitor *v)
{
  v->visitAxiomaticKeyWord(this);
}

AxiomaticKeyWord *AxiomaticKeyWord::clone() const
{
  return new AxiomaticKeyWord(*this);
}



/********************   IntegerKeyWord    ********************/
IntegerKeyWord::IntegerKeyWord()
{

}

IntegerKeyWord::IntegerKeyWord(const IntegerKeyWord & other)
{

}

IntegerKeyWord &IntegerKeyWord::operator=(const IntegerKeyWord & other)
{
  IntegerKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void IntegerKeyWord::swap(IntegerKeyWord & other)
{

}

IntegerKeyWord::~IntegerKeyWord()
{

}

void IntegerKeyWord::accept(Visitor *v)
{
  v->visitIntegerKeyWord(this);
}

IntegerKeyWord *IntegerKeyWord::clone() const
{
  return new IntegerKeyWord(*this);
}



/********************   RealKeyWord    ********************/
RealKeyWord::RealKeyWord()
{

}

RealKeyWord::RealKeyWord(const RealKeyWord & other)
{

}

RealKeyWord &RealKeyWord::operator=(const RealKeyWord & other)
{
  RealKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void RealKeyWord::swap(RealKeyWord & other)
{

}

RealKeyWord::~RealKeyWord()
{

}

void RealKeyWord::accept(Visitor *v)
{
  v->visitRealKeyWord(this);
}

RealKeyWord *RealKeyWord::clone() const
{
  return new RealKeyWord(*this);
}



/********************   ContractKeyWord    ********************/
ContractKeyWord::ContractKeyWord()
{

}

ContractKeyWord::ContractKeyWord(const ContractKeyWord & other)
{

}

ContractKeyWord &ContractKeyWord::operator=(const ContractKeyWord & other)
{
  ContractKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ContractKeyWord::swap(ContractKeyWord & other)
{

}

ContractKeyWord::~ContractKeyWord()
{

}

void ContractKeyWord::accept(Visitor *v)
{
  v->visitContractKeyWord(this);
}

ContractKeyWord *ContractKeyWord::clone() const
{
  return new ContractKeyWord(*this);
}



/********************   FunctionKeyWord    ********************/
FunctionKeyWord::FunctionKeyWord()
{

}

FunctionKeyWord::FunctionKeyWord(const FunctionKeyWord & other)
{

}

FunctionKeyWord &FunctionKeyWord::operator=(const FunctionKeyWord & other)
{
  FunctionKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void FunctionKeyWord::swap(FunctionKeyWord & other)
{

}

FunctionKeyWord::~FunctionKeyWord()
{

}

void FunctionKeyWord::accept(Visitor *v)
{
  v->visitFunctionKeyWord(this);
}

FunctionKeyWord *FunctionKeyWord::clone() const
{
  return new FunctionKeyWord(*this);
}



/********************   ModuleKeyWord    ********************/
ModuleKeyWord::ModuleKeyWord()
{

}

ModuleKeyWord::ModuleKeyWord(const ModuleKeyWord & other)
{

}

ModuleKeyWord &ModuleKeyWord::operator=(const ModuleKeyWord & other)
{
  ModuleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ModuleKeyWord::swap(ModuleKeyWord & other)
{

}

ModuleKeyWord::~ModuleKeyWord()
{

}

void ModuleKeyWord::accept(Visitor *v)
{
  v->visitModuleKeyWord(this);
}

ModuleKeyWord *ModuleKeyWord::clone() const
{
  return new ModuleKeyWord(*this);
}



/********************   IncludeKeyWord    ********************/
IncludeKeyWord::IncludeKeyWord()
{

}

IncludeKeyWord::IncludeKeyWord(const IncludeKeyWord & other)
{

}

IncludeKeyWord &IncludeKeyWord::operator=(const IncludeKeyWord & other)
{
  IncludeKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void IncludeKeyWord::swap(IncludeKeyWord & other)
{

}

IncludeKeyWord::~IncludeKeyWord()
{

}

void IncludeKeyWord::accept(Visitor *v)
{
  v->visitIncludeKeyWord(this);
}

IncludeKeyWord *IncludeKeyWord::clone() const
{
  return new IncludeKeyWord(*this);
}



/********************   AtKeyWord    ********************/
AtKeyWord::AtKeyWord()
{

}

AtKeyWord::AtKeyWord(const AtKeyWord & other)
{

}

AtKeyWord &AtKeyWord::operator=(const AtKeyWord & other)
{
  AtKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AtKeyWord::swap(AtKeyWord & other)
{

}

AtKeyWord::~AtKeyWord()
{

}

void AtKeyWord::accept(Visitor *v)
{
  v->visitAtKeyWord(this);
}

AtKeyWord *AtKeyWord::clone() const
{
  return new AtKeyWord(*this);
}



/********************   LetKeyWord    ********************/
LetKeyWord::LetKeyWord()
{

}

LetKeyWord::LetKeyWord(const LetKeyWord & other)
{

}

LetKeyWord &LetKeyWord::operator=(const LetKeyWord & other)
{
  LetKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void LetKeyWord::swap(LetKeyWord & other)
{

}

LetKeyWord::~LetKeyWord()
{

}

void LetKeyWord::accept(Visitor *v)
{
  v->visitLetKeyWord(this);
}

LetKeyWord *LetKeyWord::clone() const
{
  return new LetKeyWord(*this);
}



/********************   LogicKeyWord    ********************/
LogicKeyWord::LogicKeyWord()
{

}

LogicKeyWord::LogicKeyWord(const LogicKeyWord & other)
{

}

LogicKeyWord &LogicKeyWord::operator=(const LogicKeyWord & other)
{
  LogicKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void LogicKeyWord::swap(LogicKeyWord & other)
{

}

LogicKeyWord::~LogicKeyWord()
{

}

void LogicKeyWord::accept(Visitor *v)
{
  v->visitLogicKeyWord(this);
}

LogicKeyWord *LogicKeyWord::clone() const
{
  return new LogicKeyWord(*this);
}



/********************   CKeyWord    ********************/
CKeyWord::CKeyWord(CKeyword *p1)
{
  ckeyword_ = p1;

}

CKeyWord::CKeyWord(const CKeyWord & other)
{
  ckeyword_ = other.ckeyword_->clone();

}

CKeyWord &CKeyWord::operator=(const CKeyWord & other)
{
  CKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CKeyWord::swap(CKeyWord & other)
{
  std::swap(ckeyword_, other.ckeyword_);

}

CKeyWord::~CKeyWord()
{
  delete(ckeyword_);

}

void CKeyWord::accept(Visitor *v)
{
  v->visitCKeyWord(this);
}

CKeyWord *CKeyWord::clone() const
{
  return new CKeyWord(*this);
}



/********************   ACSLCKeyWord    ********************/
ACSLCKeyWord::ACSLCKeyWord(ACSLCKeyword *p1)
{
  acslckeyword_ = p1;

}

ACSLCKeyWord::ACSLCKeyWord(const ACSLCKeyWord & other)
{
  acslckeyword_ = other.acslckeyword_->clone();

}

ACSLCKeyWord &ACSLCKeyWord::operator=(const ACSLCKeyWord & other)
{
  ACSLCKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ACSLCKeyWord::swap(ACSLCKeyWord & other)
{
  std::swap(acslckeyword_, other.acslckeyword_);

}

ACSLCKeyWord::~ACSLCKeyWord()
{
  delete(acslckeyword_);

}

void ACSLCKeyWord::accept(Visitor *v)
{
  v->visitACSLCKeyWord(this);
}

ACSLCKeyWord *ACSLCKeyWord::clone() const
{
  return new ACSLCKeyWord(*this);
}



/********************   ExtSpecKeyWord    ********************/
ExtSpecKeyWord::ExtSpecKeyWord(IsExtSpec *p1)
{
  isextspec_ = p1;

}

ExtSpecKeyWord::ExtSpecKeyWord(const ExtSpecKeyWord & other)
{
  isextspec_ = other.isextspec_->clone();

}

ExtSpecKeyWord &ExtSpecKeyWord::operator=(const ExtSpecKeyWord & other)
{
  ExtSpecKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExtSpecKeyWord::swap(ExtSpecKeyWord & other)
{
  std::swap(isextspec_, other.isextspec_);

}

ExtSpecKeyWord::~ExtSpecKeyWord()
{
  delete(isextspec_);

}

void ExtSpecKeyWord::accept(Visitor *v)
{
  v->visitExtSpecKeyWord(this);
}

ExtSpecKeyWord *ExtSpecKeyWord::clone() const
{
  return new ExtSpecKeyWord(*this);
}



/********************   ACSLSpecKeyWord    ********************/
ACSLSpecKeyWord::ACSLSpecKeyWord(IsACSLSpec *p1)
{
  isacslspec_ = p1;

}

ACSLSpecKeyWord::ACSLSpecKeyWord(const ACSLSpecKeyWord & other)
{
  isacslspec_ = other.isacslspec_->clone();

}

ACSLSpecKeyWord &ACSLSpecKeyWord::operator=(const ACSLSpecKeyWord & other)
{
  ACSLSpecKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ACSLSpecKeyWord::swap(ACSLSpecKeyWord & other)
{
  std::swap(isacslspec_, other.isacslspec_);

}

ACSLSpecKeyWord::~ACSLSpecKeyWord()
{
  delete(isacslspec_);

}

void ACSLSpecKeyWord::accept(Visitor *v)
{
  v->visitACSLSpecKeyWord(this);
}

ACSLSpecKeyWord *ACSLSpecKeyWord::clone() const
{
  return new ACSLSpecKeyWord(*this);
}



/********************   ACSLDeclCodeAnnotKeyWord    ********************/
ACSLDeclCodeAnnotKeyWord::ACSLDeclCodeAnnotKeyWord(IsACSLDeclOrCodeAnnot *p1)
{
  isacsldeclorcodeannot_ = p1;

}

ACSLDeclCodeAnnotKeyWord::ACSLDeclCodeAnnotKeyWord(const ACSLDeclCodeAnnotKeyWord & other)
{
  isacsldeclorcodeannot_ = other.isacsldeclorcodeannot_->clone();

}

ACSLDeclCodeAnnotKeyWord &ACSLDeclCodeAnnotKeyWord::operator=(const ACSLDeclCodeAnnotKeyWord & other)
{
  ACSLDeclCodeAnnotKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ACSLDeclCodeAnnotKeyWord::swap(ACSLDeclCodeAnnotKeyWord & other)
{
  std::swap(isacsldeclorcodeannot_, other.isacsldeclorcodeannot_);

}

ACSLDeclCodeAnnotKeyWord::~ACSLDeclCodeAnnotKeyWord()
{
  delete(isacsldeclorcodeannot_);

}

void ACSLDeclCodeAnnotKeyWord::accept(Visitor *v)
{
  v->visitACSLDeclCodeAnnotKeyWord(this);
}

ACSLDeclCodeAnnotKeyWord *ACSLDeclCodeAnnotKeyWord::clone() const
{
  return new ACSLDeclCodeAnnotKeyWord(*this);
}



/********************   SlashAllocableKeyWord    ********************/
SlashAllocableKeyWord::SlashAllocableKeyWord()
{

}

SlashAllocableKeyWord::SlashAllocableKeyWord(const SlashAllocableKeyWord & other)
{

}

SlashAllocableKeyWord &SlashAllocableKeyWord::operator=(const SlashAllocableKeyWord & other)
{
  SlashAllocableKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashAllocableKeyWord::swap(SlashAllocableKeyWord & other)
{

}

SlashAllocableKeyWord::~SlashAllocableKeyWord()
{

}

void SlashAllocableKeyWord::accept(Visitor *v)
{
  v->visitSlashAllocableKeyWord(this);
}

SlashAllocableKeyWord *SlashAllocableKeyWord::clone() const
{
  return new SlashAllocableKeyWord(*this);
}



/********************   SlashAllocationKeyWord    ********************/
SlashAllocationKeyWord::SlashAllocationKeyWord()
{

}

SlashAllocationKeyWord::SlashAllocationKeyWord(const SlashAllocationKeyWord & other)
{

}

SlashAllocationKeyWord &SlashAllocationKeyWord::operator=(const SlashAllocationKeyWord & other)
{
  SlashAllocationKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashAllocationKeyWord::swap(SlashAllocationKeyWord & other)
{

}

SlashAllocationKeyWord::~SlashAllocationKeyWord()
{

}

void SlashAllocationKeyWord::accept(Visitor *v)
{
  v->visitSlashAllocationKeyWord(this);
}

SlashAllocationKeyWord *SlashAllocationKeyWord::clone() const
{
  return new SlashAllocationKeyWord(*this);
}



/********************   SlashAutomaticKeyWord    ********************/
SlashAutomaticKeyWord::SlashAutomaticKeyWord()
{

}

SlashAutomaticKeyWord::SlashAutomaticKeyWord(const SlashAutomaticKeyWord & other)
{

}

SlashAutomaticKeyWord &SlashAutomaticKeyWord::operator=(const SlashAutomaticKeyWord & other)
{
  SlashAutomaticKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashAutomaticKeyWord::swap(SlashAutomaticKeyWord & other)
{

}

SlashAutomaticKeyWord::~SlashAutomaticKeyWord()
{

}

void SlashAutomaticKeyWord::accept(Visitor *v)
{
  v->visitSlashAutomaticKeyWord(this);
}

SlashAutomaticKeyWord *SlashAutomaticKeyWord::clone() const
{
  return new SlashAutomaticKeyWord(*this);
}



/********************   SlashAtKeyWord    ********************/
SlashAtKeyWord::SlashAtKeyWord()
{

}

SlashAtKeyWord::SlashAtKeyWord(const SlashAtKeyWord & other)
{

}

SlashAtKeyWord &SlashAtKeyWord::operator=(const SlashAtKeyWord & other)
{
  SlashAtKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashAtKeyWord::swap(SlashAtKeyWord & other)
{

}

SlashAtKeyWord::~SlashAtKeyWord()
{

}

void SlashAtKeyWord::accept(Visitor *v)
{
  v->visitSlashAtKeyWord(this);
}

SlashAtKeyWord *SlashAtKeyWord::clone() const
{
  return new SlashAtKeyWord(*this);
}



/********************   SlashBaseAddrKeyWord    ********************/
SlashBaseAddrKeyWord::SlashBaseAddrKeyWord()
{

}

SlashBaseAddrKeyWord::SlashBaseAddrKeyWord(const SlashBaseAddrKeyWord & other)
{

}

SlashBaseAddrKeyWord &SlashBaseAddrKeyWord::operator=(const SlashBaseAddrKeyWord & other)
{
  SlashBaseAddrKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashBaseAddrKeyWord::swap(SlashBaseAddrKeyWord & other)
{

}

SlashBaseAddrKeyWord::~SlashBaseAddrKeyWord()
{

}

void SlashBaseAddrKeyWord::accept(Visitor *v)
{
  v->visitSlashBaseAddrKeyWord(this);
}

SlashBaseAddrKeyWord *SlashBaseAddrKeyWord::clone() const
{
  return new SlashBaseAddrKeyWord(*this);
}



/********************   SlashBlockLengthKeyWord    ********************/
SlashBlockLengthKeyWord::SlashBlockLengthKeyWord()
{

}

SlashBlockLengthKeyWord::SlashBlockLengthKeyWord(const SlashBlockLengthKeyWord & other)
{

}

SlashBlockLengthKeyWord &SlashBlockLengthKeyWord::operator=(const SlashBlockLengthKeyWord & other)
{
  SlashBlockLengthKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashBlockLengthKeyWord::swap(SlashBlockLengthKeyWord & other)
{

}

SlashBlockLengthKeyWord::~SlashBlockLengthKeyWord()
{

}

void SlashBlockLengthKeyWord::accept(Visitor *v)
{
  v->visitSlashBlockLengthKeyWord(this);
}

SlashBlockLengthKeyWord *SlashBlockLengthKeyWord::clone() const
{
  return new SlashBlockLengthKeyWord(*this);
}



/********************   SlashGhostKeyWord    ********************/
SlashGhostKeyWord::SlashGhostKeyWord()
{

}

SlashGhostKeyWord::SlashGhostKeyWord(const SlashGhostKeyWord & other)
{

}

SlashGhostKeyWord &SlashGhostKeyWord::operator=(const SlashGhostKeyWord & other)
{
  SlashGhostKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashGhostKeyWord::swap(SlashGhostKeyWord & other)
{

}

SlashGhostKeyWord::~SlashGhostKeyWord()
{

}

void SlashGhostKeyWord::accept(Visitor *v)
{
  v->visitSlashGhostKeyWord(this);
}

SlashGhostKeyWord *SlashGhostKeyWord::clone() const
{
  return new SlashGhostKeyWord(*this);
}



/********************   SlashDynamicKeyWord    ********************/
SlashDynamicKeyWord::SlashDynamicKeyWord()
{

}

SlashDynamicKeyWord::SlashDynamicKeyWord(const SlashDynamicKeyWord & other)
{

}

SlashDynamicKeyWord &SlashDynamicKeyWord::operator=(const SlashDynamicKeyWord & other)
{
  SlashDynamicKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashDynamicKeyWord::swap(SlashDynamicKeyWord & other)
{

}

SlashDynamicKeyWord::~SlashDynamicKeyWord()
{

}

void SlashDynamicKeyWord::accept(Visitor *v)
{
  v->visitSlashDynamicKeyWord(this);
}

SlashDynamicKeyWord *SlashDynamicKeyWord::clone() const
{
  return new SlashDynamicKeyWord(*this);
}



/********************   SlashEmptyKeyWord    ********************/
SlashEmptyKeyWord::SlashEmptyKeyWord()
{

}

SlashEmptyKeyWord::SlashEmptyKeyWord(const SlashEmptyKeyWord & other)
{

}

SlashEmptyKeyWord &SlashEmptyKeyWord::operator=(const SlashEmptyKeyWord & other)
{
  SlashEmptyKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashEmptyKeyWord::swap(SlashEmptyKeyWord & other)
{

}

SlashEmptyKeyWord::~SlashEmptyKeyWord()
{

}

void SlashEmptyKeyWord::accept(Visitor *v)
{
  v->visitSlashEmptyKeyWord(this);
}

SlashEmptyKeyWord *SlashEmptyKeyWord::clone() const
{
  return new SlashEmptyKeyWord(*this);
}



/********************   SlashFalseKeyWord    ********************/
SlashFalseKeyWord::SlashFalseKeyWord()
{

}

SlashFalseKeyWord::SlashFalseKeyWord(const SlashFalseKeyWord & other)
{

}

SlashFalseKeyWord &SlashFalseKeyWord::operator=(const SlashFalseKeyWord & other)
{
  SlashFalseKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashFalseKeyWord::swap(SlashFalseKeyWord & other)
{

}

SlashFalseKeyWord::~SlashFalseKeyWord()
{

}

void SlashFalseKeyWord::accept(Visitor *v)
{
  v->visitSlashFalseKeyWord(this);
}

SlashFalseKeyWord *SlashFalseKeyWord::clone() const
{
  return new SlashFalseKeyWord(*this);
}



/********************   SlashForallKeyWord    ********************/
SlashForallKeyWord::SlashForallKeyWord()
{

}

SlashForallKeyWord::SlashForallKeyWord(const SlashForallKeyWord & other)
{

}

SlashForallKeyWord &SlashForallKeyWord::operator=(const SlashForallKeyWord & other)
{
  SlashForallKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashForallKeyWord::swap(SlashForallKeyWord & other)
{

}

SlashForallKeyWord::~SlashForallKeyWord()
{

}

void SlashForallKeyWord::accept(Visitor *v)
{
  v->visitSlashForallKeyWord(this);
}

SlashForallKeyWord *SlashForallKeyWord::clone() const
{
  return new SlashForallKeyWord(*this);
}



/********************   SlashFreeableKeyWord    ********************/
SlashFreeableKeyWord::SlashFreeableKeyWord()
{

}

SlashFreeableKeyWord::SlashFreeableKeyWord(const SlashFreeableKeyWord & other)
{

}

SlashFreeableKeyWord &SlashFreeableKeyWord::operator=(const SlashFreeableKeyWord & other)
{
  SlashFreeableKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashFreeableKeyWord::swap(SlashFreeableKeyWord & other)
{

}

SlashFreeableKeyWord::~SlashFreeableKeyWord()
{

}

void SlashFreeableKeyWord::accept(Visitor *v)
{
  v->visitSlashFreeableKeyWord(this);
}

SlashFreeableKeyWord *SlashFreeableKeyWord::clone() const
{
  return new SlashFreeableKeyWord(*this);
}



/********************   SlashFreshKeyWord    ********************/
SlashFreshKeyWord::SlashFreshKeyWord()
{

}

SlashFreshKeyWord::SlashFreshKeyWord(const SlashFreshKeyWord & other)
{

}

SlashFreshKeyWord &SlashFreshKeyWord::operator=(const SlashFreshKeyWord & other)
{
  SlashFreshKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashFreshKeyWord::swap(SlashFreshKeyWord & other)
{

}

SlashFreshKeyWord::~SlashFreshKeyWord()
{

}

void SlashFreshKeyWord::accept(Visitor *v)
{
  v->visitSlashFreshKeyWord(this);
}

SlashFreshKeyWord *SlashFreshKeyWord::clone() const
{
  return new SlashFreshKeyWord(*this);
}



/********************   SlashFromKeyWord    ********************/
SlashFromKeyWord::SlashFromKeyWord()
{

}

SlashFromKeyWord::SlashFromKeyWord(const SlashFromKeyWord & other)
{

}

SlashFromKeyWord &SlashFromKeyWord::operator=(const SlashFromKeyWord & other)
{
  SlashFromKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashFromKeyWord::swap(SlashFromKeyWord & other)
{

}

SlashFromKeyWord::~SlashFromKeyWord()
{

}

void SlashFromKeyWord::accept(Visitor *v)
{
  v->visitSlashFromKeyWord(this);
}

SlashFromKeyWord *SlashFromKeyWord::clone() const
{
  return new SlashFromKeyWord(*this);
}



/********************   SlashInterKeyWord    ********************/
SlashInterKeyWord::SlashInterKeyWord()
{

}

SlashInterKeyWord::SlashInterKeyWord(const SlashInterKeyWord & other)
{

}

SlashInterKeyWord &SlashInterKeyWord::operator=(const SlashInterKeyWord & other)
{
  SlashInterKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashInterKeyWord::swap(SlashInterKeyWord & other)
{

}

SlashInterKeyWord::~SlashInterKeyWord()
{

}

void SlashInterKeyWord::accept(Visitor *v)
{
  v->visitSlashInterKeyWord(this);
}

SlashInterKeyWord *SlashInterKeyWord::clone() const
{
  return new SlashInterKeyWord(*this);
}



/********************   SlashLambdaKeyWord    ********************/
SlashLambdaKeyWord::SlashLambdaKeyWord()
{

}

SlashLambdaKeyWord::SlashLambdaKeyWord(const SlashLambdaKeyWord & other)
{

}

SlashLambdaKeyWord &SlashLambdaKeyWord::operator=(const SlashLambdaKeyWord & other)
{
  SlashLambdaKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashLambdaKeyWord::swap(SlashLambdaKeyWord & other)
{

}

SlashLambdaKeyWord::~SlashLambdaKeyWord()
{

}

void SlashLambdaKeyWord::accept(Visitor *v)
{
  v->visitSlashLambdaKeyWord(this);
}

SlashLambdaKeyWord *SlashLambdaKeyWord::clone() const
{
  return new SlashLambdaKeyWord(*this);
}



/********************   SlashLetKeyWord    ********************/
SlashLetKeyWord::SlashLetKeyWord()
{

}

SlashLetKeyWord::SlashLetKeyWord(const SlashLetKeyWord & other)
{

}

SlashLetKeyWord &SlashLetKeyWord::operator=(const SlashLetKeyWord & other)
{
  SlashLetKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashLetKeyWord::swap(SlashLetKeyWord & other)
{

}

SlashLetKeyWord::~SlashLetKeyWord()
{

}

void SlashLetKeyWord::accept(Visitor *v)
{
  v->visitSlashLetKeyWord(this);
}

SlashLetKeyWord *SlashLetKeyWord::clone() const
{
  return new SlashLetKeyWord(*this);
}



/********************   SlashNothingKeyWord    ********************/
SlashNothingKeyWord::SlashNothingKeyWord()
{

}

SlashNothingKeyWord::SlashNothingKeyWord(const SlashNothingKeyWord & other)
{

}

SlashNothingKeyWord &SlashNothingKeyWord::operator=(const SlashNothingKeyWord & other)
{
  SlashNothingKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashNothingKeyWord::swap(SlashNothingKeyWord & other)
{

}

SlashNothingKeyWord::~SlashNothingKeyWord()
{

}

void SlashNothingKeyWord::accept(Visitor *v)
{
  v->visitSlashNothingKeyWord(this);
}

SlashNothingKeyWord *SlashNothingKeyWord::clone() const
{
  return new SlashNothingKeyWord(*this);
}



/********************   SlashNullKeyWord    ********************/
SlashNullKeyWord::SlashNullKeyWord()
{

}

SlashNullKeyWord::SlashNullKeyWord(const SlashNullKeyWord & other)
{

}

SlashNullKeyWord &SlashNullKeyWord::operator=(const SlashNullKeyWord & other)
{
  SlashNullKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashNullKeyWord::swap(SlashNullKeyWord & other)
{

}

SlashNullKeyWord::~SlashNullKeyWord()
{

}

void SlashNullKeyWord::accept(Visitor *v)
{
  v->visitSlashNullKeyWord(this);
}

SlashNullKeyWord *SlashNullKeyWord::clone() const
{
  return new SlashNullKeyWord(*this);
}



/********************   SlashOldKeyWord    ********************/
SlashOldKeyWord::SlashOldKeyWord()
{

}

SlashOldKeyWord::SlashOldKeyWord(const SlashOldKeyWord & other)
{

}

SlashOldKeyWord &SlashOldKeyWord::operator=(const SlashOldKeyWord & other)
{
  SlashOldKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashOldKeyWord::swap(SlashOldKeyWord & other)
{

}

SlashOldKeyWord::~SlashOldKeyWord()
{

}

void SlashOldKeyWord::accept(Visitor *v)
{
  v->visitSlashOldKeyWord(this);
}

SlashOldKeyWord *SlashOldKeyWord::clone() const
{
  return new SlashOldKeyWord(*this);
}



/********************   SlashOffsetKeyWord    ********************/
SlashOffsetKeyWord::SlashOffsetKeyWord()
{

}

SlashOffsetKeyWord::SlashOffsetKeyWord(const SlashOffsetKeyWord & other)
{

}

SlashOffsetKeyWord &SlashOffsetKeyWord::operator=(const SlashOffsetKeyWord & other)
{
  SlashOffsetKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashOffsetKeyWord::swap(SlashOffsetKeyWord & other)
{

}

SlashOffsetKeyWord::~SlashOffsetKeyWord()
{

}

void SlashOffsetKeyWord::accept(Visitor *v)
{
  v->visitSlashOffsetKeyWord(this);
}

SlashOffsetKeyWord *SlashOffsetKeyWord::clone() const
{
  return new SlashOffsetKeyWord(*this);
}



/********************   SlashRegisterKeyWord    ********************/
SlashRegisterKeyWord::SlashRegisterKeyWord()
{

}

SlashRegisterKeyWord::SlashRegisterKeyWord(const SlashRegisterKeyWord & other)
{

}

SlashRegisterKeyWord &SlashRegisterKeyWord::operator=(const SlashRegisterKeyWord & other)
{
  SlashRegisterKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashRegisterKeyWord::swap(SlashRegisterKeyWord & other)
{

}

SlashRegisterKeyWord::~SlashRegisterKeyWord()
{

}

void SlashRegisterKeyWord::accept(Visitor *v)
{
  v->visitSlashRegisterKeyWord(this);
}

SlashRegisterKeyWord *SlashRegisterKeyWord::clone() const
{
  return new SlashRegisterKeyWord(*this);
}



/********************   SlashResultKeyWord    ********************/
SlashResultKeyWord::SlashResultKeyWord()
{

}

SlashResultKeyWord::SlashResultKeyWord(const SlashResultKeyWord & other)
{

}

SlashResultKeyWord &SlashResultKeyWord::operator=(const SlashResultKeyWord & other)
{
  SlashResultKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashResultKeyWord::swap(SlashResultKeyWord & other)
{

}

SlashResultKeyWord::~SlashResultKeyWord()
{

}

void SlashResultKeyWord::accept(Visitor *v)
{
  v->visitSlashResultKeyWord(this);
}

SlashResultKeyWord *SlashResultKeyWord::clone() const
{
  return new SlashResultKeyWord(*this);
}



/********************   SlashSeparatedKeyWord    ********************/
SlashSeparatedKeyWord::SlashSeparatedKeyWord()
{

}

SlashSeparatedKeyWord::SlashSeparatedKeyWord(const SlashSeparatedKeyWord & other)
{

}

SlashSeparatedKeyWord &SlashSeparatedKeyWord::operator=(const SlashSeparatedKeyWord & other)
{
  SlashSeparatedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashSeparatedKeyWord::swap(SlashSeparatedKeyWord & other)
{

}

SlashSeparatedKeyWord::~SlashSeparatedKeyWord()
{

}

void SlashSeparatedKeyWord::accept(Visitor *v)
{
  v->visitSlashSeparatedKeyWord(this);
}

SlashSeparatedKeyWord *SlashSeparatedKeyWord::clone() const
{
  return new SlashSeparatedKeyWord(*this);
}



/********************   SlashTrueKeyWord    ********************/
SlashTrueKeyWord::SlashTrueKeyWord()
{

}

SlashTrueKeyWord::SlashTrueKeyWord(const SlashTrueKeyWord & other)
{

}

SlashTrueKeyWord &SlashTrueKeyWord::operator=(const SlashTrueKeyWord & other)
{
  SlashTrueKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashTrueKeyWord::swap(SlashTrueKeyWord & other)
{

}

SlashTrueKeyWord::~SlashTrueKeyWord()
{

}

void SlashTrueKeyWord::accept(Visitor *v)
{
  v->visitSlashTrueKeyWord(this);
}

SlashTrueKeyWord *SlashTrueKeyWord::clone() const
{
  return new SlashTrueKeyWord(*this);
}



/********************   SlashTypeKeyWord    ********************/
SlashTypeKeyWord::SlashTypeKeyWord()
{

}

SlashTypeKeyWord::SlashTypeKeyWord(const SlashTypeKeyWord & other)
{

}

SlashTypeKeyWord &SlashTypeKeyWord::operator=(const SlashTypeKeyWord & other)
{
  SlashTypeKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashTypeKeyWord::swap(SlashTypeKeyWord & other)
{

}

SlashTypeKeyWord::~SlashTypeKeyWord()
{

}

void SlashTypeKeyWord::accept(Visitor *v)
{
  v->visitSlashTypeKeyWord(this);
}

SlashTypeKeyWord *SlashTypeKeyWord::clone() const
{
  return new SlashTypeKeyWord(*this);
}



/********************   SlashTypeofKeyWord    ********************/
SlashTypeofKeyWord::SlashTypeofKeyWord()
{

}

SlashTypeofKeyWord::SlashTypeofKeyWord(const SlashTypeofKeyWord & other)
{

}

SlashTypeofKeyWord &SlashTypeofKeyWord::operator=(const SlashTypeofKeyWord & other)
{
  SlashTypeofKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashTypeofKeyWord::swap(SlashTypeofKeyWord & other)
{

}

SlashTypeofKeyWord::~SlashTypeofKeyWord()
{

}

void SlashTypeofKeyWord::accept(Visitor *v)
{
  v->visitSlashTypeofKeyWord(this);
}

SlashTypeofKeyWord *SlashTypeofKeyWord::clone() const
{
  return new SlashTypeofKeyWord(*this);
}



/********************   SlashUnionKeyWord    ********************/
SlashUnionKeyWord::SlashUnionKeyWord()
{

}

SlashUnionKeyWord::SlashUnionKeyWord(const SlashUnionKeyWord & other)
{

}

SlashUnionKeyWord &SlashUnionKeyWord::operator=(const SlashUnionKeyWord & other)
{
  SlashUnionKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashUnionKeyWord::swap(SlashUnionKeyWord & other)
{

}

SlashUnionKeyWord::~SlashUnionKeyWord()
{

}

void SlashUnionKeyWord::accept(Visitor *v)
{
  v->visitSlashUnionKeyWord(this);
}

SlashUnionKeyWord *SlashUnionKeyWord::clone() const
{
  return new SlashUnionKeyWord(*this);
}



/********************   SlashUnallocatedKeyWord    ********************/
SlashUnallocatedKeyWord::SlashUnallocatedKeyWord()
{

}

SlashUnallocatedKeyWord::SlashUnallocatedKeyWord(const SlashUnallocatedKeyWord & other)
{

}

SlashUnallocatedKeyWord &SlashUnallocatedKeyWord::operator=(const SlashUnallocatedKeyWord & other)
{
  SlashUnallocatedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashUnallocatedKeyWord::swap(SlashUnallocatedKeyWord & other)
{

}

SlashUnallocatedKeyWord::~SlashUnallocatedKeyWord()
{

}

void SlashUnallocatedKeyWord::accept(Visitor *v)
{
  v->visitSlashUnallocatedKeyWord(this);
}

SlashUnallocatedKeyWord *SlashUnallocatedKeyWord::clone() const
{
  return new SlashUnallocatedKeyWord(*this);
}



/********************   SlashObjectPointerKeyWord    ********************/
SlashObjectPointerKeyWord::SlashObjectPointerKeyWord()
{

}

SlashObjectPointerKeyWord::SlashObjectPointerKeyWord(const SlashObjectPointerKeyWord & other)
{

}

SlashObjectPointerKeyWord &SlashObjectPointerKeyWord::operator=(const SlashObjectPointerKeyWord & other)
{
  SlashObjectPointerKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashObjectPointerKeyWord::swap(SlashObjectPointerKeyWord & other)
{

}

SlashObjectPointerKeyWord::~SlashObjectPointerKeyWord()
{

}

void SlashObjectPointerKeyWord::accept(Visitor *v)
{
  v->visitSlashObjectPointerKeyWord(this);
}

SlashObjectPointerKeyWord *SlashObjectPointerKeyWord::clone() const
{
  return new SlashObjectPointerKeyWord(*this);
}



/********************   SlashValidKeyWord    ********************/
SlashValidKeyWord::SlashValidKeyWord()
{

}

SlashValidKeyWord::SlashValidKeyWord(const SlashValidKeyWord & other)
{

}

SlashValidKeyWord &SlashValidKeyWord::operator=(const SlashValidKeyWord & other)
{
  SlashValidKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashValidKeyWord::swap(SlashValidKeyWord & other)
{

}

SlashValidKeyWord::~SlashValidKeyWord()
{

}

void SlashValidKeyWord::accept(Visitor *v)
{
  v->visitSlashValidKeyWord(this);
}

SlashValidKeyWord *SlashValidKeyWord::clone() const
{
  return new SlashValidKeyWord(*this);
}



/********************   SlashValidIndexKeyWord    ********************/
SlashValidIndexKeyWord::SlashValidIndexKeyWord()
{

}

SlashValidIndexKeyWord::SlashValidIndexKeyWord(const SlashValidIndexKeyWord & other)
{

}

SlashValidIndexKeyWord &SlashValidIndexKeyWord::operator=(const SlashValidIndexKeyWord & other)
{
  SlashValidIndexKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashValidIndexKeyWord::swap(SlashValidIndexKeyWord & other)
{

}

SlashValidIndexKeyWord::~SlashValidIndexKeyWord()
{

}

void SlashValidIndexKeyWord::accept(Visitor *v)
{
  v->visitSlashValidIndexKeyWord(this);
}

SlashValidIndexKeyWord *SlashValidIndexKeyWord::clone() const
{
  return new SlashValidIndexKeyWord(*this);
}



/********************   SlashValidRangeKeyWord    ********************/
SlashValidRangeKeyWord::SlashValidRangeKeyWord()
{

}

SlashValidRangeKeyWord::SlashValidRangeKeyWord(const SlashValidRangeKeyWord & other)
{

}

SlashValidRangeKeyWord &SlashValidRangeKeyWord::operator=(const SlashValidRangeKeyWord & other)
{
  SlashValidRangeKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashValidRangeKeyWord::swap(SlashValidRangeKeyWord & other)
{

}

SlashValidRangeKeyWord::~SlashValidRangeKeyWord()
{

}

void SlashValidRangeKeyWord::accept(Visitor *v)
{
  v->visitSlashValidRangeKeyWord(this);
}

SlashValidRangeKeyWord *SlashValidRangeKeyWord::clone() const
{
  return new SlashValidRangeKeyWord(*this);
}



/********************   SlashValidReadKeyWord    ********************/
SlashValidReadKeyWord::SlashValidReadKeyWord()
{

}

SlashValidReadKeyWord::SlashValidReadKeyWord(const SlashValidReadKeyWord & other)
{

}

SlashValidReadKeyWord &SlashValidReadKeyWord::operator=(const SlashValidReadKeyWord & other)
{
  SlashValidReadKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashValidReadKeyWord::swap(SlashValidReadKeyWord & other)
{

}

SlashValidReadKeyWord::~SlashValidReadKeyWord()
{

}

void SlashValidReadKeyWord::accept(Visitor *v)
{
  v->visitSlashValidReadKeyWord(this);
}

SlashValidReadKeyWord *SlashValidReadKeyWord::clone() const
{
  return new SlashValidReadKeyWord(*this);
}



/********************   SlashValidFunctionKeyWord    ********************/
SlashValidFunctionKeyWord::SlashValidFunctionKeyWord()
{

}

SlashValidFunctionKeyWord::SlashValidFunctionKeyWord(const SlashValidFunctionKeyWord & other)
{

}

SlashValidFunctionKeyWord &SlashValidFunctionKeyWord::operator=(const SlashValidFunctionKeyWord & other)
{
  SlashValidFunctionKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashValidFunctionKeyWord::swap(SlashValidFunctionKeyWord & other)
{

}

SlashValidFunctionKeyWord::~SlashValidFunctionKeyWord()
{

}

void SlashValidFunctionKeyWord::accept(Visitor *v)
{
  v->visitSlashValidFunctionKeyWord(this);
}

SlashValidFunctionKeyWord *SlashValidFunctionKeyWord::clone() const
{
  return new SlashValidFunctionKeyWord(*this);
}



/********************   SlashInitializedKeyWord    ********************/
SlashInitializedKeyWord::SlashInitializedKeyWord()
{

}

SlashInitializedKeyWord::SlashInitializedKeyWord(const SlashInitializedKeyWord & other)
{

}

SlashInitializedKeyWord &SlashInitializedKeyWord::operator=(const SlashInitializedKeyWord & other)
{
  SlashInitializedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashInitializedKeyWord::swap(SlashInitializedKeyWord & other)
{

}

SlashInitializedKeyWord::~SlashInitializedKeyWord()
{

}

void SlashInitializedKeyWord::accept(Visitor *v)
{
  v->visitSlashInitializedKeyWord(this);
}

SlashInitializedKeyWord *SlashInitializedKeyWord::clone() const
{
  return new SlashInitializedKeyWord(*this);
}



/********************   SlashDanglingKeyWord    ********************/
SlashDanglingKeyWord::SlashDanglingKeyWord()
{

}

SlashDanglingKeyWord::SlashDanglingKeyWord(const SlashDanglingKeyWord & other)
{

}

SlashDanglingKeyWord &SlashDanglingKeyWord::operator=(const SlashDanglingKeyWord & other)
{
  SlashDanglingKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashDanglingKeyWord::swap(SlashDanglingKeyWord & other)
{

}

SlashDanglingKeyWord::~SlashDanglingKeyWord()
{

}

void SlashDanglingKeyWord::accept(Visitor *v)
{
  v->visitSlashDanglingKeyWord(this);
}

SlashDanglingKeyWord *SlashDanglingKeyWord::clone() const
{
  return new SlashDanglingKeyWord(*this);
}



/********************   SlashWithKeyWord    ********************/
SlashWithKeyWord::SlashWithKeyWord()
{

}

SlashWithKeyWord::SlashWithKeyWord(const SlashWithKeyWord & other)
{

}

SlashWithKeyWord &SlashWithKeyWord::operator=(const SlashWithKeyWord & other)
{
  SlashWithKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void SlashWithKeyWord::swap(SlashWithKeyWord & other)
{

}

SlashWithKeyWord::~SlashWithKeyWord()
{

}

void SlashWithKeyWord::accept(Visitor *v)
{
  v->visitSlashWithKeyWord(this);
}

SlashWithKeyWord *SlashWithKeyWord::clone() const
{
  return new SlashWithKeyWord(*this);
}



/********************   WildCardAnyIdent    ********************/
WildCardAnyIdent::WildCardAnyIdent(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

WildCardAnyIdent::WildCardAnyIdent(const WildCardAnyIdent & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

WildCardAnyIdent &WildCardAnyIdent::operator=(const WildCardAnyIdent & other)
{
  WildCardAnyIdent tmp(other);
  swap(tmp);
  return *this;
}

void WildCardAnyIdent::swap(WildCardAnyIdent & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

WildCardAnyIdent::~WildCardAnyIdent()
{
  delete(anyidentifier_);

}

void WildCardAnyIdent::accept(Visitor *v)
{
  v->visitWildCardAnyIdent(this);
}

WildCardAnyIdent *WildCardAnyIdent::clone() const
{
  return new WildCardAnyIdent(*this);
}



/********************   WildCardBSKeyWord    ********************/
WildCardBSKeyWord::WildCardBSKeyWord(BSKeyword *p1)
{
  bskeyword_ = p1;

}

WildCardBSKeyWord::WildCardBSKeyWord(const WildCardBSKeyWord & other)
{
  bskeyword_ = other.bskeyword_->clone();

}

WildCardBSKeyWord &WildCardBSKeyWord::operator=(const WildCardBSKeyWord & other)
{
  WildCardBSKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WildCardBSKeyWord::swap(WildCardBSKeyWord & other)
{
  std::swap(bskeyword_, other.bskeyword_);

}

WildCardBSKeyWord::~WildCardBSKeyWord()
{
  delete(bskeyword_);

}

void WildCardBSKeyWord::accept(Visitor *v)
{
  v->visitWildCardBSKeyWord(this);
}

WildCardBSKeyWord *WildCardBSKeyWord::clone() const
{
  return new WildCardBSKeyWord(*this);
}



/********************   WildcardAmp    ********************/
WildcardAmp::WildcardAmp()
{

}

WildcardAmp::WildcardAmp(const WildcardAmp & other)
{

}

WildcardAmp &WildcardAmp::operator=(const WildcardAmp & other)
{
  WildcardAmp tmp(other);
  swap(tmp);
  return *this;
}

void WildcardAmp::swap(WildcardAmp & other)
{

}

WildcardAmp::~WildcardAmp()
{

}

void WildcardAmp::accept(Visitor *v)
{
  v->visitWildcardAmp(this);
}

WildcardAmp *WildcardAmp::clone() const
{
  return new WildcardAmp(*this);
}



/********************   WildcardAnd    ********************/
WildcardAnd::WildcardAnd()
{

}

WildcardAnd::WildcardAnd(const WildcardAnd & other)
{

}

WildcardAnd &WildcardAnd::operator=(const WildcardAnd & other)
{
  WildcardAnd tmp(other);
  swap(tmp);
  return *this;
}

void WildcardAnd::swap(WildcardAnd & other)
{

}

WildcardAnd::~WildcardAnd()
{

}

void WildcardAnd::accept(Visitor *v)
{
  v->visitWildcardAnd(this);
}

WildcardAnd *WildcardAnd::clone() const
{
  return new WildcardAnd(*this);
}



/********************   WildcardArrow    ********************/
WildcardArrow::WildcardArrow()
{

}

WildcardArrow::WildcardArrow(const WildcardArrow & other)
{

}

WildcardArrow &WildcardArrow::operator=(const WildcardArrow & other)
{
  WildcardArrow tmp(other);
  swap(tmp);
  return *this;
}

void WildcardArrow::swap(WildcardArrow & other)
{

}

WildcardArrow::~WildcardArrow()
{

}

void WildcardArrow::accept(Visitor *v)
{
  v->visitWildcardArrow(this);
}

WildcardArrow *WildcardArrow::clone() const
{
  return new WildcardArrow(*this);
}



/********************   WildcardBIff    ********************/
WildcardBIff::WildcardBIff()
{

}

WildcardBIff::WildcardBIff(const WildcardBIff & other)
{

}

WildcardBIff &WildcardBIff::operator=(const WildcardBIff & other)
{
  WildcardBIff tmp(other);
  swap(tmp);
  return *this;
}

void WildcardBIff::swap(WildcardBIff & other)
{

}

WildcardBIff::~WildcardBIff()
{

}

void WildcardBIff::accept(Visitor *v)
{
  v->visitWildcardBIff(this);
}

WildcardBIff *WildcardBIff::clone() const
{
  return new WildcardBIff(*this);
}



/********************   WildcardBImplicate    ********************/
WildcardBImplicate::WildcardBImplicate()
{

}

WildcardBImplicate::WildcardBImplicate(const WildcardBImplicate & other)
{

}

WildcardBImplicate &WildcardBImplicate::operator=(const WildcardBImplicate & other)
{
  WildcardBImplicate tmp(other);
  swap(tmp);
  return *this;
}

void WildcardBImplicate::swap(WildcardBImplicate & other)
{

}

WildcardBImplicate::~WildcardBImplicate()
{

}

void WildcardBImplicate::accept(Visitor *v)
{
  v->visitWildcardBImplicate(this);
}

WildcardBImplicate *WildcardBImplicate::clone() const
{
  return new WildcardBImplicate(*this);
}



/********************   WildcardColon    ********************/
WildcardColon::WildcardColon()
{

}

WildcardColon::WildcardColon(const WildcardColon & other)
{

}

WildcardColon &WildcardColon::operator=(const WildcardColon & other)
{
  WildcardColon tmp(other);
  swap(tmp);
  return *this;
}

void WildcardColon::swap(WildcardColon & other)
{

}

WildcardColon::~WildcardColon()
{

}

void WildcardColon::accept(Visitor *v)
{
  v->visitWildcardColon(this);
}

WildcardColon *WildcardColon::clone() const
{
  return new WildcardColon(*this);
}



/********************   WildcardColonColon    ********************/
WildcardColonColon::WildcardColonColon()
{

}

WildcardColonColon::WildcardColonColon(const WildcardColonColon & other)
{

}

WildcardColonColon &WildcardColonColon::operator=(const WildcardColonColon & other)
{
  WildcardColonColon tmp(other);
  swap(tmp);
  return *this;
}

void WildcardColonColon::swap(WildcardColonColon & other)
{

}

WildcardColonColon::~WildcardColonColon()
{

}

void WildcardColonColon::accept(Visitor *v)
{
  v->visitWildcardColonColon(this);
}

WildcardColonColon *WildcardColonColon::clone() const
{
  return new WildcardColonColon(*this);
}



/********************   WildcardComma    ********************/
WildcardComma::WildcardComma()
{

}

WildcardComma::WildcardComma(const WildcardComma & other)
{

}

WildcardComma &WildcardComma::operator=(const WildcardComma & other)
{
  WildcardComma tmp(other);
  swap(tmp);
  return *this;
}

void WildcardComma::swap(WildcardComma & other)
{

}

WildcardComma::~WildcardComma()
{

}

void WildcardComma::accept(Visitor *v)
{
  v->visitWildcardComma(this);
}

WildcardComma *WildcardComma::clone() const
{
  return new WildcardComma(*this);
}



/********************   WildcardIntConstant    ********************/
WildcardIntConstant::WildcardIntConstant(Integer p1)
{
  integer_ = p1;

}

WildcardIntConstant::WildcardIntConstant(const WildcardIntConstant & other)
{
  integer_ = other.integer_;

}

WildcardIntConstant &WildcardIntConstant::operator=(const WildcardIntConstant & other)
{
  WildcardIntConstant tmp(other);
  swap(tmp);
  return *this;
}

void WildcardIntConstant::swap(WildcardIntConstant & other)
{
  std::swap(integer_, other.integer_);

}

WildcardIntConstant::~WildcardIntConstant()
{

}

void WildcardIntConstant::accept(Visitor *v)
{
  v->visitWildcardIntConstant(this);
}

WildcardIntConstant *WildcardIntConstant::clone() const
{
  return new WildcardIntConstant(*this);
}



/********************   WildcardFloatConstant    ********************/
WildcardFloatConstant::WildcardFloatConstant(Double p1)
{
  double_ = p1;

}

WildcardFloatConstant::WildcardFloatConstant(const WildcardFloatConstant & other)
{
  double_ = other.double_;

}

WildcardFloatConstant &WildcardFloatConstant::operator=(const WildcardFloatConstant & other)
{
  WildcardFloatConstant tmp(other);
  swap(tmp);
  return *this;
}

void WildcardFloatConstant::swap(WildcardFloatConstant & other)
{
  std::swap(double_, other.double_);

}

WildcardFloatConstant::~WildcardFloatConstant()
{

}

void WildcardFloatConstant::accept(Visitor *v)
{
  v->visitWildcardFloatConstant(this);
}

WildcardFloatConstant *WildcardFloatConstant::clone() const
{
  return new WildcardFloatConstant(*this);
}



/********************   WildcardStringConstant    ********************/
WildcardStringConstant::WildcardStringConstant(String p1)
{
  string_ = p1;

}

WildcardStringConstant::WildcardStringConstant(const WildcardStringConstant & other)
{
  string_ = other.string_;

}

WildcardStringConstant &WildcardStringConstant::operator=(const WildcardStringConstant & other)
{
  WildcardStringConstant tmp(other);
  swap(tmp);
  return *this;
}

void WildcardStringConstant::swap(WildcardStringConstant & other)
{
  std::swap(string_, other.string_);

}

WildcardStringConstant::~WildcardStringConstant()
{

}

void WildcardStringConstant::accept(Visitor *v)
{
  v->visitWildcardStringConstant(this);
}

WildcardStringConstant *WildcardStringConstant::clone() const
{
  return new WildcardStringConstant(*this);
}



/********************   WildcardWstringConstant    ********************/
WildcardWstringConstant::WildcardWstringConstant(WSTRING_CONSTANT p1)
{
  wstring_constant_ = p1;

}

WildcardWstringConstant::WildcardWstringConstant(const WildcardWstringConstant & other)
{
  wstring_constant_ = other.wstring_constant_;

}

WildcardWstringConstant &WildcardWstringConstant::operator=(const WildcardWstringConstant & other)
{
  WildcardWstringConstant tmp(other);
  swap(tmp);
  return *this;
}

void WildcardWstringConstant::swap(WildcardWstringConstant & other)
{
  std::swap(wstring_constant_, other.wstring_constant_);

}

WildcardWstringConstant::~WildcardWstringConstant()
{

}

void WildcardWstringConstant::accept(Visitor *v)
{
  v->visitWildcardWstringConstant(this);
}

WildcardWstringConstant *WildcardWstringConstant::clone() const
{
  return new WildcardWstringConstant(*this);
}



/********************   WildcardDollar    ********************/
WildcardDollar::WildcardDollar()
{

}

WildcardDollar::WildcardDollar(const WildcardDollar & other)
{

}

WildcardDollar &WildcardDollar::operator=(const WildcardDollar & other)
{
  WildcardDollar tmp(other);
  swap(tmp);
  return *this;
}

void WildcardDollar::swap(WildcardDollar & other)
{

}

WildcardDollar::~WildcardDollar()
{

}

void WildcardDollar::accept(Visitor *v)
{
  v->visitWildcardDollar(this);
}

WildcardDollar *WildcardDollar::clone() const
{
  return new WildcardDollar(*this);
}



/********************   WildcardDot    ********************/
WildcardDot::WildcardDot()
{

}

WildcardDot::WildcardDot(const WildcardDot & other)
{

}

WildcardDot &WildcardDot::operator=(const WildcardDot & other)
{
  WildcardDot tmp(other);
  swap(tmp);
  return *this;
}

void WildcardDot::swap(WildcardDot & other)
{

}

WildcardDot::~WildcardDot()
{

}

void WildcardDot::accept(Visitor *v)
{
  v->visitWildcardDot(this);
}

WildcardDot *WildcardDot::clone() const
{
  return new WildcardDot(*this);
}



/********************   WildcardDotDot    ********************/
WildcardDotDot::WildcardDotDot()
{

}

WildcardDotDot::WildcardDotDot(const WildcardDotDot & other)
{

}

WildcardDotDot &WildcardDotDot::operator=(const WildcardDotDot & other)
{
  WildcardDotDot tmp(other);
  swap(tmp);
  return *this;
}

void WildcardDotDot::swap(WildcardDotDot & other)
{

}

WildcardDotDot::~WildcardDotDot()
{

}

void WildcardDotDot::accept(Visitor *v)
{
  v->visitWildcardDotDot(this);
}

WildcardDotDot *WildcardDotDot::clone() const
{
  return new WildcardDotDot(*this);
}



/********************   WildcardDotDotDot    ********************/
WildcardDotDotDot::WildcardDotDotDot()
{

}

WildcardDotDotDot::WildcardDotDotDot(const WildcardDotDotDot & other)
{

}

WildcardDotDotDot &WildcardDotDotDot::operator=(const WildcardDotDotDot & other)
{
  WildcardDotDotDot tmp(other);
  swap(tmp);
  return *this;
}

void WildcardDotDotDot::swap(WildcardDotDotDot & other)
{

}

WildcardDotDotDot::~WildcardDotDotDot()
{

}

void WildcardDotDotDot::accept(Visitor *v)
{
  v->visitWildcardDotDotDot(this);
}

WildcardDotDotDot *WildcardDotDotDot::clone() const
{
  return new WildcardDotDotDot(*this);
}



/********************   WildcardEQ    ********************/
WildcardEQ::WildcardEQ()
{

}

WildcardEQ::WildcardEQ(const WildcardEQ & other)
{

}

WildcardEQ &WildcardEQ::operator=(const WildcardEQ & other)
{
  WildcardEQ tmp(other);
  swap(tmp);
  return *this;
}

void WildcardEQ::swap(WildcardEQ & other)
{

}

WildcardEQ::~WildcardEQ()
{

}

void WildcardEQ::accept(Visitor *v)
{
  v->visitWildcardEQ(this);
}

WildcardEQ *WildcardEQ::clone() const
{
  return new WildcardEQ(*this);
}



/********************   WildcardEqual    ********************/
WildcardEqual::WildcardEqual()
{

}

WildcardEqual::WildcardEqual(const WildcardEqual & other)
{

}

WildcardEqual &WildcardEqual::operator=(const WildcardEqual & other)
{
  WildcardEqual tmp(other);
  swap(tmp);
  return *this;
}

void WildcardEqual::swap(WildcardEqual & other)
{

}

WildcardEqual::~WildcardEqual()
{

}

void WildcardEqual::accept(Visitor *v)
{
  v->visitWildcardEqual(this);
}

WildcardEqual *WildcardEqual::clone() const
{
  return new WildcardEqual(*this);
}



/********************   WildcardExistsKeyWord    ********************/
WildcardExistsKeyWord::WildcardExistsKeyWord()
{

}

WildcardExistsKeyWord::WildcardExistsKeyWord(const WildcardExistsKeyWord & other)
{

}

WildcardExistsKeyWord &WildcardExistsKeyWord::operator=(const WildcardExistsKeyWord & other)
{
  WildcardExistsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WildcardExistsKeyWord::swap(WildcardExistsKeyWord & other)
{

}

WildcardExistsKeyWord::~WildcardExistsKeyWord()
{

}

void WildcardExistsKeyWord::accept(Visitor *v)
{
  v->visitWildcardExistsKeyWord(this);
}

WildcardExistsKeyWord *WildcardExistsKeyWord::clone() const
{
  return new WildcardExistsKeyWord(*this);
}



/********************   WildcardGreaterEq    ********************/
WildcardGreaterEq::WildcardGreaterEq()
{

}

WildcardGreaterEq::WildcardGreaterEq(const WildcardGreaterEq & other)
{

}

WildcardGreaterEq &WildcardGreaterEq::operator=(const WildcardGreaterEq & other)
{
  WildcardGreaterEq tmp(other);
  swap(tmp);
  return *this;
}

void WildcardGreaterEq::swap(WildcardGreaterEq & other)
{

}

WildcardGreaterEq::~WildcardGreaterEq()
{

}

void WildcardGreaterEq::accept(Visitor *v)
{
  v->visitWildcardGreaterEq(this);
}

WildcardGreaterEq *WildcardGreaterEq::clone() const
{
  return new WildcardGreaterEq(*this);
}



/********************   WildcardGhostKeyWord    ********************/
WildcardGhostKeyWord::WildcardGhostKeyWord()
{

}

WildcardGhostKeyWord::WildcardGhostKeyWord(const WildcardGhostKeyWord & other)
{

}

WildcardGhostKeyWord &WildcardGhostKeyWord::operator=(const WildcardGhostKeyWord & other)
{
  WildcardGhostKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WildcardGhostKeyWord::swap(WildcardGhostKeyWord & other)
{

}

WildcardGhostKeyWord::~WildcardGhostKeyWord()
{

}

void WildcardGhostKeyWord::accept(Visitor *v)
{
  v->visitWildcardGhostKeyWord(this);
}

WildcardGhostKeyWord *WildcardGhostKeyWord::clone() const
{
  return new WildcardGhostKeyWord(*this);
}



/********************   WildcardGreater    ********************/
WildcardGreater::WildcardGreater()
{

}

WildcardGreater::WildcardGreater(const WildcardGreater & other)
{

}

WildcardGreater &WildcardGreater::operator=(const WildcardGreater & other)
{
  WildcardGreater tmp(other);
  swap(tmp);
  return *this;
}

void WildcardGreater::swap(WildcardGreater & other)
{

}

WildcardGreater::~WildcardGreater()
{

}

void WildcardGreater::accept(Visitor *v)
{
  v->visitWildcardGreater(this);
}

WildcardGreater *WildcardGreater::clone() const
{
  return new WildcardGreater(*this);
}



/********************   WildcardGreaterGreater    ********************/
WildcardGreaterGreater::WildcardGreaterGreater()
{

}

WildcardGreaterGreater::WildcardGreaterGreater(const WildcardGreaterGreater & other)
{

}

WildcardGreaterGreater &WildcardGreaterGreater::operator=(const WildcardGreaterGreater & other)
{
  WildcardGreaterGreater tmp(other);
  swap(tmp);
  return *this;
}

void WildcardGreaterGreater::swap(WildcardGreaterGreater & other)
{

}

WildcardGreaterGreater::~WildcardGreaterGreater()
{

}

void WildcardGreaterGreater::accept(Visitor *v)
{
  v->visitWildcardGreaterGreater(this);
}

WildcardGreaterGreater *WildcardGreaterGreater::clone() const
{
  return new WildcardGreaterGreater(*this);
}



/********************   WildcardHat    ********************/
WildcardHat::WildcardHat()
{

}

WildcardHat::WildcardHat(const WildcardHat & other)
{

}

WildcardHat &WildcardHat::operator=(const WildcardHat & other)
{
  WildcardHat tmp(other);
  swap(tmp);
  return *this;
}

void WildcardHat::swap(WildcardHat & other)
{

}

WildcardHat::~WildcardHat()
{

}

void WildcardHat::accept(Visitor *v)
{
  v->visitWildcardHat(this);
}

WildcardHat *WildcardHat::clone() const
{
  return new WildcardHat(*this);
}



/********************   WildcardHatHat    ********************/
WildcardHatHat::WildcardHatHat()
{

}

WildcardHatHat::WildcardHatHat(const WildcardHatHat & other)
{

}

WildcardHatHat &WildcardHatHat::operator=(const WildcardHatHat & other)
{
  WildcardHatHat tmp(other);
  swap(tmp);
  return *this;
}

void WildcardHatHat::swap(WildcardHatHat & other)
{

}

WildcardHatHat::~WildcardHatHat()
{

}

void WildcardHatHat::accept(Visitor *v)
{
  v->visitWildcardHatHat(this);
}

WildcardHatHat *WildcardHatHat::clone() const
{
  return new WildcardHatHat(*this);
}



/********************   WildcardIff    ********************/
WildcardIff::WildcardIff()
{

}

WildcardIff::WildcardIff(const WildcardIff & other)
{

}

WildcardIff &WildcardIff::operator=(const WildcardIff & other)
{
  WildcardIff tmp(other);
  swap(tmp);
  return *this;
}

void WildcardIff::swap(WildcardIff & other)
{

}

WildcardIff::~WildcardIff()
{

}

void WildcardIff::accept(Visitor *v)
{
  v->visitWildcardIff(this);
}

WildcardIff *WildcardIff::clone() const
{
  return new WildcardIff(*this);
}



/********************   WildcardImplicate    ********************/
WildcardImplicate::WildcardImplicate()
{

}

WildcardImplicate::WildcardImplicate(const WildcardImplicate & other)
{

}

WildcardImplicate &WildcardImplicate::operator=(const WildcardImplicate & other)
{
  WildcardImplicate tmp(other);
  swap(tmp);
  return *this;
}

void WildcardImplicate::swap(WildcardImplicate & other)
{

}

WildcardImplicate::~WildcardImplicate()
{

}

void WildcardImplicate::accept(Visitor *v)
{
  v->visitWildcardImplicate(this);
}

WildcardImplicate *WildcardImplicate::clone() const
{
  return new WildcardImplicate(*this);
}



/********************   WildcardLeftBrace    ********************/
WildcardLeftBrace::WildcardLeftBrace()
{

}

WildcardLeftBrace::WildcardLeftBrace(const WildcardLeftBrace & other)
{

}

WildcardLeftBrace &WildcardLeftBrace::operator=(const WildcardLeftBrace & other)
{
  WildcardLeftBrace tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLeftBrace::swap(WildcardLeftBrace & other)
{

}

WildcardLeftBrace::~WildcardLeftBrace()
{

}

void WildcardLeftBrace::accept(Visitor *v)
{
  v->visitWildcardLeftBrace(this);
}

WildcardLeftBrace *WildcardLeftBrace::clone() const
{
  return new WildcardLeftBrace(*this);
}



/********************   WildcardLessEq    ********************/
WildcardLessEq::WildcardLessEq()
{

}

WildcardLessEq::WildcardLessEq(const WildcardLessEq & other)
{

}

WildcardLessEq &WildcardLessEq::operator=(const WildcardLessEq & other)
{
  WildcardLessEq tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLessEq::swap(WildcardLessEq & other)
{

}

WildcardLessEq::~WildcardLessEq()
{

}

void WildcardLessEq::accept(Visitor *v)
{
  v->visitWildcardLessEq(this);
}

WildcardLessEq *WildcardLessEq::clone() const
{
  return new WildcardLessEq(*this);
}



/********************   WildcardLeftPar    ********************/
WildcardLeftPar::WildcardLeftPar()
{

}

WildcardLeftPar::WildcardLeftPar(const WildcardLeftPar & other)
{

}

WildcardLeftPar &WildcardLeftPar::operator=(const WildcardLeftPar & other)
{
  WildcardLeftPar tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLeftPar::swap(WildcardLeftPar & other)
{

}

WildcardLeftPar::~WildcardLeftPar()
{

}

void WildcardLeftPar::accept(Visitor *v)
{
  v->visitWildcardLeftPar(this);
}

WildcardLeftPar *WildcardLeftPar::clone() const
{
  return new WildcardLeftPar(*this);
}



/********************   WildcardLeftSquare    ********************/
WildcardLeftSquare::WildcardLeftSquare()
{

}

WildcardLeftSquare::WildcardLeftSquare(const WildcardLeftSquare & other)
{

}

WildcardLeftSquare &WildcardLeftSquare::operator=(const WildcardLeftSquare & other)
{
  WildcardLeftSquare tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLeftSquare::swap(WildcardLeftSquare & other)
{

}

WildcardLeftSquare::~WildcardLeftSquare()
{

}

void WildcardLeftSquare::accept(Visitor *v)
{
  v->visitWildcardLeftSquare(this);
}

WildcardLeftSquare *WildcardLeftSquare::clone() const
{
  return new WildcardLeftSquare(*this);
}



/********************   WildcardLeftSquarePipe    ********************/
WildcardLeftSquarePipe::WildcardLeftSquarePipe()
{

}

WildcardLeftSquarePipe::WildcardLeftSquarePipe(const WildcardLeftSquarePipe & other)
{

}

WildcardLeftSquarePipe &WildcardLeftSquarePipe::operator=(const WildcardLeftSquarePipe & other)
{
  WildcardLeftSquarePipe tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLeftSquarePipe::swap(WildcardLeftSquarePipe & other)
{

}

WildcardLeftSquarePipe::~WildcardLeftSquarePipe()
{

}

void WildcardLeftSquarePipe::accept(Visitor *v)
{
  v->visitWildcardLeftSquarePipe(this);
}

WildcardLeftSquarePipe *WildcardLeftSquarePipe::clone() const
{
  return new WildcardLeftSquarePipe(*this);
}



/********************   WildcardLess    ********************/
WildcardLess::WildcardLess()
{

}

WildcardLess::WildcardLess(const WildcardLess & other)
{

}

WildcardLess &WildcardLess::operator=(const WildcardLess & other)
{
  WildcardLess tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLess::swap(WildcardLess & other)
{

}

WildcardLess::~WildcardLess()
{

}

void WildcardLess::accept(Visitor *v)
{
  v->visitWildcardLess(this);
}

WildcardLess *WildcardLess::clone() const
{
  return new WildcardLess(*this);
}



/********************   WildcardLessLess    ********************/
WildcardLessLess::WildcardLessLess()
{

}

WildcardLessLess::WildcardLessLess(const WildcardLessLess & other)
{

}

WildcardLessLess &WildcardLessLess::operator=(const WildcardLessLess & other)
{
  WildcardLessLess tmp(other);
  swap(tmp);
  return *this;
}

void WildcardLessLess::swap(WildcardLessLess & other)
{

}

WildcardLessLess::~WildcardLessLess()
{

}

void WildcardLessLess::accept(Visitor *v)
{
  v->visitWildcardLessLess(this);
}

WildcardLessLess *WildcardLessLess::clone() const
{
  return new WildcardLessLess(*this);
}



/********************   WildcardMinus    ********************/
WildcardMinus::WildcardMinus()
{

}

WildcardMinus::WildcardMinus(const WildcardMinus & other)
{

}

WildcardMinus &WildcardMinus::operator=(const WildcardMinus & other)
{
  WildcardMinus tmp(other);
  swap(tmp);
  return *this;
}

void WildcardMinus::swap(WildcardMinus & other)
{

}

WildcardMinus::~WildcardMinus()
{

}

void WildcardMinus::accept(Visitor *v)
{
  v->visitWildcardMinus(this);
}

WildcardMinus *WildcardMinus::clone() const
{
  return new WildcardMinus(*this);
}



/********************   WildcardNotEq    ********************/
WildcardNotEq::WildcardNotEq()
{

}

WildcardNotEq::WildcardNotEq(const WildcardNotEq & other)
{

}

WildcardNotEq &WildcardNotEq::operator=(const WildcardNotEq & other)
{
  WildcardNotEq tmp(other);
  swap(tmp);
  return *this;
}

void WildcardNotEq::swap(WildcardNotEq & other)
{

}

WildcardNotEq::~WildcardNotEq()
{

}

void WildcardNotEq::accept(Visitor *v)
{
  v->visitWildcardNotEq(this);
}

WildcardNotEq *WildcardNotEq::clone() const
{
  return new WildcardNotEq(*this);
}



/********************   WildcardNot    ********************/
WildcardNot::WildcardNot()
{

}

WildcardNot::WildcardNot(const WildcardNot & other)
{

}

WildcardNot &WildcardNot::operator=(const WildcardNot & other)
{
  WildcardNot tmp(other);
  swap(tmp);
  return *this;
}

void WildcardNot::swap(WildcardNot & other)
{

}

WildcardNot::~WildcardNot()
{

}

void WildcardNot::accept(Visitor *v)
{
  v->visitWildcardNot(this);
}

WildcardNot *WildcardNot::clone() const
{
  return new WildcardNot(*this);
}



/********************   WildcardPipePipe    ********************/
WildcardPipePipe::WildcardPipePipe()
{

}

WildcardPipePipe::WildcardPipePipe(const WildcardPipePipe & other)
{

}

WildcardPipePipe &WildcardPipePipe::operator=(const WildcardPipePipe & other)
{
  WildcardPipePipe tmp(other);
  swap(tmp);
  return *this;
}

void WildcardPipePipe::swap(WildcardPipePipe & other)
{

}

WildcardPipePipe::~WildcardPipePipe()
{

}

void WildcardPipePipe::accept(Visitor *v)
{
  v->visitWildcardPipePipe(this);
}

WildcardPipePipe *WildcardPipePipe::clone() const
{
  return new WildcardPipePipe(*this);
}



/********************   WildcardMod    ********************/
WildcardMod::WildcardMod()
{

}

WildcardMod::WildcardMod(const WildcardMod & other)
{

}

WildcardMod &WildcardMod::operator=(const WildcardMod & other)
{
  WildcardMod tmp(other);
  swap(tmp);
  return *this;
}

void WildcardMod::swap(WildcardMod & other)
{

}

WildcardMod::~WildcardMod()
{

}

void WildcardMod::accept(Visitor *v)
{
  v->visitWildcardMod(this);
}

WildcardMod *WildcardMod::clone() const
{
  return new WildcardMod(*this);
}



/********************   WildcardPiKeyWord    ********************/
WildcardPiKeyWord::WildcardPiKeyWord()
{

}

WildcardPiKeyWord::WildcardPiKeyWord(const WildcardPiKeyWord & other)
{

}

WildcardPiKeyWord &WildcardPiKeyWord::operator=(const WildcardPiKeyWord & other)
{
  WildcardPiKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WildcardPiKeyWord::swap(WildcardPiKeyWord & other)
{

}

WildcardPiKeyWord::~WildcardPiKeyWord()
{

}

void WildcardPiKeyWord::accept(Visitor *v)
{
  v->visitWildcardPiKeyWord(this);
}

WildcardPiKeyWord *WildcardPiKeyWord::clone() const
{
  return new WildcardPiKeyWord(*this);
}



/********************   WildcardPipe    ********************/
WildcardPipe::WildcardPipe()
{

}

WildcardPipe::WildcardPipe(const WildcardPipe & other)
{

}

WildcardPipe &WildcardPipe::operator=(const WildcardPipe & other)
{
  WildcardPipe tmp(other);
  swap(tmp);
  return *this;
}

void WildcardPipe::swap(WildcardPipe & other)
{

}

WildcardPipe::~WildcardPipe()
{

}

void WildcardPipe::accept(Visitor *v)
{
  v->visitWildcardPipe(this);
}

WildcardPipe *WildcardPipe::clone() const
{
  return new WildcardPipe(*this);
}



/********************   WildcardPlus    ********************/
WildcardPlus::WildcardPlus()
{

}

WildcardPlus::WildcardPlus(const WildcardPlus & other)
{

}

WildcardPlus &WildcardPlus::operator=(const WildcardPlus & other)
{
  WildcardPlus tmp(other);
  swap(tmp);
  return *this;
}

void WildcardPlus::swap(WildcardPlus & other)
{

}

WildcardPlus::~WildcardPlus()
{

}

void WildcardPlus::accept(Visitor *v)
{
  v->visitWildcardPlus(this);
}

WildcardPlus *WildcardPlus::clone() const
{
  return new WildcardPlus(*this);
}



/********************   WildcardQuestion    ********************/
WildcardQuestion::WildcardQuestion()
{

}

WildcardQuestion::WildcardQuestion(const WildcardQuestion & other)
{

}

WildcardQuestion &WildcardQuestion::operator=(const WildcardQuestion & other)
{
  WildcardQuestion tmp(other);
  swap(tmp);
  return *this;
}

void WildcardQuestion::swap(WildcardQuestion & other)
{

}

WildcardQuestion::~WildcardQuestion()
{

}

void WildcardQuestion::accept(Visitor *v)
{
  v->visitWildcardQuestion(this);
}

WildcardQuestion *WildcardQuestion::clone() const
{
  return new WildcardQuestion(*this);
}



/********************   WildcardRightBrace    ********************/
WildcardRightBrace::WildcardRightBrace()
{

}

WildcardRightBrace::WildcardRightBrace(const WildcardRightBrace & other)
{

}

WildcardRightBrace &WildcardRightBrace::operator=(const WildcardRightBrace & other)
{
  WildcardRightBrace tmp(other);
  swap(tmp);
  return *this;
}

void WildcardRightBrace::swap(WildcardRightBrace & other)
{

}

WildcardRightBrace::~WildcardRightBrace()
{

}

void WildcardRightBrace::accept(Visitor *v)
{
  v->visitWildcardRightBrace(this);
}

WildcardRightBrace *WildcardRightBrace::clone() const
{
  return new WildcardRightBrace(*this);
}



/********************   WildcardRightPar    ********************/
WildcardRightPar::WildcardRightPar()
{

}

WildcardRightPar::WildcardRightPar(const WildcardRightPar & other)
{

}

WildcardRightPar &WildcardRightPar::operator=(const WildcardRightPar & other)
{
  WildcardRightPar tmp(other);
  swap(tmp);
  return *this;
}

void WildcardRightPar::swap(WildcardRightPar & other)
{

}

WildcardRightPar::~WildcardRightPar()
{

}

void WildcardRightPar::accept(Visitor *v)
{
  v->visitWildcardRightPar(this);
}

WildcardRightPar *WildcardRightPar::clone() const
{
  return new WildcardRightPar(*this);
}



/********************   WildcardRightSquare    ********************/
WildcardRightSquare::WildcardRightSquare()
{

}

WildcardRightSquare::WildcardRightSquare(const WildcardRightSquare & other)
{

}

WildcardRightSquare &WildcardRightSquare::operator=(const WildcardRightSquare & other)
{
  WildcardRightSquare tmp(other);
  swap(tmp);
  return *this;
}

void WildcardRightSquare::swap(WildcardRightSquare & other)
{

}

WildcardRightSquare::~WildcardRightSquare()
{

}

void WildcardRightSquare::accept(Visitor *v)
{
  v->visitWildcardRightSquare(this);
}

WildcardRightSquare *WildcardRightSquare::clone() const
{
  return new WildcardRightSquare(*this);
}



/********************   WildcardRightSquarePipe    ********************/
WildcardRightSquarePipe::WildcardRightSquarePipe()
{

}

WildcardRightSquarePipe::WildcardRightSquarePipe(const WildcardRightSquarePipe & other)
{

}

WildcardRightSquarePipe &WildcardRightSquarePipe::operator=(const WildcardRightSquarePipe & other)
{
  WildcardRightSquarePipe tmp(other);
  swap(tmp);
  return *this;
}

void WildcardRightSquarePipe::swap(WildcardRightSquarePipe & other)
{

}

WildcardRightSquarePipe::~WildcardRightSquarePipe()
{

}

void WildcardRightSquarePipe::accept(Visitor *v)
{
  v->visitWildcardRightSquarePipe(this);
}

WildcardRightSquarePipe *WildcardRightSquarePipe::clone() const
{
  return new WildcardRightSquarePipe(*this);
}



/********************   WildcardSemiColon    ********************/
WildcardSemiColon::WildcardSemiColon()
{

}

WildcardSemiColon::WildcardSemiColon(const WildcardSemiColon & other)
{

}

WildcardSemiColon &WildcardSemiColon::operator=(const WildcardSemiColon & other)
{
  WildcardSemiColon tmp(other);
  swap(tmp);
  return *this;
}

void WildcardSemiColon::swap(WildcardSemiColon & other)
{

}

WildcardSemiColon::~WildcardSemiColon()
{

}

void WildcardSemiColon::accept(Visitor *v)
{
  v->visitWildcardSemiColon(this);
}

WildcardSemiColon *WildcardSemiColon::clone() const
{
  return new WildcardSemiColon(*this);
}



/********************   WildcardDivide    ********************/
WildcardDivide::WildcardDivide()
{

}

WildcardDivide::WildcardDivide(const WildcardDivide & other)
{

}

WildcardDivide &WildcardDivide::operator=(const WildcardDivide & other)
{
  WildcardDivide tmp(other);
  swap(tmp);
  return *this;
}

void WildcardDivide::swap(WildcardDivide & other)
{

}

WildcardDivide::~WildcardDivide()
{

}

void WildcardDivide::accept(Visitor *v)
{
  v->visitWildcardDivide(this);
}

WildcardDivide *WildcardDivide::clone() const
{
  return new WildcardDivide(*this);
}



/********************   WildcardMult    ********************/
WildcardMult::WildcardMult()
{

}

WildcardMult::WildcardMult(const WildcardMult & other)
{

}

WildcardMult &WildcardMult::operator=(const WildcardMult & other)
{
  WildcardMult tmp(other);
  swap(tmp);
  return *this;
}

void WildcardMult::swap(WildcardMult & other)
{

}

WildcardMult::~WildcardMult()
{

}

void WildcardMult::accept(Visitor *v)
{
  v->visitWildcardMult(this);
}

WildcardMult *WildcardMult::clone() const
{
  return new WildcardMult(*this);
}



/********************   WildcardMultHat    ********************/
WildcardMultHat::WildcardMultHat()
{

}

WildcardMultHat::WildcardMultHat(const WildcardMultHat & other)
{

}

WildcardMultHat &WildcardMultHat::operator=(const WildcardMultHat & other)
{
  WildcardMultHat tmp(other);
  swap(tmp);
  return *this;
}

void WildcardMultHat::swap(WildcardMultHat & other)
{

}

WildcardMultHat::~WildcardMultHat()
{

}

void WildcardMultHat::accept(Visitor *v)
{
  v->visitWildcardMultHat(this);
}

WildcardMultHat *WildcardMultHat::clone() const
{
  return new WildcardMultHat(*this);
}



/********************   WildcardStringLiteral    ********************/
WildcardStringLiteral::WildcardStringLiteral(STRING_LITERAL p1)
{
  string_literal_ = p1;

}

WildcardStringLiteral::WildcardStringLiteral(const WildcardStringLiteral & other)
{
  string_literal_ = other.string_literal_;

}

WildcardStringLiteral &WildcardStringLiteral::operator=(const WildcardStringLiteral & other)
{
  WildcardStringLiteral tmp(other);
  swap(tmp);
  return *this;
}

void WildcardStringLiteral::swap(WildcardStringLiteral & other)
{
  std::swap(string_literal_, other.string_literal_);

}

WildcardStringLiteral::~WildcardStringLiteral()
{

}

void WildcardStringLiteral::accept(Visitor *v)
{
  v->visitWildcardStringLiteral(this);
}

WildcardStringLiteral *WildcardStringLiteral::clone() const
{
  return new WildcardStringLiteral(*this);
}



/********************   WildcardTildeKeyWord    ********************/
WildcardTildeKeyWord::WildcardTildeKeyWord()
{

}

WildcardTildeKeyWord::WildcardTildeKeyWord(const WildcardTildeKeyWord & other)
{

}

WildcardTildeKeyWord &WildcardTildeKeyWord::operator=(const WildcardTildeKeyWord & other)
{
  WildcardTildeKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WildcardTildeKeyWord::swap(WildcardTildeKeyWord & other)
{

}

WildcardTildeKeyWord::~WildcardTildeKeyWord()
{

}

void WildcardTildeKeyWord::accept(Visitor *v)
{
  v->visitWildcardTildeKeyWord(this);
}

WildcardTildeKeyWord *WildcardTildeKeyWord::clone() const
{
  return new WildcardTildeKeyWord(*this);
}



/********************   WildcardInKeyWord    ********************/
WildcardInKeyWord::WildcardInKeyWord()
{

}

WildcardInKeyWord::WildcardInKeyWord(const WildcardInKeyWord & other)
{

}

WildcardInKeyWord &WildcardInKeyWord::operator=(const WildcardInKeyWord & other)
{
  WildcardInKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void WildcardInKeyWord::swap(WildcardInKeyWord & other)
{

}

WildcardInKeyWord::~WildcardInKeyWord()
{

}

void WildcardInKeyWord::accept(Visitor *v)
{
  v->visitWildcardInKeyWord(this);
}

WildcardInKeyWord *WildcardInKeyWord::clone() const
{
  return new WildcardInKeyWord(*this);
}




/********************   ListOneString    ********************/

void ListOneString::accept(Visitor *v)
{
  v->visitListOneString(this);
}

ListOneString *ListOneString::clone() const
{
  return new ListOneString(*this);
}

ListOneString* consListOneString(OneString* x, ListOneString* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListInitializerSingle    ********************/

void ListInitializerSingle::accept(Visitor *v)
{
  v->visitListInitializerSingle(this);
}

ListInitializerSingle *ListInitializerSingle::clone() const
{
  return new ListInitializerSingle(*this);
}

ListInitializerSingle* consListInitializerSingle(InitializerSingle* x, ListInitializerSingle* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}

ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}

ListExpression* consListExpression(Expression* x, ListExpression* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBlockElement    ********************/

void ListBlockElement::accept(Visitor *v)
{
  v->visitListBlockElement(this);
}

ListBlockElement *ListBlockElement::clone() const
{
  return new ListBlockElement(*this);
}

ListBlockElement* consListBlockElement(BlockElement* x, ListBlockElement* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAnnot    ********************/

void ListAnnot::accept(Visitor *v)
{
  v->visitListAnnot(this);
}

ListAnnot *ListAnnot::clone() const
{
  return new ListAnnot(*this);
}

ListAnnot* consListAnnot(Annot* x, ListAnnot* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLocalLabel    ********************/

void ListLocalLabel::accept(Visitor *v)
{
  v->visitListLocalLabel(this);
}

ListLocalLabel *ListLocalLabel::clone() const
{
  return new ListLocalLabel(*this);
}

ListLocalLabel* consListLocalLabel(LocalLabel* x, ListLocalLabel* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLocalLabelName    ********************/

void ListLocalLabelName::accept(Visitor *v)
{
  v->visitListLocalLabelName(this);
}

ListLocalLabelName *ListLocalLabelName::clone() const
{
  return new ListLocalLabelName(*this);
}

ListLocalLabelName* consListLocalLabelName(LocalLabelName* x, ListLocalLabelName* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListGenericAssociation    ********************/

void ListGenericAssociation::accept(Visitor *v)
{
  v->visitListGenericAssociation(this);
}

ListGenericAssociation *ListGenericAssociation::clone() const
{
  return new ListGenericAssociation(*this);
}

ListGenericAssociation* consListGenericAssociation(GenericAssociation* x, ListGenericAssociation* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListInitDeclaratorAttr    ********************/

void ListInitDeclaratorAttr::accept(Visitor *v)
{
  v->visitListInitDeclaratorAttr(this);
}

ListInitDeclaratorAttr *ListInitDeclaratorAttr::clone() const
{
  return new ListInitDeclaratorAttr(*this);
}

ListInitDeclaratorAttr* consListInitDeclaratorAttr(InitDeclaratorAttr* x, ListInitDeclaratorAttr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFieldDecl    ********************/

void ListFieldDecl::accept(Visitor *v)
{
  v->visitListFieldDecl(this);
}

ListFieldDecl *ListFieldDecl::clone() const
{
  return new ListFieldDecl(*this);
}

ListFieldDecl* consListFieldDecl(FieldDecl* x, ListFieldDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListEnumerator    ********************/

void ListEnumerator::accept(Visitor *v)
{
  v->visitListEnumerator(this);
}

ListEnumerator *ListEnumerator::clone() const
{
  return new ListEnumerator(*this);
}

ListEnumerator* consListEnumerator(Enumerator* x, ListEnumerator* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListDeclarator    ********************/

void ListDeclarator::accept(Visitor *v)
{
  v->visitListDeclarator(this);
}

ListDeclarator *ListDeclarator::clone() const
{
  return new ListDeclarator(*this);
}

ListDeclarator* consListDeclarator(Declarator* x, ListDeclarator* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListParameterDecl    ********************/

void ListParameterDecl::accept(Visitor *v)
{
  v->visitListParameterDecl(this);
}

ListParameterDecl *ListParameterDecl::clone() const
{
  return new ListParameterDecl(*this);
}

ListParameterDecl* consListParameterDecl(ParameterDecl* x, ListParameterDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}

ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}

ListIdent* consListIdent(Ident x, ListIdent* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListOldPardef    ********************/

void ListOldPardef::accept(Visitor *v)
{
  v->visitListOldPardef(this);
}

ListOldPardef *ListOldPardef::clone() const
{
  return new ListOldPardef(*this);
}

ListOldPardef* consListOldPardef(OldPardef* x, ListOldPardef* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAttributeNocv    ********************/

void ListAttributeNocv::accept(Visitor *v)
{
  v->visitListAttributeNocv(this);
}

ListAttributeNocv *ListAttributeNocv::clone() const
{
  return new ListAttributeNocv(*this);
}

ListAttributeNocv* consListAttributeNocv(AttributeNocv* x, ListAttributeNocv* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAttribute    ********************/

void ListAttribute::accept(Visitor *v)
{
  v->visitListAttribute(this);
}

ListAttribute *ListAttribute::clone() const
{
  return new ListAttribute(*this);
}

ListAttribute* consListAttribute(Attribute* x, ListAttribute* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListJustAttribute    ********************/

void ListJustAttribute::accept(Visitor *v)
{
  v->visitListJustAttribute(this);
}

ListJustAttribute *ListJustAttribute::clone() const
{
  return new ListJustAttribute(*this);
}

ListJustAttribute* consListJustAttribute(JustAttribute* x, ListJustAttribute* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBasicAttribute    ********************/

void ListBasicAttribute::accept(Visitor *v)
{
  v->visitListBasicAttribute(this);
}

ListBasicAttribute *ListBasicAttribute::clone() const
{
  return new ListBasicAttribute(*this);
}

ListBasicAttribute* consListBasicAttribute(BasicAttribute* x, ListBasicAttribute* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAttr    ********************/

void ListAttr::accept(Visitor *v)
{
  v->visitListAttr(this);
}

ListAttr *ListAttr::clone() const
{
  return new ListAttr(*this);
}

ListAttr* consListAttr(Attr* x, ListAttr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAsmattr    ********************/

void ListAsmattr::accept(Visitor *v)
{
  v->visitListAsmattr(this);
}

ListAsmattr *ListAsmattr::clone() const
{
  return new ListAsmattr(*this);
}

ListAsmattr* consListAsmattr(Asmattr* x, ListAsmattr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAsmoperand    ********************/

void ListAsmoperand::accept(Visitor *v)
{
  v->visitListAsmoperand(this);
}

ListAsmoperand *ListAsmoperand::clone() const
{
  return new ListAsmoperand(*this);
}

ListAsmoperand* consListAsmoperand(Asmoperand* x, ListAsmoperand* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStringConstant    ********************/

void ListStringConstant::accept(Visitor *v)
{
  v->visitListStringConstant(this);
}

ListStringConstant *ListStringConstant::clone() const
{
  return new ListStringConstant(*this);
}

ListStringConstant* consListStringConstant(StringConstant* x, ListStringConstant* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLexpr    ********************/

void ListLexpr::accept(Visitor *v)
{
  v->visitListLexpr(this);
}

ListLexpr *ListLexpr::clone() const
{
  return new ListLexpr(*this);
}

ListLexpr* consListLexpr(Lexpr* x, ListLexpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLexprRelInner    ********************/

void ListLexprRelInner::accept(Visitor *v)
{
  v->visitListLexprRelInner(this);
}

ListLexprRelInner *ListLexprRelInner::clone() const
{
  return new ListLexprRelInner(*this);
}

ListLexprRelInner* consListLexprRelInner(LexprRelInner* x, ListLexprRelInner* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListSTRING_LITERAL    ********************/

void ListSTRING_LITERAL::accept(Visitor *v)
{
  v->visitListSTRING_LITERAL(this);
}

ListSTRING_LITERAL *ListSTRING_LITERAL::clone() const
{
  return new ListSTRING_LITERAL(*this);
}

ListSTRING_LITERAL* consListSTRING_LITERAL(STRING_LITERAL x, ListSTRING_LITERAL* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFieldInitElt    ********************/

void ListFieldInitElt::accept(Visitor *v)
{
  v->visitListFieldInitElt(this);
}

ListFieldInitElt *ListFieldInitElt::clone() const
{
  return new ListFieldInitElt(*this);
}

ListFieldInitElt* consListFieldInitElt(FieldInitElt* x, ListFieldInitElt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListArrayInitElt    ********************/

void ListArrayInitElt::accept(Visitor *v)
{
  v->visitListArrayInitElt(this);
}

ListArrayInitElt *ListArrayInitElt::clone() const
{
  return new ListArrayInitElt(*this);
}

ListArrayInitElt* consListArrayInitElt(ArrayInitElt* x, ListArrayInitElt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListUpdateElt    ********************/

void ListUpdateElt::accept(Visitor *v)
{
  v->visitListUpdateElt(this);
}

ListUpdateElt *ListUpdateElt::clone() const
{
  return new ListUpdateElt(*this);
}

ListUpdateElt* consListUpdateElt(UpdateElt* x, ListUpdateElt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListPathElt    ********************/

void ListPathElt::accept(Visitor *v)
{
  v->visitListPathElt(this);
}

ListPathElt *ListPathElt::clone() const
{
  return new ListPathElt(*this);
}

ListPathElt* consListPathElt(PathElt* x, ListPathElt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBindersReentrance    ********************/

void ListBindersReentrance::accept(Visitor *v)
{
  v->visitListBindersReentrance(this);
}

ListBindersReentrance *ListBindersReentrance::clone() const
{
  return new ListBindersReentrance(*this);
}

ListBindersReentrance* consListBindersReentrance(BindersReentrance* x, ListBindersReentrance* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAbsParam    ********************/

void ListAbsParam::accept(Visitor *v)
{
  v->visitListAbsParam(this);
}

ListAbsParam *ListAbsParam::clone() const
{
  return new ListAbsParam(*this);
}

ListAbsParam* consListAbsParam(AbsParam* x, ListAbsParam* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListParameter    ********************/

void ListParameter::accept(Visitor *v)
{
  v->visitListParameter(this);
}

ListParameter *ListParameter::clone() const
{
  return new ListParameter(*this);
}

ListParameter* consListParameter(Parameter* x, ListParameter* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLogicTypeGenOFTYPENAME    ********************/

void ListLogicTypeGenOFTYPENAME::accept(Visitor *v)
{
  v->visitListLogicTypeGenOFTYPENAME(this);
}

ListLogicTypeGenOFTYPENAME *ListLogicTypeGenOFTYPENAME::clone() const
{
  return new ListLogicTypeGenOFTYPENAME(*this);
}

ListLogicTypeGenOFTYPENAME* consListLogicTypeGenOFTYPENAME(LogicTypeGenOFTYPENAME* x, ListLogicTypeGenOFTYPENAME* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLogicTypeGenOFIdentifierOrTypename    ********************/

void ListLogicTypeGenOFIdentifierOrTypename::accept(Visitor *v)
{
  v->visitListLogicTypeGenOFIdentifierOrTypename(this);
}

ListLogicTypeGenOFIdentifierOrTypename *ListLogicTypeGenOFIdentifierOrTypename::clone() const
{
  return new ListLogicTypeGenOFIdentifierOrTypename(*this);
}

ListLogicTypeGenOFIdentifierOrTypename* consListLogicTypeGenOFIdentifierOrTypename(LogicTypeGenOFIdentifierOrTypename* x, ListLogicTypeGenOFIdentifierOrTypename* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListCV    ********************/

void ListCV::accept(Visitor *v)
{
  v->visitListCV(this);
}

ListCV *ListCV::clone() const
{
  return new ListCV(*this);
}

ListCV* consListCV(CV* x, ListCV* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStars    ********************/

void ListStars::accept(Visitor *v)
{
  v->visitListStars(this);
}

ListStars *ListStars::clone() const
{
  return new ListStars(*this);
}

ListStars* consListStars(Stars* x, ListStars* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStarsCV    ********************/

void ListStarsCV::accept(Visitor *v)
{
  v->visitListStarsCV(this);
}

ListStarsCV *ListStarsCV::clone() const
{
  return new ListStarsCV(*this);
}

ListStarsCV* consListStarsCV(StarsCV* x, ListStarsCV* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListTabs    ********************/

void ListTabs::accept(Visitor *v)
{
  v->visitListTabs(this);
}

ListTabs *ListTabs::clone() const
{
  return new ListTabs(*this);
}

ListTabs* consListTabs(Tabs* x, ListTabs* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFullIdentifier    ********************/

void ListFullIdentifier::accept(Visitor *v)
{
  v->visitListFullIdentifier(this);
}

ListFullIdentifier *ListFullIdentifier::clone() const
{
  return new ListFullIdentifier(*this);
}

ListFullIdentifier* consListFullIdentifier(FullIdentifier* x, ListFullIdentifier* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtGlobalClause    ********************/

void ListExtGlobalClause::accept(Visitor *v)
{
  v->visitListExtGlobalClause(this);
}

ListExtGlobalClause *ListExtGlobalClause::clone() const
{
  return new ListExtGlobalClause(*this);
}

ListExtGlobalClause* consListExtGlobalClause(ExtGlobalClause* x, ListExtGlobalClause* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtGlobalSpec    ********************/

void ListExtGlobalSpec::accept(Visitor *v)
{
  v->visitListExtGlobalSpec(this);
}

ListExtGlobalSpec *ListExtGlobalSpec::clone() const
{
  return new ListExtGlobalSpec(*this);
}

ListExtGlobalSpec* consListExtGlobalSpec(ExtGlobalSpec* x, ListExtGlobalSpec* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtModuleSpec    ********************/

void ListExtModuleSpec::accept(Visitor *v)
{
  v->visitListExtModuleSpec(this);
}

ListExtModuleSpec *ListExtModuleSpec::clone() const
{
  return new ListExtModuleSpec(*this);
}

ListExtModuleSpec* consListExtModuleSpec(ExtModuleSpec* x, ListExtModuleSpec* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtFunctionSpec    ********************/

void ListExtFunctionSpec::accept(Visitor *v)
{
  v->visitListExtFunctionSpec(this);
}

ListExtFunctionSpec *ListExtFunctionSpec::clone() const
{
  return new ListExtFunctionSpec(*this);
}

ListExtFunctionSpec* consListExtFunctionSpec(ExtFunctionSpec* x, ListExtFunctionSpec* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtFunSpec    ********************/

void ListExtFunSpec::accept(Visitor *v)
{
  v->visitListExtFunSpec(this);
}

ListExtFunSpec *ListExtFunSpec::clone() const
{
  return new ListExtFunSpec(*this);
}

ListExtFunSpec* consListExtFunSpec(ExtFunSpec* x, ListExtFunSpec* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStmtMarkup    ********************/

void ListStmtMarkup::accept(Visitor *v)
{
  v->visitListStmtMarkup(this);
}

ListStmtMarkup *ListStmtMarkup::clone() const
{
  return new ListStmtMarkup(*this);
}

ListStmtMarkup* consListStmtMarkup(StmtMarkup* x, ListStmtMarkup* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLogicPTreeAnnot    ********************/

void ListLogicPTreeAnnot::accept(Visitor *v)
{
  v->visitListLogicPTreeAnnot(this);
}

ListLogicPTreeAnnot *ListLogicPTreeAnnot::clone() const
{
  return new ListLogicPTreeAnnot(*this);
}

ListLogicPTreeAnnot* consListLogicPTreeAnnot(LogicPTreeAnnot* x, ListLogicPTreeAnnot* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}

ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}

ListDecl* consListDecl(Decl* x, ListDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtDecl    ********************/

void ListExtDecl::accept(Visitor *v)
{
  v->visitListExtDecl(this);
}

ListExtDecl *ListExtDecl::clone() const
{
  return new ListExtDecl(*this);
}

ListExtDecl* consListExtDecl(ExtDecl* x, ListExtDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListVolatileOpt    ********************/

void ListVolatileOpt::accept(Visitor *v)
{
  v->visitListVolatileOpt(this);
}

ListVolatileOpt *ListVolatileOpt::clone() const
{
  return new ListVolatileOpt(*this);
}

ListVolatileOpt* consListVolatileOpt(VolatileOpt* x, ListVolatileOpt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLogicDecl    ********************/

void ListLogicDecl::accept(Visitor *v)
{
  v->visitListLogicDecl(this);
}

ListLogicDecl *ListLogicDecl::clone() const
{
  return new ListLogicDecl(*this);
}

ListLogicDecl* consListLogicDecl(LogicDecl* x, ListLogicDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListDataconsWithSeparator    ********************/

void ListDataconsWithSeparator::accept(Visitor *v)
{
  v->visitListDataconsWithSeparator(this);
}

ListDataconsWithSeparator *ListDataconsWithSeparator::clone() const
{
  return new ListDataconsWithSeparator(*this);
}

ListDataconsWithSeparator* consListDataconsWithSeparator(DataconsWithSeparator* x, ListDataconsWithSeparator* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListIndcase    ********************/

void ListIndcase::accept(Visitor *v)
{
  v->visitListIndcase(this);
}

ListIndcase *ListIndcase::clone() const
{
  return new ListIndcase(*this);
}

ListIndcase* consListIndcase(Indcase* x, ListIndcase* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLabelName    ********************/

void ListLabelName::accept(Visitor *v)
{
  v->visitListLabelName(this);
}

ListLabelName *ListLabelName::clone() const
{
  return new ListLabelName(*this);
}

ListLabelName* consListLabelName(LabelName* x, ListLabelName* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBehaviorName    ********************/

void ListBehaviorName::accept(Visitor *v)
{
  v->visitListBehaviorName(this);
}

ListBehaviorName *ListBehaviorName::clone() const
{
  return new ListBehaviorName(*this);
}

ListBehaviorName* consListBehaviorName(BehaviorName* x, ListBehaviorName* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListIdentifierOrTypenameFull    ********************/

void ListIdentifierOrTypenameFull::accept(Visitor *v)
{
  v->visitListIdentifierOrTypenameFull(this);
}

ListIdentifierOrTypenameFull *ListIdentifierOrTypenameFull::clone() const
{
  return new ListIdentifierOrTypenameFull(*this);
}

ListIdentifierOrTypenameFull* consListIdentifierOrTypenameFull(IdentifierOrTypenameFull* x, ListIdentifierOrTypenameFull* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListWildcard    ********************/

void ListWildcard::accept(Visitor *v)
{
  v->visitListWildcard(this);
}

ListWildcard *ListWildcard::clone() const
{
  return new ListWildcard(*this);
}

ListWildcard* consListWildcard(Wildcard* x, ListWildcard* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
