/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"
%name-prefix = "acsl"
  /* From Bison 2.6: %define api.prefix {acsl} */

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the acsllloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE acsl_scan_string(const char *str, yyscan_t scanner);
extern void acsl_delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void acsllex_destroy(yyscan_t scanner);
extern char* acslget_text(yyscan_t scanner);

extern yyscan_t acsl_initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  acsl::Program* program_;
  acsl::Globals* globals_;
  acsl::Global* global_;
  acsl::FunctionDef* functiondef_;
  acsl::FunctionDefStart* functiondefstart_;
  acsl::DeclSpecList* declspeclist_;
  acsl::DeclSpecListNoNamed* declspeclistnonamed_;
  acsl::TypeSpec* typespec_;
  acsl::Declarator* declarator_;
  acsl::PointerOpt* pointeropt_;
  acsl::DirectDecl* directdecl_;
  acsl::AttributesWithAsm* attributeswithasm_;
  acsl::RestParList* restparlist_;
  acsl::ParameterDecl* parameterdecl_;
  acsl::ListParameterDecl* listparameterdecl_;
  acsl::GhostParameterOpt* ghostparameteropt_;
  acsl::IdOrTypename* idortypename_;
  acsl::IdOrTypenameAsId* idortypenameasid_;
  acsl::Declaration* declaration_;
  acsl::DeclAndInitDeclAttrList* declandinitdeclattrlist_;
  acsl::InitDeclaratorAttr* initdeclaratorattr_;
  acsl::ListInitDeclaratorAttr* listinitdeclaratorattr_;
  acsl::InitDeclarator* initdeclarator_;
  acsl::StructDeclList* structdecllist_;
  acsl::FieldDecl* fielddecl_;
  acsl::ListFieldDecl* listfielddecl_;
  acsl::Attribute* attribute_;
  acsl::ListAttribute* listattribute_;
  acsl::Block* block_;
  acsl::BlockAttrs* blockattrs_;
  acsl::BlockElement* blockelement_;
  acsl::ListBlockElement* listblockelement_;
  acsl::Statement* statement_;
  acsl::ForClause* forclause_;
  acsl::Attr* attr_;
  acsl::ListAttr* listattr_;
  acsl::BasicAttribute* basicattribute_;
  acsl::AnnotatedStmt* annotatedstmt_;
  acsl::ElsePart* elsepart_;
  acsl::OptExpression* optexpression_;
  acsl::Expression* expression_;
  acsl::ListExpression* listexpression_;
  acsl::AssignExpr* assignexpr_;
  acsl::Constant* constant_;
  acsl::TypeName* typename_;
  acsl::ACSLProgram* acslprogram_;
  acsl::Annot* annot_;
  acsl::Code_Annot* code_annot_;
  acsl::Contract* contract_;
  acsl::Requires* requires_;
  acsl::NERequires* nerequires_;
  acsl::Terminates* terminates_;
  acsl::Decreases* decreases_;
  acsl::SimpleClauses* simpleclauses_;
  acsl::NESimpleClauses* nesimpleclauses_;
  acsl::Assigns* assigns_;
  acsl::Zones* zones_;
  acsl::Behaviors* behaviors_;
  acsl::CompleteOrDisjoint* completeordisjoint_;
  acsl::Lexpr* lexpr_;
  acsl::ListLexpr* listlexpr_;
  acsl::LexprRelInner* lexprrelinner_;
  acsl::ListLexprRelInner* listlexprrelinner_;
  acsl::Relation* relation_;
  acsl::LexprBinder* lexprbinder_;
  acsl::Binders* binders_;
  acsl::TypeSpecOFTYPENAME* typespecoftypename_;
  acsl::BindersReentrance* bindersreentrance_;
  acsl::ListBindersReentrance* listbindersreentrance_;
  acsl::VarSpec* varspec_;
  acsl::Stars* stars_;
  acsl::ListStars* liststars_;
  acsl::ArraySize* arraysize_;
  acsl::OptLabel* optlabel_;
  acsl::OptLabelList* optlabellist_;
  acsl::LabelName* labelname_;
  acsl::ListLabelName* listlabelname_;
  acsl::Range* range_;
  acsl::LexprOption* lexproption_;
  acsl::AnyIdentifier* anyidentifier_;
  acsl::PostCond* postcond_;
  acsl::FullIdentifier* fullidentifier_;
  acsl::ListFullIdentifier* listfullidentifier_;
  acsl::Identifier* identifier_;
  acsl::TypeSpecSimple* typespecsimple_;
  acsl::LogicPTreeAnnot* logicptreeannot_;
  acsl::Annotation* annotation_;
  acsl::LoopAnnotStack* loopannotstack_;
  acsl::LoopAnnotOpt* loopannotopt_;
  acsl::LoopInvariant* loopinvariant_;
  acsl::LoopVariant* loopvariant_;
  acsl::LoopEffects* loopeffects_;
  acsl::Variant* variant_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, acslget_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG             /* ! */
%token          _BANGEQ           /* != */
%token          _PERCENT          /* % */
%token          _PERCENTEQ        /* %= */
%token          _AMP              /* & */
%token          _DAMP             /* && */
%token          _AMPEQ            /* &= */
%token          _LPAREN           /* ( */
%token          _RPAREN           /* ) */
%token          _STAR             /* * */
%token          _STAREQ           /* *= */
%token          _PLUS             /* + */
%token          _DPLUS            /* ++ */
%token          _PLUSEQ           /* += */
%token          _COMMA            /* , */
%token          _MINUS            /* - */
%token          _DMINUS           /* -- */
%token          _MINUSEQ          /* -= */
%token          _RARROW           /* -> */
%token          _DOT              /* . */
%token          _DDOT             /* .. */
%token          _ELLIPSIS         /* ... */
%token          _SLASH            /* / */
%token          _SLASHEQ          /* /= */
%token          _COLON            /* : */
%token          _SEMI             /* ; */
%token          _LT               /* < */
%token          _DLT              /* << */
%token          _DLTEQ            /* <<= */
%token          _LDARROW          /* <= */
%token          _SYMB_48          /* <==> */
%token          _EQ               /* = */
%token          _DEQ              /* == */
%token          _SYMB_47          /* ==> */
%token          _GT               /* > */
%token          _GTEQ             /* >= */
%token          _DGT              /* >> */
%token          _DGTEQ            /* >>= */
%token          _QUESTION         /* ? */
%token          _KW_69            /* ACSL_END */
%token          _KW_70            /* ACSL_START */
%token          _LBRACK           /* [ */
%token          _SYMB_58          /* \\automatic */
%token          _SYMB_59          /* \\dynamic */
%token          _SYMB_51          /* \\exists */
%token          _SYMB_56          /* \\false */
%token          _SYMB_50          /* \\forall */
%token          _SYMB_45          /* \\from */
%token          _SYMB_52          /* \\lambda */
%token          _SYMB_46          /* \\nothing */
%token          _SYMB_63          /* \\null */
%token          _SYMB_65          /* \\pi */
%token          _SYMB_60          /* \\register */
%token          _SYMB_64          /* \\separated */
%token          _SYMB_61          /* \\static */
%token          _SYMB_55          /* \\true */
%token          _SYMB_62          /* \\unallocated */
%token          _SYMB_57          /* \\valid */
%token          _RBRACK           /* ] */
%token          _CARET            /* ^ */
%token          _CARETEQ          /* ^= */
%token          _DCARET           /* ^^ */
%token          _SYMB_1           /* _Bool */
%token          _SYMB_2           /* __int32 */
%token          _SYMB_3           /* __int64 */
%token          _KW_admit         /* admit */
%token          _KW_assigns       /* assigns */
%token          _KW_boolean       /* boolean */
%token          _KW_break         /* break */
%token          _KW_breaks        /* breaks */
%token          _KW_case          /* case */
%token          _KW_char          /* char */
%token          _KW_check         /* check */
%token          _KW_continue      /* continue */
%token          _KW_continues     /* continues */
%token          _KW_default       /* default */
%token          _KW_double        /* double */
%token          _KW_else          /* else */
%token          _KW_ensures       /* ensures */
%token          _KW_exits         /* exits */
%token          _KW_float         /* float */
%token          _KW_for           /* for */
%token          _KW_if            /* if */
%token          _KW_int           /* int */
%token          _KW_integer       /* integer */
%token          _KW_invariant     /* invariant */
%token          _KW_long          /* long */
%token          _KW_loop          /* loop */
%token          _KW_real          /* real */
%token          _KW_requires      /* requires */
%token          _KW_return        /* return */
%token          _KW_returns       /* returns */
%token          _KW_short         /* short */
%token          _KW_99            /* size_t */
%token          _KW_struct        /* struct */
%token          _KW_switch        /* switch */
%token          _KW_unsigned      /* unsigned */
%token          _KW_variant       /* variant */
%token          _KW_void          /* void */
%token          _KW_while         /* while */
%token          _LBRACE           /* { */
%token          _BAR              /* | */
%token          _BAREQ            /* |= */
%token          _DBAR             /* || */
%token          _RBRACE           /* } */
%token          _TILDE            /* ~ */
%token<_string> T_BLOCKATTRIBUTE  /* BLOCKATTRIBUTE */
%token<_string> T_CONST           /* CONST */
%token<_string> T_LBRACE          /* LBRACE */
%token<_string> T_LBRACKET        /* LBRACKET */
%token<_string> T_RBRACE          /* RBRACE */
%token<_string> T_RBRACKET        /* RBRACKET */
%token<_string> T_RESTRICT        /* RESTRICT */
%token<_string> T_SIGNED          /* SIGNED */
%token<_string> T_VOLATILE        /* VOLATILE */
%token<_string> _STRING_
%token<_char>   _CHAR_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <program_> Program
%type <globals_> Globals
%type <global_> Global
%type <functiondef_> FunctionDef
%type <functiondefstart_> FunctionDefStart
%type <declspeclist_> DeclSpecList
%type <declspeclistnonamed_> DeclSpecListNoNamed
%type <typespec_> TypeSpec
%type <declarator_> Declarator
%type <pointeropt_> PointerOpt
%type <directdecl_> DirectDecl
%type <attributeswithasm_> AttributesWithAsm
%type <restparlist_> RestParList
%type <parameterdecl_> ParameterDecl
%type <listparameterdecl_> ListParameterDecl
%type <ghostparameteropt_> GhostParameterOpt
%type <idortypename_> IdOrTypename
%type <idortypenameasid_> IdOrTypenameAsId
%type <declaration_> Declaration
%type <declandinitdeclattrlist_> DeclAndInitDeclAttrList
%type <initdeclaratorattr_> InitDeclaratorAttr
%type <listinitdeclaratorattr_> ListInitDeclaratorAttr
%type <initdeclarator_> InitDeclarator
%type <structdecllist_> StructDeclList
%type <fielddecl_> FieldDecl
%type <listfielddecl_> ListFieldDecl
%type <attribute_> Attribute
%type <listattribute_> ListAttribute
%type <block_> Block
%type <blockattrs_> BlockAttrs
%type <blockelement_> BlockElement
%type <listblockelement_> ListBlockElement
%type <statement_> Statement
%type <forclause_> ForClause
%type <attr_> Attr
%type <listattr_> ListAttr
%type <attr_> Attr1
%type <attr_> Attr2
%type <attr_> Attr3
%type <attr_> Attr4
%type <attr_> Attr5
%type <attr_> Attr6
%type <attr_> Attr7
%type <attr_> Attr8
%type <attr_> Attr9
%type <attr_> Attr10
%type <attr_> Attr11
%type <attr_> Attr12
%type <attr_> Attr13
%type <attr_> Attr14
%type <basicattribute_> BasicAttribute
%type <annotatedstmt_> AnnotatedStmt
%type <elsepart_> ElsePart
%type <optexpression_> OptExpression
%type <expression_> Expression
%type <listexpression_> ListExpression
%type <assignexpr_> AssignExpr
%type <assignexpr_> AssignExpr1
%type <assignexpr_> AssignExpr2
%type <assignexpr_> AssignExpr3
%type <assignexpr_> AssignExpr4
%type <assignexpr_> AssignExpr5
%type <assignexpr_> AssignExpr6
%type <assignexpr_> AssignExpr7
%type <assignexpr_> AssignExpr8
%type <assignexpr_> AssignExpr9
%type <assignexpr_> AssignExpr10
%type <assignexpr_> AssignExpr11
%type <assignexpr_> AssignExpr12
%type <assignexpr_> AssignExpr13
%type <assignexpr_> AssignExpr14
%type <assignexpr_> AssignExpr15
%type <constant_> Constant
%type <typename_> TypeName
%type <acslprogram_> ACSLProgram
%type <annot_> Annot
%type <code_annot_> Code_Annot
%type <contract_> Contract
%type <requires_> Requires
%type <nerequires_> NERequires
%type <terminates_> Terminates
%type <decreases_> Decreases
%type <simpleclauses_> SimpleClauses
%type <nesimpleclauses_> NESimpleClauses
%type <assigns_> Assigns
%type <zones_> Zones
%type <behaviors_> Behaviors
%type <completeordisjoint_> CompleteOrDisjoint
%type <lexpr_> Lexpr
%type <listlexpr_> ListLexpr
%type <lexpr_> Lexpr1
%type <lexprrelinner_> LexprRelInner
%type <listlexprrelinner_> ListLexprRelInner
%type <relation_> Relation
%type <lexpr_> Lexpr2
%type <lexprbinder_> LexprBinder
%type <binders_> Binders
%type <typespecoftypename_> TypeSpecOFTYPENAME
%type <bindersreentrance_> BindersReentrance
%type <listbindersreentrance_> ListBindersReentrance
%type <varspec_> VarSpec
%type <stars_> Stars
%type <liststars_> ListStars
%type <varspec_> VarSpec1
%type <arraysize_> ArraySize
%type <lexpr_> Lexpr3
%type <optlabel_> OptLabel1
%type <optlabel_> OptLabel2
%type <optlabellist_> OptLabelList
%type <labelname_> LabelName
%type <listlabelname_> ListLabelName
%type <range_> Range
%type <lexproption_> LexprOption
%type <anyidentifier_> AnyIdentifier
%type <postcond_> PostCond
%type <fullidentifier_> FullIdentifier
%type <listfullidentifier_> ListFullIdentifier
%type <identifier_> Identifier
%type <typespecsimple_> TypeSpecSimple
%type <logicptreeannot_> LogicPTreeAnnot
%type <annotation_> Annotation
%type <loopannotstack_> LoopAnnotStack
%type <loopannotopt_> LoopAnnotOpt
%type <loopinvariant_> LoopInvariant
%type <loopvariant_> LoopVariant
%type <loopeffects_> LoopEffects
%type <variant_> Variant

%start Program

%%

Program : Globals { $$ = new acsl::AProgram($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->program_ = $$; }
;
Globals : /* empty */ { $$ = new acsl::NoGlobals(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
  | Global Globals { $$ = new acsl::SimpleGlobals($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
  | _SEMI Globals { $$ = new acsl::SemiColonGlobals($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->globals_ = $$; }
;
Global : FunctionDef { $$ = new acsl::GlobalsFunctionDef($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
  | Declaration { $$ = new acsl::GlobalsDeclataion($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->global_ = $$; }
;
FunctionDef : FunctionDefStart Block { $$ = new acsl::SimpleFunctionDef($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondef_ = $$; }
  | ACSLProgram FunctionDefStart Block { $$ = new acsl::FunctionDefSpec($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondef_ = $$; }
;
FunctionDefStart : DeclSpecList Declarator { $$ = new acsl::FunctionDefStartDeclarator($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->functiondefstart_ = $$; }
;
DeclSpecList : TypeSpec { $$ = new acsl::DeclSpecTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclist_ = $$; }
  | TypeSpec DeclSpecListNoNamed { $$ = new acsl::DeclSpecTypeSpecNext($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclist_ = $$; }
;
DeclSpecListNoNamed : TypeSpec { $$ = new acsl::DeclSpecNoNamedTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclistnonamed_ = $$; }
  | TypeSpec DeclSpecListNoNamed { $$ = new acsl::DeclSpecNoNamedTypeSpecNext($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declspeclistnonamed_ = $$; }
;
TypeSpec : _KW_void { $$ = new acsl::TypeSpecVoidKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_char { $$ = new acsl::TypeSpecCharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _SYMB_1 { $$ = new acsl::TypeSpecBoolKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_short { $$ = new acsl::TypeSpecShortKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _SYMB_2 { $$ = new acsl::TypeSpecInt32KeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_int { $$ = new acsl::TypeSpecIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_99 { $$ = new acsl::TypeSpecSizeTKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_long { $$ = new acsl::TypeSpecLongKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _SYMB_3 { $$ = new acsl::TypeSpecInt64KeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_float { $$ = new acsl::TypeSpecFloatKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_double { $$ = new acsl::TypeSpecDoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | T_SIGNED { $$ = new acsl::TypeSpecSignedKeyWord($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_unsigned { $$ = new acsl::TypeSpecUnsignedKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct IdOrTypename { $$ = new acsl::StructId($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct IdOrTypename T_LBRACE StructDeclList T_RBRACE { $$ = new acsl::StructIdBraces($2, $3, $4, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
  | _KW_struct T_LBRACE StructDeclList T_RBRACE { $$ = new acsl::StructBraces($2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespec_ = $$; }
;
Declarator : PointerOpt DirectDecl AttributesWithAsm { $$ = new acsl::ADeclarator($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declarator_ = $$; }
;
PointerOpt : /* empty */ { $$ = new acsl::NoPointer(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pointeropt_ = $$; }
  | _STAR ListAttribute PointerOpt { $$ = new acsl::SomePointer($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pointeropt_ = $$; }
;
DirectDecl : IdOrTypename { $$ = new acsl::DirectDeclIdTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
  | DirectDecl _LPAREN _RPAREN GhostParameterOpt { $$ = new acsl::DirectDeclGhostParam($1, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
  | DirectDecl _LPAREN RestParList _RPAREN GhostParameterOpt { $$ = new acsl::DirectDeclGhostRestParParam($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->directdecl_ = $$; }
;
AttributesWithAsm : /* empty */ { $$ = new acsl::EmptyAttrWithASM(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attributeswithasm_ = $$; }
;
RestParList : ListParameterDecl { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SimpleParameterDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->restparlist_ = $$; }
;
ParameterDecl : DeclSpecList Declarator { $$ = new acsl::ParameterDeclSpecDeclarator($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
  | DeclSpecList { $$ = new acsl::ParameterDeclSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
  | _LPAREN ParameterDecl _RPAREN { $$ = new acsl::ParameterDeclPar($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->parameterdecl_ = $$; }
;
ListParameterDecl : ParameterDecl { $$ = new acsl::ListParameterDecl(); $$->push_back($1); result->listparameterdecl_ = $$; }
  | ParameterDecl _COMMA ListParameterDecl { $3->push_back($1); $$ = $3; result->listparameterdecl_ = $$; }
;
GhostParameterOpt : /* empty */ { $$ = new acsl::NoGhostParameter(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->ghostparameteropt_ = $$; }
;
IdOrTypename : IdOrTypenameAsId { $$ = new acsl::IdTypename($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->idortypename_ = $$; }
;
IdOrTypenameAsId : _IDENT_ { $$ = new acsl::IdOrTypenameAsIdIdentifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->idortypenameasid_ = $$; }
;
Declaration : DeclSpecList DeclAndInitDeclAttrList _SEMI { $$ = new acsl::DeclSpecInitDecl($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | DeclSpecList _SEMI { $$ = new acsl::DeclSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | ACSLProgram DeclSpecList DeclAndInitDeclAttrList _SEMI { $$ = new acsl::SpecDeclSpecInitDecl($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
  | ACSLProgram DeclSpecList _SEMI { $$ = new acsl::SpecDeclSpec($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declaration_ = $$; }
;
DeclAndInitDeclAttrList : InitDeclarator { $$ = new acsl::InitDeclaration($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declandinitdeclattrlist_ = $$; }
  | InitDeclarator _COMMA ListInitDeclaratorAttr { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::InitDeclarationWithAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->declandinitdeclattrlist_ = $$; }
;
InitDeclaratorAttr : InitDeclarator { $$ = new acsl::InitDeclaratorAttribute($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdeclaratorattr_ = $$; }
;
ListInitDeclaratorAttr : InitDeclaratorAttr { $$ = new acsl::ListInitDeclaratorAttr(); $$->push_back($1); result->listinitdeclaratorattr_ = $$; }
  | InitDeclaratorAttr _COMMA ListInitDeclaratorAttr { $3->push_back($1); $$ = $3; result->listinitdeclaratorattr_ = $$; }
;
InitDeclarator : Declarator { $$ = new acsl::SimpleInitDeclarator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->initdeclarator_ = $$; }
;
StructDeclList : /* empty */ { $$ = new acsl::EmptyStructDecl(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | DeclSpecList _SEMI StructDeclList { $$ = new acsl::DeclSpecStructDecl($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | _SEMI StructDeclList { $$ = new acsl::SemicolonStructDecl($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
  | DeclSpecList ListFieldDecl _SEMI StructDeclList { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::SpecFieldDeclStructDecl($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->structdecllist_ = $$; }
;
FieldDecl : Declarator { $$ = new acsl::FieldDeclDeclarator($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fielddecl_ = $$; }
;
ListFieldDecl : FieldDecl { $$ = new acsl::ListFieldDecl(); $$->push_back($1); result->listfielddecl_ = $$; }
  | FieldDecl _COMMA ListFieldDecl { $3->push_back($1); $$ = $3; result->listfielddecl_ = $$; }
;
Attribute : T_CONST { $$ = new acsl::AttributeConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attribute_ = $$; }
;
ListAttribute : /* empty */ { $$ = new acsl::ListAttribute(); result->listattribute_ = $$; }
  | ListAttribute Attribute { $1->push_back($2); $$ = $1; result->listattribute_ = $$; }
;
Block : T_LBRACE BlockAttrs ListBlockElement T_RBRACE { $$ = new acsl::ABlock($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->block_ = $$; }
;
BlockAttrs : /* empty */ { $$ = new acsl::NoBlockAttrs(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockattrs_ = $$; }
  | T_BLOCKATTRIBUTE _LPAREN ListAttr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::SomeBlockAttrs($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockattrs_ = $$; }
;
BlockElement : Declaration { $$ = new acsl::DeclarationElement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockelement_ = $$; }
  | Statement { $$ = new acsl::StatementElement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->blockelement_ = $$; }
;
ListBlockElement : /* empty */ { $$ = new acsl::ListBlockElement(); result->listblockelement_ = $$; }
  | ListBlockElement BlockElement { $1->push_back($2); $$ = $1; result->listblockelement_ = $$; }
;
Statement : _SEMI { $$ = new acsl::SemicolonStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | ACSLProgram AnnotatedStmt { $$ = new acsl::SpecStatement($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | ListExpression _SEMI { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::ExprsStatement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | Block { $$ = new acsl::BlockStatement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_if _LPAREN ListExpression _RPAREN AnnotatedStmt ElsePart { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::IfStatement($3, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_switch _LPAREN ListExpression _RPAREN AnnotatedStmt { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::SwitchStatement($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_while _LPAREN ListExpression _RPAREN AnnotatedStmt { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::WhileStatement($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_for _LPAREN ForClause OptExpression _SEMI OptExpression _RPAREN AnnotatedStmt { $$ = new acsl::ForStatement($3, $4, $6, $8); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_case Expression _COLON AnnotatedStmt { $$ = new acsl::CaseStatement($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_case Expression _ELLIPSIS Expression _COLON AnnotatedStmt { $$ = new acsl::CaseSliceStatement($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_default _COLON AnnotatedStmt { $$ = new acsl::DefaultStatement($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_return _SEMI { $$ = new acsl::EmptyReturnStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_return ListExpression _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::ReturnStatement($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_break _SEMI { $$ = new acsl::BreakStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
  | _KW_continue _SEMI { $$ = new acsl::ContinueStatement(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->statement_ = $$; }
;
ForClause : OptExpression _SEMI { $$ = new acsl::ForClauseExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->forclause_ = $$; }
  | Declaration { $$ = new acsl::ForClauseDeclaration($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->forclause_ = $$; }
;
Attr : Attr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr1 _EQ Attr1 { $$ = new acsl::AnAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
ListAttr : Attr { $$ = new acsl::ListAttr(); $$->push_back($1); result->listattr_ = $$; }
  | Attr _COMMA ListAttr { $3->push_back($1); $$ = $3; result->listattr_ = $$; }
;
Attr1 : Attr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr2 _QUESTION Attr1 _COLON Attr1 { $$ = new acsl::TernaryCond($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr2 : Attr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr2 _DBAR Attr3 { $$ = new acsl::Or($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr3 : Attr4 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr3 _DAMP Attr4 { $$ = new acsl::And($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr4 : Attr5 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr4 _BAR Attr5 { $$ = new acsl::BitOr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr5 : Attr6 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr5 _CARET Attr6 { $$ = new acsl::Xor($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr6 : Attr7 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr6 _AMP Attr7 { $$ = new acsl::BitAnd($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr7 : Attr8 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr7 _DEQ Attr8 { $$ = new acsl::EqualEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr7 _BANGEQ Attr8 { $$ = new acsl::NotEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr8 : Attr9 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _LT Attr9 { $$ = new acsl::Less($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _GT Attr9 { $$ = new acsl::Greater($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _LDARROW Attr9 { $$ = new acsl::LessEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr8 _GTEQ Attr9 { $$ = new acsl::GreaterEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr9 : Attr10 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr9 _DLT Attr10 { $$ = new acsl::LeftShiftOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr9 _DGT Attr10 { $$ = new acsl::RightShiftOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr10 : Attr11 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr10 _PLUS Attr11 { $$ = new acsl::AddOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr10 _MINUS Attr11 { $$ = new acsl::SubOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr11 : Attr12 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr11 _STAR Attr12 { $$ = new acsl::MultOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr11 _SLASH Attr12 { $$ = new acsl::DivOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr11 _PERCENT Attr12 { $$ = new acsl::ModOp($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr12 : Attr13 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _PLUS Attr12 { $$ = new acsl::PlusUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _MINUS Attr12 { $$ = new acsl::MinusUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _STAR Attr12 { $$ = new acsl::MultUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _AMP Attr12 { $$ = new acsl::AmpUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _BANG Attr12 { $$ = new acsl::NotUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _TILDE Attr12 { $$ = new acsl::TildeUnaryAttr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr13 : Attr14 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | IdOrTypenameAsId _LPAREN ListAttr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::FuncationCall($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | IdOrTypenameAsId _LPAREN _RPAREN { $$ = new acsl::ProcedureCall($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr13 _RARROW IdOrTypename { $$ = new acsl::ArrowAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr13 _DOT IdOrTypename { $$ = new acsl::DotAttr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | Attr13 T_LBRACKET Attr T_RBRACKET { $$ = new acsl::ArrayAttr($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
Attr14 : BasicAttribute { $$ = new acsl::BasicAttr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
  | _LPAREN Attr _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->attr_ = $$; }
;
BasicAttribute : _INTEGER_ { $$ = new acsl::BasicAttrConsInt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->basicattribute_ = $$; }
  | _DOUBLE_ { $$ = new acsl::BasicAttrConsFloat($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->basicattribute_ = $$; }
;
AnnotatedStmt : Statement { $$ = new acsl::AnnotatedStatement($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotatedstmt_ = $$; }
;
ElsePart : /* empty */ { $$ = new acsl::NoElsePart(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->elsepart_ = $$; }
  | _KW_else AnnotatedStmt { $$ = new acsl::SimpleElsePart($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->elsepart_ = $$; }
;
OptExpression : /* empty */ { $$ = new acsl::NoExpression(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optexpression_ = $$; }
  | ListExpression { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optexpression_ = $$; }
;
Expression : AssignExpr { $$ = new acsl::AssignmentExpr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expression_ = $$; }
;
ListExpression : Expression { $$ = new acsl::ListExpression(); $$->push_back($1); result->listexpression_ = $$; }
  | Expression _COMMA ListExpression { $3->push_back($1); $$ = $3; result->listexpression_ = $$; }
;
AssignExpr : AssignExpr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _EQ AssignExpr { $$ = new acsl::EqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _PLUSEQ AssignExpr { $$ = new acsl::PlusEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _MINUSEQ AssignExpr { $$ = new acsl::MinusEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _STAREQ AssignExpr { $$ = new acsl::MultEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _SLASHEQ AssignExpr { $$ = new acsl::DivEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _PERCENTEQ AssignExpr { $$ = new acsl::ModEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _AMPEQ AssignExpr { $$ = new acsl::AndEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _BAREQ AssignExpr { $$ = new acsl::OrEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _CARETEQ AssignExpr { $$ = new acsl::XorEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _DLTEQ AssignExpr { $$ = new acsl::LeftShiftEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr12 _DGTEQ AssignExpr { $$ = new acsl::RightShiftEqAssignExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr1 : AssignExpr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr2 _QUESTION OptExpression _COLON AssignExpr1 { $$ = new acsl::TernaryCondExpr($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr2 : AssignExpr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr2 _DBAR AssignExpr3 { $$ = new acsl::OrExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr3 : AssignExpr4 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr3 _DAMP AssignExpr4 { $$ = new acsl::AndExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr4 : AssignExpr5 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr4 _BAR AssignExpr5 { $$ = new acsl::BitOrExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr5 : AssignExpr6 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr5 _CARET AssignExpr6 { $$ = new acsl::BitXorExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr6 : AssignExpr7 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr6 _AMP AssignExpr7 { $$ = new acsl::BitAndExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr7 : AssignExpr8 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr7 _DEQ AssignExpr8 { $$ = new acsl::EqExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr7 _BANGEQ AssignExpr8 { $$ = new acsl::NotEqExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr8 : AssignExpr9 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _LT AssignExpr9 { $$ = new acsl::LessExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _GT AssignExpr9 { $$ = new acsl::GreaterExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _LDARROW AssignExpr9 { $$ = new acsl::LessEqualExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr8 _GTEQ AssignExpr9 { $$ = new acsl::GreaterEqualExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr9 : AssignExpr10 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr9 _DLT AssignExpr10 { $$ = new acsl::LeftShiftExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr9 _DGT AssignExpr10 { $$ = new acsl::RightShiftExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr10 : AssignExpr11 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr10 _PLUS AssignExpr11 { $$ = new acsl::PlusExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr10 _MINUS AssignExpr11 { $$ = new acsl::MinusExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr11 : AssignExpr12 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr11 _STAR AssignExpr12 { $$ = new acsl::MulsExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr11 _SLASH AssignExpr12 { $$ = new acsl::DivExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr11 _PERCENT AssignExpr12 { $$ = new acsl::ModExpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr12 : AssignExpr13 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN TypeName _RPAREN AssignExpr12 { $$ = new acsl::CastExpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr13 : AssignExpr14 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _DPLUS AssignExpr13 { $$ = new acsl::UnaryExprPlusPlus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _DMINUS AssignExpr13 { $$ = new acsl::UnaryExprMinusMinus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _PLUS AssignExpr12 { $$ = new acsl::UnaryExprPlus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _MINUS AssignExpr12 { $$ = new acsl::UnaryExprMinus($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _STAR AssignExpr12 { $$ = new acsl::UnaryExprMult($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _AMP AssignExpr12 { $$ = new acsl::UnaryExprAmp($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _BANG AssignExpr12 { $$ = new acsl::UnaryExprNot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _TILDE AssignExpr12 { $$ = new acsl::UnaryExprTilde($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _DAMP IdOrTypenameAsId { $$ = new acsl::UnaryExprAddress($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr14 : AssignExpr15 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 T_LBRACKET ListExpression T_RBRACKET { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::BracketsPostfixExpression($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _DOT IdOrTypename { $$ = new acsl::DotPostfixExpression($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _RARROW IdOrTypename { $$ = new acsl::ArrowPostfixExpression($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _DPLUS { $$ = new acsl::PlusPlusPostfixExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | AssignExpr14 _DMINUS { $$ = new acsl::MinusMinusPostfixExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
AssignExpr15 : _IDENT_ { $$ = new acsl::IdentifierPrimaryExpression($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | Constant { $$ = new acsl::ConstantPrimaryExpressin($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN ListExpression _RPAREN { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::CommaExpressionPrimaryExpressin($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
  | _LPAREN Block _RPAREN { $$ = new acsl::BlockPrimaryExpressin($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assignexpr_ = $$; }
;
Constant : _INTEGER_ { $$ = new acsl::ConstantInt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | _DOUBLE_ { $$ = new acsl::ConstantFloat($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
  | _CHAR_ { $$ = new acsl::ConstantChar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->constant_ = $$; }
;
TypeName : DeclSpecList { $$ = new acsl::TypeNameDeclSpecList($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typename_ = $$; }
;
ACSLProgram : _KW_70 Annot _KW_69 { $$ = new acsl::AnnotProgram($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->acslprogram_ = $$; }
  | _KW_70 LogicPTreeAnnot _KW_69 { $$ = new acsl::AnnotationProgram($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->acslprogram_ = $$; }
;
Annot : Code_Annot { $$ = new acsl::CodeAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annot_ = $$; }
;
Code_Annot : Contract { $$ = new acsl::CodeAnnotContract($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->code_annot_ = $$; }
;
Contract : Requires Terminates Decreases SimpleClauses Behaviors CompleteOrDisjoint { $$ = new acsl::SimpleContract($1, $2, $3, $4, $5, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->contract_ = $$; }
;
Requires : /* empty */ { $$ = new acsl::NoRequires(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->requires_ = $$; }
  | NERequires { $$ = new acsl::SomeRequires($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->requires_ = $$; }
;
NERequires : _KW_requires Lexpr _SEMI Requires { $$ = new acsl::SimpleRequires($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_check _KW_requires Lexpr _SEMI Requires { $$ = new acsl::CheckRequires($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
  | _KW_admit _KW_requires Lexpr _SEMI Requires { $$ = new acsl::AdimtRequires($3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nerequires_ = $$; }
;
Terminates : /* empty */ { $$ = new acsl::NoTerminate(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->terminates_ = $$; }
;
Decreases : /* empty */ { $$ = new acsl::NoDecreases(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decreases_ = $$; }
;
SimpleClauses : /* empty */ { $$ = new acsl::NoSimpleClauses(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->simpleclauses_ = $$; }
  | NESimpleClauses { $$ = new acsl::SomeSimpleClauses($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->simpleclauses_ = $$; }
;
NESimpleClauses : PostCond Lexpr _SEMI SimpleClauses { $$ = new acsl::PostCondSimpleClauses($1, $2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
  | _KW_assigns Assigns _SEMI SimpleClauses { $$ = new acsl::AssignsSimpleClauses($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->nesimpleclauses_ = $$; }
;
Assigns : Zones { $$ = new acsl::AssignZone($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assigns_ = $$; }
  | ListLexpr _SYMB_45 Zones { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::AssignZoneFromZone($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->assigns_ = $$; }
;
Zones : ListLexpr { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::SomeZone($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->zones_ = $$; }
  | _SYMB_46 { $$ = new acsl::NoZone(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->zones_ = $$; }
;
Behaviors : /* empty */ { $$ = new acsl::NoBehaviors(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->behaviors_ = $$; }
;
CompleteOrDisjoint : /* empty */ { $$ = new acsl::NoComplDisj(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->completeordisjoint_ = $$; }
;
Lexpr : Lexpr _SYMB_47 Lexpr1 { $$ = new acsl::ImplLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _SYMB_48 Lexpr1 { $$ = new acsl::IffLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _DBAR Lexpr1 { $$ = new acsl::OrLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _DAMP Lexpr1 { $$ = new acsl::AndLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr _DCARET Lexpr1 { $$ = new acsl::HatHatLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
ListLexpr : Lexpr { $$ = new acsl::ListLexpr(); $$->push_back($1); result->listlexpr_ = $$; }
  | Lexpr _COMMA ListLexpr { $3->push_back($1); $$ = $3; result->listlexpr_ = $$; }
;
Lexpr1 : Lexpr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 ListLexprRelInner Relation Lexpr2 { $$ = new acsl::RelationLexpr($1, $2, $3, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
LexprRelInner : Relation Lexpr3 { $$ = new acsl::RelInnerLexpr($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprrelinner_ = $$; }
;
ListLexprRelInner : /* empty */ { $$ = new acsl::ListLexprRelInner(); result->listlexprrelinner_ = $$; }
  | ListLexprRelInner LexprRelInner { $1->push_back($2); $$ = $1; result->listlexprrelinner_ = $$; }
;
Relation : _LT { $$ = new acsl::LessRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _GT { $$ = new acsl::GreaterRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _LDARROW { $$ = new acsl::LessEqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _GTEQ { $$ = new acsl::GreaterEqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _DEQ { $$ = new acsl::EqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
  | _BANGEQ { $$ = new acsl::NotEqRel(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->relation_ = $$; }
;
Lexpr2 : Lexpr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | LexprBinder { $$ = new acsl::BinderLexpr($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _BANG LexprBinder { $$ = new acsl::NotBinderLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
LexprBinder : _SYMB_50 Binders _SEMI Lexpr { $$ = new acsl::ForallBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
  | _SYMB_51 Binders _SEMI Lexpr { $$ = new acsl::ExistBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
  | _SYMB_52 Binders _SEMI Lexpr { $$ = new acsl::LambdaBinderLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexprbinder_ = $$; }
;
Binders : TypeSpecOFTYPENAME VarSpec ListBindersReentrance { $$ = new acsl::TheBinders($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->binders_ = $$; }
;
TypeSpecOFTYPENAME : _IDENT_ { $$ = new acsl::TypeSpecTYPENAME($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecoftypename_ = $$; }
  | TypeSpecSimple { $$ = new acsl::TypeSpecSimpleFromTypenameTypeSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecoftypename_ = $$; }
;
BindersReentrance : _COMMA TypeSpecOFTYPENAME VarSpec { $$ = new acsl::BindersReentranceDeclSpec($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bindersreentrance_ = $$; }
  | _COMMA VarSpec { $$ = new acsl::BindersReentranceVarSpec($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->bindersreentrance_ = $$; }
;
ListBindersReentrance : /* empty */ { $$ = new acsl::ListBindersReentrance(); result->listbindersreentrance_ = $$; }
  | ListBindersReentrance BindersReentrance { $1->push_back($2); $$ = $1; result->listbindersreentrance_ = $$; }
;
VarSpec : VarSpec1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | ListStars VarSpec1 { std::reverse($1->begin(),$1->end()) ;$$ = new acsl::StartVarSpec($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
;
Stars : _STAR { $$ = new acsl::Star(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->stars_ = $$; }
;
ListStars : Stars { $$ = new acsl::ListStars(); $$->push_back($1); result->liststars_ = $$; }
  | Stars ListStars { $2->push_back($1); $$ = $2; result->liststars_ = $$; }
;
VarSpec1 : FullIdentifier { $$ = new acsl::SimpleSpec($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | VarSpec1 _LBRACK ArraySize _RBRACK { $$ = new acsl::ArraySpec($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
  | _LPAREN VarSpec _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->varspec_ = $$; }
;
ArraySize : _INTEGER_ { $$ = new acsl::IntConstArraySize($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arraysize_ = $$; }
  | FullIdentifier { $$ = new acsl::SomeArraySize($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arraysize_ = $$; }
  | /* empty */ { $$ = new acsl::NoSize(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->arraysize_ = $$; }
;
Lexpr3 : _SYMB_55 { $$ = new acsl::TrueLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_56 { $$ = new acsl::FalseLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_57 OptLabel1 _LPAREN Lexpr _RPAREN { $$ = new acsl::ValidLexpr($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_58 { $$ = new acsl::AutomaticLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_59 { $$ = new acsl::DynamicLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_60 { $$ = new acsl::RegisterLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_61 { $$ = new acsl::StaticLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_62 { $$ = new acsl::UnallocatedLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_63 { $$ = new acsl::NullLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _INTEGER_ { $$ = new acsl::LexprIntConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _DOUBLE_ { $$ = new acsl::LexprFloatConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _STRING_ { $$ = new acsl::LexprStringConst($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _PLUS Lexpr3 { $$ = new acsl::AddLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _MINUS Lexpr3 { $$ = new acsl::SubtrLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _LBRACK Range _RBRACK { $$ = new acsl::SquaresRangeLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | Lexpr3 _LBRACK Lexpr _RBRACK { $$ = new acsl::SquaresLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_64 _LPAREN ListLexpr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::SeparatedLexpr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | FullIdentifier _LPAREN ListLexpr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::FullIdParenLexpr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | FullIdentifier { $$ = new acsl::FullId($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _SYMB_65 { $$ = new acsl::PiLexpr(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LPAREN Lexpr _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
  | _LPAREN Range _RPAREN { $$ = new acsl::ParenRangeLexpr($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexpr_ = $$; }
;
OptLabel1 : OptLabelList { $$ = new acsl::OptLabelOne($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabel_ = $$; }
;
OptLabel2 : OptLabelList { $$ = new acsl::OptLabelTwo($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabel_ = $$; }
;
OptLabelList : /* empty */ { $$ = new acsl::NoLableList(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabellist_ = $$; }
  | _LBRACE ListLabelName _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::LableList($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optlabellist_ = $$; }
;
LabelName : AnyIdentifier { $$ = new acsl::LableName($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->labelname_ = $$; }
;
ListLabelName : LabelName { $$ = new acsl::ListLabelName(); $$->push_back($1); result->listlabelname_ = $$; }
  | LabelName _COMMA ListLabelName { $3->push_back($1); $$ = $3; result->listlabelname_ = $$; }
;
Range : LexprOption _DDOT LexprOption { $$ = new acsl::LexprRange($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->range_ = $$; }
;
LexprOption : /* empty */ { $$ = new acsl::NoLexprOption(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexproption_ = $$; }
  | Lexpr { $$ = new acsl::SomeLexprOption($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->lexproption_ = $$; }
;
AnyIdentifier : Identifier { $$ = new acsl::SimpleIdentifierAny($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->anyidentifier_ = $$; }
;
PostCond : _KW_ensures { $$ = new acsl::EnsuresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_exits { $$ = new acsl::ExitsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_breaks { $$ = new acsl::BreaksKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_continues { $$ = new acsl::ContinuesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_returns { $$ = new acsl::ReturnsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_ensures { $$ = new acsl::CheckEnsuresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_exits { $$ = new acsl::CheckExitsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_breaks { $$ = new acsl::CheckBreaksKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_continues { $$ = new acsl::CheckContinuesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_check _KW_returns { $$ = new acsl::CheckReturnsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_ensures { $$ = new acsl::AdmitEnsuresKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_exits { $$ = new acsl::AdmitExitsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_breaks { $$ = new acsl::AdmitBreaksKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_continues { $$ = new acsl::AdmitContinuesKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _KW_admit _KW_returns { $$ = new acsl::AdmitReturnsKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
;
FullIdentifier : Identifier { $$ = new acsl::SimpleIdentifierFull($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->fullidentifier_ = $$; }
;
ListFullIdentifier : FullIdentifier { $$ = new acsl::ListFullIdentifier(); $$->push_back($1); result->listfullidentifier_ = $$; }
  | FullIdentifier _COMMA ListFullIdentifier { $3->push_back($1); $$ = $3; result->listfullidentifier_ = $$; }
;
Identifier : _IDENT_ { $$ = new acsl::IdentifierIdent($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->identifier_ = $$; }
;
TypeSpecSimple : _KW_integer { $$ = new acsl::TypeSpecSimpleIntegerKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_real { $$ = new acsl::TypeSpecSimpleRealKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_boolean { $$ = new acsl::TypeSpecSimpleBooleanKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_void { $$ = new acsl::TypeSpecSimpleVoidKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _SYMB_1 { $$ = new acsl::TypeSpecSimpleBoolKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_char { $$ = new acsl::TypeSpecSimpleCharKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_int { $$ = new acsl::TypeSpecSimpleIntKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_double { $$ = new acsl::TypeSpecSimpleDoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
  | _KW_long _KW_double { $$ = new acsl::TypeSpecSimpleLongDoubleKeyWord(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->typespecsimple_ = $$; }
;
LogicPTreeAnnot : Annotation { $$ = new acsl::AnAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicptreeannot_ = $$; }
;
Annotation : LoopAnnotStack { $$ = new acsl::LoopAnnotation($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
;
LoopAnnotStack : LoopInvariant LoopAnnotOpt { $$ = new acsl::LoopAnnotStackInvariant($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopEffects LoopAnnotOpt { $$ = new acsl::LoopAnnotStackEffects($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
  | LoopVariant LoopAnnotOpt { $$ = new acsl::LoopAnnotStackVariant($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotstack_ = $$; }
;
LoopAnnotOpt : /* empty */ { $$ = new acsl::NoLoopAnnot(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotopt_ = $$; }
  | LoopAnnotStack { $$ = new acsl::SomeLoopAnnot($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopannotopt_ = $$; }
;
LoopInvariant : _KW_loop _KW_invariant Lexpr _SEMI { $$ = new acsl::SimpleLoopInvariant($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopinvariant_ = $$; }
  | _KW_check _KW_loop _KW_invariant Lexpr _SEMI { $$ = new acsl::CheckLoopInvariant($4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopinvariant_ = $$; }
  | _KW_admit _KW_loop _KW_invariant Lexpr _SEMI { $$ = new acsl::AdmitLoopInvariant($4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopinvariant_ = $$; }
;
LoopVariant : _KW_loop _KW_variant Variant _SEMI { $$ = new acsl::SimpleLoopVariant($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopvariant_ = $$; }
;
LoopEffects : _KW_loop _KW_assigns Assigns _SEMI { $$ = new acsl::LoopAssigns($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->loopeffects_ = $$; }
;
Variant : Lexpr _KW_for AnyIdentifier { $$ = new acsl::ForVariant($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->variant_ = $$; }
  | Lexpr { $$ = new acsl::LexprVariant($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->variant_ = $$; }
;

%%

namespace acsl
{
/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Globals* from file. */
Globals* pGlobals(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.globals_;
  }
}

/* Entrypoint: parse Globals* from string. */
Globals* psGlobals(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.globals_;
  }
}

/* Entrypoint: parse Global* from file. */
Global* pGlobal(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.global_;
  }
}

/* Entrypoint: parse Global* from string. */
Global* psGlobal(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.global_;
  }
}

/* Entrypoint: parse FunctionDef* from file. */
FunctionDef* pFunctionDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondef_;
  }
}

/* Entrypoint: parse FunctionDef* from string. */
FunctionDef* psFunctionDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondef_;
  }
}

/* Entrypoint: parse FunctionDefStart* from file. */
FunctionDefStart* pFunctionDefStart(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondefstart_;
  }
}

/* Entrypoint: parse FunctionDefStart* from string. */
FunctionDefStart* psFunctionDefStart(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.functiondefstart_;
  }
}

/* Entrypoint: parse DeclSpecList* from file. */
DeclSpecList* pDeclSpecList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclist_;
  }
}

/* Entrypoint: parse DeclSpecList* from string. */
DeclSpecList* psDeclSpecList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclist_;
  }
}

/* Entrypoint: parse DeclSpecListNoNamed* from file. */
DeclSpecListNoNamed* pDeclSpecListNoNamed(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclistnonamed_;
  }
}

/* Entrypoint: parse DeclSpecListNoNamed* from string. */
DeclSpecListNoNamed* psDeclSpecListNoNamed(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declspeclistnonamed_;
  }
}

/* Entrypoint: parse TypeSpec* from file. */
TypeSpec* pTypeSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespec_;
  }
}

/* Entrypoint: parse TypeSpec* from string. */
TypeSpec* psTypeSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespec_;
  }
}

/* Entrypoint: parse Declarator* from file. */
Declarator* pDeclarator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declarator_;
  }
}

/* Entrypoint: parse Declarator* from string. */
Declarator* psDeclarator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declarator_;
  }
}

/* Entrypoint: parse PointerOpt* from file. */
PointerOpt* pPointerOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pointeropt_;
  }
}

/* Entrypoint: parse PointerOpt* from string. */
PointerOpt* psPointerOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pointeropt_;
  }
}

/* Entrypoint: parse DirectDecl* from file. */
DirectDecl* pDirectDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.directdecl_;
  }
}

/* Entrypoint: parse DirectDecl* from string. */
DirectDecl* psDirectDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.directdecl_;
  }
}

/* Entrypoint: parse AttributesWithAsm* from file. */
AttributesWithAsm* pAttributesWithAsm(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributeswithasm_;
  }
}

/* Entrypoint: parse AttributesWithAsm* from string. */
AttributesWithAsm* psAttributesWithAsm(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attributeswithasm_;
  }
}

/* Entrypoint: parse RestParList* from file. */
RestParList* pRestParList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.restparlist_;
  }
}

/* Entrypoint: parse RestParList* from string. */
RestParList* psRestParList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.restparlist_;
  }
}

/* Entrypoint: parse ParameterDecl* from file. */
ParameterDecl* pParameterDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameterdecl_;
  }
}

/* Entrypoint: parse ParameterDecl* from string. */
ParameterDecl* psParameterDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.parameterdecl_;
  }
}

/* Entrypoint: parse ListParameterDecl* from file. */
ListParameterDecl* pListParameterDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparameterdecl_->begin(), result.listparameterdecl_->end());
    return result.listparameterdecl_;
  }
}

/* Entrypoint: parse ListParameterDecl* from string. */
ListParameterDecl* psListParameterDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparameterdecl_->begin(), result.listparameterdecl_->end());
    return result.listparameterdecl_;
  }
}

/* Entrypoint: parse GhostParameterOpt* from file. */
GhostParameterOpt* pGhostParameterOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostparameteropt_;
  }
}

/* Entrypoint: parse GhostParameterOpt* from string. */
GhostParameterOpt* psGhostParameterOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ghostparameteropt_;
  }
}

/* Entrypoint: parse IdOrTypename* from file. */
IdOrTypename* pIdOrTypename(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypename_;
  }
}

/* Entrypoint: parse IdOrTypename* from string. */
IdOrTypename* psIdOrTypename(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypename_;
  }
}

/* Entrypoint: parse IdOrTypenameAsId* from file. */
IdOrTypenameAsId* pIdOrTypenameAsId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypenameasid_;
  }
}

/* Entrypoint: parse IdOrTypenameAsId* from string. */
IdOrTypenameAsId* psIdOrTypenameAsId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idortypenameasid_;
  }
}

/* Entrypoint: parse Declaration* from file. */
Declaration* pDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declaration_;
  }
}

/* Entrypoint: parse Declaration* from string. */
Declaration* psDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declaration_;
  }
}

/* Entrypoint: parse DeclAndInitDeclAttrList* from file. */
DeclAndInitDeclAttrList* pDeclAndInitDeclAttrList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declandinitdeclattrlist_;
  }
}

/* Entrypoint: parse DeclAndInitDeclAttrList* from string. */
DeclAndInitDeclAttrList* psDeclAndInitDeclAttrList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declandinitdeclattrlist_;
  }
}

/* Entrypoint: parse InitDeclaratorAttr* from file. */
InitDeclaratorAttr* pInitDeclaratorAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclaratorattr_;
  }
}

/* Entrypoint: parse InitDeclaratorAttr* from string. */
InitDeclaratorAttr* psInitDeclaratorAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclaratorattr_;
  }
}

/* Entrypoint: parse ListInitDeclaratorAttr* from file. */
ListInitDeclaratorAttr* pListInitDeclaratorAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listinitdeclaratorattr_->begin(), result.listinitdeclaratorattr_->end());
    return result.listinitdeclaratorattr_;
  }
}

/* Entrypoint: parse ListInitDeclaratorAttr* from string. */
ListInitDeclaratorAttr* psListInitDeclaratorAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listinitdeclaratorattr_->begin(), result.listinitdeclaratorattr_->end());
    return result.listinitdeclaratorattr_;
  }
}

/* Entrypoint: parse InitDeclarator* from file. */
InitDeclarator* pInitDeclarator(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclarator_;
  }
}

/* Entrypoint: parse InitDeclarator* from string. */
InitDeclarator* psInitDeclarator(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.initdeclarator_;
  }
}

/* Entrypoint: parse StructDeclList* from file. */
StructDeclList* pStructDeclList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.structdecllist_;
  }
}

/* Entrypoint: parse StructDeclList* from string. */
StructDeclList* psStructDeclList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.structdecllist_;
  }
}

/* Entrypoint: parse FieldDecl* from file. */
FieldDecl* pFieldDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fielddecl_;
  }
}

/* Entrypoint: parse FieldDecl* from string. */
FieldDecl* psFieldDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fielddecl_;
  }
}

/* Entrypoint: parse ListFieldDecl* from file. */
ListFieldDecl* pListFieldDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfielddecl_->begin(), result.listfielddecl_->end());
    return result.listfielddecl_;
  }
}

/* Entrypoint: parse ListFieldDecl* from string. */
ListFieldDecl* psListFieldDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfielddecl_->begin(), result.listfielddecl_->end());
    return result.listfielddecl_;
  }
}

/* Entrypoint: parse Attribute* from file. */
Attribute* pAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attribute_;
  }
}

/* Entrypoint: parse Attribute* from string. */
Attribute* psAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attribute_;
  }
}

/* Entrypoint: parse ListAttribute* from file. */
ListAttribute* pListAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listattribute_;
  }
}

/* Entrypoint: parse ListAttribute* from string. */
ListAttribute* psListAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listattribute_;
  }
}

/* Entrypoint: parse Block* from file. */
Block* pBlock(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse Block* from string. */
Block* psBlock(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse BlockAttrs* from file. */
BlockAttrs* pBlockAttrs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockattrs_;
  }
}

/* Entrypoint: parse BlockAttrs* from string. */
BlockAttrs* psBlockAttrs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockattrs_;
  }
}

/* Entrypoint: parse BlockElement* from file. */
BlockElement* pBlockElement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockelement_;
  }
}

/* Entrypoint: parse BlockElement* from string. */
BlockElement* psBlockElement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockelement_;
  }
}

/* Entrypoint: parse ListBlockElement* from file. */
ListBlockElement* pListBlockElement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listblockelement_;
  }
}

/* Entrypoint: parse ListBlockElement* from string. */
ListBlockElement* psListBlockElement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listblockelement_;
  }
}

/* Entrypoint: parse Statement* from file. */
Statement* pStatement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse Statement* from string. */
Statement* psStatement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse ForClause* from file. */
ForClause* pForClause(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.forclause_;
  }
}

/* Entrypoint: parse ForClause* from string. */
ForClause* psForClause(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.forclause_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse ListAttr* from file. */
ListAttr* pListAttr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listattr_->begin(), result.listattr_->end());
    return result.listattr_;
  }
}

/* Entrypoint: parse ListAttr* from string. */
ListAttr* psListAttr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listattr_->begin(), result.listattr_->end());
    return result.listattr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from file. */
Attr* pAttr14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse Attr* from string. */
Attr* psAttr14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.attr_;
  }
}

/* Entrypoint: parse BasicAttribute* from file. */
BasicAttribute* pBasicAttribute(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.basicattribute_;
  }
}

/* Entrypoint: parse BasicAttribute* from string. */
BasicAttribute* psBasicAttribute(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.basicattribute_;
  }
}

/* Entrypoint: parse AnnotatedStmt* from file. */
AnnotatedStmt* pAnnotatedStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotatedstmt_;
  }
}

/* Entrypoint: parse AnnotatedStmt* from string. */
AnnotatedStmt* psAnnotatedStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotatedstmt_;
  }
}

/* Entrypoint: parse ElsePart* from file. */
ElsePart* pElsePart(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsepart_;
  }
}

/* Entrypoint: parse ElsePart* from string. */
ElsePart* psElsePart(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsepart_;
  }
}

/* Entrypoint: parse OptExpression* from file. */
OptExpression* pOptExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optexpression_;
  }
}

/* Entrypoint: parse OptExpression* from string. */
OptExpression* psOptExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optexpression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse ListExpression* from file. */
ListExpression* pListExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse ListExpression* from string. */
ListExpression* psListExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from file. */
AssignExpr* pAssignExpr15(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse AssignExpr* from string. */
AssignExpr* psAssignExpr15(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assignexpr_;
  }
}

/* Entrypoint: parse Constant* from file. */
Constant* pConstant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse Constant* from string. */
Constant* psConstant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constant_;
  }
}

/* Entrypoint: parse TypeName* from file. */
TypeName* pTypeName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typename_;
  }
}

/* Entrypoint: parse TypeName* from string. */
TypeName* psTypeName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typename_;
  }
}

/* Entrypoint: parse ACSLProgram* from file. */
ACSLProgram* pACSLProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.acslprogram_;
  }
}

/* Entrypoint: parse ACSLProgram* from string. */
ACSLProgram* psACSLProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.acslprogram_;
  }
}

/* Entrypoint: parse Annot* from file. */
Annot* pAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annot_;
  }
}

/* Entrypoint: parse Annot* from string. */
Annot* psAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annot_;
  }
}

/* Entrypoint: parse Code_Annot* from file. */
Code_Annot* pCode_Annot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.code_annot_;
  }
}

/* Entrypoint: parse Code_Annot* from string. */
Code_Annot* psCode_Annot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.code_annot_;
  }
}

/* Entrypoint: parse Contract* from file. */
Contract* pContract(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.contract_;
  }
}

/* Entrypoint: parse Contract* from string. */
Contract* psContract(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.contract_;
  }
}

/* Entrypoint: parse Requires* from file. */
Requires* pRequires(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.requires_;
  }
}

/* Entrypoint: parse Requires* from string. */
Requires* psRequires(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.requires_;
  }
}

/* Entrypoint: parse NERequires* from file. */
NERequires* pNERequires(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nerequires_;
  }
}

/* Entrypoint: parse NERequires* from string. */
NERequires* psNERequires(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nerequires_;
  }
}

/* Entrypoint: parse Terminates* from file. */
Terminates* pTerminates(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.terminates_;
  }
}

/* Entrypoint: parse Terminates* from string. */
Terminates* psTerminates(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.terminates_;
  }
}

/* Entrypoint: parse Decreases* from file. */
Decreases* pDecreases(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decreases_;
  }
}

/* Entrypoint: parse Decreases* from string. */
Decreases* psDecreases(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decreases_;
  }
}

/* Entrypoint: parse SimpleClauses* from file. */
SimpleClauses* pSimpleClauses(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.simpleclauses_;
  }
}

/* Entrypoint: parse SimpleClauses* from string. */
SimpleClauses* psSimpleClauses(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.simpleclauses_;
  }
}

/* Entrypoint: parse NESimpleClauses* from file. */
NESimpleClauses* pNESimpleClauses(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nesimpleclauses_;
  }
}

/* Entrypoint: parse NESimpleClauses* from string. */
NESimpleClauses* psNESimpleClauses(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.nesimpleclauses_;
  }
}

/* Entrypoint: parse Assigns* from file. */
Assigns* pAssigns(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assigns_;
  }
}

/* Entrypoint: parse Assigns* from string. */
Assigns* psAssigns(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assigns_;
  }
}

/* Entrypoint: parse Zones* from file. */
Zones* pZones(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.zones_;
  }
}

/* Entrypoint: parse Zones* from string. */
Zones* psZones(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.zones_;
  }
}

/* Entrypoint: parse Behaviors* from file. */
Behaviors* pBehaviors(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviors_;
  }
}

/* Entrypoint: parse Behaviors* from string. */
Behaviors* psBehaviors(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.behaviors_;
  }
}

/* Entrypoint: parse CompleteOrDisjoint* from file. */
CompleteOrDisjoint* pCompleteOrDisjoint(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.completeordisjoint_;
  }
}

/* Entrypoint: parse CompleteOrDisjoint* from string. */
CompleteOrDisjoint* psCompleteOrDisjoint(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.completeordisjoint_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse ListLexpr* from file. */
ListLexpr* pListLexpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlexpr_->begin(), result.listlexpr_->end());
    return result.listlexpr_;
  }
}

/* Entrypoint: parse ListLexpr* from string. */
ListLexpr* psListLexpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlexpr_->begin(), result.listlexpr_->end());
    return result.listlexpr_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse LexprRelInner* from file. */
LexprRelInner* pLexprRelInner(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprrelinner_;
  }
}

/* Entrypoint: parse LexprRelInner* from string. */
LexprRelInner* psLexprRelInner(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprrelinner_;
  }
}

/* Entrypoint: parse ListLexprRelInner* from file. */
ListLexprRelInner* pListLexprRelInner(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlexprrelinner_;
  }
}

/* Entrypoint: parse ListLexprRelInner* from string. */
ListLexprRelInner* psListLexprRelInner(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlexprrelinner_;
  }
}

/* Entrypoint: parse Relation* from file. */
Relation* pRelation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.relation_;
  }
}

/* Entrypoint: parse Relation* from string. */
Relation* psRelation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.relation_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse LexprBinder* from file. */
LexprBinder* pLexprBinder(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprbinder_;
  }
}

/* Entrypoint: parse LexprBinder* from string. */
LexprBinder* psLexprBinder(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexprbinder_;
  }
}

/* Entrypoint: parse Binders* from file. */
Binders* pBinders(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.binders_;
  }
}

/* Entrypoint: parse Binders* from string. */
Binders* psBinders(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.binders_;
  }
}

/* Entrypoint: parse TypeSpecOFTYPENAME* from file. */
TypeSpecOFTYPENAME* pTypeSpecOFTYPENAME(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecoftypename_;
  }
}

/* Entrypoint: parse TypeSpecOFTYPENAME* from string. */
TypeSpecOFTYPENAME* psTypeSpecOFTYPENAME(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecoftypename_;
  }
}

/* Entrypoint: parse BindersReentrance* from file. */
BindersReentrance* pBindersReentrance(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bindersreentrance_;
  }
}

/* Entrypoint: parse BindersReentrance* from string. */
BindersReentrance* psBindersReentrance(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bindersreentrance_;
  }
}

/* Entrypoint: parse ListBindersReentrance* from file. */
ListBindersReentrance* pListBindersReentrance(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listbindersreentrance_;
  }
}

/* Entrypoint: parse ListBindersReentrance* from string. */
ListBindersReentrance* psListBindersReentrance(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listbindersreentrance_;
  }
}

/* Entrypoint: parse VarSpec* from file. */
VarSpec* pVarSpec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse VarSpec* from string. */
VarSpec* psVarSpec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse Stars* from file. */
Stars* pStars(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stars_;
  }
}

/* Entrypoint: parse Stars* from string. */
Stars* psStars(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stars_;
  }
}

/* Entrypoint: parse ListStars* from file. */
ListStars* pListStars(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststars_->begin(), result.liststars_->end());
    return result.liststars_;
  }
}

/* Entrypoint: parse ListStars* from string. */
ListStars* psListStars(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststars_->begin(), result.liststars_->end());
    return result.liststars_;
  }
}

/* Entrypoint: parse VarSpec* from file. */
VarSpec* pVarSpec1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse VarSpec* from string. */
VarSpec* psVarSpec1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varspec_;
  }
}

/* Entrypoint: parse ArraySize* from file. */
ArraySize* pArraySize(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arraysize_;
  }
}

/* Entrypoint: parse ArraySize* from string. */
ArraySize* psArraySize(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arraysize_;
  }
}

/* Entrypoint: parse Lexpr* from file. */
Lexpr* pLexpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse Lexpr* from string. */
Lexpr* psLexpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexpr_;
  }
}

/* Entrypoint: parse OptLabel* from file. */
OptLabel* pOptLabel1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabel* from string. */
OptLabel* psOptLabel1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabel* from file. */
OptLabel* pOptLabel2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabel* from string. */
OptLabel* psOptLabel2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabel_;
  }
}

/* Entrypoint: parse OptLabelList* from file. */
OptLabelList* pOptLabelList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabellist_;
  }
}

/* Entrypoint: parse OptLabelList* from string. */
OptLabelList* psOptLabelList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optlabellist_;
  }
}

/* Entrypoint: parse LabelName* from file. */
LabelName* pLabelName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.labelname_;
  }
}

/* Entrypoint: parse LabelName* from string. */
LabelName* psLabelName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.labelname_;
  }
}

/* Entrypoint: parse ListLabelName* from file. */
ListLabelName* pListLabelName(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlabelname_->begin(), result.listlabelname_->end());
    return result.listlabelname_;
  }
}

/* Entrypoint: parse ListLabelName* from string. */
ListLabelName* psListLabelName(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlabelname_->begin(), result.listlabelname_->end());
    return result.listlabelname_;
  }
}

/* Entrypoint: parse Range* from file. */
Range* pRange(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.range_;
  }
}

/* Entrypoint: parse Range* from string. */
Range* psRange(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.range_;
  }
}

/* Entrypoint: parse LexprOption* from file. */
LexprOption* pLexprOption(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexproption_;
  }
}

/* Entrypoint: parse LexprOption* from string. */
LexprOption* psLexprOption(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.lexproption_;
  }
}

/* Entrypoint: parse AnyIdentifier* from file. */
AnyIdentifier* pAnyIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.anyidentifier_;
  }
}

/* Entrypoint: parse AnyIdentifier* from string. */
AnyIdentifier* psAnyIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.anyidentifier_;
  }
}

/* Entrypoint: parse PostCond* from file. */
PostCond* pPostCond(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.postcond_;
  }
}

/* Entrypoint: parse PostCond* from string. */
PostCond* psPostCond(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.postcond_;
  }
}

/* Entrypoint: parse FullIdentifier* from file. */
FullIdentifier* pFullIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fullidentifier_;
  }
}

/* Entrypoint: parse FullIdentifier* from string. */
FullIdentifier* psFullIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fullidentifier_;
  }
}

/* Entrypoint: parse ListFullIdentifier* from file. */
ListFullIdentifier* pListFullIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfullidentifier_->begin(), result.listfullidentifier_->end());
    return result.listfullidentifier_;
  }
}

/* Entrypoint: parse ListFullIdentifier* from string. */
ListFullIdentifier* psListFullIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfullidentifier_->begin(), result.listfullidentifier_->end());
    return result.listfullidentifier_;
  }
}

/* Entrypoint: parse Identifier* from file. */
Identifier* pIdentifier(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifier_;
  }
}

/* Entrypoint: parse Identifier* from string. */
Identifier* psIdentifier(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.identifier_;
  }
}

/* Entrypoint: parse TypeSpecSimple* from file. */
TypeSpecSimple* pTypeSpecSimple(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecsimple_;
  }
}

/* Entrypoint: parse TypeSpecSimple* from string. */
TypeSpecSimple* psTypeSpecSimple(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typespecsimple_;
  }
}

/* Entrypoint: parse LogicPTreeAnnot* from file. */
LogicPTreeAnnot* pLogicPTreeAnnot(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicptreeannot_;
  }
}

/* Entrypoint: parse LogicPTreeAnnot* from string. */
LogicPTreeAnnot* psLogicPTreeAnnot(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicptreeannot_;
  }
}

/* Entrypoint: parse Annotation* from file. */
Annotation* pAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotation_;
  }
}

/* Entrypoint: parse Annotation* from string. */
Annotation* psAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotation_;
  }
}

/* Entrypoint: parse LoopAnnotStack* from file. */
LoopAnnotStack* pLoopAnnotStack(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotstack_;
  }
}

/* Entrypoint: parse LoopAnnotStack* from string. */
LoopAnnotStack* psLoopAnnotStack(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotstack_;
  }
}

/* Entrypoint: parse LoopAnnotOpt* from file. */
LoopAnnotOpt* pLoopAnnotOpt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotopt_;
  }
}

/* Entrypoint: parse LoopAnnotOpt* from string. */
LoopAnnotOpt* psLoopAnnotOpt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopannotopt_;
  }
}

/* Entrypoint: parse LoopInvariant* from file. */
LoopInvariant* pLoopInvariant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopinvariant_;
  }
}

/* Entrypoint: parse LoopInvariant* from string. */
LoopInvariant* psLoopInvariant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopinvariant_;
  }
}

/* Entrypoint: parse LoopVariant* from file. */
LoopVariant* pLoopVariant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopvariant_;
  }
}

/* Entrypoint: parse LoopVariant* from string. */
LoopVariant* psLoopVariant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopvariant_;
  }
}

/* Entrypoint: parse LoopEffects* from file. */
LoopEffects* pLoopEffects(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopeffects_;
  }
}

/* Entrypoint: parse LoopEffects* from string. */
LoopEffects* psLoopEffects(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.loopeffects_;
  }
}

/* Entrypoint: parse Variant* from file. */
Variant* pVariant(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variant_;
  }
}

/* Entrypoint: parse Variant* from string. */
Variant* psVariant(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variant_;
  }
}


}
