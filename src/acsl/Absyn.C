/* File generated by the BNF Converter (bnfc 2.9.4.1). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace acsl
{
/********************   AProgram    ********************/
AProgram::AProgram(Globals *p1)
{
  globals_ = p1;

}

AProgram::AProgram(const AProgram & other)
{
  globals_ = other.globals_->clone();

}

AProgram &AProgram::operator=(const AProgram & other)
{
  AProgram tmp(other);
  swap(tmp);
  return *this;
}

void AProgram::swap(AProgram & other)
{
  std::swap(globals_, other.globals_);

}

AProgram::~AProgram()
{
  delete(globals_);

}

void AProgram::accept(Visitor *v)
{
  v->visitAProgram(this);
}

AProgram *AProgram::clone() const
{
  return new AProgram(*this);
}



/********************   NoGlobals    ********************/
NoGlobals::NoGlobals()
{

}

NoGlobals::NoGlobals(const NoGlobals & other)
{

}

NoGlobals &NoGlobals::operator=(const NoGlobals & other)
{
  NoGlobals tmp(other);
  swap(tmp);
  return *this;
}

void NoGlobals::swap(NoGlobals & other)
{

}

NoGlobals::~NoGlobals()
{

}

void NoGlobals::accept(Visitor *v)
{
  v->visitNoGlobals(this);
}

NoGlobals *NoGlobals::clone() const
{
  return new NoGlobals(*this);
}



/********************   SimpleGlobals    ********************/
SimpleGlobals::SimpleGlobals(Global *p1, Globals *p2)
{
  global_ = p1;
  globals_ = p2;

}

SimpleGlobals::SimpleGlobals(const SimpleGlobals & other)
{
  global_ = other.global_->clone();
  globals_ = other.globals_->clone();

}

SimpleGlobals &SimpleGlobals::operator=(const SimpleGlobals & other)
{
  SimpleGlobals tmp(other);
  swap(tmp);
  return *this;
}

void SimpleGlobals::swap(SimpleGlobals & other)
{
  std::swap(global_, other.global_);
  std::swap(globals_, other.globals_);

}

SimpleGlobals::~SimpleGlobals()
{
  delete(global_);
  delete(globals_);

}

void SimpleGlobals::accept(Visitor *v)
{
  v->visitSimpleGlobals(this);
}

SimpleGlobals *SimpleGlobals::clone() const
{
  return new SimpleGlobals(*this);
}



/********************   SemiColonGlobals    ********************/
SemiColonGlobals::SemiColonGlobals(Globals *p1)
{
  globals_ = p1;

}

SemiColonGlobals::SemiColonGlobals(const SemiColonGlobals & other)
{
  globals_ = other.globals_->clone();

}

SemiColonGlobals &SemiColonGlobals::operator=(const SemiColonGlobals & other)
{
  SemiColonGlobals tmp(other);
  swap(tmp);
  return *this;
}

void SemiColonGlobals::swap(SemiColonGlobals & other)
{
  std::swap(globals_, other.globals_);

}

SemiColonGlobals::~SemiColonGlobals()
{
  delete(globals_);

}

void SemiColonGlobals::accept(Visitor *v)
{
  v->visitSemiColonGlobals(this);
}

SemiColonGlobals *SemiColonGlobals::clone() const
{
  return new SemiColonGlobals(*this);
}



/********************   GlobalsFunctionDef    ********************/
GlobalsFunctionDef::GlobalsFunctionDef(FunctionDef *p1)
{
  functiondef_ = p1;

}

GlobalsFunctionDef::GlobalsFunctionDef(const GlobalsFunctionDef & other)
{
  functiondef_ = other.functiondef_->clone();

}

GlobalsFunctionDef &GlobalsFunctionDef::operator=(const GlobalsFunctionDef & other)
{
  GlobalsFunctionDef tmp(other);
  swap(tmp);
  return *this;
}

void GlobalsFunctionDef::swap(GlobalsFunctionDef & other)
{
  std::swap(functiondef_, other.functiondef_);

}

GlobalsFunctionDef::~GlobalsFunctionDef()
{
  delete(functiondef_);

}

void GlobalsFunctionDef::accept(Visitor *v)
{
  v->visitGlobalsFunctionDef(this);
}

GlobalsFunctionDef *GlobalsFunctionDef::clone() const
{
  return new GlobalsFunctionDef(*this);
}



/********************   GlobalsDeclataion    ********************/
GlobalsDeclataion::GlobalsDeclataion(Declaration *p1)
{
  declaration_ = p1;

}

GlobalsDeclataion::GlobalsDeclataion(const GlobalsDeclataion & other)
{
  declaration_ = other.declaration_->clone();

}

GlobalsDeclataion &GlobalsDeclataion::operator=(const GlobalsDeclataion & other)
{
  GlobalsDeclataion tmp(other);
  swap(tmp);
  return *this;
}

void GlobalsDeclataion::swap(GlobalsDeclataion & other)
{
  std::swap(declaration_, other.declaration_);

}

GlobalsDeclataion::~GlobalsDeclataion()
{
  delete(declaration_);

}

void GlobalsDeclataion::accept(Visitor *v)
{
  v->visitGlobalsDeclataion(this);
}

GlobalsDeclataion *GlobalsDeclataion::clone() const
{
  return new GlobalsDeclataion(*this);
}



/********************   SimpleFunctionDef    ********************/
SimpleFunctionDef::SimpleFunctionDef(FunctionDefStart *p1, Block *p2)
{
  functiondefstart_ = p1;
  block_ = p2;

}

SimpleFunctionDef::SimpleFunctionDef(const SimpleFunctionDef & other)
{
  functiondefstart_ = other.functiondefstart_->clone();
  block_ = other.block_->clone();

}

SimpleFunctionDef &SimpleFunctionDef::operator=(const SimpleFunctionDef & other)
{
  SimpleFunctionDef tmp(other);
  swap(tmp);
  return *this;
}

void SimpleFunctionDef::swap(SimpleFunctionDef & other)
{
  std::swap(functiondefstart_, other.functiondefstart_);
  std::swap(block_, other.block_);

}

SimpleFunctionDef::~SimpleFunctionDef()
{
  delete(functiondefstart_);
  delete(block_);

}

void SimpleFunctionDef::accept(Visitor *v)
{
  v->visitSimpleFunctionDef(this);
}

SimpleFunctionDef *SimpleFunctionDef::clone() const
{
  return new SimpleFunctionDef(*this);
}



/********************   FunctionDefSpec    ********************/
FunctionDefSpec::FunctionDefSpec(ACSLProgram *p1, FunctionDefStart *p2, Block *p3)
{
  acslprogram_ = p1;
  functiondefstart_ = p2;
  block_ = p3;

}

FunctionDefSpec::FunctionDefSpec(const FunctionDefSpec & other)
{
  acslprogram_ = other.acslprogram_->clone();
  functiondefstart_ = other.functiondefstart_->clone();
  block_ = other.block_->clone();

}

FunctionDefSpec &FunctionDefSpec::operator=(const FunctionDefSpec & other)
{
  FunctionDefSpec tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefSpec::swap(FunctionDefSpec & other)
{
  std::swap(acslprogram_, other.acslprogram_);
  std::swap(functiondefstart_, other.functiondefstart_);
  std::swap(block_, other.block_);

}

FunctionDefSpec::~FunctionDefSpec()
{
  delete(acslprogram_);
  delete(functiondefstart_);
  delete(block_);

}

void FunctionDefSpec::accept(Visitor *v)
{
  v->visitFunctionDefSpec(this);
}

FunctionDefSpec *FunctionDefSpec::clone() const
{
  return new FunctionDefSpec(*this);
}



/********************   FunctionDefStartDeclarator    ********************/
FunctionDefStartDeclarator::FunctionDefStartDeclarator(DeclSpecList *p1, Declarator *p2)
{
  declspeclist_ = p1;
  declarator_ = p2;

}

FunctionDefStartDeclarator::FunctionDefStartDeclarator(const FunctionDefStartDeclarator & other)
{
  declspeclist_ = other.declspeclist_->clone();
  declarator_ = other.declarator_->clone();

}

FunctionDefStartDeclarator &FunctionDefStartDeclarator::operator=(const FunctionDefStartDeclarator & other)
{
  FunctionDefStartDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefStartDeclarator::swap(FunctionDefStartDeclarator & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declarator_, other.declarator_);

}

FunctionDefStartDeclarator::~FunctionDefStartDeclarator()
{
  delete(declspeclist_);
  delete(declarator_);

}

void FunctionDefStartDeclarator::accept(Visitor *v)
{
  v->visitFunctionDefStartDeclarator(this);
}

FunctionDefStartDeclarator *FunctionDefStartDeclarator::clone() const
{
  return new FunctionDefStartDeclarator(*this);
}



/********************   DeclSpecTypeSpec    ********************/
DeclSpecTypeSpec::DeclSpecTypeSpec(TypeSpec *p1)
{
  typespec_ = p1;

}

DeclSpecTypeSpec::DeclSpecTypeSpec(const DeclSpecTypeSpec & other)
{
  typespec_ = other.typespec_->clone();

}

DeclSpecTypeSpec &DeclSpecTypeSpec::operator=(const DeclSpecTypeSpec & other)
{
  DeclSpecTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecTypeSpec::swap(DeclSpecTypeSpec & other)
{
  std::swap(typespec_, other.typespec_);

}

DeclSpecTypeSpec::~DeclSpecTypeSpec()
{
  delete(typespec_);

}

void DeclSpecTypeSpec::accept(Visitor *v)
{
  v->visitDeclSpecTypeSpec(this);
}

DeclSpecTypeSpec *DeclSpecTypeSpec::clone() const
{
  return new DeclSpecTypeSpec(*this);
}



/********************   DeclSpecTypeSpecNext    ********************/
DeclSpecTypeSpecNext::DeclSpecTypeSpecNext(TypeSpec *p1, DeclSpecListNoNamed *p2)
{
  typespec_ = p1;
  declspeclistnonamed_ = p2;

}

DeclSpecTypeSpecNext::DeclSpecTypeSpecNext(const DeclSpecTypeSpecNext & other)
{
  typespec_ = other.typespec_->clone();
  declspeclistnonamed_ = other.declspeclistnonamed_->clone();

}

DeclSpecTypeSpecNext &DeclSpecTypeSpecNext::operator=(const DeclSpecTypeSpecNext & other)
{
  DeclSpecTypeSpecNext tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecTypeSpecNext::swap(DeclSpecTypeSpecNext & other)
{
  std::swap(typespec_, other.typespec_);
  std::swap(declspeclistnonamed_, other.declspeclistnonamed_);

}

DeclSpecTypeSpecNext::~DeclSpecTypeSpecNext()
{
  delete(typespec_);
  delete(declspeclistnonamed_);

}

void DeclSpecTypeSpecNext::accept(Visitor *v)
{
  v->visitDeclSpecTypeSpecNext(this);
}

DeclSpecTypeSpecNext *DeclSpecTypeSpecNext::clone() const
{
  return new DeclSpecTypeSpecNext(*this);
}



/********************   DeclSpecNoNamedTypeSpec    ********************/
DeclSpecNoNamedTypeSpec::DeclSpecNoNamedTypeSpec(TypeSpec *p1)
{
  typespec_ = p1;

}

DeclSpecNoNamedTypeSpec::DeclSpecNoNamedTypeSpec(const DeclSpecNoNamedTypeSpec & other)
{
  typespec_ = other.typespec_->clone();

}

DeclSpecNoNamedTypeSpec &DeclSpecNoNamedTypeSpec::operator=(const DeclSpecNoNamedTypeSpec & other)
{
  DeclSpecNoNamedTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecNoNamedTypeSpec::swap(DeclSpecNoNamedTypeSpec & other)
{
  std::swap(typespec_, other.typespec_);

}

DeclSpecNoNamedTypeSpec::~DeclSpecNoNamedTypeSpec()
{
  delete(typespec_);

}

void DeclSpecNoNamedTypeSpec::accept(Visitor *v)
{
  v->visitDeclSpecNoNamedTypeSpec(this);
}

DeclSpecNoNamedTypeSpec *DeclSpecNoNamedTypeSpec::clone() const
{
  return new DeclSpecNoNamedTypeSpec(*this);
}



/********************   DeclSpecNoNamedTypeSpecNext    ********************/
DeclSpecNoNamedTypeSpecNext::DeclSpecNoNamedTypeSpecNext(TypeSpec *p1, DeclSpecListNoNamed *p2)
{
  typespec_ = p1;
  declspeclistnonamed_ = p2;

}

DeclSpecNoNamedTypeSpecNext::DeclSpecNoNamedTypeSpecNext(const DeclSpecNoNamedTypeSpecNext & other)
{
  typespec_ = other.typespec_->clone();
  declspeclistnonamed_ = other.declspeclistnonamed_->clone();

}

DeclSpecNoNamedTypeSpecNext &DeclSpecNoNamedTypeSpecNext::operator=(const DeclSpecNoNamedTypeSpecNext & other)
{
  DeclSpecNoNamedTypeSpecNext tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecNoNamedTypeSpecNext::swap(DeclSpecNoNamedTypeSpecNext & other)
{
  std::swap(typespec_, other.typespec_);
  std::swap(declspeclistnonamed_, other.declspeclistnonamed_);

}

DeclSpecNoNamedTypeSpecNext::~DeclSpecNoNamedTypeSpecNext()
{
  delete(typespec_);
  delete(declspeclistnonamed_);

}

void DeclSpecNoNamedTypeSpecNext::accept(Visitor *v)
{
  v->visitDeclSpecNoNamedTypeSpecNext(this);
}

DeclSpecNoNamedTypeSpecNext *DeclSpecNoNamedTypeSpecNext::clone() const
{
  return new DeclSpecNoNamedTypeSpecNext(*this);
}



/********************   TypeSpecVoidKeyWord    ********************/
TypeSpecVoidKeyWord::TypeSpecVoidKeyWord()
{

}

TypeSpecVoidKeyWord::TypeSpecVoidKeyWord(const TypeSpecVoidKeyWord & other)
{

}

TypeSpecVoidKeyWord &TypeSpecVoidKeyWord::operator=(const TypeSpecVoidKeyWord & other)
{
  TypeSpecVoidKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecVoidKeyWord::swap(TypeSpecVoidKeyWord & other)
{

}

TypeSpecVoidKeyWord::~TypeSpecVoidKeyWord()
{

}

void TypeSpecVoidKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecVoidKeyWord(this);
}

TypeSpecVoidKeyWord *TypeSpecVoidKeyWord::clone() const
{
  return new TypeSpecVoidKeyWord(*this);
}



/********************   TypeSpecCharKeyWord    ********************/
TypeSpecCharKeyWord::TypeSpecCharKeyWord()
{

}

TypeSpecCharKeyWord::TypeSpecCharKeyWord(const TypeSpecCharKeyWord & other)
{

}

TypeSpecCharKeyWord &TypeSpecCharKeyWord::operator=(const TypeSpecCharKeyWord & other)
{
  TypeSpecCharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecCharKeyWord::swap(TypeSpecCharKeyWord & other)
{

}

TypeSpecCharKeyWord::~TypeSpecCharKeyWord()
{

}

void TypeSpecCharKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecCharKeyWord(this);
}

TypeSpecCharKeyWord *TypeSpecCharKeyWord::clone() const
{
  return new TypeSpecCharKeyWord(*this);
}



/********************   TypeSpecBoolKeyWord    ********************/
TypeSpecBoolKeyWord::TypeSpecBoolKeyWord()
{

}

TypeSpecBoolKeyWord::TypeSpecBoolKeyWord(const TypeSpecBoolKeyWord & other)
{

}

TypeSpecBoolKeyWord &TypeSpecBoolKeyWord::operator=(const TypeSpecBoolKeyWord & other)
{
  TypeSpecBoolKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecBoolKeyWord::swap(TypeSpecBoolKeyWord & other)
{

}

TypeSpecBoolKeyWord::~TypeSpecBoolKeyWord()
{

}

void TypeSpecBoolKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecBoolKeyWord(this);
}

TypeSpecBoolKeyWord *TypeSpecBoolKeyWord::clone() const
{
  return new TypeSpecBoolKeyWord(*this);
}



/********************   TypeSpecShortKeyWord    ********************/
TypeSpecShortKeyWord::TypeSpecShortKeyWord()
{

}

TypeSpecShortKeyWord::TypeSpecShortKeyWord(const TypeSpecShortKeyWord & other)
{

}

TypeSpecShortKeyWord &TypeSpecShortKeyWord::operator=(const TypeSpecShortKeyWord & other)
{
  TypeSpecShortKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecShortKeyWord::swap(TypeSpecShortKeyWord & other)
{

}

TypeSpecShortKeyWord::~TypeSpecShortKeyWord()
{

}

void TypeSpecShortKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecShortKeyWord(this);
}

TypeSpecShortKeyWord *TypeSpecShortKeyWord::clone() const
{
  return new TypeSpecShortKeyWord(*this);
}



/********************   TypeSpecInt32KeyWord    ********************/
TypeSpecInt32KeyWord::TypeSpecInt32KeyWord()
{

}

TypeSpecInt32KeyWord::TypeSpecInt32KeyWord(const TypeSpecInt32KeyWord & other)
{

}

TypeSpecInt32KeyWord &TypeSpecInt32KeyWord::operator=(const TypeSpecInt32KeyWord & other)
{
  TypeSpecInt32KeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecInt32KeyWord::swap(TypeSpecInt32KeyWord & other)
{

}

TypeSpecInt32KeyWord::~TypeSpecInt32KeyWord()
{

}

void TypeSpecInt32KeyWord::accept(Visitor *v)
{
  v->visitTypeSpecInt32KeyWord(this);
}

TypeSpecInt32KeyWord *TypeSpecInt32KeyWord::clone() const
{
  return new TypeSpecInt32KeyWord(*this);
}



/********************   TypeSpecIntKeyWord    ********************/
TypeSpecIntKeyWord::TypeSpecIntKeyWord()
{

}

TypeSpecIntKeyWord::TypeSpecIntKeyWord(const TypeSpecIntKeyWord & other)
{

}

TypeSpecIntKeyWord &TypeSpecIntKeyWord::operator=(const TypeSpecIntKeyWord & other)
{
  TypeSpecIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecIntKeyWord::swap(TypeSpecIntKeyWord & other)
{

}

TypeSpecIntKeyWord::~TypeSpecIntKeyWord()
{

}

void TypeSpecIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecIntKeyWord(this);
}

TypeSpecIntKeyWord *TypeSpecIntKeyWord::clone() const
{
  return new TypeSpecIntKeyWord(*this);
}



/********************   TypeSpecSizeTKeyWord    ********************/
TypeSpecSizeTKeyWord::TypeSpecSizeTKeyWord()
{

}

TypeSpecSizeTKeyWord::TypeSpecSizeTKeyWord(const TypeSpecSizeTKeyWord & other)
{

}

TypeSpecSizeTKeyWord &TypeSpecSizeTKeyWord::operator=(const TypeSpecSizeTKeyWord & other)
{
  TypeSpecSizeTKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSizeTKeyWord::swap(TypeSpecSizeTKeyWord & other)
{

}

TypeSpecSizeTKeyWord::~TypeSpecSizeTKeyWord()
{

}

void TypeSpecSizeTKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSizeTKeyWord(this);
}

TypeSpecSizeTKeyWord *TypeSpecSizeTKeyWord::clone() const
{
  return new TypeSpecSizeTKeyWord(*this);
}



/********************   TypeSpecLongKeyWord    ********************/
TypeSpecLongKeyWord::TypeSpecLongKeyWord()
{

}

TypeSpecLongKeyWord::TypeSpecLongKeyWord(const TypeSpecLongKeyWord & other)
{

}

TypeSpecLongKeyWord &TypeSpecLongKeyWord::operator=(const TypeSpecLongKeyWord & other)
{
  TypeSpecLongKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecLongKeyWord::swap(TypeSpecLongKeyWord & other)
{

}

TypeSpecLongKeyWord::~TypeSpecLongKeyWord()
{

}

void TypeSpecLongKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecLongKeyWord(this);
}

TypeSpecLongKeyWord *TypeSpecLongKeyWord::clone() const
{
  return new TypeSpecLongKeyWord(*this);
}



/********************   TypeSpecInt64KeyWord    ********************/
TypeSpecInt64KeyWord::TypeSpecInt64KeyWord()
{

}

TypeSpecInt64KeyWord::TypeSpecInt64KeyWord(const TypeSpecInt64KeyWord & other)
{

}

TypeSpecInt64KeyWord &TypeSpecInt64KeyWord::operator=(const TypeSpecInt64KeyWord & other)
{
  TypeSpecInt64KeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecInt64KeyWord::swap(TypeSpecInt64KeyWord & other)
{

}

TypeSpecInt64KeyWord::~TypeSpecInt64KeyWord()
{

}

void TypeSpecInt64KeyWord::accept(Visitor *v)
{
  v->visitTypeSpecInt64KeyWord(this);
}

TypeSpecInt64KeyWord *TypeSpecInt64KeyWord::clone() const
{
  return new TypeSpecInt64KeyWord(*this);
}



/********************   TypeSpecFloatKeyWord    ********************/
TypeSpecFloatKeyWord::TypeSpecFloatKeyWord()
{

}

TypeSpecFloatKeyWord::TypeSpecFloatKeyWord(const TypeSpecFloatKeyWord & other)
{

}

TypeSpecFloatKeyWord &TypeSpecFloatKeyWord::operator=(const TypeSpecFloatKeyWord & other)
{
  TypeSpecFloatKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecFloatKeyWord::swap(TypeSpecFloatKeyWord & other)
{

}

TypeSpecFloatKeyWord::~TypeSpecFloatKeyWord()
{

}

void TypeSpecFloatKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecFloatKeyWord(this);
}

TypeSpecFloatKeyWord *TypeSpecFloatKeyWord::clone() const
{
  return new TypeSpecFloatKeyWord(*this);
}



/********************   TypeSpecDoubleKeyWord    ********************/
TypeSpecDoubleKeyWord::TypeSpecDoubleKeyWord()
{

}

TypeSpecDoubleKeyWord::TypeSpecDoubleKeyWord(const TypeSpecDoubleKeyWord & other)
{

}

TypeSpecDoubleKeyWord &TypeSpecDoubleKeyWord::operator=(const TypeSpecDoubleKeyWord & other)
{
  TypeSpecDoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecDoubleKeyWord::swap(TypeSpecDoubleKeyWord & other)
{

}

TypeSpecDoubleKeyWord::~TypeSpecDoubleKeyWord()
{

}

void TypeSpecDoubleKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecDoubleKeyWord(this);
}

TypeSpecDoubleKeyWord *TypeSpecDoubleKeyWord::clone() const
{
  return new TypeSpecDoubleKeyWord(*this);
}



/********************   TypeSpecSignedKeyWord    ********************/
TypeSpecSignedKeyWord::TypeSpecSignedKeyWord(SIGNED p1)
{
  signed_ = p1;

}

TypeSpecSignedKeyWord::TypeSpecSignedKeyWord(const TypeSpecSignedKeyWord & other)
{
  signed_ = other.signed_;

}

TypeSpecSignedKeyWord &TypeSpecSignedKeyWord::operator=(const TypeSpecSignedKeyWord & other)
{
  TypeSpecSignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSignedKeyWord::swap(TypeSpecSignedKeyWord & other)
{
  std::swap(signed_, other.signed_);

}

TypeSpecSignedKeyWord::~TypeSpecSignedKeyWord()
{

}

void TypeSpecSignedKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSignedKeyWord(this);
}

TypeSpecSignedKeyWord *TypeSpecSignedKeyWord::clone() const
{
  return new TypeSpecSignedKeyWord(*this);
}



/********************   TypeSpecUnsignedKeyWord    ********************/
TypeSpecUnsignedKeyWord::TypeSpecUnsignedKeyWord()
{

}

TypeSpecUnsignedKeyWord::TypeSpecUnsignedKeyWord(const TypeSpecUnsignedKeyWord & other)
{

}

TypeSpecUnsignedKeyWord &TypeSpecUnsignedKeyWord::operator=(const TypeSpecUnsignedKeyWord & other)
{
  TypeSpecUnsignedKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecUnsignedKeyWord::swap(TypeSpecUnsignedKeyWord & other)
{

}

TypeSpecUnsignedKeyWord::~TypeSpecUnsignedKeyWord()
{

}

void TypeSpecUnsignedKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecUnsignedKeyWord(this);
}

TypeSpecUnsignedKeyWord *TypeSpecUnsignedKeyWord::clone() const
{
  return new TypeSpecUnsignedKeyWord(*this);
}



/********************   StructId    ********************/
StructId::StructId(IdOrTypename *p1)
{
  idortypename_ = p1;

}

StructId::StructId(const StructId & other)
{
  idortypename_ = other.idortypename_->clone();

}

StructId &StructId::operator=(const StructId & other)
{
  StructId tmp(other);
  swap(tmp);
  return *this;
}

void StructId::swap(StructId & other)
{
  std::swap(idortypename_, other.idortypename_);

}

StructId::~StructId()
{
  delete(idortypename_);

}

void StructId::accept(Visitor *v)
{
  v->visitStructId(this);
}

StructId *StructId::clone() const
{
  return new StructId(*this);
}



/********************   StructIdBraces    ********************/
StructIdBraces::StructIdBraces(IdOrTypename *p1, StructDeclList *p2)
{
  idortypename_ = p1;
  structdecllist_ = p2;

}

StructIdBraces::StructIdBraces(const StructIdBraces & other)
{
  idortypename_ = other.idortypename_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

StructIdBraces &StructIdBraces::operator=(const StructIdBraces & other)
{
  StructIdBraces tmp(other);
  swap(tmp);
  return *this;
}

void StructIdBraces::swap(StructIdBraces & other)
{
  std::swap(idortypename_, other.idortypename_);
  std::swap(structdecllist_, other.structdecllist_);

}

StructIdBraces::~StructIdBraces()
{
  delete(idortypename_);
  delete(structdecllist_);

}

void StructIdBraces::accept(Visitor *v)
{
  v->visitStructIdBraces(this);
}

StructIdBraces *StructIdBraces::clone() const
{
  return new StructIdBraces(*this);
}



/********************   StructBraces    ********************/
StructBraces::StructBraces(StructDeclList *p1)
{
  structdecllist_ = p1;

}

StructBraces::StructBraces(const StructBraces & other)
{
  structdecllist_ = other.structdecllist_->clone();

}

StructBraces &StructBraces::operator=(const StructBraces & other)
{
  StructBraces tmp(other);
  swap(tmp);
  return *this;
}

void StructBraces::swap(StructBraces & other)
{
  std::swap(structdecllist_, other.structdecllist_);

}

StructBraces::~StructBraces()
{
  delete(structdecllist_);

}

void StructBraces::accept(Visitor *v)
{
  v->visitStructBraces(this);
}

StructBraces *StructBraces::clone() const
{
  return new StructBraces(*this);
}



/********************   ADeclarator    ********************/
ADeclarator::ADeclarator(PointerOpt *p1, DirectDecl *p2, AttributesWithAsm *p3)
{
  pointeropt_ = p1;
  directdecl_ = p2;
  attributeswithasm_ = p3;

}

ADeclarator::ADeclarator(const ADeclarator & other)
{
  pointeropt_ = other.pointeropt_->clone();
  directdecl_ = other.directdecl_->clone();
  attributeswithasm_ = other.attributeswithasm_->clone();

}

ADeclarator &ADeclarator::operator=(const ADeclarator & other)
{
  ADeclarator tmp(other);
  swap(tmp);
  return *this;
}

void ADeclarator::swap(ADeclarator & other)
{
  std::swap(pointeropt_, other.pointeropt_);
  std::swap(directdecl_, other.directdecl_);
  std::swap(attributeswithasm_, other.attributeswithasm_);

}

ADeclarator::~ADeclarator()
{
  delete(pointeropt_);
  delete(directdecl_);
  delete(attributeswithasm_);

}

void ADeclarator::accept(Visitor *v)
{
  v->visitADeclarator(this);
}

ADeclarator *ADeclarator::clone() const
{
  return new ADeclarator(*this);
}



/********************   NoPointer    ********************/
NoPointer::NoPointer()
{

}

NoPointer::NoPointer(const NoPointer & other)
{

}

NoPointer &NoPointer::operator=(const NoPointer & other)
{
  NoPointer tmp(other);
  swap(tmp);
  return *this;
}

void NoPointer::swap(NoPointer & other)
{

}

NoPointer::~NoPointer()
{

}

void NoPointer::accept(Visitor *v)
{
  v->visitNoPointer(this);
}

NoPointer *NoPointer::clone() const
{
  return new NoPointer(*this);
}



/********************   SomePointer    ********************/
SomePointer::SomePointer(ListAttribute *p1, PointerOpt *p2)
{
  listattribute_ = p1;
  pointeropt_ = p2;

}

SomePointer::SomePointer(const SomePointer & other)
{
  listattribute_ = other.listattribute_->clone();
  pointeropt_ = other.pointeropt_->clone();

}

SomePointer &SomePointer::operator=(const SomePointer & other)
{
  SomePointer tmp(other);
  swap(tmp);
  return *this;
}

void SomePointer::swap(SomePointer & other)
{
  std::swap(listattribute_, other.listattribute_);
  std::swap(pointeropt_, other.pointeropt_);

}

SomePointer::~SomePointer()
{
  delete(listattribute_);
  delete(pointeropt_);

}

void SomePointer::accept(Visitor *v)
{
  v->visitSomePointer(this);
}

SomePointer *SomePointer::clone() const
{
  return new SomePointer(*this);
}



/********************   DirectDeclIdTypename    ********************/
DirectDeclIdTypename::DirectDeclIdTypename(IdOrTypename *p1)
{
  idortypename_ = p1;

}

DirectDeclIdTypename::DirectDeclIdTypename(const DirectDeclIdTypename & other)
{
  idortypename_ = other.idortypename_->clone();

}

DirectDeclIdTypename &DirectDeclIdTypename::operator=(const DirectDeclIdTypename & other)
{
  DirectDeclIdTypename tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclIdTypename::swap(DirectDeclIdTypename & other)
{
  std::swap(idortypename_, other.idortypename_);

}

DirectDeclIdTypename::~DirectDeclIdTypename()
{
  delete(idortypename_);

}

void DirectDeclIdTypename::accept(Visitor *v)
{
  v->visitDirectDeclIdTypename(this);
}

DirectDeclIdTypename *DirectDeclIdTypename::clone() const
{
  return new DirectDeclIdTypename(*this);
}



/********************   DirectDeclGhostParam    ********************/
DirectDeclGhostParam::DirectDeclGhostParam(DirectDecl *p1, GhostParameterOpt *p2)
{
  directdecl_ = p1;
  ghostparameteropt_ = p2;

}

DirectDeclGhostParam::DirectDeclGhostParam(const DirectDeclGhostParam & other)
{
  directdecl_ = other.directdecl_->clone();
  ghostparameteropt_ = other.ghostparameteropt_->clone();

}

DirectDeclGhostParam &DirectDeclGhostParam::operator=(const DirectDeclGhostParam & other)
{
  DirectDeclGhostParam tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclGhostParam::swap(DirectDeclGhostParam & other)
{
  std::swap(directdecl_, other.directdecl_);
  std::swap(ghostparameteropt_, other.ghostparameteropt_);

}

DirectDeclGhostParam::~DirectDeclGhostParam()
{
  delete(directdecl_);
  delete(ghostparameteropt_);

}

void DirectDeclGhostParam::accept(Visitor *v)
{
  v->visitDirectDeclGhostParam(this);
}

DirectDeclGhostParam *DirectDeclGhostParam::clone() const
{
  return new DirectDeclGhostParam(*this);
}



/********************   DirectDeclGhostRestParParam    ********************/
DirectDeclGhostRestParParam::DirectDeclGhostRestParParam(DirectDecl *p1, RestParList *p2, GhostParameterOpt *p3)
{
  directdecl_ = p1;
  restparlist_ = p2;
  ghostparameteropt_ = p3;

}

DirectDeclGhostRestParParam::DirectDeclGhostRestParParam(const DirectDeclGhostRestParParam & other)
{
  directdecl_ = other.directdecl_->clone();
  restparlist_ = other.restparlist_->clone();
  ghostparameteropt_ = other.ghostparameteropt_->clone();

}

DirectDeclGhostRestParParam &DirectDeclGhostRestParParam::operator=(const DirectDeclGhostRestParParam & other)
{
  DirectDeclGhostRestParParam tmp(other);
  swap(tmp);
  return *this;
}

void DirectDeclGhostRestParParam::swap(DirectDeclGhostRestParParam & other)
{
  std::swap(directdecl_, other.directdecl_);
  std::swap(restparlist_, other.restparlist_);
  std::swap(ghostparameteropt_, other.ghostparameteropt_);

}

DirectDeclGhostRestParParam::~DirectDeclGhostRestParParam()
{
  delete(directdecl_);
  delete(restparlist_);
  delete(ghostparameteropt_);

}

void DirectDeclGhostRestParParam::accept(Visitor *v)
{
  v->visitDirectDeclGhostRestParParam(this);
}

DirectDeclGhostRestParParam *DirectDeclGhostRestParParam::clone() const
{
  return new DirectDeclGhostRestParParam(*this);
}



/********************   EmptyAttrWithASM    ********************/
EmptyAttrWithASM::EmptyAttrWithASM()
{

}

EmptyAttrWithASM::EmptyAttrWithASM(const EmptyAttrWithASM & other)
{

}

EmptyAttrWithASM &EmptyAttrWithASM::operator=(const EmptyAttrWithASM & other)
{
  EmptyAttrWithASM tmp(other);
  swap(tmp);
  return *this;
}

void EmptyAttrWithASM::swap(EmptyAttrWithASM & other)
{

}

EmptyAttrWithASM::~EmptyAttrWithASM()
{

}

void EmptyAttrWithASM::accept(Visitor *v)
{
  v->visitEmptyAttrWithASM(this);
}

EmptyAttrWithASM *EmptyAttrWithASM::clone() const
{
  return new EmptyAttrWithASM(*this);
}



/********************   SimpleParameterDecl    ********************/
SimpleParameterDecl::SimpleParameterDecl(ListParameterDecl *p1)
{
  listparameterdecl_ = p1;

}

SimpleParameterDecl::SimpleParameterDecl(const SimpleParameterDecl & other)
{
  listparameterdecl_ = other.listparameterdecl_->clone();

}

SimpleParameterDecl &SimpleParameterDecl::operator=(const SimpleParameterDecl & other)
{
  SimpleParameterDecl tmp(other);
  swap(tmp);
  return *this;
}

void SimpleParameterDecl::swap(SimpleParameterDecl & other)
{
  std::swap(listparameterdecl_, other.listparameterdecl_);

}

SimpleParameterDecl::~SimpleParameterDecl()
{
  delete(listparameterdecl_);

}

void SimpleParameterDecl::accept(Visitor *v)
{
  v->visitSimpleParameterDecl(this);
}

SimpleParameterDecl *SimpleParameterDecl::clone() const
{
  return new SimpleParameterDecl(*this);
}



/********************   ParameterDeclSpecDeclarator    ********************/
ParameterDeclSpecDeclarator::ParameterDeclSpecDeclarator(DeclSpecList *p1, Declarator *p2)
{
  declspeclist_ = p1;
  declarator_ = p2;

}

ParameterDeclSpecDeclarator::ParameterDeclSpecDeclarator(const ParameterDeclSpecDeclarator & other)
{
  declspeclist_ = other.declspeclist_->clone();
  declarator_ = other.declarator_->clone();

}

ParameterDeclSpecDeclarator &ParameterDeclSpecDeclarator::operator=(const ParameterDeclSpecDeclarator & other)
{
  ParameterDeclSpecDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclSpecDeclarator::swap(ParameterDeclSpecDeclarator & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declarator_, other.declarator_);

}

ParameterDeclSpecDeclarator::~ParameterDeclSpecDeclarator()
{
  delete(declspeclist_);
  delete(declarator_);

}

void ParameterDeclSpecDeclarator::accept(Visitor *v)
{
  v->visitParameterDeclSpecDeclarator(this);
}

ParameterDeclSpecDeclarator *ParameterDeclSpecDeclarator::clone() const
{
  return new ParameterDeclSpecDeclarator(*this);
}



/********************   ParameterDeclSpec    ********************/
ParameterDeclSpec::ParameterDeclSpec(DeclSpecList *p1)
{
  declspeclist_ = p1;

}

ParameterDeclSpec::ParameterDeclSpec(const ParameterDeclSpec & other)
{
  declspeclist_ = other.declspeclist_->clone();

}

ParameterDeclSpec &ParameterDeclSpec::operator=(const ParameterDeclSpec & other)
{
  ParameterDeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclSpec::swap(ParameterDeclSpec & other)
{
  std::swap(declspeclist_, other.declspeclist_);

}

ParameterDeclSpec::~ParameterDeclSpec()
{
  delete(declspeclist_);

}

void ParameterDeclSpec::accept(Visitor *v)
{
  v->visitParameterDeclSpec(this);
}

ParameterDeclSpec *ParameterDeclSpec::clone() const
{
  return new ParameterDeclSpec(*this);
}



/********************   ParameterDeclPar    ********************/
ParameterDeclPar::ParameterDeclPar(ParameterDecl *p1)
{
  parameterdecl_ = p1;

}

ParameterDeclPar::ParameterDeclPar(const ParameterDeclPar & other)
{
  parameterdecl_ = other.parameterdecl_->clone();

}

ParameterDeclPar &ParameterDeclPar::operator=(const ParameterDeclPar & other)
{
  ParameterDeclPar tmp(other);
  swap(tmp);
  return *this;
}

void ParameterDeclPar::swap(ParameterDeclPar & other)
{
  std::swap(parameterdecl_, other.parameterdecl_);

}

ParameterDeclPar::~ParameterDeclPar()
{
  delete(parameterdecl_);

}

void ParameterDeclPar::accept(Visitor *v)
{
  v->visitParameterDeclPar(this);
}

ParameterDeclPar *ParameterDeclPar::clone() const
{
  return new ParameterDeclPar(*this);
}



/********************   NoGhostParameter    ********************/
NoGhostParameter::NoGhostParameter()
{

}

NoGhostParameter::NoGhostParameter(const NoGhostParameter & other)
{

}

NoGhostParameter &NoGhostParameter::operator=(const NoGhostParameter & other)
{
  NoGhostParameter tmp(other);
  swap(tmp);
  return *this;
}

void NoGhostParameter::swap(NoGhostParameter & other)
{

}

NoGhostParameter::~NoGhostParameter()
{

}

void NoGhostParameter::accept(Visitor *v)
{
  v->visitNoGhostParameter(this);
}

NoGhostParameter *NoGhostParameter::clone() const
{
  return new NoGhostParameter(*this);
}



/********************   IdTypename    ********************/
IdTypename::IdTypename(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

IdTypename::IdTypename(const IdTypename & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

IdTypename &IdTypename::operator=(const IdTypename & other)
{
  IdTypename tmp(other);
  swap(tmp);
  return *this;
}

void IdTypename::swap(IdTypename & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

IdTypename::~IdTypename()
{
  delete(idortypenameasid_);

}

void IdTypename::accept(Visitor *v)
{
  v->visitIdTypename(this);
}

IdTypename *IdTypename::clone() const
{
  return new IdTypename(*this);
}



/********************   IdOrTypenameAsIdIdentifier    ********************/
IdOrTypenameAsIdIdentifier::IdOrTypenameAsIdIdentifier(Ident p1)
{
  ident_ = p1;

}

IdOrTypenameAsIdIdentifier::IdOrTypenameAsIdIdentifier(const IdOrTypenameAsIdIdentifier & other)
{
  ident_ = other.ident_;

}

IdOrTypenameAsIdIdentifier &IdOrTypenameAsIdIdentifier::operator=(const IdOrTypenameAsIdIdentifier & other)
{
  IdOrTypenameAsIdIdentifier tmp(other);
  swap(tmp);
  return *this;
}

void IdOrTypenameAsIdIdentifier::swap(IdOrTypenameAsIdIdentifier & other)
{
  std::swap(ident_, other.ident_);

}

IdOrTypenameAsIdIdentifier::~IdOrTypenameAsIdIdentifier()
{

}

void IdOrTypenameAsIdIdentifier::accept(Visitor *v)
{
  v->visitIdOrTypenameAsIdIdentifier(this);
}

IdOrTypenameAsIdIdentifier *IdOrTypenameAsIdIdentifier::clone() const
{
  return new IdOrTypenameAsIdIdentifier(*this);
}



/********************   DeclSpecInitDecl    ********************/
DeclSpecInitDecl::DeclSpecInitDecl(DeclSpecList *p1, DeclAndInitDeclAttrList *p2)
{
  declspeclist_ = p1;
  declandinitdeclattrlist_ = p2;

}

DeclSpecInitDecl::DeclSpecInitDecl(const DeclSpecInitDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  declandinitdeclattrlist_ = other.declandinitdeclattrlist_->clone();

}

DeclSpecInitDecl &DeclSpecInitDecl::operator=(const DeclSpecInitDecl & other)
{
  DeclSpecInitDecl tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecInitDecl::swap(DeclSpecInitDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declandinitdeclattrlist_, other.declandinitdeclattrlist_);

}

DeclSpecInitDecl::~DeclSpecInitDecl()
{
  delete(declspeclist_);
  delete(declandinitdeclattrlist_);

}

void DeclSpecInitDecl::accept(Visitor *v)
{
  v->visitDeclSpecInitDecl(this);
}

DeclSpecInitDecl *DeclSpecInitDecl::clone() const
{
  return new DeclSpecInitDecl(*this);
}



/********************   DeclSpec    ********************/
DeclSpec::DeclSpec(DeclSpecList *p1)
{
  declspeclist_ = p1;

}

DeclSpec::DeclSpec(const DeclSpec & other)
{
  declspeclist_ = other.declspeclist_->clone();

}

DeclSpec &DeclSpec::operator=(const DeclSpec & other)
{
  DeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpec::swap(DeclSpec & other)
{
  std::swap(declspeclist_, other.declspeclist_);

}

DeclSpec::~DeclSpec()
{
  delete(declspeclist_);

}

void DeclSpec::accept(Visitor *v)
{
  v->visitDeclSpec(this);
}

DeclSpec *DeclSpec::clone() const
{
  return new DeclSpec(*this);
}



/********************   SpecDeclSpecInitDecl    ********************/
SpecDeclSpecInitDecl::SpecDeclSpecInitDecl(ACSLProgram *p1, DeclSpecList *p2, DeclAndInitDeclAttrList *p3)
{
  acslprogram_ = p1;
  declspeclist_ = p2;
  declandinitdeclattrlist_ = p3;

}

SpecDeclSpecInitDecl::SpecDeclSpecInitDecl(const SpecDeclSpecInitDecl & other)
{
  acslprogram_ = other.acslprogram_->clone();
  declspeclist_ = other.declspeclist_->clone();
  declandinitdeclattrlist_ = other.declandinitdeclattrlist_->clone();

}

SpecDeclSpecInitDecl &SpecDeclSpecInitDecl::operator=(const SpecDeclSpecInitDecl & other)
{
  SpecDeclSpecInitDecl tmp(other);
  swap(tmp);
  return *this;
}

void SpecDeclSpecInitDecl::swap(SpecDeclSpecInitDecl & other)
{
  std::swap(acslprogram_, other.acslprogram_);
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(declandinitdeclattrlist_, other.declandinitdeclattrlist_);

}

SpecDeclSpecInitDecl::~SpecDeclSpecInitDecl()
{
  delete(acslprogram_);
  delete(declspeclist_);
  delete(declandinitdeclattrlist_);

}

void SpecDeclSpecInitDecl::accept(Visitor *v)
{
  v->visitSpecDeclSpecInitDecl(this);
}

SpecDeclSpecInitDecl *SpecDeclSpecInitDecl::clone() const
{
  return new SpecDeclSpecInitDecl(*this);
}



/********************   SpecDeclSpec    ********************/
SpecDeclSpec::SpecDeclSpec(ACSLProgram *p1, DeclSpecList *p2)
{
  acslprogram_ = p1;
  declspeclist_ = p2;

}

SpecDeclSpec::SpecDeclSpec(const SpecDeclSpec & other)
{
  acslprogram_ = other.acslprogram_->clone();
  declspeclist_ = other.declspeclist_->clone();

}

SpecDeclSpec &SpecDeclSpec::operator=(const SpecDeclSpec & other)
{
  SpecDeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void SpecDeclSpec::swap(SpecDeclSpec & other)
{
  std::swap(acslprogram_, other.acslprogram_);
  std::swap(declspeclist_, other.declspeclist_);

}

SpecDeclSpec::~SpecDeclSpec()
{
  delete(acslprogram_);
  delete(declspeclist_);

}

void SpecDeclSpec::accept(Visitor *v)
{
  v->visitSpecDeclSpec(this);
}

SpecDeclSpec *SpecDeclSpec::clone() const
{
  return new SpecDeclSpec(*this);
}



/********************   InitDeclaration    ********************/
InitDeclaration::InitDeclaration(InitDeclarator *p1)
{
  initdeclarator_ = p1;

}

InitDeclaration::InitDeclaration(const InitDeclaration & other)
{
  initdeclarator_ = other.initdeclarator_->clone();

}

InitDeclaration &InitDeclaration::operator=(const InitDeclaration & other)
{
  InitDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclaration::swap(InitDeclaration & other)
{
  std::swap(initdeclarator_, other.initdeclarator_);

}

InitDeclaration::~InitDeclaration()
{
  delete(initdeclarator_);

}

void InitDeclaration::accept(Visitor *v)
{
  v->visitInitDeclaration(this);
}

InitDeclaration *InitDeclaration::clone() const
{
  return new InitDeclaration(*this);
}



/********************   InitDeclarationWithAttr    ********************/
InitDeclarationWithAttr::InitDeclarationWithAttr(InitDeclarator *p1, ListInitDeclaratorAttr *p2)
{
  initdeclarator_ = p1;
  listinitdeclaratorattr_ = p2;

}

InitDeclarationWithAttr::InitDeclarationWithAttr(const InitDeclarationWithAttr & other)
{
  initdeclarator_ = other.initdeclarator_->clone();
  listinitdeclaratorattr_ = other.listinitdeclaratorattr_->clone();

}

InitDeclarationWithAttr &InitDeclarationWithAttr::operator=(const InitDeclarationWithAttr & other)
{
  InitDeclarationWithAttr tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclarationWithAttr::swap(InitDeclarationWithAttr & other)
{
  std::swap(initdeclarator_, other.initdeclarator_);
  std::swap(listinitdeclaratorattr_, other.listinitdeclaratorattr_);

}

InitDeclarationWithAttr::~InitDeclarationWithAttr()
{
  delete(initdeclarator_);
  delete(listinitdeclaratorattr_);

}

void InitDeclarationWithAttr::accept(Visitor *v)
{
  v->visitInitDeclarationWithAttr(this);
}

InitDeclarationWithAttr *InitDeclarationWithAttr::clone() const
{
  return new InitDeclarationWithAttr(*this);
}



/********************   InitDeclaratorAttribute    ********************/
InitDeclaratorAttribute::InitDeclaratorAttribute(InitDeclarator *p1)
{
  initdeclarator_ = p1;

}

InitDeclaratorAttribute::InitDeclaratorAttribute(const InitDeclaratorAttribute & other)
{
  initdeclarator_ = other.initdeclarator_->clone();

}

InitDeclaratorAttribute &InitDeclaratorAttribute::operator=(const InitDeclaratorAttribute & other)
{
  InitDeclaratorAttribute tmp(other);
  swap(tmp);
  return *this;
}

void InitDeclaratorAttribute::swap(InitDeclaratorAttribute & other)
{
  std::swap(initdeclarator_, other.initdeclarator_);

}

InitDeclaratorAttribute::~InitDeclaratorAttribute()
{
  delete(initdeclarator_);

}

void InitDeclaratorAttribute::accept(Visitor *v)
{
  v->visitInitDeclaratorAttribute(this);
}

InitDeclaratorAttribute *InitDeclaratorAttribute::clone() const
{
  return new InitDeclaratorAttribute(*this);
}



/********************   SimpleInitDeclarator    ********************/
SimpleInitDeclarator::SimpleInitDeclarator(Declarator *p1)
{
  declarator_ = p1;

}

SimpleInitDeclarator::SimpleInitDeclarator(const SimpleInitDeclarator & other)
{
  declarator_ = other.declarator_->clone();

}

SimpleInitDeclarator &SimpleInitDeclarator::operator=(const SimpleInitDeclarator & other)
{
  SimpleInitDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void SimpleInitDeclarator::swap(SimpleInitDeclarator & other)
{
  std::swap(declarator_, other.declarator_);

}

SimpleInitDeclarator::~SimpleInitDeclarator()
{
  delete(declarator_);

}

void SimpleInitDeclarator::accept(Visitor *v)
{
  v->visitSimpleInitDeclarator(this);
}

SimpleInitDeclarator *SimpleInitDeclarator::clone() const
{
  return new SimpleInitDeclarator(*this);
}



/********************   EmptyStructDecl    ********************/
EmptyStructDecl::EmptyStructDecl()
{

}

EmptyStructDecl::EmptyStructDecl(const EmptyStructDecl & other)
{

}

EmptyStructDecl &EmptyStructDecl::operator=(const EmptyStructDecl & other)
{
  EmptyStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void EmptyStructDecl::swap(EmptyStructDecl & other)
{

}

EmptyStructDecl::~EmptyStructDecl()
{

}

void EmptyStructDecl::accept(Visitor *v)
{
  v->visitEmptyStructDecl(this);
}

EmptyStructDecl *EmptyStructDecl::clone() const
{
  return new EmptyStructDecl(*this);
}



/********************   DeclSpecStructDecl    ********************/
DeclSpecStructDecl::DeclSpecStructDecl(DeclSpecList *p1, StructDeclList *p2)
{
  declspeclist_ = p1;
  structdecllist_ = p2;

}

DeclSpecStructDecl::DeclSpecStructDecl(const DeclSpecStructDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

DeclSpecStructDecl &DeclSpecStructDecl::operator=(const DeclSpecStructDecl & other)
{
  DeclSpecStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void DeclSpecStructDecl::swap(DeclSpecStructDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(structdecllist_, other.structdecllist_);

}

DeclSpecStructDecl::~DeclSpecStructDecl()
{
  delete(declspeclist_);
  delete(structdecllist_);

}

void DeclSpecStructDecl::accept(Visitor *v)
{
  v->visitDeclSpecStructDecl(this);
}

DeclSpecStructDecl *DeclSpecStructDecl::clone() const
{
  return new DeclSpecStructDecl(*this);
}



/********************   SemicolonStructDecl    ********************/
SemicolonStructDecl::SemicolonStructDecl(StructDeclList *p1)
{
  structdecllist_ = p1;

}

SemicolonStructDecl::SemicolonStructDecl(const SemicolonStructDecl & other)
{
  structdecllist_ = other.structdecllist_->clone();

}

SemicolonStructDecl &SemicolonStructDecl::operator=(const SemicolonStructDecl & other)
{
  SemicolonStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void SemicolonStructDecl::swap(SemicolonStructDecl & other)
{
  std::swap(structdecllist_, other.structdecllist_);

}

SemicolonStructDecl::~SemicolonStructDecl()
{
  delete(structdecllist_);

}

void SemicolonStructDecl::accept(Visitor *v)
{
  v->visitSemicolonStructDecl(this);
}

SemicolonStructDecl *SemicolonStructDecl::clone() const
{
  return new SemicolonStructDecl(*this);
}



/********************   SpecFieldDeclStructDecl    ********************/
SpecFieldDeclStructDecl::SpecFieldDeclStructDecl(DeclSpecList *p1, ListFieldDecl *p2, StructDeclList *p3)
{
  declspeclist_ = p1;
  listfielddecl_ = p2;
  structdecllist_ = p3;

}

SpecFieldDeclStructDecl::SpecFieldDeclStructDecl(const SpecFieldDeclStructDecl & other)
{
  declspeclist_ = other.declspeclist_->clone();
  listfielddecl_ = other.listfielddecl_->clone();
  structdecllist_ = other.structdecllist_->clone();

}

SpecFieldDeclStructDecl &SpecFieldDeclStructDecl::operator=(const SpecFieldDeclStructDecl & other)
{
  SpecFieldDeclStructDecl tmp(other);
  swap(tmp);
  return *this;
}

void SpecFieldDeclStructDecl::swap(SpecFieldDeclStructDecl & other)
{
  std::swap(declspeclist_, other.declspeclist_);
  std::swap(listfielddecl_, other.listfielddecl_);
  std::swap(structdecllist_, other.structdecllist_);

}

SpecFieldDeclStructDecl::~SpecFieldDeclStructDecl()
{
  delete(declspeclist_);
  delete(listfielddecl_);
  delete(structdecllist_);

}

void SpecFieldDeclStructDecl::accept(Visitor *v)
{
  v->visitSpecFieldDeclStructDecl(this);
}

SpecFieldDeclStructDecl *SpecFieldDeclStructDecl::clone() const
{
  return new SpecFieldDeclStructDecl(*this);
}



/********************   FieldDeclDeclarator    ********************/
FieldDeclDeclarator::FieldDeclDeclarator(Declarator *p1)
{
  declarator_ = p1;

}

FieldDeclDeclarator::FieldDeclDeclarator(const FieldDeclDeclarator & other)
{
  declarator_ = other.declarator_->clone();

}

FieldDeclDeclarator &FieldDeclDeclarator::operator=(const FieldDeclDeclarator & other)
{
  FieldDeclDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void FieldDeclDeclarator::swap(FieldDeclDeclarator & other)
{
  std::swap(declarator_, other.declarator_);

}

FieldDeclDeclarator::~FieldDeclDeclarator()
{
  delete(declarator_);

}

void FieldDeclDeclarator::accept(Visitor *v)
{
  v->visitFieldDeclDeclarator(this);
}

FieldDeclDeclarator *FieldDeclDeclarator::clone() const
{
  return new FieldDeclDeclarator(*this);
}



/********************   AttributeConst    ********************/
AttributeConst::AttributeConst(CONST p1)
{
  const_ = p1;

}

AttributeConst::AttributeConst(const AttributeConst & other)
{
  const_ = other.const_;

}

AttributeConst &AttributeConst::operator=(const AttributeConst & other)
{
  AttributeConst tmp(other);
  swap(tmp);
  return *this;
}

void AttributeConst::swap(AttributeConst & other)
{
  std::swap(const_, other.const_);

}

AttributeConst::~AttributeConst()
{

}

void AttributeConst::accept(Visitor *v)
{
  v->visitAttributeConst(this);
}

AttributeConst *AttributeConst::clone() const
{
  return new AttributeConst(*this);
}



/********************   ABlock    ********************/
ABlock::ABlock(BlockAttrs *p1, ListBlockElement *p2)
{
  blockattrs_ = p1;
  listblockelement_ = p2;

}

ABlock::ABlock(const ABlock & other)
{
  blockattrs_ = other.blockattrs_->clone();
  listblockelement_ = other.listblockelement_->clone();

}

ABlock &ABlock::operator=(const ABlock & other)
{
  ABlock tmp(other);
  swap(tmp);
  return *this;
}

void ABlock::swap(ABlock & other)
{
  std::swap(blockattrs_, other.blockattrs_);
  std::swap(listblockelement_, other.listblockelement_);

}

ABlock::~ABlock()
{
  delete(blockattrs_);
  delete(listblockelement_);

}

void ABlock::accept(Visitor *v)
{
  v->visitABlock(this);
}

ABlock *ABlock::clone() const
{
  return new ABlock(*this);
}



/********************   NoBlockAttrs    ********************/
NoBlockAttrs::NoBlockAttrs()
{

}

NoBlockAttrs::NoBlockAttrs(const NoBlockAttrs & other)
{

}

NoBlockAttrs &NoBlockAttrs::operator=(const NoBlockAttrs & other)
{
  NoBlockAttrs tmp(other);
  swap(tmp);
  return *this;
}

void NoBlockAttrs::swap(NoBlockAttrs & other)
{

}

NoBlockAttrs::~NoBlockAttrs()
{

}

void NoBlockAttrs::accept(Visitor *v)
{
  v->visitNoBlockAttrs(this);
}

NoBlockAttrs *NoBlockAttrs::clone() const
{
  return new NoBlockAttrs(*this);
}



/********************   SomeBlockAttrs    ********************/
SomeBlockAttrs::SomeBlockAttrs(BLOCKATTRIBUTE p1, ListAttr *p2)
{
  blockattribute_ = p1;
  listattr_ = p2;

}

SomeBlockAttrs::SomeBlockAttrs(const SomeBlockAttrs & other)
{
  blockattribute_ = other.blockattribute_;
  listattr_ = other.listattr_->clone();

}

SomeBlockAttrs &SomeBlockAttrs::operator=(const SomeBlockAttrs & other)
{
  SomeBlockAttrs tmp(other);
  swap(tmp);
  return *this;
}

void SomeBlockAttrs::swap(SomeBlockAttrs & other)
{
  std::swap(blockattribute_, other.blockattribute_);
  std::swap(listattr_, other.listattr_);

}

SomeBlockAttrs::~SomeBlockAttrs()
{
  delete(listattr_);

}

void SomeBlockAttrs::accept(Visitor *v)
{
  v->visitSomeBlockAttrs(this);
}

SomeBlockAttrs *SomeBlockAttrs::clone() const
{
  return new SomeBlockAttrs(*this);
}



/********************   DeclarationElement    ********************/
DeclarationElement::DeclarationElement(Declaration *p1)
{
  declaration_ = p1;

}

DeclarationElement::DeclarationElement(const DeclarationElement & other)
{
  declaration_ = other.declaration_->clone();

}

DeclarationElement &DeclarationElement::operator=(const DeclarationElement & other)
{
  DeclarationElement tmp(other);
  swap(tmp);
  return *this;
}

void DeclarationElement::swap(DeclarationElement & other)
{
  std::swap(declaration_, other.declaration_);

}

DeclarationElement::~DeclarationElement()
{
  delete(declaration_);

}

void DeclarationElement::accept(Visitor *v)
{
  v->visitDeclarationElement(this);
}

DeclarationElement *DeclarationElement::clone() const
{
  return new DeclarationElement(*this);
}



/********************   StatementElement    ********************/
StatementElement::StatementElement(Statement *p1)
{
  statement_ = p1;

}

StatementElement::StatementElement(const StatementElement & other)
{
  statement_ = other.statement_->clone();

}

StatementElement &StatementElement::operator=(const StatementElement & other)
{
  StatementElement tmp(other);
  swap(tmp);
  return *this;
}

void StatementElement::swap(StatementElement & other)
{
  std::swap(statement_, other.statement_);

}

StatementElement::~StatementElement()
{
  delete(statement_);

}

void StatementElement::accept(Visitor *v)
{
  v->visitStatementElement(this);
}

StatementElement *StatementElement::clone() const
{
  return new StatementElement(*this);
}



/********************   SemicolonStatement    ********************/
SemicolonStatement::SemicolonStatement()
{

}

SemicolonStatement::SemicolonStatement(const SemicolonStatement & other)
{

}

SemicolonStatement &SemicolonStatement::operator=(const SemicolonStatement & other)
{
  SemicolonStatement tmp(other);
  swap(tmp);
  return *this;
}

void SemicolonStatement::swap(SemicolonStatement & other)
{

}

SemicolonStatement::~SemicolonStatement()
{

}

void SemicolonStatement::accept(Visitor *v)
{
  v->visitSemicolonStatement(this);
}

SemicolonStatement *SemicolonStatement::clone() const
{
  return new SemicolonStatement(*this);
}



/********************   SpecStatement    ********************/
SpecStatement::SpecStatement(ACSLProgram *p1, AnnotatedStmt *p2)
{
  acslprogram_ = p1;
  annotatedstmt_ = p2;

}

SpecStatement::SpecStatement(const SpecStatement & other)
{
  acslprogram_ = other.acslprogram_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

SpecStatement &SpecStatement::operator=(const SpecStatement & other)
{
  SpecStatement tmp(other);
  swap(tmp);
  return *this;
}

void SpecStatement::swap(SpecStatement & other)
{
  std::swap(acslprogram_, other.acslprogram_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

SpecStatement::~SpecStatement()
{
  delete(acslprogram_);
  delete(annotatedstmt_);

}

void SpecStatement::accept(Visitor *v)
{
  v->visitSpecStatement(this);
}

SpecStatement *SpecStatement::clone() const
{
  return new SpecStatement(*this);
}



/********************   ExprsStatement    ********************/
ExprsStatement::ExprsStatement(ListExpression *p1)
{
  listexpression_ = p1;

}

ExprsStatement::ExprsStatement(const ExprsStatement & other)
{
  listexpression_ = other.listexpression_->clone();

}

ExprsStatement &ExprsStatement::operator=(const ExprsStatement & other)
{
  ExprsStatement tmp(other);
  swap(tmp);
  return *this;
}

void ExprsStatement::swap(ExprsStatement & other)
{
  std::swap(listexpression_, other.listexpression_);

}

ExprsStatement::~ExprsStatement()
{
  delete(listexpression_);

}

void ExprsStatement::accept(Visitor *v)
{
  v->visitExprsStatement(this);
}

ExprsStatement *ExprsStatement::clone() const
{
  return new ExprsStatement(*this);
}



/********************   BlockStatement    ********************/
BlockStatement::BlockStatement(Block *p1)
{
  block_ = p1;

}

BlockStatement::BlockStatement(const BlockStatement & other)
{
  block_ = other.block_->clone();

}

BlockStatement &BlockStatement::operator=(const BlockStatement & other)
{
  BlockStatement tmp(other);
  swap(tmp);
  return *this;
}

void BlockStatement::swap(BlockStatement & other)
{
  std::swap(block_, other.block_);

}

BlockStatement::~BlockStatement()
{
  delete(block_);

}

void BlockStatement::accept(Visitor *v)
{
  v->visitBlockStatement(this);
}

BlockStatement *BlockStatement::clone() const
{
  return new BlockStatement(*this);
}



/********************   IfStatement    ********************/
IfStatement::IfStatement(ListExpression *p1, AnnotatedStmt *p2, ElsePart *p3)
{
  listexpression_ = p1;
  annotatedstmt_ = p2;
  elsepart_ = p3;

}

IfStatement::IfStatement(const IfStatement & other)
{
  listexpression_ = other.listexpression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();
  elsepart_ = other.elsepart_->clone();

}

IfStatement &IfStatement::operator=(const IfStatement & other)
{
  IfStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfStatement::swap(IfStatement & other)
{
  std::swap(listexpression_, other.listexpression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);
  std::swap(elsepart_, other.elsepart_);

}

IfStatement::~IfStatement()
{
  delete(listexpression_);
  delete(annotatedstmt_);
  delete(elsepart_);

}

void IfStatement::accept(Visitor *v)
{
  v->visitIfStatement(this);
}

IfStatement *IfStatement::clone() const
{
  return new IfStatement(*this);
}



/********************   SwitchStatement    ********************/
SwitchStatement::SwitchStatement(ListExpression *p1, AnnotatedStmt *p2)
{
  listexpression_ = p1;
  annotatedstmt_ = p2;

}

SwitchStatement::SwitchStatement(const SwitchStatement & other)
{
  listexpression_ = other.listexpression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

SwitchStatement &SwitchStatement::operator=(const SwitchStatement & other)
{
  SwitchStatement tmp(other);
  swap(tmp);
  return *this;
}

void SwitchStatement::swap(SwitchStatement & other)
{
  std::swap(listexpression_, other.listexpression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

SwitchStatement::~SwitchStatement()
{
  delete(listexpression_);
  delete(annotatedstmt_);

}

void SwitchStatement::accept(Visitor *v)
{
  v->visitSwitchStatement(this);
}

SwitchStatement *SwitchStatement::clone() const
{
  return new SwitchStatement(*this);
}



/********************   WhileStatement    ********************/
WhileStatement::WhileStatement(ListExpression *p1, AnnotatedStmt *p2)
{
  listexpression_ = p1;
  annotatedstmt_ = p2;

}

WhileStatement::WhileStatement(const WhileStatement & other)
{
  listexpression_ = other.listexpression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

WhileStatement &WhileStatement::operator=(const WhileStatement & other)
{
  WhileStatement tmp(other);
  swap(tmp);
  return *this;
}

void WhileStatement::swap(WhileStatement & other)
{
  std::swap(listexpression_, other.listexpression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

WhileStatement::~WhileStatement()
{
  delete(listexpression_);
  delete(annotatedstmt_);

}

void WhileStatement::accept(Visitor *v)
{
  v->visitWhileStatement(this);
}

WhileStatement *WhileStatement::clone() const
{
  return new WhileStatement(*this);
}



/********************   ForStatement    ********************/
ForStatement::ForStatement(ForClause *p1, OptExpression *p2, OptExpression *p3, AnnotatedStmt *p4)
{
  forclause_ = p1;
  optexpression_1 = p2;
  optexpression_2 = p3;
  annotatedstmt_ = p4;

}

ForStatement::ForStatement(const ForStatement & other)
{
  forclause_ = other.forclause_->clone();
  optexpression_1 = other.optexpression_1->clone();
  optexpression_2 = other.optexpression_2->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

ForStatement &ForStatement::operator=(const ForStatement & other)
{
  ForStatement tmp(other);
  swap(tmp);
  return *this;
}

void ForStatement::swap(ForStatement & other)
{
  std::swap(forclause_, other.forclause_);
  std::swap(optexpression_1, other.optexpression_1);
  std::swap(optexpression_2, other.optexpression_2);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

ForStatement::~ForStatement()
{
  delete(forclause_);
  delete(optexpression_1);
  delete(optexpression_2);
  delete(annotatedstmt_);

}

void ForStatement::accept(Visitor *v)
{
  v->visitForStatement(this);
}

ForStatement *ForStatement::clone() const
{
  return new ForStatement(*this);
}



/********************   CaseStatement    ********************/
CaseStatement::CaseStatement(Expression *p1, AnnotatedStmt *p2)
{
  expression_ = p1;
  annotatedstmt_ = p2;

}

CaseStatement::CaseStatement(const CaseStatement & other)
{
  expression_ = other.expression_->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

CaseStatement &CaseStatement::operator=(const CaseStatement & other)
{
  CaseStatement tmp(other);
  swap(tmp);
  return *this;
}

void CaseStatement::swap(CaseStatement & other)
{
  std::swap(expression_, other.expression_);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

CaseStatement::~CaseStatement()
{
  delete(expression_);
  delete(annotatedstmt_);

}

void CaseStatement::accept(Visitor *v)
{
  v->visitCaseStatement(this);
}

CaseStatement *CaseStatement::clone() const
{
  return new CaseStatement(*this);
}



/********************   CaseSliceStatement    ********************/
CaseSliceStatement::CaseSliceStatement(Expression *p1, Expression *p2, AnnotatedStmt *p3)
{
  expression_1 = p1;
  expression_2 = p2;
  annotatedstmt_ = p3;

}

CaseSliceStatement::CaseSliceStatement(const CaseSliceStatement & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  annotatedstmt_ = other.annotatedstmt_->clone();

}

CaseSliceStatement &CaseSliceStatement::operator=(const CaseSliceStatement & other)
{
  CaseSliceStatement tmp(other);
  swap(tmp);
  return *this;
}

void CaseSliceStatement::swap(CaseSliceStatement & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

CaseSliceStatement::~CaseSliceStatement()
{
  delete(expression_1);
  delete(expression_2);
  delete(annotatedstmt_);

}

void CaseSliceStatement::accept(Visitor *v)
{
  v->visitCaseSliceStatement(this);
}

CaseSliceStatement *CaseSliceStatement::clone() const
{
  return new CaseSliceStatement(*this);
}



/********************   DefaultStatement    ********************/
DefaultStatement::DefaultStatement(AnnotatedStmt *p1)
{
  annotatedstmt_ = p1;

}

DefaultStatement::DefaultStatement(const DefaultStatement & other)
{
  annotatedstmt_ = other.annotatedstmt_->clone();

}

DefaultStatement &DefaultStatement::operator=(const DefaultStatement & other)
{
  DefaultStatement tmp(other);
  swap(tmp);
  return *this;
}

void DefaultStatement::swap(DefaultStatement & other)
{
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

DefaultStatement::~DefaultStatement()
{
  delete(annotatedstmt_);

}

void DefaultStatement::accept(Visitor *v)
{
  v->visitDefaultStatement(this);
}

DefaultStatement *DefaultStatement::clone() const
{
  return new DefaultStatement(*this);
}



/********************   EmptyReturnStatement    ********************/
EmptyReturnStatement::EmptyReturnStatement()
{

}

EmptyReturnStatement::EmptyReturnStatement(const EmptyReturnStatement & other)
{

}

EmptyReturnStatement &EmptyReturnStatement::operator=(const EmptyReturnStatement & other)
{
  EmptyReturnStatement tmp(other);
  swap(tmp);
  return *this;
}

void EmptyReturnStatement::swap(EmptyReturnStatement & other)
{

}

EmptyReturnStatement::~EmptyReturnStatement()
{

}

void EmptyReturnStatement::accept(Visitor *v)
{
  v->visitEmptyReturnStatement(this);
}

EmptyReturnStatement *EmptyReturnStatement::clone() const
{
  return new EmptyReturnStatement(*this);
}



/********************   ReturnStatement    ********************/
ReturnStatement::ReturnStatement(ListExpression *p1)
{
  listexpression_ = p1;

}

ReturnStatement::ReturnStatement(const ReturnStatement & other)
{
  listexpression_ = other.listexpression_->clone();

}

ReturnStatement &ReturnStatement::operator=(const ReturnStatement & other)
{
  ReturnStatement tmp(other);
  swap(tmp);
  return *this;
}

void ReturnStatement::swap(ReturnStatement & other)
{
  std::swap(listexpression_, other.listexpression_);

}

ReturnStatement::~ReturnStatement()
{
  delete(listexpression_);

}

void ReturnStatement::accept(Visitor *v)
{
  v->visitReturnStatement(this);
}

ReturnStatement *ReturnStatement::clone() const
{
  return new ReturnStatement(*this);
}



/********************   BreakStatement    ********************/
BreakStatement::BreakStatement()
{

}

BreakStatement::BreakStatement(const BreakStatement & other)
{

}

BreakStatement &BreakStatement::operator=(const BreakStatement & other)
{
  BreakStatement tmp(other);
  swap(tmp);
  return *this;
}

void BreakStatement::swap(BreakStatement & other)
{

}

BreakStatement::~BreakStatement()
{

}

void BreakStatement::accept(Visitor *v)
{
  v->visitBreakStatement(this);
}

BreakStatement *BreakStatement::clone() const
{
  return new BreakStatement(*this);
}



/********************   ContinueStatement    ********************/
ContinueStatement::ContinueStatement()
{

}

ContinueStatement::ContinueStatement(const ContinueStatement & other)
{

}

ContinueStatement &ContinueStatement::operator=(const ContinueStatement & other)
{
  ContinueStatement tmp(other);
  swap(tmp);
  return *this;
}

void ContinueStatement::swap(ContinueStatement & other)
{

}

ContinueStatement::~ContinueStatement()
{

}

void ContinueStatement::accept(Visitor *v)
{
  v->visitContinueStatement(this);
}

ContinueStatement *ContinueStatement::clone() const
{
  return new ContinueStatement(*this);
}



/********************   ForClauseExpression    ********************/
ForClauseExpression::ForClauseExpression(OptExpression *p1)
{
  optexpression_ = p1;

}

ForClauseExpression::ForClauseExpression(const ForClauseExpression & other)
{
  optexpression_ = other.optexpression_->clone();

}

ForClauseExpression &ForClauseExpression::operator=(const ForClauseExpression & other)
{
  ForClauseExpression tmp(other);
  swap(tmp);
  return *this;
}

void ForClauseExpression::swap(ForClauseExpression & other)
{
  std::swap(optexpression_, other.optexpression_);

}

ForClauseExpression::~ForClauseExpression()
{
  delete(optexpression_);

}

void ForClauseExpression::accept(Visitor *v)
{
  v->visitForClauseExpression(this);
}

ForClauseExpression *ForClauseExpression::clone() const
{
  return new ForClauseExpression(*this);
}



/********************   ForClauseDeclaration    ********************/
ForClauseDeclaration::ForClauseDeclaration(Declaration *p1)
{
  declaration_ = p1;

}

ForClauseDeclaration::ForClauseDeclaration(const ForClauseDeclaration & other)
{
  declaration_ = other.declaration_->clone();

}

ForClauseDeclaration &ForClauseDeclaration::operator=(const ForClauseDeclaration & other)
{
  ForClauseDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void ForClauseDeclaration::swap(ForClauseDeclaration & other)
{
  std::swap(declaration_, other.declaration_);

}

ForClauseDeclaration::~ForClauseDeclaration()
{
  delete(declaration_);

}

void ForClauseDeclaration::accept(Visitor *v)
{
  v->visitForClauseDeclaration(this);
}

ForClauseDeclaration *ForClauseDeclaration::clone() const
{
  return new ForClauseDeclaration(*this);
}



/********************   AnAttr    ********************/
AnAttr::AnAttr(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

AnAttr::AnAttr(const AnAttr & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

AnAttr &AnAttr::operator=(const AnAttr & other)
{
  AnAttr tmp(other);
  swap(tmp);
  return *this;
}

void AnAttr::swap(AnAttr & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

AnAttr::~AnAttr()
{
  delete(attr_1);
  delete(attr_2);

}

void AnAttr::accept(Visitor *v)
{
  v->visitAnAttr(this);
}

AnAttr *AnAttr::clone() const
{
  return new AnAttr(*this);
}



/********************   TernaryCond    ********************/
TernaryCond::TernaryCond(Attr *p1, Attr *p2, Attr *p3)
{
  attr_1 = p1;
  attr_2 = p2;
  attr_3 = p3;

}

TernaryCond::TernaryCond(const TernaryCond & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();
  attr_3 = other.attr_3->clone();

}

TernaryCond &TernaryCond::operator=(const TernaryCond & other)
{
  TernaryCond tmp(other);
  swap(tmp);
  return *this;
}

void TernaryCond::swap(TernaryCond & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);
  std::swap(attr_3, other.attr_3);

}

TernaryCond::~TernaryCond()
{
  delete(attr_1);
  delete(attr_2);
  delete(attr_3);

}

void TernaryCond::accept(Visitor *v)
{
  v->visitTernaryCond(this);
}

TernaryCond *TernaryCond::clone() const
{
  return new TernaryCond(*this);
}



/********************   Or    ********************/
Or::Or(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Or::Or(const Or & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Or &Or::operator=(const Or & other)
{
  Or tmp(other);
  swap(tmp);
  return *this;
}

void Or::swap(Or & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Or::~Or()
{
  delete(attr_1);
  delete(attr_2);

}

void Or::accept(Visitor *v)
{
  v->visitOr(this);
}

Or *Or::clone() const
{
  return new Or(*this);
}



/********************   And    ********************/
And::And(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

And::And(const And & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

And &And::operator=(const And & other)
{
  And tmp(other);
  swap(tmp);
  return *this;
}

void And::swap(And & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

And::~And()
{
  delete(attr_1);
  delete(attr_2);

}

void And::accept(Visitor *v)
{
  v->visitAnd(this);
}

And *And::clone() const
{
  return new And(*this);
}



/********************   BitOr    ********************/
BitOr::BitOr(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

BitOr::BitOr(const BitOr & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

BitOr &BitOr::operator=(const BitOr & other)
{
  BitOr tmp(other);
  swap(tmp);
  return *this;
}

void BitOr::swap(BitOr & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

BitOr::~BitOr()
{
  delete(attr_1);
  delete(attr_2);

}

void BitOr::accept(Visitor *v)
{
  v->visitBitOr(this);
}

BitOr *BitOr::clone() const
{
  return new BitOr(*this);
}



/********************   Xor    ********************/
Xor::Xor(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Xor::Xor(const Xor & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Xor &Xor::operator=(const Xor & other)
{
  Xor tmp(other);
  swap(tmp);
  return *this;
}

void Xor::swap(Xor & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Xor::~Xor()
{
  delete(attr_1);
  delete(attr_2);

}

void Xor::accept(Visitor *v)
{
  v->visitXor(this);
}

Xor *Xor::clone() const
{
  return new Xor(*this);
}



/********************   BitAnd    ********************/
BitAnd::BitAnd(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

BitAnd::BitAnd(const BitAnd & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

BitAnd &BitAnd::operator=(const BitAnd & other)
{
  BitAnd tmp(other);
  swap(tmp);
  return *this;
}

void BitAnd::swap(BitAnd & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

BitAnd::~BitAnd()
{
  delete(attr_1);
  delete(attr_2);

}

void BitAnd::accept(Visitor *v)
{
  v->visitBitAnd(this);
}

BitAnd *BitAnd::clone() const
{
  return new BitAnd(*this);
}



/********************   EqualEqual    ********************/
EqualEqual::EqualEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

EqualEqual::EqualEqual(const EqualEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

EqualEqual &EqualEqual::operator=(const EqualEqual & other)
{
  EqualEqual tmp(other);
  swap(tmp);
  return *this;
}

void EqualEqual::swap(EqualEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

EqualEqual::~EqualEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void EqualEqual::accept(Visitor *v)
{
  v->visitEqualEqual(this);
}

EqualEqual *EqualEqual::clone() const
{
  return new EqualEqual(*this);
}



/********************   NotEqual    ********************/
NotEqual::NotEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

NotEqual::NotEqual(const NotEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

NotEqual &NotEqual::operator=(const NotEqual & other)
{
  NotEqual tmp(other);
  swap(tmp);
  return *this;
}

void NotEqual::swap(NotEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

NotEqual::~NotEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void NotEqual::accept(Visitor *v)
{
  v->visitNotEqual(this);
}

NotEqual *NotEqual::clone() const
{
  return new NotEqual(*this);
}



/********************   Less    ********************/
Less::Less(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Less::Less(const Less & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Less &Less::operator=(const Less & other)
{
  Less tmp(other);
  swap(tmp);
  return *this;
}

void Less::swap(Less & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Less::~Less()
{
  delete(attr_1);
  delete(attr_2);

}

void Less::accept(Visitor *v)
{
  v->visitLess(this);
}

Less *Less::clone() const
{
  return new Less(*this);
}



/********************   Greater    ********************/
Greater::Greater(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

Greater::Greater(const Greater & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

Greater &Greater::operator=(const Greater & other)
{
  Greater tmp(other);
  swap(tmp);
  return *this;
}

void Greater::swap(Greater & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

Greater::~Greater()
{
  delete(attr_1);
  delete(attr_2);

}

void Greater::accept(Visitor *v)
{
  v->visitGreater(this);
}

Greater *Greater::clone() const
{
  return new Greater(*this);
}



/********************   LessEqual    ********************/
LessEqual::LessEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

LessEqual::LessEqual(const LessEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

LessEqual &LessEqual::operator=(const LessEqual & other)
{
  LessEqual tmp(other);
  swap(tmp);
  return *this;
}

void LessEqual::swap(LessEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

LessEqual::~LessEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void LessEqual::accept(Visitor *v)
{
  v->visitLessEqual(this);
}

LessEqual *LessEqual::clone() const
{
  return new LessEqual(*this);
}



/********************   GreaterEqual    ********************/
GreaterEqual::GreaterEqual(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

GreaterEqual::GreaterEqual(const GreaterEqual & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

GreaterEqual &GreaterEqual::operator=(const GreaterEqual & other)
{
  GreaterEqual tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqual::swap(GreaterEqual & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

GreaterEqual::~GreaterEqual()
{
  delete(attr_1);
  delete(attr_2);

}

void GreaterEqual::accept(Visitor *v)
{
  v->visitGreaterEqual(this);
}

GreaterEqual *GreaterEqual::clone() const
{
  return new GreaterEqual(*this);
}



/********************   LeftShiftOp    ********************/
LeftShiftOp::LeftShiftOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

LeftShiftOp::LeftShiftOp(const LeftShiftOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

LeftShiftOp &LeftShiftOp::operator=(const LeftShiftOp & other)
{
  LeftShiftOp tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftOp::swap(LeftShiftOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

LeftShiftOp::~LeftShiftOp()
{
  delete(attr_1);
  delete(attr_2);

}

void LeftShiftOp::accept(Visitor *v)
{
  v->visitLeftShiftOp(this);
}

LeftShiftOp *LeftShiftOp::clone() const
{
  return new LeftShiftOp(*this);
}



/********************   RightShiftOp    ********************/
RightShiftOp::RightShiftOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

RightShiftOp::RightShiftOp(const RightShiftOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

RightShiftOp &RightShiftOp::operator=(const RightShiftOp & other)
{
  RightShiftOp tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftOp::swap(RightShiftOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

RightShiftOp::~RightShiftOp()
{
  delete(attr_1);
  delete(attr_2);

}

void RightShiftOp::accept(Visitor *v)
{
  v->visitRightShiftOp(this);
}

RightShiftOp *RightShiftOp::clone() const
{
  return new RightShiftOp(*this);
}



/********************   AddOp    ********************/
AddOp::AddOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

AddOp::AddOp(const AddOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

AddOp &AddOp::operator=(const AddOp & other)
{
  AddOp tmp(other);
  swap(tmp);
  return *this;
}

void AddOp::swap(AddOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

AddOp::~AddOp()
{
  delete(attr_1);
  delete(attr_2);

}

void AddOp::accept(Visitor *v)
{
  v->visitAddOp(this);
}

AddOp *AddOp::clone() const
{
  return new AddOp(*this);
}



/********************   SubOp    ********************/
SubOp::SubOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

SubOp::SubOp(const SubOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

SubOp &SubOp::operator=(const SubOp & other)
{
  SubOp tmp(other);
  swap(tmp);
  return *this;
}

void SubOp::swap(SubOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

SubOp::~SubOp()
{
  delete(attr_1);
  delete(attr_2);

}

void SubOp::accept(Visitor *v)
{
  v->visitSubOp(this);
}

SubOp *SubOp::clone() const
{
  return new SubOp(*this);
}



/********************   MultOp    ********************/
MultOp::MultOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

MultOp::MultOp(const MultOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

MultOp &MultOp::operator=(const MultOp & other)
{
  MultOp tmp(other);
  swap(tmp);
  return *this;
}

void MultOp::swap(MultOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

MultOp::~MultOp()
{
  delete(attr_1);
  delete(attr_2);

}

void MultOp::accept(Visitor *v)
{
  v->visitMultOp(this);
}

MultOp *MultOp::clone() const
{
  return new MultOp(*this);
}



/********************   DivOp    ********************/
DivOp::DivOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

DivOp::DivOp(const DivOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

DivOp &DivOp::operator=(const DivOp & other)
{
  DivOp tmp(other);
  swap(tmp);
  return *this;
}

void DivOp::swap(DivOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

DivOp::~DivOp()
{
  delete(attr_1);
  delete(attr_2);

}

void DivOp::accept(Visitor *v)
{
  v->visitDivOp(this);
}

DivOp *DivOp::clone() const
{
  return new DivOp(*this);
}



/********************   ModOp    ********************/
ModOp::ModOp(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

ModOp::ModOp(const ModOp & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

ModOp &ModOp::operator=(const ModOp & other)
{
  ModOp tmp(other);
  swap(tmp);
  return *this;
}

void ModOp::swap(ModOp & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

ModOp::~ModOp()
{
  delete(attr_1);
  delete(attr_2);

}

void ModOp::accept(Visitor *v)
{
  v->visitModOp(this);
}

ModOp *ModOp::clone() const
{
  return new ModOp(*this);
}



/********************   PlusUnaryAttr    ********************/
PlusUnaryAttr::PlusUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

PlusUnaryAttr::PlusUnaryAttr(const PlusUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

PlusUnaryAttr &PlusUnaryAttr::operator=(const PlusUnaryAttr & other)
{
  PlusUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void PlusUnaryAttr::swap(PlusUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

PlusUnaryAttr::~PlusUnaryAttr()
{
  delete(attr_);

}

void PlusUnaryAttr::accept(Visitor *v)
{
  v->visitPlusUnaryAttr(this);
}

PlusUnaryAttr *PlusUnaryAttr::clone() const
{
  return new PlusUnaryAttr(*this);
}



/********************   MinusUnaryAttr    ********************/
MinusUnaryAttr::MinusUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

MinusUnaryAttr::MinusUnaryAttr(const MinusUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

MinusUnaryAttr &MinusUnaryAttr::operator=(const MinusUnaryAttr & other)
{
  MinusUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void MinusUnaryAttr::swap(MinusUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

MinusUnaryAttr::~MinusUnaryAttr()
{
  delete(attr_);

}

void MinusUnaryAttr::accept(Visitor *v)
{
  v->visitMinusUnaryAttr(this);
}

MinusUnaryAttr *MinusUnaryAttr::clone() const
{
  return new MinusUnaryAttr(*this);
}



/********************   MultUnaryAttr    ********************/
MultUnaryAttr::MultUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

MultUnaryAttr::MultUnaryAttr(const MultUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

MultUnaryAttr &MultUnaryAttr::operator=(const MultUnaryAttr & other)
{
  MultUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void MultUnaryAttr::swap(MultUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

MultUnaryAttr::~MultUnaryAttr()
{
  delete(attr_);

}

void MultUnaryAttr::accept(Visitor *v)
{
  v->visitMultUnaryAttr(this);
}

MultUnaryAttr *MultUnaryAttr::clone() const
{
  return new MultUnaryAttr(*this);
}



/********************   AmpUnaryAttr    ********************/
AmpUnaryAttr::AmpUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

AmpUnaryAttr::AmpUnaryAttr(const AmpUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

AmpUnaryAttr &AmpUnaryAttr::operator=(const AmpUnaryAttr & other)
{
  AmpUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void AmpUnaryAttr::swap(AmpUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

AmpUnaryAttr::~AmpUnaryAttr()
{
  delete(attr_);

}

void AmpUnaryAttr::accept(Visitor *v)
{
  v->visitAmpUnaryAttr(this);
}

AmpUnaryAttr *AmpUnaryAttr::clone() const
{
  return new AmpUnaryAttr(*this);
}



/********************   NotUnaryAttr    ********************/
NotUnaryAttr::NotUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

NotUnaryAttr::NotUnaryAttr(const NotUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

NotUnaryAttr &NotUnaryAttr::operator=(const NotUnaryAttr & other)
{
  NotUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void NotUnaryAttr::swap(NotUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

NotUnaryAttr::~NotUnaryAttr()
{
  delete(attr_);

}

void NotUnaryAttr::accept(Visitor *v)
{
  v->visitNotUnaryAttr(this);
}

NotUnaryAttr *NotUnaryAttr::clone() const
{
  return new NotUnaryAttr(*this);
}



/********************   TildeUnaryAttr    ********************/
TildeUnaryAttr::TildeUnaryAttr(Attr *p1)
{
  attr_ = p1;

}

TildeUnaryAttr::TildeUnaryAttr(const TildeUnaryAttr & other)
{
  attr_ = other.attr_->clone();

}

TildeUnaryAttr &TildeUnaryAttr::operator=(const TildeUnaryAttr & other)
{
  TildeUnaryAttr tmp(other);
  swap(tmp);
  return *this;
}

void TildeUnaryAttr::swap(TildeUnaryAttr & other)
{
  std::swap(attr_, other.attr_);

}

TildeUnaryAttr::~TildeUnaryAttr()
{
  delete(attr_);

}

void TildeUnaryAttr::accept(Visitor *v)
{
  v->visitTildeUnaryAttr(this);
}

TildeUnaryAttr *TildeUnaryAttr::clone() const
{
  return new TildeUnaryAttr(*this);
}



/********************   FuncationCall    ********************/
FuncationCall::FuncationCall(IdOrTypenameAsId *p1, ListAttr *p2)
{
  idortypenameasid_ = p1;
  listattr_ = p2;

}

FuncationCall::FuncationCall(const FuncationCall & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();
  listattr_ = other.listattr_->clone();

}

FuncationCall &FuncationCall::operator=(const FuncationCall & other)
{
  FuncationCall tmp(other);
  swap(tmp);
  return *this;
}

void FuncationCall::swap(FuncationCall & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);
  std::swap(listattr_, other.listattr_);

}

FuncationCall::~FuncationCall()
{
  delete(idortypenameasid_);
  delete(listattr_);

}

void FuncationCall::accept(Visitor *v)
{
  v->visitFuncationCall(this);
}

FuncationCall *FuncationCall::clone() const
{
  return new FuncationCall(*this);
}



/********************   ProcedureCall    ********************/
ProcedureCall::ProcedureCall(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

ProcedureCall::ProcedureCall(const ProcedureCall & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

ProcedureCall &ProcedureCall::operator=(const ProcedureCall & other)
{
  ProcedureCall tmp(other);
  swap(tmp);
  return *this;
}

void ProcedureCall::swap(ProcedureCall & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

ProcedureCall::~ProcedureCall()
{
  delete(idortypenameasid_);

}

void ProcedureCall::accept(Visitor *v)
{
  v->visitProcedureCall(this);
}

ProcedureCall *ProcedureCall::clone() const
{
  return new ProcedureCall(*this);
}



/********************   ArrowAttr    ********************/
ArrowAttr::ArrowAttr(Attr *p1, IdOrTypename *p2)
{
  attr_ = p1;
  idortypename_ = p2;

}

ArrowAttr::ArrowAttr(const ArrowAttr & other)
{
  attr_ = other.attr_->clone();
  idortypename_ = other.idortypename_->clone();

}

ArrowAttr &ArrowAttr::operator=(const ArrowAttr & other)
{
  ArrowAttr tmp(other);
  swap(tmp);
  return *this;
}

void ArrowAttr::swap(ArrowAttr & other)
{
  std::swap(attr_, other.attr_);
  std::swap(idortypename_, other.idortypename_);

}

ArrowAttr::~ArrowAttr()
{
  delete(attr_);
  delete(idortypename_);

}

void ArrowAttr::accept(Visitor *v)
{
  v->visitArrowAttr(this);
}

ArrowAttr *ArrowAttr::clone() const
{
  return new ArrowAttr(*this);
}



/********************   DotAttr    ********************/
DotAttr::DotAttr(Attr *p1, IdOrTypename *p2)
{
  attr_ = p1;
  idortypename_ = p2;

}

DotAttr::DotAttr(const DotAttr & other)
{
  attr_ = other.attr_->clone();
  idortypename_ = other.idortypename_->clone();

}

DotAttr &DotAttr::operator=(const DotAttr & other)
{
  DotAttr tmp(other);
  swap(tmp);
  return *this;
}

void DotAttr::swap(DotAttr & other)
{
  std::swap(attr_, other.attr_);
  std::swap(idortypename_, other.idortypename_);

}

DotAttr::~DotAttr()
{
  delete(attr_);
  delete(idortypename_);

}

void DotAttr::accept(Visitor *v)
{
  v->visitDotAttr(this);
}

DotAttr *DotAttr::clone() const
{
  return new DotAttr(*this);
}



/********************   ArrayAttr    ********************/
ArrayAttr::ArrayAttr(Attr *p1, Attr *p2)
{
  attr_1 = p1;
  attr_2 = p2;

}

ArrayAttr::ArrayAttr(const ArrayAttr & other)
{
  attr_1 = other.attr_1->clone();
  attr_2 = other.attr_2->clone();

}

ArrayAttr &ArrayAttr::operator=(const ArrayAttr & other)
{
  ArrayAttr tmp(other);
  swap(tmp);
  return *this;
}

void ArrayAttr::swap(ArrayAttr & other)
{
  std::swap(attr_1, other.attr_1);
  std::swap(attr_2, other.attr_2);

}

ArrayAttr::~ArrayAttr()
{
  delete(attr_1);
  delete(attr_2);

}

void ArrayAttr::accept(Visitor *v)
{
  v->visitArrayAttr(this);
}

ArrayAttr *ArrayAttr::clone() const
{
  return new ArrayAttr(*this);
}



/********************   BasicAttr    ********************/
BasicAttr::BasicAttr(BasicAttribute *p1)
{
  basicattribute_ = p1;

}

BasicAttr::BasicAttr(const BasicAttr & other)
{
  basicattribute_ = other.basicattribute_->clone();

}

BasicAttr &BasicAttr::operator=(const BasicAttr & other)
{
  BasicAttr tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttr::swap(BasicAttr & other)
{
  std::swap(basicattribute_, other.basicattribute_);

}

BasicAttr::~BasicAttr()
{
  delete(basicattribute_);

}

void BasicAttr::accept(Visitor *v)
{
  v->visitBasicAttr(this);
}

BasicAttr *BasicAttr::clone() const
{
  return new BasicAttr(*this);
}



/********************   BasicAttrConsInt    ********************/
BasicAttrConsInt::BasicAttrConsInt(Integer p1)
{
  integer_ = p1;

}

BasicAttrConsInt::BasicAttrConsInt(const BasicAttrConsInt & other)
{
  integer_ = other.integer_;

}

BasicAttrConsInt &BasicAttrConsInt::operator=(const BasicAttrConsInt & other)
{
  BasicAttrConsInt tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttrConsInt::swap(BasicAttrConsInt & other)
{
  std::swap(integer_, other.integer_);

}

BasicAttrConsInt::~BasicAttrConsInt()
{

}

void BasicAttrConsInt::accept(Visitor *v)
{
  v->visitBasicAttrConsInt(this);
}

BasicAttrConsInt *BasicAttrConsInt::clone() const
{
  return new BasicAttrConsInt(*this);
}



/********************   BasicAttrConsFloat    ********************/
BasicAttrConsFloat::BasicAttrConsFloat(Double p1)
{
  double_ = p1;

}

BasicAttrConsFloat::BasicAttrConsFloat(const BasicAttrConsFloat & other)
{
  double_ = other.double_;

}

BasicAttrConsFloat &BasicAttrConsFloat::operator=(const BasicAttrConsFloat & other)
{
  BasicAttrConsFloat tmp(other);
  swap(tmp);
  return *this;
}

void BasicAttrConsFloat::swap(BasicAttrConsFloat & other)
{
  std::swap(double_, other.double_);

}

BasicAttrConsFloat::~BasicAttrConsFloat()
{

}

void BasicAttrConsFloat::accept(Visitor *v)
{
  v->visitBasicAttrConsFloat(this);
}

BasicAttrConsFloat *BasicAttrConsFloat::clone() const
{
  return new BasicAttrConsFloat(*this);
}



/********************   AnnotatedStatement    ********************/
AnnotatedStatement::AnnotatedStatement(Statement *p1)
{
  statement_ = p1;

}

AnnotatedStatement::AnnotatedStatement(const AnnotatedStatement & other)
{
  statement_ = other.statement_->clone();

}

AnnotatedStatement &AnnotatedStatement::operator=(const AnnotatedStatement & other)
{
  AnnotatedStatement tmp(other);
  swap(tmp);
  return *this;
}

void AnnotatedStatement::swap(AnnotatedStatement & other)
{
  std::swap(statement_, other.statement_);

}

AnnotatedStatement::~AnnotatedStatement()
{
  delete(statement_);

}

void AnnotatedStatement::accept(Visitor *v)
{
  v->visitAnnotatedStatement(this);
}

AnnotatedStatement *AnnotatedStatement::clone() const
{
  return new AnnotatedStatement(*this);
}



/********************   NoElsePart    ********************/
NoElsePart::NoElsePart()
{

}

NoElsePart::NoElsePart(const NoElsePart & other)
{

}

NoElsePart &NoElsePart::operator=(const NoElsePart & other)
{
  NoElsePart tmp(other);
  swap(tmp);
  return *this;
}

void NoElsePart::swap(NoElsePart & other)
{

}

NoElsePart::~NoElsePart()
{

}

void NoElsePart::accept(Visitor *v)
{
  v->visitNoElsePart(this);
}

NoElsePart *NoElsePart::clone() const
{
  return new NoElsePart(*this);
}



/********************   SimpleElsePart    ********************/
SimpleElsePart::SimpleElsePart(AnnotatedStmt *p1)
{
  annotatedstmt_ = p1;

}

SimpleElsePart::SimpleElsePart(const SimpleElsePart & other)
{
  annotatedstmt_ = other.annotatedstmt_->clone();

}

SimpleElsePart &SimpleElsePart::operator=(const SimpleElsePart & other)
{
  SimpleElsePart tmp(other);
  swap(tmp);
  return *this;
}

void SimpleElsePart::swap(SimpleElsePart & other)
{
  std::swap(annotatedstmt_, other.annotatedstmt_);

}

SimpleElsePart::~SimpleElsePart()
{
  delete(annotatedstmt_);

}

void SimpleElsePart::accept(Visitor *v)
{
  v->visitSimpleElsePart(this);
}

SimpleElsePart *SimpleElsePart::clone() const
{
  return new SimpleElsePart(*this);
}



/********************   NoExpression    ********************/
NoExpression::NoExpression()
{

}

NoExpression::NoExpression(const NoExpression & other)
{

}

NoExpression &NoExpression::operator=(const NoExpression & other)
{
  NoExpression tmp(other);
  swap(tmp);
  return *this;
}

void NoExpression::swap(NoExpression & other)
{

}

NoExpression::~NoExpression()
{

}

void NoExpression::accept(Visitor *v)
{
  v->visitNoExpression(this);
}

NoExpression *NoExpression::clone() const
{
  return new NoExpression(*this);
}



/********************   SomeExpression    ********************/
SomeExpression::SomeExpression(ListExpression *p1)
{
  listexpression_ = p1;

}

SomeExpression::SomeExpression(const SomeExpression & other)
{
  listexpression_ = other.listexpression_->clone();

}

SomeExpression &SomeExpression::operator=(const SomeExpression & other)
{
  SomeExpression tmp(other);
  swap(tmp);
  return *this;
}

void SomeExpression::swap(SomeExpression & other)
{
  std::swap(listexpression_, other.listexpression_);

}

SomeExpression::~SomeExpression()
{
  delete(listexpression_);

}

void SomeExpression::accept(Visitor *v)
{
  v->visitSomeExpression(this);
}

SomeExpression *SomeExpression::clone() const
{
  return new SomeExpression(*this);
}



/********************   AssignmentExpr    ********************/
AssignmentExpr::AssignmentExpr(AssignExpr *p1)
{
  assignexpr_ = p1;

}

AssignmentExpr::AssignmentExpr(const AssignmentExpr & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

AssignmentExpr &AssignmentExpr::operator=(const AssignmentExpr & other)
{
  AssignmentExpr tmp(other);
  swap(tmp);
  return *this;
}

void AssignmentExpr::swap(AssignmentExpr & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

AssignmentExpr::~AssignmentExpr()
{
  delete(assignexpr_);

}

void AssignmentExpr::accept(Visitor *v)
{
  v->visitAssignmentExpr(this);
}

AssignmentExpr *AssignmentExpr::clone() const
{
  return new AssignmentExpr(*this);
}



/********************   EqAssignExpr    ********************/
EqAssignExpr::EqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

EqAssignExpr::EqAssignExpr(const EqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

EqAssignExpr &EqAssignExpr::operator=(const EqAssignExpr & other)
{
  EqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void EqAssignExpr::swap(EqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

EqAssignExpr::~EqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void EqAssignExpr::accept(Visitor *v)
{
  v->visitEqAssignExpr(this);
}

EqAssignExpr *EqAssignExpr::clone() const
{
  return new EqAssignExpr(*this);
}



/********************   PlusEqAssignExpr    ********************/
PlusEqAssignExpr::PlusEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

PlusEqAssignExpr::PlusEqAssignExpr(const PlusEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

PlusEqAssignExpr &PlusEqAssignExpr::operator=(const PlusEqAssignExpr & other)
{
  PlusEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void PlusEqAssignExpr::swap(PlusEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

PlusEqAssignExpr::~PlusEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void PlusEqAssignExpr::accept(Visitor *v)
{
  v->visitPlusEqAssignExpr(this);
}

PlusEqAssignExpr *PlusEqAssignExpr::clone() const
{
  return new PlusEqAssignExpr(*this);
}



/********************   MinusEqAssignExpr    ********************/
MinusEqAssignExpr::MinusEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MinusEqAssignExpr::MinusEqAssignExpr(const MinusEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MinusEqAssignExpr &MinusEqAssignExpr::operator=(const MinusEqAssignExpr & other)
{
  MinusEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void MinusEqAssignExpr::swap(MinusEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MinusEqAssignExpr::~MinusEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MinusEqAssignExpr::accept(Visitor *v)
{
  v->visitMinusEqAssignExpr(this);
}

MinusEqAssignExpr *MinusEqAssignExpr::clone() const
{
  return new MinusEqAssignExpr(*this);
}



/********************   MultEqAssignExpr    ********************/
MultEqAssignExpr::MultEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MultEqAssignExpr::MultEqAssignExpr(const MultEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MultEqAssignExpr &MultEqAssignExpr::operator=(const MultEqAssignExpr & other)
{
  MultEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void MultEqAssignExpr::swap(MultEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MultEqAssignExpr::~MultEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MultEqAssignExpr::accept(Visitor *v)
{
  v->visitMultEqAssignExpr(this);
}

MultEqAssignExpr *MultEqAssignExpr::clone() const
{
  return new MultEqAssignExpr(*this);
}



/********************   DivEqAssignExpr    ********************/
DivEqAssignExpr::DivEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

DivEqAssignExpr::DivEqAssignExpr(const DivEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

DivEqAssignExpr &DivEqAssignExpr::operator=(const DivEqAssignExpr & other)
{
  DivEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void DivEqAssignExpr::swap(DivEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

DivEqAssignExpr::~DivEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void DivEqAssignExpr::accept(Visitor *v)
{
  v->visitDivEqAssignExpr(this);
}

DivEqAssignExpr *DivEqAssignExpr::clone() const
{
  return new DivEqAssignExpr(*this);
}



/********************   ModEqAssignExpr    ********************/
ModEqAssignExpr::ModEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

ModEqAssignExpr::ModEqAssignExpr(const ModEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

ModEqAssignExpr &ModEqAssignExpr::operator=(const ModEqAssignExpr & other)
{
  ModEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void ModEqAssignExpr::swap(ModEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

ModEqAssignExpr::~ModEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void ModEqAssignExpr::accept(Visitor *v)
{
  v->visitModEqAssignExpr(this);
}

ModEqAssignExpr *ModEqAssignExpr::clone() const
{
  return new ModEqAssignExpr(*this);
}



/********************   AndEqAssignExpr    ********************/
AndEqAssignExpr::AndEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

AndEqAssignExpr::AndEqAssignExpr(const AndEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

AndEqAssignExpr &AndEqAssignExpr::operator=(const AndEqAssignExpr & other)
{
  AndEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void AndEqAssignExpr::swap(AndEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

AndEqAssignExpr::~AndEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void AndEqAssignExpr::accept(Visitor *v)
{
  v->visitAndEqAssignExpr(this);
}

AndEqAssignExpr *AndEqAssignExpr::clone() const
{
  return new AndEqAssignExpr(*this);
}



/********************   OrEqAssignExpr    ********************/
OrEqAssignExpr::OrEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

OrEqAssignExpr::OrEqAssignExpr(const OrEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

OrEqAssignExpr &OrEqAssignExpr::operator=(const OrEqAssignExpr & other)
{
  OrEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void OrEqAssignExpr::swap(OrEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

OrEqAssignExpr::~OrEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void OrEqAssignExpr::accept(Visitor *v)
{
  v->visitOrEqAssignExpr(this);
}

OrEqAssignExpr *OrEqAssignExpr::clone() const
{
  return new OrEqAssignExpr(*this);
}



/********************   XorEqAssignExpr    ********************/
XorEqAssignExpr::XorEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

XorEqAssignExpr::XorEqAssignExpr(const XorEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

XorEqAssignExpr &XorEqAssignExpr::operator=(const XorEqAssignExpr & other)
{
  XorEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void XorEqAssignExpr::swap(XorEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

XorEqAssignExpr::~XorEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void XorEqAssignExpr::accept(Visitor *v)
{
  v->visitXorEqAssignExpr(this);
}

XorEqAssignExpr *XorEqAssignExpr::clone() const
{
  return new XorEqAssignExpr(*this);
}



/********************   LeftShiftEqAssignExpr    ********************/
LeftShiftEqAssignExpr::LeftShiftEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LeftShiftEqAssignExpr::LeftShiftEqAssignExpr(const LeftShiftEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LeftShiftEqAssignExpr &LeftShiftEqAssignExpr::operator=(const LeftShiftEqAssignExpr & other)
{
  LeftShiftEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftEqAssignExpr::swap(LeftShiftEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LeftShiftEqAssignExpr::~LeftShiftEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LeftShiftEqAssignExpr::accept(Visitor *v)
{
  v->visitLeftShiftEqAssignExpr(this);
}

LeftShiftEqAssignExpr *LeftShiftEqAssignExpr::clone() const
{
  return new LeftShiftEqAssignExpr(*this);
}



/********************   RightShiftEqAssignExpr    ********************/
RightShiftEqAssignExpr::RightShiftEqAssignExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

RightShiftEqAssignExpr::RightShiftEqAssignExpr(const RightShiftEqAssignExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

RightShiftEqAssignExpr &RightShiftEqAssignExpr::operator=(const RightShiftEqAssignExpr & other)
{
  RightShiftEqAssignExpr tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftEqAssignExpr::swap(RightShiftEqAssignExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

RightShiftEqAssignExpr::~RightShiftEqAssignExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void RightShiftEqAssignExpr::accept(Visitor *v)
{
  v->visitRightShiftEqAssignExpr(this);
}

RightShiftEqAssignExpr *RightShiftEqAssignExpr::clone() const
{
  return new RightShiftEqAssignExpr(*this);
}



/********************   TernaryCondExpr    ********************/
TernaryCondExpr::TernaryCondExpr(AssignExpr *p1, OptExpression *p2, AssignExpr *p3)
{
  assignexpr_1 = p1;
  optexpression_ = p2;
  assignexpr_2 = p3;

}

TernaryCondExpr::TernaryCondExpr(const TernaryCondExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  optexpression_ = other.optexpression_->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

TernaryCondExpr &TernaryCondExpr::operator=(const TernaryCondExpr & other)
{
  TernaryCondExpr tmp(other);
  swap(tmp);
  return *this;
}

void TernaryCondExpr::swap(TernaryCondExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(optexpression_, other.optexpression_);
  std::swap(assignexpr_2, other.assignexpr_2);

}

TernaryCondExpr::~TernaryCondExpr()
{
  delete(assignexpr_1);
  delete(optexpression_);
  delete(assignexpr_2);

}

void TernaryCondExpr::accept(Visitor *v)
{
  v->visitTernaryCondExpr(this);
}

TernaryCondExpr *TernaryCondExpr::clone() const
{
  return new TernaryCondExpr(*this);
}



/********************   OrExpr    ********************/
OrExpr::OrExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

OrExpr::OrExpr(const OrExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

OrExpr &OrExpr::operator=(const OrExpr & other)
{
  OrExpr tmp(other);
  swap(tmp);
  return *this;
}

void OrExpr::swap(OrExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

OrExpr::~OrExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void OrExpr::accept(Visitor *v)
{
  v->visitOrExpr(this);
}

OrExpr *OrExpr::clone() const
{
  return new OrExpr(*this);
}



/********************   AndExpr    ********************/
AndExpr::AndExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

AndExpr::AndExpr(const AndExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

AndExpr &AndExpr::operator=(const AndExpr & other)
{
  AndExpr tmp(other);
  swap(tmp);
  return *this;
}

void AndExpr::swap(AndExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

AndExpr::~AndExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void AndExpr::accept(Visitor *v)
{
  v->visitAndExpr(this);
}

AndExpr *AndExpr::clone() const
{
  return new AndExpr(*this);
}



/********************   BitOrExpr    ********************/
BitOrExpr::BitOrExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

BitOrExpr::BitOrExpr(const BitOrExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

BitOrExpr &BitOrExpr::operator=(const BitOrExpr & other)
{
  BitOrExpr tmp(other);
  swap(tmp);
  return *this;
}

void BitOrExpr::swap(BitOrExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

BitOrExpr::~BitOrExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void BitOrExpr::accept(Visitor *v)
{
  v->visitBitOrExpr(this);
}

BitOrExpr *BitOrExpr::clone() const
{
  return new BitOrExpr(*this);
}



/********************   BitXorExpr    ********************/
BitXorExpr::BitXorExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

BitXorExpr::BitXorExpr(const BitXorExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

BitXorExpr &BitXorExpr::operator=(const BitXorExpr & other)
{
  BitXorExpr tmp(other);
  swap(tmp);
  return *this;
}

void BitXorExpr::swap(BitXorExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

BitXorExpr::~BitXorExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void BitXorExpr::accept(Visitor *v)
{
  v->visitBitXorExpr(this);
}

BitXorExpr *BitXorExpr::clone() const
{
  return new BitXorExpr(*this);
}



/********************   BitAndExpr    ********************/
BitAndExpr::BitAndExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

BitAndExpr::BitAndExpr(const BitAndExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

BitAndExpr &BitAndExpr::operator=(const BitAndExpr & other)
{
  BitAndExpr tmp(other);
  swap(tmp);
  return *this;
}

void BitAndExpr::swap(BitAndExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

BitAndExpr::~BitAndExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void BitAndExpr::accept(Visitor *v)
{
  v->visitBitAndExpr(this);
}

BitAndExpr *BitAndExpr::clone() const
{
  return new BitAndExpr(*this);
}



/********************   EqExpr    ********************/
EqExpr::EqExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

EqExpr::EqExpr(const EqExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

EqExpr &EqExpr::operator=(const EqExpr & other)
{
  EqExpr tmp(other);
  swap(tmp);
  return *this;
}

void EqExpr::swap(EqExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

EqExpr::~EqExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void EqExpr::accept(Visitor *v)
{
  v->visitEqExpr(this);
}

EqExpr *EqExpr::clone() const
{
  return new EqExpr(*this);
}



/********************   NotEqExpr    ********************/
NotEqExpr::NotEqExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

NotEqExpr::NotEqExpr(const NotEqExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

NotEqExpr &NotEqExpr::operator=(const NotEqExpr & other)
{
  NotEqExpr tmp(other);
  swap(tmp);
  return *this;
}

void NotEqExpr::swap(NotEqExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

NotEqExpr::~NotEqExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void NotEqExpr::accept(Visitor *v)
{
  v->visitNotEqExpr(this);
}

NotEqExpr *NotEqExpr::clone() const
{
  return new NotEqExpr(*this);
}



/********************   LessExpr    ********************/
LessExpr::LessExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LessExpr::LessExpr(const LessExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LessExpr &LessExpr::operator=(const LessExpr & other)
{
  LessExpr tmp(other);
  swap(tmp);
  return *this;
}

void LessExpr::swap(LessExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LessExpr::~LessExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LessExpr::accept(Visitor *v)
{
  v->visitLessExpr(this);
}

LessExpr *LessExpr::clone() const
{
  return new LessExpr(*this);
}



/********************   GreaterExpr    ********************/
GreaterExpr::GreaterExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

GreaterExpr::GreaterExpr(const GreaterExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

GreaterExpr &GreaterExpr::operator=(const GreaterExpr & other)
{
  GreaterExpr tmp(other);
  swap(tmp);
  return *this;
}

void GreaterExpr::swap(GreaterExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

GreaterExpr::~GreaterExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void GreaterExpr::accept(Visitor *v)
{
  v->visitGreaterExpr(this);
}

GreaterExpr *GreaterExpr::clone() const
{
  return new GreaterExpr(*this);
}



/********************   LessEqualExpr    ********************/
LessEqualExpr::LessEqualExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LessEqualExpr::LessEqualExpr(const LessEqualExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LessEqualExpr &LessEqualExpr::operator=(const LessEqualExpr & other)
{
  LessEqualExpr tmp(other);
  swap(tmp);
  return *this;
}

void LessEqualExpr::swap(LessEqualExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LessEqualExpr::~LessEqualExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LessEqualExpr::accept(Visitor *v)
{
  v->visitLessEqualExpr(this);
}

LessEqualExpr *LessEqualExpr::clone() const
{
  return new LessEqualExpr(*this);
}



/********************   GreaterEqualExpr    ********************/
GreaterEqualExpr::GreaterEqualExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

GreaterEqualExpr::GreaterEqualExpr(const GreaterEqualExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

GreaterEqualExpr &GreaterEqualExpr::operator=(const GreaterEqualExpr & other)
{
  GreaterEqualExpr tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqualExpr::swap(GreaterEqualExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

GreaterEqualExpr::~GreaterEqualExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void GreaterEqualExpr::accept(Visitor *v)
{
  v->visitGreaterEqualExpr(this);
}

GreaterEqualExpr *GreaterEqualExpr::clone() const
{
  return new GreaterEqualExpr(*this);
}



/********************   LeftShiftExpr    ********************/
LeftShiftExpr::LeftShiftExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

LeftShiftExpr::LeftShiftExpr(const LeftShiftExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

LeftShiftExpr &LeftShiftExpr::operator=(const LeftShiftExpr & other)
{
  LeftShiftExpr tmp(other);
  swap(tmp);
  return *this;
}

void LeftShiftExpr::swap(LeftShiftExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

LeftShiftExpr::~LeftShiftExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void LeftShiftExpr::accept(Visitor *v)
{
  v->visitLeftShiftExpr(this);
}

LeftShiftExpr *LeftShiftExpr::clone() const
{
  return new LeftShiftExpr(*this);
}



/********************   RightShiftExpr    ********************/
RightShiftExpr::RightShiftExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

RightShiftExpr::RightShiftExpr(const RightShiftExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

RightShiftExpr &RightShiftExpr::operator=(const RightShiftExpr & other)
{
  RightShiftExpr tmp(other);
  swap(tmp);
  return *this;
}

void RightShiftExpr::swap(RightShiftExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

RightShiftExpr::~RightShiftExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void RightShiftExpr::accept(Visitor *v)
{
  v->visitRightShiftExpr(this);
}

RightShiftExpr *RightShiftExpr::clone() const
{
  return new RightShiftExpr(*this);
}



/********************   PlusExpr    ********************/
PlusExpr::PlusExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

PlusExpr::PlusExpr(const PlusExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

PlusExpr &PlusExpr::operator=(const PlusExpr & other)
{
  PlusExpr tmp(other);
  swap(tmp);
  return *this;
}

void PlusExpr::swap(PlusExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

PlusExpr::~PlusExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void PlusExpr::accept(Visitor *v)
{
  v->visitPlusExpr(this);
}

PlusExpr *PlusExpr::clone() const
{
  return new PlusExpr(*this);
}



/********************   MinusExpr    ********************/
MinusExpr::MinusExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MinusExpr::MinusExpr(const MinusExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MinusExpr &MinusExpr::operator=(const MinusExpr & other)
{
  MinusExpr tmp(other);
  swap(tmp);
  return *this;
}

void MinusExpr::swap(MinusExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MinusExpr::~MinusExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MinusExpr::accept(Visitor *v)
{
  v->visitMinusExpr(this);
}

MinusExpr *MinusExpr::clone() const
{
  return new MinusExpr(*this);
}



/********************   MulsExpr    ********************/
MulsExpr::MulsExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

MulsExpr::MulsExpr(const MulsExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

MulsExpr &MulsExpr::operator=(const MulsExpr & other)
{
  MulsExpr tmp(other);
  swap(tmp);
  return *this;
}

void MulsExpr::swap(MulsExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

MulsExpr::~MulsExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void MulsExpr::accept(Visitor *v)
{
  v->visitMulsExpr(this);
}

MulsExpr *MulsExpr::clone() const
{
  return new MulsExpr(*this);
}



/********************   DivExpr    ********************/
DivExpr::DivExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

DivExpr::DivExpr(const DivExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

DivExpr &DivExpr::operator=(const DivExpr & other)
{
  DivExpr tmp(other);
  swap(tmp);
  return *this;
}

void DivExpr::swap(DivExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

DivExpr::~DivExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void DivExpr::accept(Visitor *v)
{
  v->visitDivExpr(this);
}

DivExpr *DivExpr::clone() const
{
  return new DivExpr(*this);
}



/********************   ModExpr    ********************/
ModExpr::ModExpr(AssignExpr *p1, AssignExpr *p2)
{
  assignexpr_1 = p1;
  assignexpr_2 = p2;

}

ModExpr::ModExpr(const ModExpr & other)
{
  assignexpr_1 = other.assignexpr_1->clone();
  assignexpr_2 = other.assignexpr_2->clone();

}

ModExpr &ModExpr::operator=(const ModExpr & other)
{
  ModExpr tmp(other);
  swap(tmp);
  return *this;
}

void ModExpr::swap(ModExpr & other)
{
  std::swap(assignexpr_1, other.assignexpr_1);
  std::swap(assignexpr_2, other.assignexpr_2);

}

ModExpr::~ModExpr()
{
  delete(assignexpr_1);
  delete(assignexpr_2);

}

void ModExpr::accept(Visitor *v)
{
  v->visitModExpr(this);
}

ModExpr *ModExpr::clone() const
{
  return new ModExpr(*this);
}



/********************   CastExpr    ********************/
CastExpr::CastExpr(TypeName *p1, AssignExpr *p2)
{
  typename_ = p1;
  assignexpr_ = p2;

}

CastExpr::CastExpr(const CastExpr & other)
{
  typename_ = other.typename_->clone();
  assignexpr_ = other.assignexpr_->clone();

}

CastExpr &CastExpr::operator=(const CastExpr & other)
{
  CastExpr tmp(other);
  swap(tmp);
  return *this;
}

void CastExpr::swap(CastExpr & other)
{
  std::swap(typename_, other.typename_);
  std::swap(assignexpr_, other.assignexpr_);

}

CastExpr::~CastExpr()
{
  delete(typename_);
  delete(assignexpr_);

}

void CastExpr::accept(Visitor *v)
{
  v->visitCastExpr(this);
}

CastExpr *CastExpr::clone() const
{
  return new CastExpr(*this);
}



/********************   UnaryExprPlusPlus    ********************/
UnaryExprPlusPlus::UnaryExprPlusPlus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprPlusPlus::UnaryExprPlusPlus(const UnaryExprPlusPlus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprPlusPlus &UnaryExprPlusPlus::operator=(const UnaryExprPlusPlus & other)
{
  UnaryExprPlusPlus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprPlusPlus::swap(UnaryExprPlusPlus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprPlusPlus::~UnaryExprPlusPlus()
{
  delete(assignexpr_);

}

void UnaryExprPlusPlus::accept(Visitor *v)
{
  v->visitUnaryExprPlusPlus(this);
}

UnaryExprPlusPlus *UnaryExprPlusPlus::clone() const
{
  return new UnaryExprPlusPlus(*this);
}



/********************   UnaryExprMinusMinus    ********************/
UnaryExprMinusMinus::UnaryExprMinusMinus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprMinusMinus::UnaryExprMinusMinus(const UnaryExprMinusMinus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprMinusMinus &UnaryExprMinusMinus::operator=(const UnaryExprMinusMinus & other)
{
  UnaryExprMinusMinus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprMinusMinus::swap(UnaryExprMinusMinus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprMinusMinus::~UnaryExprMinusMinus()
{
  delete(assignexpr_);

}

void UnaryExprMinusMinus::accept(Visitor *v)
{
  v->visitUnaryExprMinusMinus(this);
}

UnaryExprMinusMinus *UnaryExprMinusMinus::clone() const
{
  return new UnaryExprMinusMinus(*this);
}



/********************   UnaryExprPlus    ********************/
UnaryExprPlus::UnaryExprPlus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprPlus::UnaryExprPlus(const UnaryExprPlus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprPlus &UnaryExprPlus::operator=(const UnaryExprPlus & other)
{
  UnaryExprPlus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprPlus::swap(UnaryExprPlus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprPlus::~UnaryExprPlus()
{
  delete(assignexpr_);

}

void UnaryExprPlus::accept(Visitor *v)
{
  v->visitUnaryExprPlus(this);
}

UnaryExprPlus *UnaryExprPlus::clone() const
{
  return new UnaryExprPlus(*this);
}



/********************   UnaryExprMinus    ********************/
UnaryExprMinus::UnaryExprMinus(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprMinus::UnaryExprMinus(const UnaryExprMinus & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprMinus &UnaryExprMinus::operator=(const UnaryExprMinus & other)
{
  UnaryExprMinus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprMinus::swap(UnaryExprMinus & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprMinus::~UnaryExprMinus()
{
  delete(assignexpr_);

}

void UnaryExprMinus::accept(Visitor *v)
{
  v->visitUnaryExprMinus(this);
}

UnaryExprMinus *UnaryExprMinus::clone() const
{
  return new UnaryExprMinus(*this);
}



/********************   UnaryExprMult    ********************/
UnaryExprMult::UnaryExprMult(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprMult::UnaryExprMult(const UnaryExprMult & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprMult &UnaryExprMult::operator=(const UnaryExprMult & other)
{
  UnaryExprMult tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprMult::swap(UnaryExprMult & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprMult::~UnaryExprMult()
{
  delete(assignexpr_);

}

void UnaryExprMult::accept(Visitor *v)
{
  v->visitUnaryExprMult(this);
}

UnaryExprMult *UnaryExprMult::clone() const
{
  return new UnaryExprMult(*this);
}



/********************   UnaryExprAmp    ********************/
UnaryExprAmp::UnaryExprAmp(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprAmp::UnaryExprAmp(const UnaryExprAmp & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprAmp &UnaryExprAmp::operator=(const UnaryExprAmp & other)
{
  UnaryExprAmp tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprAmp::swap(UnaryExprAmp & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprAmp::~UnaryExprAmp()
{
  delete(assignexpr_);

}

void UnaryExprAmp::accept(Visitor *v)
{
  v->visitUnaryExprAmp(this);
}

UnaryExprAmp *UnaryExprAmp::clone() const
{
  return new UnaryExprAmp(*this);
}



/********************   UnaryExprNot    ********************/
UnaryExprNot::UnaryExprNot(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprNot::UnaryExprNot(const UnaryExprNot & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprNot &UnaryExprNot::operator=(const UnaryExprNot & other)
{
  UnaryExprNot tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprNot::swap(UnaryExprNot & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprNot::~UnaryExprNot()
{
  delete(assignexpr_);

}

void UnaryExprNot::accept(Visitor *v)
{
  v->visitUnaryExprNot(this);
}

UnaryExprNot *UnaryExprNot::clone() const
{
  return new UnaryExprNot(*this);
}



/********************   UnaryExprTilde    ********************/
UnaryExprTilde::UnaryExprTilde(AssignExpr *p1)
{
  assignexpr_ = p1;

}

UnaryExprTilde::UnaryExprTilde(const UnaryExprTilde & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

UnaryExprTilde &UnaryExprTilde::operator=(const UnaryExprTilde & other)
{
  UnaryExprTilde tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprTilde::swap(UnaryExprTilde & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

UnaryExprTilde::~UnaryExprTilde()
{
  delete(assignexpr_);

}

void UnaryExprTilde::accept(Visitor *v)
{
  v->visitUnaryExprTilde(this);
}

UnaryExprTilde *UnaryExprTilde::clone() const
{
  return new UnaryExprTilde(*this);
}



/********************   UnaryExprAddress    ********************/
UnaryExprAddress::UnaryExprAddress(IdOrTypenameAsId *p1)
{
  idortypenameasid_ = p1;

}

UnaryExprAddress::UnaryExprAddress(const UnaryExprAddress & other)
{
  idortypenameasid_ = other.idortypenameasid_->clone();

}

UnaryExprAddress &UnaryExprAddress::operator=(const UnaryExprAddress & other)
{
  UnaryExprAddress tmp(other);
  swap(tmp);
  return *this;
}

void UnaryExprAddress::swap(UnaryExprAddress & other)
{
  std::swap(idortypenameasid_, other.idortypenameasid_);

}

UnaryExprAddress::~UnaryExprAddress()
{
  delete(idortypenameasid_);

}

void UnaryExprAddress::accept(Visitor *v)
{
  v->visitUnaryExprAddress(this);
}

UnaryExprAddress *UnaryExprAddress::clone() const
{
  return new UnaryExprAddress(*this);
}



/********************   BracketsPostfixExpression    ********************/
BracketsPostfixExpression::BracketsPostfixExpression(AssignExpr *p1, ListExpression *p2)
{
  assignexpr_ = p1;
  listexpression_ = p2;

}

BracketsPostfixExpression::BracketsPostfixExpression(const BracketsPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  listexpression_ = other.listexpression_->clone();

}

BracketsPostfixExpression &BracketsPostfixExpression::operator=(const BracketsPostfixExpression & other)
{
  BracketsPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void BracketsPostfixExpression::swap(BracketsPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(listexpression_, other.listexpression_);

}

BracketsPostfixExpression::~BracketsPostfixExpression()
{
  delete(assignexpr_);
  delete(listexpression_);

}

void BracketsPostfixExpression::accept(Visitor *v)
{
  v->visitBracketsPostfixExpression(this);
}

BracketsPostfixExpression *BracketsPostfixExpression::clone() const
{
  return new BracketsPostfixExpression(*this);
}



/********************   DotPostfixExpression    ********************/
DotPostfixExpression::DotPostfixExpression(AssignExpr *p1, IdOrTypename *p2)
{
  assignexpr_ = p1;
  idortypename_ = p2;

}

DotPostfixExpression::DotPostfixExpression(const DotPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  idortypename_ = other.idortypename_->clone();

}

DotPostfixExpression &DotPostfixExpression::operator=(const DotPostfixExpression & other)
{
  DotPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void DotPostfixExpression::swap(DotPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(idortypename_, other.idortypename_);

}

DotPostfixExpression::~DotPostfixExpression()
{
  delete(assignexpr_);
  delete(idortypename_);

}

void DotPostfixExpression::accept(Visitor *v)
{
  v->visitDotPostfixExpression(this);
}

DotPostfixExpression *DotPostfixExpression::clone() const
{
  return new DotPostfixExpression(*this);
}



/********************   ArrowPostfixExpression    ********************/
ArrowPostfixExpression::ArrowPostfixExpression(AssignExpr *p1, IdOrTypename *p2)
{
  assignexpr_ = p1;
  idortypename_ = p2;

}

ArrowPostfixExpression::ArrowPostfixExpression(const ArrowPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();
  idortypename_ = other.idortypename_->clone();

}

ArrowPostfixExpression &ArrowPostfixExpression::operator=(const ArrowPostfixExpression & other)
{
  ArrowPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void ArrowPostfixExpression::swap(ArrowPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);
  std::swap(idortypename_, other.idortypename_);

}

ArrowPostfixExpression::~ArrowPostfixExpression()
{
  delete(assignexpr_);
  delete(idortypename_);

}

void ArrowPostfixExpression::accept(Visitor *v)
{
  v->visitArrowPostfixExpression(this);
}

ArrowPostfixExpression *ArrowPostfixExpression::clone() const
{
  return new ArrowPostfixExpression(*this);
}



/********************   PlusPlusPostfixExpression    ********************/
PlusPlusPostfixExpression::PlusPlusPostfixExpression(AssignExpr *p1)
{
  assignexpr_ = p1;

}

PlusPlusPostfixExpression::PlusPlusPostfixExpression(const PlusPlusPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

PlusPlusPostfixExpression &PlusPlusPostfixExpression::operator=(const PlusPlusPostfixExpression & other)
{
  PlusPlusPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void PlusPlusPostfixExpression::swap(PlusPlusPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

PlusPlusPostfixExpression::~PlusPlusPostfixExpression()
{
  delete(assignexpr_);

}

void PlusPlusPostfixExpression::accept(Visitor *v)
{
  v->visitPlusPlusPostfixExpression(this);
}

PlusPlusPostfixExpression *PlusPlusPostfixExpression::clone() const
{
  return new PlusPlusPostfixExpression(*this);
}



/********************   MinusMinusPostfixExpression    ********************/
MinusMinusPostfixExpression::MinusMinusPostfixExpression(AssignExpr *p1)
{
  assignexpr_ = p1;

}

MinusMinusPostfixExpression::MinusMinusPostfixExpression(const MinusMinusPostfixExpression & other)
{
  assignexpr_ = other.assignexpr_->clone();

}

MinusMinusPostfixExpression &MinusMinusPostfixExpression::operator=(const MinusMinusPostfixExpression & other)
{
  MinusMinusPostfixExpression tmp(other);
  swap(tmp);
  return *this;
}

void MinusMinusPostfixExpression::swap(MinusMinusPostfixExpression & other)
{
  std::swap(assignexpr_, other.assignexpr_);

}

MinusMinusPostfixExpression::~MinusMinusPostfixExpression()
{
  delete(assignexpr_);

}

void MinusMinusPostfixExpression::accept(Visitor *v)
{
  v->visitMinusMinusPostfixExpression(this);
}

MinusMinusPostfixExpression *MinusMinusPostfixExpression::clone() const
{
  return new MinusMinusPostfixExpression(*this);
}



/********************   IdentifierPrimaryExpression    ********************/
IdentifierPrimaryExpression::IdentifierPrimaryExpression(Ident p1)
{
  ident_ = p1;

}

IdentifierPrimaryExpression::IdentifierPrimaryExpression(const IdentifierPrimaryExpression & other)
{
  ident_ = other.ident_;

}

IdentifierPrimaryExpression &IdentifierPrimaryExpression::operator=(const IdentifierPrimaryExpression & other)
{
  IdentifierPrimaryExpression tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierPrimaryExpression::swap(IdentifierPrimaryExpression & other)
{
  std::swap(ident_, other.ident_);

}

IdentifierPrimaryExpression::~IdentifierPrimaryExpression()
{

}

void IdentifierPrimaryExpression::accept(Visitor *v)
{
  v->visitIdentifierPrimaryExpression(this);
}

IdentifierPrimaryExpression *IdentifierPrimaryExpression::clone() const
{
  return new IdentifierPrimaryExpression(*this);
}



/********************   ConstantPrimaryExpressin    ********************/
ConstantPrimaryExpressin::ConstantPrimaryExpressin(Constant *p1)
{
  constant_ = p1;

}

ConstantPrimaryExpressin::ConstantPrimaryExpressin(const ConstantPrimaryExpressin & other)
{
  constant_ = other.constant_->clone();

}

ConstantPrimaryExpressin &ConstantPrimaryExpressin::operator=(const ConstantPrimaryExpressin & other)
{
  ConstantPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void ConstantPrimaryExpressin::swap(ConstantPrimaryExpressin & other)
{
  std::swap(constant_, other.constant_);

}

ConstantPrimaryExpressin::~ConstantPrimaryExpressin()
{
  delete(constant_);

}

void ConstantPrimaryExpressin::accept(Visitor *v)
{
  v->visitConstantPrimaryExpressin(this);
}

ConstantPrimaryExpressin *ConstantPrimaryExpressin::clone() const
{
  return new ConstantPrimaryExpressin(*this);
}



/********************   CommaExpressionPrimaryExpressin    ********************/
CommaExpressionPrimaryExpressin::CommaExpressionPrimaryExpressin(ListExpression *p1)
{
  listexpression_ = p1;

}

CommaExpressionPrimaryExpressin::CommaExpressionPrimaryExpressin(const CommaExpressionPrimaryExpressin & other)
{
  listexpression_ = other.listexpression_->clone();

}

CommaExpressionPrimaryExpressin &CommaExpressionPrimaryExpressin::operator=(const CommaExpressionPrimaryExpressin & other)
{
  CommaExpressionPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void CommaExpressionPrimaryExpressin::swap(CommaExpressionPrimaryExpressin & other)
{
  std::swap(listexpression_, other.listexpression_);

}

CommaExpressionPrimaryExpressin::~CommaExpressionPrimaryExpressin()
{
  delete(listexpression_);

}

void CommaExpressionPrimaryExpressin::accept(Visitor *v)
{
  v->visitCommaExpressionPrimaryExpressin(this);
}

CommaExpressionPrimaryExpressin *CommaExpressionPrimaryExpressin::clone() const
{
  return new CommaExpressionPrimaryExpressin(*this);
}



/********************   BlockPrimaryExpressin    ********************/
BlockPrimaryExpressin::BlockPrimaryExpressin(Block *p1)
{
  block_ = p1;

}

BlockPrimaryExpressin::BlockPrimaryExpressin(const BlockPrimaryExpressin & other)
{
  block_ = other.block_->clone();

}

BlockPrimaryExpressin &BlockPrimaryExpressin::operator=(const BlockPrimaryExpressin & other)
{
  BlockPrimaryExpressin tmp(other);
  swap(tmp);
  return *this;
}

void BlockPrimaryExpressin::swap(BlockPrimaryExpressin & other)
{
  std::swap(block_, other.block_);

}

BlockPrimaryExpressin::~BlockPrimaryExpressin()
{
  delete(block_);

}

void BlockPrimaryExpressin::accept(Visitor *v)
{
  v->visitBlockPrimaryExpressin(this);
}

BlockPrimaryExpressin *BlockPrimaryExpressin::clone() const
{
  return new BlockPrimaryExpressin(*this);
}



/********************   ConstantInt    ********************/
ConstantInt::ConstantInt(Integer p1)
{
  integer_ = p1;

}

ConstantInt::ConstantInt(const ConstantInt & other)
{
  integer_ = other.integer_;

}

ConstantInt &ConstantInt::operator=(const ConstantInt & other)
{
  ConstantInt tmp(other);
  swap(tmp);
  return *this;
}

void ConstantInt::swap(ConstantInt & other)
{
  std::swap(integer_, other.integer_);

}

ConstantInt::~ConstantInt()
{

}

void ConstantInt::accept(Visitor *v)
{
  v->visitConstantInt(this);
}

ConstantInt *ConstantInt::clone() const
{
  return new ConstantInt(*this);
}



/********************   ConstantFloat    ********************/
ConstantFloat::ConstantFloat(Double p1)
{
  double_ = p1;

}

ConstantFloat::ConstantFloat(const ConstantFloat & other)
{
  double_ = other.double_;

}

ConstantFloat &ConstantFloat::operator=(const ConstantFloat & other)
{
  ConstantFloat tmp(other);
  swap(tmp);
  return *this;
}

void ConstantFloat::swap(ConstantFloat & other)
{
  std::swap(double_, other.double_);

}

ConstantFloat::~ConstantFloat()
{

}

void ConstantFloat::accept(Visitor *v)
{
  v->visitConstantFloat(this);
}

ConstantFloat *ConstantFloat::clone() const
{
  return new ConstantFloat(*this);
}



/********************   ConstantChar    ********************/
ConstantChar::ConstantChar(Char p1)
{
  char_ = p1;

}

ConstantChar::ConstantChar(const ConstantChar & other)
{
  char_ = other.char_;

}

ConstantChar &ConstantChar::operator=(const ConstantChar & other)
{
  ConstantChar tmp(other);
  swap(tmp);
  return *this;
}

void ConstantChar::swap(ConstantChar & other)
{
  std::swap(char_, other.char_);

}

ConstantChar::~ConstantChar()
{

}

void ConstantChar::accept(Visitor *v)
{
  v->visitConstantChar(this);
}

ConstantChar *ConstantChar::clone() const
{
  return new ConstantChar(*this);
}



/********************   TypeNameDeclSpecList    ********************/
TypeNameDeclSpecList::TypeNameDeclSpecList(DeclSpecList *p1)
{
  declspeclist_ = p1;

}

TypeNameDeclSpecList::TypeNameDeclSpecList(const TypeNameDeclSpecList & other)
{
  declspeclist_ = other.declspeclist_->clone();

}

TypeNameDeclSpecList &TypeNameDeclSpecList::operator=(const TypeNameDeclSpecList & other)
{
  TypeNameDeclSpecList tmp(other);
  swap(tmp);
  return *this;
}

void TypeNameDeclSpecList::swap(TypeNameDeclSpecList & other)
{
  std::swap(declspeclist_, other.declspeclist_);

}

TypeNameDeclSpecList::~TypeNameDeclSpecList()
{
  delete(declspeclist_);

}

void TypeNameDeclSpecList::accept(Visitor *v)
{
  v->visitTypeNameDeclSpecList(this);
}

TypeNameDeclSpecList *TypeNameDeclSpecList::clone() const
{
  return new TypeNameDeclSpecList(*this);
}



/********************   AnnotProgram    ********************/
AnnotProgram::AnnotProgram(Annot *p1)
{
  annot_ = p1;

}

AnnotProgram::AnnotProgram(const AnnotProgram & other)
{
  annot_ = other.annot_->clone();

}

AnnotProgram &AnnotProgram::operator=(const AnnotProgram & other)
{
  AnnotProgram tmp(other);
  swap(tmp);
  return *this;
}

void AnnotProgram::swap(AnnotProgram & other)
{
  std::swap(annot_, other.annot_);

}

AnnotProgram::~AnnotProgram()
{
  delete(annot_);

}

void AnnotProgram::accept(Visitor *v)
{
  v->visitAnnotProgram(this);
}

AnnotProgram *AnnotProgram::clone() const
{
  return new AnnotProgram(*this);
}



/********************   AnnotationProgram    ********************/
AnnotationProgram::AnnotationProgram(LogicPTreeAnnot *p1)
{
  logicptreeannot_ = p1;

}

AnnotationProgram::AnnotationProgram(const AnnotationProgram & other)
{
  logicptreeannot_ = other.logicptreeannot_->clone();

}

AnnotationProgram &AnnotationProgram::operator=(const AnnotationProgram & other)
{
  AnnotationProgram tmp(other);
  swap(tmp);
  return *this;
}

void AnnotationProgram::swap(AnnotationProgram & other)
{
  std::swap(logicptreeannot_, other.logicptreeannot_);

}

AnnotationProgram::~AnnotationProgram()
{
  delete(logicptreeannot_);

}

void AnnotationProgram::accept(Visitor *v)
{
  v->visitAnnotationProgram(this);
}

AnnotationProgram *AnnotationProgram::clone() const
{
  return new AnnotationProgram(*this);
}



/********************   CodeAnnot    ********************/
CodeAnnot::CodeAnnot(Code_Annot *p1)
{
  code_annot_ = p1;

}

CodeAnnot::CodeAnnot(const CodeAnnot & other)
{
  code_annot_ = other.code_annot_->clone();

}

CodeAnnot &CodeAnnot::operator=(const CodeAnnot & other)
{
  CodeAnnot tmp(other);
  swap(tmp);
  return *this;
}

void CodeAnnot::swap(CodeAnnot & other)
{
  std::swap(code_annot_, other.code_annot_);

}

CodeAnnot::~CodeAnnot()
{
  delete(code_annot_);

}

void CodeAnnot::accept(Visitor *v)
{
  v->visitCodeAnnot(this);
}

CodeAnnot *CodeAnnot::clone() const
{
  return new CodeAnnot(*this);
}



/********************   CodeAnnotContract    ********************/
CodeAnnotContract::CodeAnnotContract(Contract *p1)
{
  contract_ = p1;

}

CodeAnnotContract::CodeAnnotContract(const CodeAnnotContract & other)
{
  contract_ = other.contract_->clone();

}

CodeAnnotContract &CodeAnnotContract::operator=(const CodeAnnotContract & other)
{
  CodeAnnotContract tmp(other);
  swap(tmp);
  return *this;
}

void CodeAnnotContract::swap(CodeAnnotContract & other)
{
  std::swap(contract_, other.contract_);

}

CodeAnnotContract::~CodeAnnotContract()
{
  delete(contract_);

}

void CodeAnnotContract::accept(Visitor *v)
{
  v->visitCodeAnnotContract(this);
}

CodeAnnotContract *CodeAnnotContract::clone() const
{
  return new CodeAnnotContract(*this);
}



/********************   SimpleContract    ********************/
SimpleContract::SimpleContract(Requires *p1, Terminates *p2, Decreases *p3, SimpleClauses *p4, Behaviors *p5, CompleteOrDisjoint *p6)
{
  requires_ = p1;
  terminates_ = p2;
  decreases_ = p3;
  simpleclauses_ = p4;
  behaviors_ = p5;
  completeordisjoint_ = p6;

}

SimpleContract::SimpleContract(const SimpleContract & other)
{
  requires_ = other.requires_->clone();
  terminates_ = other.terminates_->clone();
  decreases_ = other.decreases_->clone();
  simpleclauses_ = other.simpleclauses_->clone();
  behaviors_ = other.behaviors_->clone();
  completeordisjoint_ = other.completeordisjoint_->clone();

}

SimpleContract &SimpleContract::operator=(const SimpleContract & other)
{
  SimpleContract tmp(other);
  swap(tmp);
  return *this;
}

void SimpleContract::swap(SimpleContract & other)
{
  std::swap(requires_, other.requires_);
  std::swap(terminates_, other.terminates_);
  std::swap(decreases_, other.decreases_);
  std::swap(simpleclauses_, other.simpleclauses_);
  std::swap(behaviors_, other.behaviors_);
  std::swap(completeordisjoint_, other.completeordisjoint_);

}

SimpleContract::~SimpleContract()
{
  delete(requires_);
  delete(terminates_);
  delete(decreases_);
  delete(simpleclauses_);
  delete(behaviors_);
  delete(completeordisjoint_);

}

void SimpleContract::accept(Visitor *v)
{
  v->visitSimpleContract(this);
}

SimpleContract *SimpleContract::clone() const
{
  return new SimpleContract(*this);
}



/********************   NoRequires    ********************/
NoRequires::NoRequires()
{

}

NoRequires::NoRequires(const NoRequires & other)
{

}

NoRequires &NoRequires::operator=(const NoRequires & other)
{
  NoRequires tmp(other);
  swap(tmp);
  return *this;
}

void NoRequires::swap(NoRequires & other)
{

}

NoRequires::~NoRequires()
{

}

void NoRequires::accept(Visitor *v)
{
  v->visitNoRequires(this);
}

NoRequires *NoRequires::clone() const
{
  return new NoRequires(*this);
}



/********************   SomeRequires    ********************/
SomeRequires::SomeRequires(NERequires *p1)
{
  nerequires_ = p1;

}

SomeRequires::SomeRequires(const SomeRequires & other)
{
  nerequires_ = other.nerequires_->clone();

}

SomeRequires &SomeRequires::operator=(const SomeRequires & other)
{
  SomeRequires tmp(other);
  swap(tmp);
  return *this;
}

void SomeRequires::swap(SomeRequires & other)
{
  std::swap(nerequires_, other.nerequires_);

}

SomeRequires::~SomeRequires()
{
  delete(nerequires_);

}

void SomeRequires::accept(Visitor *v)
{
  v->visitSomeRequires(this);
}

SomeRequires *SomeRequires::clone() const
{
  return new SomeRequires(*this);
}



/********************   SimpleRequires    ********************/
SimpleRequires::SimpleRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

SimpleRequires::SimpleRequires(const SimpleRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

SimpleRequires &SimpleRequires::operator=(const SimpleRequires & other)
{
  SimpleRequires tmp(other);
  swap(tmp);
  return *this;
}

void SimpleRequires::swap(SimpleRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

SimpleRequires::~SimpleRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void SimpleRequires::accept(Visitor *v)
{
  v->visitSimpleRequires(this);
}

SimpleRequires *SimpleRequires::clone() const
{
  return new SimpleRequires(*this);
}



/********************   CheckRequires    ********************/
CheckRequires::CheckRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

CheckRequires::CheckRequires(const CheckRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

CheckRequires &CheckRequires::operator=(const CheckRequires & other)
{
  CheckRequires tmp(other);
  swap(tmp);
  return *this;
}

void CheckRequires::swap(CheckRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

CheckRequires::~CheckRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void CheckRequires::accept(Visitor *v)
{
  v->visitCheckRequires(this);
}

CheckRequires *CheckRequires::clone() const
{
  return new CheckRequires(*this);
}



/********************   AdimtRequires    ********************/
AdimtRequires::AdimtRequires(Lexpr *p1, Requires *p2)
{
  lexpr_ = p1;
  requires_ = p2;

}

AdimtRequires::AdimtRequires(const AdimtRequires & other)
{
  lexpr_ = other.lexpr_->clone();
  requires_ = other.requires_->clone();

}

AdimtRequires &AdimtRequires::operator=(const AdimtRequires & other)
{
  AdimtRequires tmp(other);
  swap(tmp);
  return *this;
}

void AdimtRequires::swap(AdimtRequires & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(requires_, other.requires_);

}

AdimtRequires::~AdimtRequires()
{
  delete(lexpr_);
  delete(requires_);

}

void AdimtRequires::accept(Visitor *v)
{
  v->visitAdimtRequires(this);
}

AdimtRequires *AdimtRequires::clone() const
{
  return new AdimtRequires(*this);
}



/********************   NoTerminate    ********************/
NoTerminate::NoTerminate()
{

}

NoTerminate::NoTerminate(const NoTerminate & other)
{

}

NoTerminate &NoTerminate::operator=(const NoTerminate & other)
{
  NoTerminate tmp(other);
  swap(tmp);
  return *this;
}

void NoTerminate::swap(NoTerminate & other)
{

}

NoTerminate::~NoTerminate()
{

}

void NoTerminate::accept(Visitor *v)
{
  v->visitNoTerminate(this);
}

NoTerminate *NoTerminate::clone() const
{
  return new NoTerminate(*this);
}



/********************   NoDecreases    ********************/
NoDecreases::NoDecreases()
{

}

NoDecreases::NoDecreases(const NoDecreases & other)
{

}

NoDecreases &NoDecreases::operator=(const NoDecreases & other)
{
  NoDecreases tmp(other);
  swap(tmp);
  return *this;
}

void NoDecreases::swap(NoDecreases & other)
{

}

NoDecreases::~NoDecreases()
{

}

void NoDecreases::accept(Visitor *v)
{
  v->visitNoDecreases(this);
}

NoDecreases *NoDecreases::clone() const
{
  return new NoDecreases(*this);
}



/********************   NoSimpleClauses    ********************/
NoSimpleClauses::NoSimpleClauses()
{

}

NoSimpleClauses::NoSimpleClauses(const NoSimpleClauses & other)
{

}

NoSimpleClauses &NoSimpleClauses::operator=(const NoSimpleClauses & other)
{
  NoSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void NoSimpleClauses::swap(NoSimpleClauses & other)
{

}

NoSimpleClauses::~NoSimpleClauses()
{

}

void NoSimpleClauses::accept(Visitor *v)
{
  v->visitNoSimpleClauses(this);
}

NoSimpleClauses *NoSimpleClauses::clone() const
{
  return new NoSimpleClauses(*this);
}



/********************   SomeSimpleClauses    ********************/
SomeSimpleClauses::SomeSimpleClauses(NESimpleClauses *p1)
{
  nesimpleclauses_ = p1;

}

SomeSimpleClauses::SomeSimpleClauses(const SomeSimpleClauses & other)
{
  nesimpleclauses_ = other.nesimpleclauses_->clone();

}

SomeSimpleClauses &SomeSimpleClauses::operator=(const SomeSimpleClauses & other)
{
  SomeSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void SomeSimpleClauses::swap(SomeSimpleClauses & other)
{
  std::swap(nesimpleclauses_, other.nesimpleclauses_);

}

SomeSimpleClauses::~SomeSimpleClauses()
{
  delete(nesimpleclauses_);

}

void SomeSimpleClauses::accept(Visitor *v)
{
  v->visitSomeSimpleClauses(this);
}

SomeSimpleClauses *SomeSimpleClauses::clone() const
{
  return new SomeSimpleClauses(*this);
}



/********************   PostCondSimpleClauses    ********************/
PostCondSimpleClauses::PostCondSimpleClauses(PostCond *p1, Lexpr *p2, SimpleClauses *p3)
{
  postcond_ = p1;
  lexpr_ = p2;
  simpleclauses_ = p3;

}

PostCondSimpleClauses::PostCondSimpleClauses(const PostCondSimpleClauses & other)
{
  postcond_ = other.postcond_->clone();
  lexpr_ = other.lexpr_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

PostCondSimpleClauses &PostCondSimpleClauses::operator=(const PostCondSimpleClauses & other)
{
  PostCondSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void PostCondSimpleClauses::swap(PostCondSimpleClauses & other)
{
  std::swap(postcond_, other.postcond_);
  std::swap(lexpr_, other.lexpr_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

PostCondSimpleClauses::~PostCondSimpleClauses()
{
  delete(postcond_);
  delete(lexpr_);
  delete(simpleclauses_);

}

void PostCondSimpleClauses::accept(Visitor *v)
{
  v->visitPostCondSimpleClauses(this);
}

PostCondSimpleClauses *PostCondSimpleClauses::clone() const
{
  return new PostCondSimpleClauses(*this);
}



/********************   AssignsSimpleClauses    ********************/
AssignsSimpleClauses::AssignsSimpleClauses(Assigns *p1, SimpleClauses *p2)
{
  assigns_ = p1;
  simpleclauses_ = p2;

}

AssignsSimpleClauses::AssignsSimpleClauses(const AssignsSimpleClauses & other)
{
  assigns_ = other.assigns_->clone();
  simpleclauses_ = other.simpleclauses_->clone();

}

AssignsSimpleClauses &AssignsSimpleClauses::operator=(const AssignsSimpleClauses & other)
{
  AssignsSimpleClauses tmp(other);
  swap(tmp);
  return *this;
}

void AssignsSimpleClauses::swap(AssignsSimpleClauses & other)
{
  std::swap(assigns_, other.assigns_);
  std::swap(simpleclauses_, other.simpleclauses_);

}

AssignsSimpleClauses::~AssignsSimpleClauses()
{
  delete(assigns_);
  delete(simpleclauses_);

}

void AssignsSimpleClauses::accept(Visitor *v)
{
  v->visitAssignsSimpleClauses(this);
}

AssignsSimpleClauses *AssignsSimpleClauses::clone() const
{
  return new AssignsSimpleClauses(*this);
}



/********************   AssignZone    ********************/
AssignZone::AssignZone(Zones *p1)
{
  zones_ = p1;

}

AssignZone::AssignZone(const AssignZone & other)
{
  zones_ = other.zones_->clone();

}

AssignZone &AssignZone::operator=(const AssignZone & other)
{
  AssignZone tmp(other);
  swap(tmp);
  return *this;
}

void AssignZone::swap(AssignZone & other)
{
  std::swap(zones_, other.zones_);

}

AssignZone::~AssignZone()
{
  delete(zones_);

}

void AssignZone::accept(Visitor *v)
{
  v->visitAssignZone(this);
}

AssignZone *AssignZone::clone() const
{
  return new AssignZone(*this);
}



/********************   AssignZoneFromZone    ********************/
AssignZoneFromZone::AssignZoneFromZone(ListLexpr *p1, Zones *p2)
{
  listlexpr_ = p1;
  zones_ = p2;

}

AssignZoneFromZone::AssignZoneFromZone(const AssignZoneFromZone & other)
{
  listlexpr_ = other.listlexpr_->clone();
  zones_ = other.zones_->clone();

}

AssignZoneFromZone &AssignZoneFromZone::operator=(const AssignZoneFromZone & other)
{
  AssignZoneFromZone tmp(other);
  swap(tmp);
  return *this;
}

void AssignZoneFromZone::swap(AssignZoneFromZone & other)
{
  std::swap(listlexpr_, other.listlexpr_);
  std::swap(zones_, other.zones_);

}

AssignZoneFromZone::~AssignZoneFromZone()
{
  delete(listlexpr_);
  delete(zones_);

}

void AssignZoneFromZone::accept(Visitor *v)
{
  v->visitAssignZoneFromZone(this);
}

AssignZoneFromZone *AssignZoneFromZone::clone() const
{
  return new AssignZoneFromZone(*this);
}



/********************   SomeZone    ********************/
SomeZone::SomeZone(ListLexpr *p1)
{
  listlexpr_ = p1;

}

SomeZone::SomeZone(const SomeZone & other)
{
  listlexpr_ = other.listlexpr_->clone();

}

SomeZone &SomeZone::operator=(const SomeZone & other)
{
  SomeZone tmp(other);
  swap(tmp);
  return *this;
}

void SomeZone::swap(SomeZone & other)
{
  std::swap(listlexpr_, other.listlexpr_);

}

SomeZone::~SomeZone()
{
  delete(listlexpr_);

}

void SomeZone::accept(Visitor *v)
{
  v->visitSomeZone(this);
}

SomeZone *SomeZone::clone() const
{
  return new SomeZone(*this);
}



/********************   NoZone    ********************/
NoZone::NoZone()
{

}

NoZone::NoZone(const NoZone & other)
{

}

NoZone &NoZone::operator=(const NoZone & other)
{
  NoZone tmp(other);
  swap(tmp);
  return *this;
}

void NoZone::swap(NoZone & other)
{

}

NoZone::~NoZone()
{

}

void NoZone::accept(Visitor *v)
{
  v->visitNoZone(this);
}

NoZone *NoZone::clone() const
{
  return new NoZone(*this);
}



/********************   NoBehaviors    ********************/
NoBehaviors::NoBehaviors()
{

}

NoBehaviors::NoBehaviors(const NoBehaviors & other)
{

}

NoBehaviors &NoBehaviors::operator=(const NoBehaviors & other)
{
  NoBehaviors tmp(other);
  swap(tmp);
  return *this;
}

void NoBehaviors::swap(NoBehaviors & other)
{

}

NoBehaviors::~NoBehaviors()
{

}

void NoBehaviors::accept(Visitor *v)
{
  v->visitNoBehaviors(this);
}

NoBehaviors *NoBehaviors::clone() const
{
  return new NoBehaviors(*this);
}



/********************   NoComplDisj    ********************/
NoComplDisj::NoComplDisj()
{

}

NoComplDisj::NoComplDisj(const NoComplDisj & other)
{

}

NoComplDisj &NoComplDisj::operator=(const NoComplDisj & other)
{
  NoComplDisj tmp(other);
  swap(tmp);
  return *this;
}

void NoComplDisj::swap(NoComplDisj & other)
{

}

NoComplDisj::~NoComplDisj()
{

}

void NoComplDisj::accept(Visitor *v)
{
  v->visitNoComplDisj(this);
}

NoComplDisj *NoComplDisj::clone() const
{
  return new NoComplDisj(*this);
}



/********************   ImplLexpr    ********************/
ImplLexpr::ImplLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

ImplLexpr::ImplLexpr(const ImplLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

ImplLexpr &ImplLexpr::operator=(const ImplLexpr & other)
{
  ImplLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ImplLexpr::swap(ImplLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

ImplLexpr::~ImplLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void ImplLexpr::accept(Visitor *v)
{
  v->visitImplLexpr(this);
}

ImplLexpr *ImplLexpr::clone() const
{
  return new ImplLexpr(*this);
}



/********************   IffLexpr    ********************/
IffLexpr::IffLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

IffLexpr::IffLexpr(const IffLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

IffLexpr &IffLexpr::operator=(const IffLexpr & other)
{
  IffLexpr tmp(other);
  swap(tmp);
  return *this;
}

void IffLexpr::swap(IffLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

IffLexpr::~IffLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void IffLexpr::accept(Visitor *v)
{
  v->visitIffLexpr(this);
}

IffLexpr *IffLexpr::clone() const
{
  return new IffLexpr(*this);
}



/********************   OrLexpr    ********************/
OrLexpr::OrLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

OrLexpr::OrLexpr(const OrLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

OrLexpr &OrLexpr::operator=(const OrLexpr & other)
{
  OrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void OrLexpr::swap(OrLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

OrLexpr::~OrLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void OrLexpr::accept(Visitor *v)
{
  v->visitOrLexpr(this);
}

OrLexpr *OrLexpr::clone() const
{
  return new OrLexpr(*this);
}



/********************   AndLexpr    ********************/
AndLexpr::AndLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AndLexpr::AndLexpr(const AndLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AndLexpr &AndLexpr::operator=(const AndLexpr & other)
{
  AndLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AndLexpr::swap(AndLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AndLexpr::~AndLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AndLexpr::accept(Visitor *v)
{
  v->visitAndLexpr(this);
}

AndLexpr *AndLexpr::clone() const
{
  return new AndLexpr(*this);
}



/********************   HatHatLexpr    ********************/
HatHatLexpr::HatHatLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

HatHatLexpr::HatHatLexpr(const HatHatLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

HatHatLexpr &HatHatLexpr::operator=(const HatHatLexpr & other)
{
  HatHatLexpr tmp(other);
  swap(tmp);
  return *this;
}

void HatHatLexpr::swap(HatHatLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

HatHatLexpr::~HatHatLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void HatHatLexpr::accept(Visitor *v)
{
  v->visitHatHatLexpr(this);
}

HatHatLexpr *HatHatLexpr::clone() const
{
  return new HatHatLexpr(*this);
}



/********************   RelationLexpr    ********************/
RelationLexpr::RelationLexpr(Lexpr *p1, ListLexprRelInner *p2, Relation *p3, Lexpr *p4)
{
  lexpr_1 = p1;
  listlexprrelinner_ = p2;
  relation_ = p3;
  lexpr_2 = p4;

}

RelationLexpr::RelationLexpr(const RelationLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  listlexprrelinner_ = other.listlexprrelinner_->clone();
  relation_ = other.relation_->clone();
  lexpr_2 = other.lexpr_2->clone();

}

RelationLexpr &RelationLexpr::operator=(const RelationLexpr & other)
{
  RelationLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RelationLexpr::swap(RelationLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(listlexprrelinner_, other.listlexprrelinner_);
  std::swap(relation_, other.relation_);
  std::swap(lexpr_2, other.lexpr_2);

}

RelationLexpr::~RelationLexpr()
{
  delete(lexpr_1);
  delete(listlexprrelinner_);
  delete(relation_);
  delete(lexpr_2);

}

void RelationLexpr::accept(Visitor *v)
{
  v->visitRelationLexpr(this);
}

RelationLexpr *RelationLexpr::clone() const
{
  return new RelationLexpr(*this);
}



/********************   BinderLexpr    ********************/
BinderLexpr::BinderLexpr(LexprBinder *p1)
{
  lexprbinder_ = p1;

}

BinderLexpr::BinderLexpr(const BinderLexpr & other)
{
  lexprbinder_ = other.lexprbinder_->clone();

}

BinderLexpr &BinderLexpr::operator=(const BinderLexpr & other)
{
  BinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void BinderLexpr::swap(BinderLexpr & other)
{
  std::swap(lexprbinder_, other.lexprbinder_);

}

BinderLexpr::~BinderLexpr()
{
  delete(lexprbinder_);

}

void BinderLexpr::accept(Visitor *v)
{
  v->visitBinderLexpr(this);
}

BinderLexpr *BinderLexpr::clone() const
{
  return new BinderLexpr(*this);
}



/********************   NotBinderLexpr    ********************/
NotBinderLexpr::NotBinderLexpr(LexprBinder *p1)
{
  lexprbinder_ = p1;

}

NotBinderLexpr::NotBinderLexpr(const NotBinderLexpr & other)
{
  lexprbinder_ = other.lexprbinder_->clone();

}

NotBinderLexpr &NotBinderLexpr::operator=(const NotBinderLexpr & other)
{
  NotBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NotBinderLexpr::swap(NotBinderLexpr & other)
{
  std::swap(lexprbinder_, other.lexprbinder_);

}

NotBinderLexpr::~NotBinderLexpr()
{
  delete(lexprbinder_);

}

void NotBinderLexpr::accept(Visitor *v)
{
  v->visitNotBinderLexpr(this);
}

NotBinderLexpr *NotBinderLexpr::clone() const
{
  return new NotBinderLexpr(*this);
}



/********************   TrueLexpr    ********************/
TrueLexpr::TrueLexpr()
{

}

TrueLexpr::TrueLexpr(const TrueLexpr & other)
{

}

TrueLexpr &TrueLexpr::operator=(const TrueLexpr & other)
{
  TrueLexpr tmp(other);
  swap(tmp);
  return *this;
}

void TrueLexpr::swap(TrueLexpr & other)
{

}

TrueLexpr::~TrueLexpr()
{

}

void TrueLexpr::accept(Visitor *v)
{
  v->visitTrueLexpr(this);
}

TrueLexpr *TrueLexpr::clone() const
{
  return new TrueLexpr(*this);
}



/********************   FalseLexpr    ********************/
FalseLexpr::FalseLexpr()
{

}

FalseLexpr::FalseLexpr(const FalseLexpr & other)
{

}

FalseLexpr &FalseLexpr::operator=(const FalseLexpr & other)
{
  FalseLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FalseLexpr::swap(FalseLexpr & other)
{

}

FalseLexpr::~FalseLexpr()
{

}

void FalseLexpr::accept(Visitor *v)
{
  v->visitFalseLexpr(this);
}

FalseLexpr *FalseLexpr::clone() const
{
  return new FalseLexpr(*this);
}



/********************   ValidLexpr    ********************/
ValidLexpr::ValidLexpr(OptLabel *p1, Lexpr *p2)
{
  optlabel_ = p1;
  lexpr_ = p2;

}

ValidLexpr::ValidLexpr(const ValidLexpr & other)
{
  optlabel_ = other.optlabel_->clone();
  lexpr_ = other.lexpr_->clone();

}

ValidLexpr &ValidLexpr::operator=(const ValidLexpr & other)
{
  ValidLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ValidLexpr::swap(ValidLexpr & other)
{
  std::swap(optlabel_, other.optlabel_);
  std::swap(lexpr_, other.lexpr_);

}

ValidLexpr::~ValidLexpr()
{
  delete(optlabel_);
  delete(lexpr_);

}

void ValidLexpr::accept(Visitor *v)
{
  v->visitValidLexpr(this);
}

ValidLexpr *ValidLexpr::clone() const
{
  return new ValidLexpr(*this);
}



/********************   AutomaticLexpr    ********************/
AutomaticLexpr::AutomaticLexpr()
{

}

AutomaticLexpr::AutomaticLexpr(const AutomaticLexpr & other)
{

}

AutomaticLexpr &AutomaticLexpr::operator=(const AutomaticLexpr & other)
{
  AutomaticLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AutomaticLexpr::swap(AutomaticLexpr & other)
{

}

AutomaticLexpr::~AutomaticLexpr()
{

}

void AutomaticLexpr::accept(Visitor *v)
{
  v->visitAutomaticLexpr(this);
}

AutomaticLexpr *AutomaticLexpr::clone() const
{
  return new AutomaticLexpr(*this);
}



/********************   DynamicLexpr    ********************/
DynamicLexpr::DynamicLexpr()
{

}

DynamicLexpr::DynamicLexpr(const DynamicLexpr & other)
{

}

DynamicLexpr &DynamicLexpr::operator=(const DynamicLexpr & other)
{
  DynamicLexpr tmp(other);
  swap(tmp);
  return *this;
}

void DynamicLexpr::swap(DynamicLexpr & other)
{

}

DynamicLexpr::~DynamicLexpr()
{

}

void DynamicLexpr::accept(Visitor *v)
{
  v->visitDynamicLexpr(this);
}

DynamicLexpr *DynamicLexpr::clone() const
{
  return new DynamicLexpr(*this);
}



/********************   RegisterLexpr    ********************/
RegisterLexpr::RegisterLexpr()
{

}

RegisterLexpr::RegisterLexpr(const RegisterLexpr & other)
{

}

RegisterLexpr &RegisterLexpr::operator=(const RegisterLexpr & other)
{
  RegisterLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RegisterLexpr::swap(RegisterLexpr & other)
{

}

RegisterLexpr::~RegisterLexpr()
{

}

void RegisterLexpr::accept(Visitor *v)
{
  v->visitRegisterLexpr(this);
}

RegisterLexpr *RegisterLexpr::clone() const
{
  return new RegisterLexpr(*this);
}



/********************   StaticLexpr    ********************/
StaticLexpr::StaticLexpr()
{

}

StaticLexpr::StaticLexpr(const StaticLexpr & other)
{

}

StaticLexpr &StaticLexpr::operator=(const StaticLexpr & other)
{
  StaticLexpr tmp(other);
  swap(tmp);
  return *this;
}

void StaticLexpr::swap(StaticLexpr & other)
{

}

StaticLexpr::~StaticLexpr()
{

}

void StaticLexpr::accept(Visitor *v)
{
  v->visitStaticLexpr(this);
}

StaticLexpr *StaticLexpr::clone() const
{
  return new StaticLexpr(*this);
}



/********************   UnallocatedLexpr    ********************/
UnallocatedLexpr::UnallocatedLexpr()
{

}

UnallocatedLexpr::UnallocatedLexpr(const UnallocatedLexpr & other)
{

}

UnallocatedLexpr &UnallocatedLexpr::operator=(const UnallocatedLexpr & other)
{
  UnallocatedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void UnallocatedLexpr::swap(UnallocatedLexpr & other)
{

}

UnallocatedLexpr::~UnallocatedLexpr()
{

}

void UnallocatedLexpr::accept(Visitor *v)
{
  v->visitUnallocatedLexpr(this);
}

UnallocatedLexpr *UnallocatedLexpr::clone() const
{
  return new UnallocatedLexpr(*this);
}



/********************   NullLexpr    ********************/
NullLexpr::NullLexpr()
{

}

NullLexpr::NullLexpr(const NullLexpr & other)
{

}

NullLexpr &NullLexpr::operator=(const NullLexpr & other)
{
  NullLexpr tmp(other);
  swap(tmp);
  return *this;
}

void NullLexpr::swap(NullLexpr & other)
{

}

NullLexpr::~NullLexpr()
{

}

void NullLexpr::accept(Visitor *v)
{
  v->visitNullLexpr(this);
}

NullLexpr *NullLexpr::clone() const
{
  return new NullLexpr(*this);
}



/********************   LexprIntConst    ********************/
LexprIntConst::LexprIntConst(Integer p1)
{
  integer_ = p1;

}

LexprIntConst::LexprIntConst(const LexprIntConst & other)
{
  integer_ = other.integer_;

}

LexprIntConst &LexprIntConst::operator=(const LexprIntConst & other)
{
  LexprIntConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprIntConst::swap(LexprIntConst & other)
{
  std::swap(integer_, other.integer_);

}

LexprIntConst::~LexprIntConst()
{

}

void LexprIntConst::accept(Visitor *v)
{
  v->visitLexprIntConst(this);
}

LexprIntConst *LexprIntConst::clone() const
{
  return new LexprIntConst(*this);
}



/********************   LexprFloatConst    ********************/
LexprFloatConst::LexprFloatConst(Double p1)
{
  double_ = p1;

}

LexprFloatConst::LexprFloatConst(const LexprFloatConst & other)
{
  double_ = other.double_;

}

LexprFloatConst &LexprFloatConst::operator=(const LexprFloatConst & other)
{
  LexprFloatConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprFloatConst::swap(LexprFloatConst & other)
{
  std::swap(double_, other.double_);

}

LexprFloatConst::~LexprFloatConst()
{

}

void LexprFloatConst::accept(Visitor *v)
{
  v->visitLexprFloatConst(this);
}

LexprFloatConst *LexprFloatConst::clone() const
{
  return new LexprFloatConst(*this);
}



/********************   LexprStringConst    ********************/
LexprStringConst::LexprStringConst(String p1)
{
  string_ = p1;

}

LexprStringConst::LexprStringConst(const LexprStringConst & other)
{
  string_ = other.string_;

}

LexprStringConst &LexprStringConst::operator=(const LexprStringConst & other)
{
  LexprStringConst tmp(other);
  swap(tmp);
  return *this;
}

void LexprStringConst::swap(LexprStringConst & other)
{
  std::swap(string_, other.string_);

}

LexprStringConst::~LexprStringConst()
{

}

void LexprStringConst::accept(Visitor *v)
{
  v->visitLexprStringConst(this);
}

LexprStringConst *LexprStringConst::clone() const
{
  return new LexprStringConst(*this);
}



/********************   AddLexpr    ********************/
AddLexpr::AddLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

AddLexpr::AddLexpr(const AddLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

AddLexpr &AddLexpr::operator=(const AddLexpr & other)
{
  AddLexpr tmp(other);
  swap(tmp);
  return *this;
}

void AddLexpr::swap(AddLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

AddLexpr::~AddLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void AddLexpr::accept(Visitor *v)
{
  v->visitAddLexpr(this);
}

AddLexpr *AddLexpr::clone() const
{
  return new AddLexpr(*this);
}



/********************   SubtrLexpr    ********************/
SubtrLexpr::SubtrLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

SubtrLexpr::SubtrLexpr(const SubtrLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

SubtrLexpr &SubtrLexpr::operator=(const SubtrLexpr & other)
{
  SubtrLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SubtrLexpr::swap(SubtrLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

SubtrLexpr::~SubtrLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void SubtrLexpr::accept(Visitor *v)
{
  v->visitSubtrLexpr(this);
}

SubtrLexpr *SubtrLexpr::clone() const
{
  return new SubtrLexpr(*this);
}



/********************   SquaresRangeLexpr    ********************/
SquaresRangeLexpr::SquaresRangeLexpr(Lexpr *p1, Range *p2)
{
  lexpr_ = p1;
  range_ = p2;

}

SquaresRangeLexpr::SquaresRangeLexpr(const SquaresRangeLexpr & other)
{
  lexpr_ = other.lexpr_->clone();
  range_ = other.range_->clone();

}

SquaresRangeLexpr &SquaresRangeLexpr::operator=(const SquaresRangeLexpr & other)
{
  SquaresRangeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SquaresRangeLexpr::swap(SquaresRangeLexpr & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(range_, other.range_);

}

SquaresRangeLexpr::~SquaresRangeLexpr()
{
  delete(lexpr_);
  delete(range_);

}

void SquaresRangeLexpr::accept(Visitor *v)
{
  v->visitSquaresRangeLexpr(this);
}

SquaresRangeLexpr *SquaresRangeLexpr::clone() const
{
  return new SquaresRangeLexpr(*this);
}



/********************   SquaresLexpr    ********************/
SquaresLexpr::SquaresLexpr(Lexpr *p1, Lexpr *p2)
{
  lexpr_1 = p1;
  lexpr_2 = p2;

}

SquaresLexpr::SquaresLexpr(const SquaresLexpr & other)
{
  lexpr_1 = other.lexpr_1->clone();
  lexpr_2 = other.lexpr_2->clone();

}

SquaresLexpr &SquaresLexpr::operator=(const SquaresLexpr & other)
{
  SquaresLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SquaresLexpr::swap(SquaresLexpr & other)
{
  std::swap(lexpr_1, other.lexpr_1);
  std::swap(lexpr_2, other.lexpr_2);

}

SquaresLexpr::~SquaresLexpr()
{
  delete(lexpr_1);
  delete(lexpr_2);

}

void SquaresLexpr::accept(Visitor *v)
{
  v->visitSquaresLexpr(this);
}

SquaresLexpr *SquaresLexpr::clone() const
{
  return new SquaresLexpr(*this);
}



/********************   SeparatedLexpr    ********************/
SeparatedLexpr::SeparatedLexpr(ListLexpr *p1)
{
  listlexpr_ = p1;

}

SeparatedLexpr::SeparatedLexpr(const SeparatedLexpr & other)
{
  listlexpr_ = other.listlexpr_->clone();

}

SeparatedLexpr &SeparatedLexpr::operator=(const SeparatedLexpr & other)
{
  SeparatedLexpr tmp(other);
  swap(tmp);
  return *this;
}

void SeparatedLexpr::swap(SeparatedLexpr & other)
{
  std::swap(listlexpr_, other.listlexpr_);

}

SeparatedLexpr::~SeparatedLexpr()
{
  delete(listlexpr_);

}

void SeparatedLexpr::accept(Visitor *v)
{
  v->visitSeparatedLexpr(this);
}

SeparatedLexpr *SeparatedLexpr::clone() const
{
  return new SeparatedLexpr(*this);
}



/********************   FullIdParenLexpr    ********************/
FullIdParenLexpr::FullIdParenLexpr(FullIdentifier *p1, ListLexpr *p2)
{
  fullidentifier_ = p1;
  listlexpr_ = p2;

}

FullIdParenLexpr::FullIdParenLexpr(const FullIdParenLexpr & other)
{
  fullidentifier_ = other.fullidentifier_->clone();
  listlexpr_ = other.listlexpr_->clone();

}

FullIdParenLexpr &FullIdParenLexpr::operator=(const FullIdParenLexpr & other)
{
  FullIdParenLexpr tmp(other);
  swap(tmp);
  return *this;
}

void FullIdParenLexpr::swap(FullIdParenLexpr & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);
  std::swap(listlexpr_, other.listlexpr_);

}

FullIdParenLexpr::~FullIdParenLexpr()
{
  delete(fullidentifier_);
  delete(listlexpr_);

}

void FullIdParenLexpr::accept(Visitor *v)
{
  v->visitFullIdParenLexpr(this);
}

FullIdParenLexpr *FullIdParenLexpr::clone() const
{
  return new FullIdParenLexpr(*this);
}



/********************   FullId    ********************/
FullId::FullId(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

FullId::FullId(const FullId & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

FullId &FullId::operator=(const FullId & other)
{
  FullId tmp(other);
  swap(tmp);
  return *this;
}

void FullId::swap(FullId & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

FullId::~FullId()
{
  delete(fullidentifier_);

}

void FullId::accept(Visitor *v)
{
  v->visitFullId(this);
}

FullId *FullId::clone() const
{
  return new FullId(*this);
}



/********************   PiLexpr    ********************/
PiLexpr::PiLexpr()
{

}

PiLexpr::PiLexpr(const PiLexpr & other)
{

}

PiLexpr &PiLexpr::operator=(const PiLexpr & other)
{
  PiLexpr tmp(other);
  swap(tmp);
  return *this;
}

void PiLexpr::swap(PiLexpr & other)
{

}

PiLexpr::~PiLexpr()
{

}

void PiLexpr::accept(Visitor *v)
{
  v->visitPiLexpr(this);
}

PiLexpr *PiLexpr::clone() const
{
  return new PiLexpr(*this);
}



/********************   ParenRangeLexpr    ********************/
ParenRangeLexpr::ParenRangeLexpr(Range *p1)
{
  range_ = p1;

}

ParenRangeLexpr::ParenRangeLexpr(const ParenRangeLexpr & other)
{
  range_ = other.range_->clone();

}

ParenRangeLexpr &ParenRangeLexpr::operator=(const ParenRangeLexpr & other)
{
  ParenRangeLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ParenRangeLexpr::swap(ParenRangeLexpr & other)
{
  std::swap(range_, other.range_);

}

ParenRangeLexpr::~ParenRangeLexpr()
{
  delete(range_);

}

void ParenRangeLexpr::accept(Visitor *v)
{
  v->visitParenRangeLexpr(this);
}

ParenRangeLexpr *ParenRangeLexpr::clone() const
{
  return new ParenRangeLexpr(*this);
}



/********************   RelInnerLexpr    ********************/
RelInnerLexpr::RelInnerLexpr(Relation *p1, Lexpr *p2)
{
  relation_ = p1;
  lexpr_ = p2;

}

RelInnerLexpr::RelInnerLexpr(const RelInnerLexpr & other)
{
  relation_ = other.relation_->clone();
  lexpr_ = other.lexpr_->clone();

}

RelInnerLexpr &RelInnerLexpr::operator=(const RelInnerLexpr & other)
{
  RelInnerLexpr tmp(other);
  swap(tmp);
  return *this;
}

void RelInnerLexpr::swap(RelInnerLexpr & other)
{
  std::swap(relation_, other.relation_);
  std::swap(lexpr_, other.lexpr_);

}

RelInnerLexpr::~RelInnerLexpr()
{
  delete(relation_);
  delete(lexpr_);

}

void RelInnerLexpr::accept(Visitor *v)
{
  v->visitRelInnerLexpr(this);
}

RelInnerLexpr *RelInnerLexpr::clone() const
{
  return new RelInnerLexpr(*this);
}



/********************   LessRel    ********************/
LessRel::LessRel()
{

}

LessRel::LessRel(const LessRel & other)
{

}

LessRel &LessRel::operator=(const LessRel & other)
{
  LessRel tmp(other);
  swap(tmp);
  return *this;
}

void LessRel::swap(LessRel & other)
{

}

LessRel::~LessRel()
{

}

void LessRel::accept(Visitor *v)
{
  v->visitLessRel(this);
}

LessRel *LessRel::clone() const
{
  return new LessRel(*this);
}



/********************   GreaterRel    ********************/
GreaterRel::GreaterRel()
{

}

GreaterRel::GreaterRel(const GreaterRel & other)
{

}

GreaterRel &GreaterRel::operator=(const GreaterRel & other)
{
  GreaterRel tmp(other);
  swap(tmp);
  return *this;
}

void GreaterRel::swap(GreaterRel & other)
{

}

GreaterRel::~GreaterRel()
{

}

void GreaterRel::accept(Visitor *v)
{
  v->visitGreaterRel(this);
}

GreaterRel *GreaterRel::clone() const
{
  return new GreaterRel(*this);
}



/********************   LessEqRel    ********************/
LessEqRel::LessEqRel()
{

}

LessEqRel::LessEqRel(const LessEqRel & other)
{

}

LessEqRel &LessEqRel::operator=(const LessEqRel & other)
{
  LessEqRel tmp(other);
  swap(tmp);
  return *this;
}

void LessEqRel::swap(LessEqRel & other)
{

}

LessEqRel::~LessEqRel()
{

}

void LessEqRel::accept(Visitor *v)
{
  v->visitLessEqRel(this);
}

LessEqRel *LessEqRel::clone() const
{
  return new LessEqRel(*this);
}



/********************   GreaterEqRel    ********************/
GreaterEqRel::GreaterEqRel()
{

}

GreaterEqRel::GreaterEqRel(const GreaterEqRel & other)
{

}

GreaterEqRel &GreaterEqRel::operator=(const GreaterEqRel & other)
{
  GreaterEqRel tmp(other);
  swap(tmp);
  return *this;
}

void GreaterEqRel::swap(GreaterEqRel & other)
{

}

GreaterEqRel::~GreaterEqRel()
{

}

void GreaterEqRel::accept(Visitor *v)
{
  v->visitGreaterEqRel(this);
}

GreaterEqRel *GreaterEqRel::clone() const
{
  return new GreaterEqRel(*this);
}



/********************   EqRel    ********************/
EqRel::EqRel()
{

}

EqRel::EqRel(const EqRel & other)
{

}

EqRel &EqRel::operator=(const EqRel & other)
{
  EqRel tmp(other);
  swap(tmp);
  return *this;
}

void EqRel::swap(EqRel & other)
{

}

EqRel::~EqRel()
{

}

void EqRel::accept(Visitor *v)
{
  v->visitEqRel(this);
}

EqRel *EqRel::clone() const
{
  return new EqRel(*this);
}



/********************   NotEqRel    ********************/
NotEqRel::NotEqRel()
{

}

NotEqRel::NotEqRel(const NotEqRel & other)
{

}

NotEqRel &NotEqRel::operator=(const NotEqRel & other)
{
  NotEqRel tmp(other);
  swap(tmp);
  return *this;
}

void NotEqRel::swap(NotEqRel & other)
{

}

NotEqRel::~NotEqRel()
{

}

void NotEqRel::accept(Visitor *v)
{
  v->visitNotEqRel(this);
}

NotEqRel *NotEqRel::clone() const
{
  return new NotEqRel(*this);
}



/********************   ForallBinderLexpr    ********************/
ForallBinderLexpr::ForallBinderLexpr(Binders *p1, Lexpr *p2)
{
  binders_ = p1;
  lexpr_ = p2;

}

ForallBinderLexpr::ForallBinderLexpr(const ForallBinderLexpr & other)
{
  binders_ = other.binders_->clone();
  lexpr_ = other.lexpr_->clone();

}

ForallBinderLexpr &ForallBinderLexpr::operator=(const ForallBinderLexpr & other)
{
  ForallBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ForallBinderLexpr::swap(ForallBinderLexpr & other)
{
  std::swap(binders_, other.binders_);
  std::swap(lexpr_, other.lexpr_);

}

ForallBinderLexpr::~ForallBinderLexpr()
{
  delete(binders_);
  delete(lexpr_);

}

void ForallBinderLexpr::accept(Visitor *v)
{
  v->visitForallBinderLexpr(this);
}

ForallBinderLexpr *ForallBinderLexpr::clone() const
{
  return new ForallBinderLexpr(*this);
}



/********************   ExistBinderLexpr    ********************/
ExistBinderLexpr::ExistBinderLexpr(Binders *p1, Lexpr *p2)
{
  binders_ = p1;
  lexpr_ = p2;

}

ExistBinderLexpr::ExistBinderLexpr(const ExistBinderLexpr & other)
{
  binders_ = other.binders_->clone();
  lexpr_ = other.lexpr_->clone();

}

ExistBinderLexpr &ExistBinderLexpr::operator=(const ExistBinderLexpr & other)
{
  ExistBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void ExistBinderLexpr::swap(ExistBinderLexpr & other)
{
  std::swap(binders_, other.binders_);
  std::swap(lexpr_, other.lexpr_);

}

ExistBinderLexpr::~ExistBinderLexpr()
{
  delete(binders_);
  delete(lexpr_);

}

void ExistBinderLexpr::accept(Visitor *v)
{
  v->visitExistBinderLexpr(this);
}

ExistBinderLexpr *ExistBinderLexpr::clone() const
{
  return new ExistBinderLexpr(*this);
}



/********************   LambdaBinderLexpr    ********************/
LambdaBinderLexpr::LambdaBinderLexpr(Binders *p1, Lexpr *p2)
{
  binders_ = p1;
  lexpr_ = p2;

}

LambdaBinderLexpr::LambdaBinderLexpr(const LambdaBinderLexpr & other)
{
  binders_ = other.binders_->clone();
  lexpr_ = other.lexpr_->clone();

}

LambdaBinderLexpr &LambdaBinderLexpr::operator=(const LambdaBinderLexpr & other)
{
  LambdaBinderLexpr tmp(other);
  swap(tmp);
  return *this;
}

void LambdaBinderLexpr::swap(LambdaBinderLexpr & other)
{
  std::swap(binders_, other.binders_);
  std::swap(lexpr_, other.lexpr_);

}

LambdaBinderLexpr::~LambdaBinderLexpr()
{
  delete(binders_);
  delete(lexpr_);

}

void LambdaBinderLexpr::accept(Visitor *v)
{
  v->visitLambdaBinderLexpr(this);
}

LambdaBinderLexpr *LambdaBinderLexpr::clone() const
{
  return new LambdaBinderLexpr(*this);
}



/********************   TheBinders    ********************/
TheBinders::TheBinders(TypeSpecOFTYPENAME *p1, VarSpec *p2, ListBindersReentrance *p3)
{
  typespecoftypename_ = p1;
  varspec_ = p2;
  listbindersreentrance_ = p3;

}

TheBinders::TheBinders(const TheBinders & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  varspec_ = other.varspec_->clone();
  listbindersreentrance_ = other.listbindersreentrance_->clone();

}

TheBinders &TheBinders::operator=(const TheBinders & other)
{
  TheBinders tmp(other);
  swap(tmp);
  return *this;
}

void TheBinders::swap(TheBinders & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(varspec_, other.varspec_);
  std::swap(listbindersreentrance_, other.listbindersreentrance_);

}

TheBinders::~TheBinders()
{
  delete(typespecoftypename_);
  delete(varspec_);
  delete(listbindersreentrance_);

}

void TheBinders::accept(Visitor *v)
{
  v->visitTheBinders(this);
}

TheBinders *TheBinders::clone() const
{
  return new TheBinders(*this);
}



/********************   TypeSpecTYPENAME    ********************/
TypeSpecTYPENAME::TypeSpecTYPENAME(Ident p1)
{
  ident_ = p1;

}

TypeSpecTYPENAME::TypeSpecTYPENAME(const TypeSpecTYPENAME & other)
{
  ident_ = other.ident_;

}

TypeSpecTYPENAME &TypeSpecTYPENAME::operator=(const TypeSpecTYPENAME & other)
{
  TypeSpecTYPENAME tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecTYPENAME::swap(TypeSpecTYPENAME & other)
{
  std::swap(ident_, other.ident_);

}

TypeSpecTYPENAME::~TypeSpecTYPENAME()
{

}

void TypeSpecTYPENAME::accept(Visitor *v)
{
  v->visitTypeSpecTYPENAME(this);
}

TypeSpecTYPENAME *TypeSpecTYPENAME::clone() const
{
  return new TypeSpecTYPENAME(*this);
}



/********************   TypeSpecSimpleFromTypenameTypeSpec    ********************/
TypeSpecSimpleFromTypenameTypeSpec::TypeSpecSimpleFromTypenameTypeSpec(TypeSpecSimple *p1)
{
  typespecsimple_ = p1;

}

TypeSpecSimpleFromTypenameTypeSpec::TypeSpecSimpleFromTypenameTypeSpec(const TypeSpecSimpleFromTypenameTypeSpec & other)
{
  typespecsimple_ = other.typespecsimple_->clone();

}

TypeSpecSimpleFromTypenameTypeSpec &TypeSpecSimpleFromTypenameTypeSpec::operator=(const TypeSpecSimpleFromTypenameTypeSpec & other)
{
  TypeSpecSimpleFromTypenameTypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleFromTypenameTypeSpec::swap(TypeSpecSimpleFromTypenameTypeSpec & other)
{
  std::swap(typespecsimple_, other.typespecsimple_);

}

TypeSpecSimpleFromTypenameTypeSpec::~TypeSpecSimpleFromTypenameTypeSpec()
{
  delete(typespecsimple_);

}

void TypeSpecSimpleFromTypenameTypeSpec::accept(Visitor *v)
{
  v->visitTypeSpecSimpleFromTypenameTypeSpec(this);
}

TypeSpecSimpleFromTypenameTypeSpec *TypeSpecSimpleFromTypenameTypeSpec::clone() const
{
  return new TypeSpecSimpleFromTypenameTypeSpec(*this);
}



/********************   BindersReentranceDeclSpec    ********************/
BindersReentranceDeclSpec::BindersReentranceDeclSpec(TypeSpecOFTYPENAME *p1, VarSpec *p2)
{
  typespecoftypename_ = p1;
  varspec_ = p2;

}

BindersReentranceDeclSpec::BindersReentranceDeclSpec(const BindersReentranceDeclSpec & other)
{
  typespecoftypename_ = other.typespecoftypename_->clone();
  varspec_ = other.varspec_->clone();

}

BindersReentranceDeclSpec &BindersReentranceDeclSpec::operator=(const BindersReentranceDeclSpec & other)
{
  BindersReentranceDeclSpec tmp(other);
  swap(tmp);
  return *this;
}

void BindersReentranceDeclSpec::swap(BindersReentranceDeclSpec & other)
{
  std::swap(typespecoftypename_, other.typespecoftypename_);
  std::swap(varspec_, other.varspec_);

}

BindersReentranceDeclSpec::~BindersReentranceDeclSpec()
{
  delete(typespecoftypename_);
  delete(varspec_);

}

void BindersReentranceDeclSpec::accept(Visitor *v)
{
  v->visitBindersReentranceDeclSpec(this);
}

BindersReentranceDeclSpec *BindersReentranceDeclSpec::clone() const
{
  return new BindersReentranceDeclSpec(*this);
}



/********************   BindersReentranceVarSpec    ********************/
BindersReentranceVarSpec::BindersReentranceVarSpec(VarSpec *p1)
{
  varspec_ = p1;

}

BindersReentranceVarSpec::BindersReentranceVarSpec(const BindersReentranceVarSpec & other)
{
  varspec_ = other.varspec_->clone();

}

BindersReentranceVarSpec &BindersReentranceVarSpec::operator=(const BindersReentranceVarSpec & other)
{
  BindersReentranceVarSpec tmp(other);
  swap(tmp);
  return *this;
}

void BindersReentranceVarSpec::swap(BindersReentranceVarSpec & other)
{
  std::swap(varspec_, other.varspec_);

}

BindersReentranceVarSpec::~BindersReentranceVarSpec()
{
  delete(varspec_);

}

void BindersReentranceVarSpec::accept(Visitor *v)
{
  v->visitBindersReentranceVarSpec(this);
}

BindersReentranceVarSpec *BindersReentranceVarSpec::clone() const
{
  return new BindersReentranceVarSpec(*this);
}



/********************   StartVarSpec    ********************/
StartVarSpec::StartVarSpec(ListStars *p1, VarSpec *p2)
{
  liststars_ = p1;
  varspec_ = p2;

}

StartVarSpec::StartVarSpec(const StartVarSpec & other)
{
  liststars_ = other.liststars_->clone();
  varspec_ = other.varspec_->clone();

}

StartVarSpec &StartVarSpec::operator=(const StartVarSpec & other)
{
  StartVarSpec tmp(other);
  swap(tmp);
  return *this;
}

void StartVarSpec::swap(StartVarSpec & other)
{
  std::swap(liststars_, other.liststars_);
  std::swap(varspec_, other.varspec_);

}

StartVarSpec::~StartVarSpec()
{
  delete(liststars_);
  delete(varspec_);

}

void StartVarSpec::accept(Visitor *v)
{
  v->visitStartVarSpec(this);
}

StartVarSpec *StartVarSpec::clone() const
{
  return new StartVarSpec(*this);
}



/********************   SimpleSpec    ********************/
SimpleSpec::SimpleSpec(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

SimpleSpec::SimpleSpec(const SimpleSpec & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

SimpleSpec &SimpleSpec::operator=(const SimpleSpec & other)
{
  SimpleSpec tmp(other);
  swap(tmp);
  return *this;
}

void SimpleSpec::swap(SimpleSpec & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

SimpleSpec::~SimpleSpec()
{
  delete(fullidentifier_);

}

void SimpleSpec::accept(Visitor *v)
{
  v->visitSimpleSpec(this);
}

SimpleSpec *SimpleSpec::clone() const
{
  return new SimpleSpec(*this);
}



/********************   ArraySpec    ********************/
ArraySpec::ArraySpec(VarSpec *p1, ArraySize *p2)
{
  varspec_ = p1;
  arraysize_ = p2;

}

ArraySpec::ArraySpec(const ArraySpec & other)
{
  varspec_ = other.varspec_->clone();
  arraysize_ = other.arraysize_->clone();

}

ArraySpec &ArraySpec::operator=(const ArraySpec & other)
{
  ArraySpec tmp(other);
  swap(tmp);
  return *this;
}

void ArraySpec::swap(ArraySpec & other)
{
  std::swap(varspec_, other.varspec_);
  std::swap(arraysize_, other.arraysize_);

}

ArraySpec::~ArraySpec()
{
  delete(varspec_);
  delete(arraysize_);

}

void ArraySpec::accept(Visitor *v)
{
  v->visitArraySpec(this);
}

ArraySpec *ArraySpec::clone() const
{
  return new ArraySpec(*this);
}



/********************   Star    ********************/
Star::Star()
{

}

Star::Star(const Star & other)
{

}

Star &Star::operator=(const Star & other)
{
  Star tmp(other);
  swap(tmp);
  return *this;
}

void Star::swap(Star & other)
{

}

Star::~Star()
{

}

void Star::accept(Visitor *v)
{
  v->visitStar(this);
}

Star *Star::clone() const
{
  return new Star(*this);
}



/********************   IntConstArraySize    ********************/
IntConstArraySize::IntConstArraySize(Integer p1)
{
  integer_ = p1;

}

IntConstArraySize::IntConstArraySize(const IntConstArraySize & other)
{
  integer_ = other.integer_;

}

IntConstArraySize &IntConstArraySize::operator=(const IntConstArraySize & other)
{
  IntConstArraySize tmp(other);
  swap(tmp);
  return *this;
}

void IntConstArraySize::swap(IntConstArraySize & other)
{
  std::swap(integer_, other.integer_);

}

IntConstArraySize::~IntConstArraySize()
{

}

void IntConstArraySize::accept(Visitor *v)
{
  v->visitIntConstArraySize(this);
}

IntConstArraySize *IntConstArraySize::clone() const
{
  return new IntConstArraySize(*this);
}



/********************   SomeArraySize    ********************/
SomeArraySize::SomeArraySize(FullIdentifier *p1)
{
  fullidentifier_ = p1;

}

SomeArraySize::SomeArraySize(const SomeArraySize & other)
{
  fullidentifier_ = other.fullidentifier_->clone();

}

SomeArraySize &SomeArraySize::operator=(const SomeArraySize & other)
{
  SomeArraySize tmp(other);
  swap(tmp);
  return *this;
}

void SomeArraySize::swap(SomeArraySize & other)
{
  std::swap(fullidentifier_, other.fullidentifier_);

}

SomeArraySize::~SomeArraySize()
{
  delete(fullidentifier_);

}

void SomeArraySize::accept(Visitor *v)
{
  v->visitSomeArraySize(this);
}

SomeArraySize *SomeArraySize::clone() const
{
  return new SomeArraySize(*this);
}



/********************   NoSize    ********************/
NoSize::NoSize()
{

}

NoSize::NoSize(const NoSize & other)
{

}

NoSize &NoSize::operator=(const NoSize & other)
{
  NoSize tmp(other);
  swap(tmp);
  return *this;
}

void NoSize::swap(NoSize & other)
{

}

NoSize::~NoSize()
{

}

void NoSize::accept(Visitor *v)
{
  v->visitNoSize(this);
}

NoSize *NoSize::clone() const
{
  return new NoSize(*this);
}



/********************   OptLabelOne    ********************/
OptLabelOne::OptLabelOne(OptLabelList *p1)
{
  optlabellist_ = p1;

}

OptLabelOne::OptLabelOne(const OptLabelOne & other)
{
  optlabellist_ = other.optlabellist_->clone();

}

OptLabelOne &OptLabelOne::operator=(const OptLabelOne & other)
{
  OptLabelOne tmp(other);
  swap(tmp);
  return *this;
}

void OptLabelOne::swap(OptLabelOne & other)
{
  std::swap(optlabellist_, other.optlabellist_);

}

OptLabelOne::~OptLabelOne()
{
  delete(optlabellist_);

}

void OptLabelOne::accept(Visitor *v)
{
  v->visitOptLabelOne(this);
}

OptLabelOne *OptLabelOne::clone() const
{
  return new OptLabelOne(*this);
}



/********************   OptLabelTwo    ********************/
OptLabelTwo::OptLabelTwo(OptLabelList *p1)
{
  optlabellist_ = p1;

}

OptLabelTwo::OptLabelTwo(const OptLabelTwo & other)
{
  optlabellist_ = other.optlabellist_->clone();

}

OptLabelTwo &OptLabelTwo::operator=(const OptLabelTwo & other)
{
  OptLabelTwo tmp(other);
  swap(tmp);
  return *this;
}

void OptLabelTwo::swap(OptLabelTwo & other)
{
  std::swap(optlabellist_, other.optlabellist_);

}

OptLabelTwo::~OptLabelTwo()
{
  delete(optlabellist_);

}

void OptLabelTwo::accept(Visitor *v)
{
  v->visitOptLabelTwo(this);
}

OptLabelTwo *OptLabelTwo::clone() const
{
  return new OptLabelTwo(*this);
}



/********************   NoLableList    ********************/
NoLableList::NoLableList()
{

}

NoLableList::NoLableList(const NoLableList & other)
{

}

NoLableList &NoLableList::operator=(const NoLableList & other)
{
  NoLableList tmp(other);
  swap(tmp);
  return *this;
}

void NoLableList::swap(NoLableList & other)
{

}

NoLableList::~NoLableList()
{

}

void NoLableList::accept(Visitor *v)
{
  v->visitNoLableList(this);
}

NoLableList *NoLableList::clone() const
{
  return new NoLableList(*this);
}



/********************   LableList    ********************/
LableList::LableList(ListLabelName *p1)
{
  listlabelname_ = p1;

}

LableList::LableList(const LableList & other)
{
  listlabelname_ = other.listlabelname_->clone();

}

LableList &LableList::operator=(const LableList & other)
{
  LableList tmp(other);
  swap(tmp);
  return *this;
}

void LableList::swap(LableList & other)
{
  std::swap(listlabelname_, other.listlabelname_);

}

LableList::~LableList()
{
  delete(listlabelname_);

}

void LableList::accept(Visitor *v)
{
  v->visitLableList(this);
}

LableList *LableList::clone() const
{
  return new LableList(*this);
}



/********************   LableName    ********************/
LableName::LableName(AnyIdentifier *p1)
{
  anyidentifier_ = p1;

}

LableName::LableName(const LableName & other)
{
  anyidentifier_ = other.anyidentifier_->clone();

}

LableName &LableName::operator=(const LableName & other)
{
  LableName tmp(other);
  swap(tmp);
  return *this;
}

void LableName::swap(LableName & other)
{
  std::swap(anyidentifier_, other.anyidentifier_);

}

LableName::~LableName()
{
  delete(anyidentifier_);

}

void LableName::accept(Visitor *v)
{
  v->visitLableName(this);
}

LableName *LableName::clone() const
{
  return new LableName(*this);
}



/********************   LexprRange    ********************/
LexprRange::LexprRange(LexprOption *p1, LexprOption *p2)
{
  lexproption_1 = p1;
  lexproption_2 = p2;

}

LexprRange::LexprRange(const LexprRange & other)
{
  lexproption_1 = other.lexproption_1->clone();
  lexproption_2 = other.lexproption_2->clone();

}

LexprRange &LexprRange::operator=(const LexprRange & other)
{
  LexprRange tmp(other);
  swap(tmp);
  return *this;
}

void LexprRange::swap(LexprRange & other)
{
  std::swap(lexproption_1, other.lexproption_1);
  std::swap(lexproption_2, other.lexproption_2);

}

LexprRange::~LexprRange()
{
  delete(lexproption_1);
  delete(lexproption_2);

}

void LexprRange::accept(Visitor *v)
{
  v->visitLexprRange(this);
}

LexprRange *LexprRange::clone() const
{
  return new LexprRange(*this);
}



/********************   NoLexprOption    ********************/
NoLexprOption::NoLexprOption()
{

}

NoLexprOption::NoLexprOption(const NoLexprOption & other)
{

}

NoLexprOption &NoLexprOption::operator=(const NoLexprOption & other)
{
  NoLexprOption tmp(other);
  swap(tmp);
  return *this;
}

void NoLexprOption::swap(NoLexprOption & other)
{

}

NoLexprOption::~NoLexprOption()
{

}

void NoLexprOption::accept(Visitor *v)
{
  v->visitNoLexprOption(this);
}

NoLexprOption *NoLexprOption::clone() const
{
  return new NoLexprOption(*this);
}



/********************   SomeLexprOption    ********************/
SomeLexprOption::SomeLexprOption(Lexpr *p1)
{
  lexpr_ = p1;

}

SomeLexprOption::SomeLexprOption(const SomeLexprOption & other)
{
  lexpr_ = other.lexpr_->clone();

}

SomeLexprOption &SomeLexprOption::operator=(const SomeLexprOption & other)
{
  SomeLexprOption tmp(other);
  swap(tmp);
  return *this;
}

void SomeLexprOption::swap(SomeLexprOption & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SomeLexprOption::~SomeLexprOption()
{
  delete(lexpr_);

}

void SomeLexprOption::accept(Visitor *v)
{
  v->visitSomeLexprOption(this);
}

SomeLexprOption *SomeLexprOption::clone() const
{
  return new SomeLexprOption(*this);
}



/********************   SimpleIdentifierAny    ********************/
SimpleIdentifierAny::SimpleIdentifierAny(Identifier *p1)
{
  identifier_ = p1;

}

SimpleIdentifierAny::SimpleIdentifierAny(const SimpleIdentifierAny & other)
{
  identifier_ = other.identifier_->clone();

}

SimpleIdentifierAny &SimpleIdentifierAny::operator=(const SimpleIdentifierAny & other)
{
  SimpleIdentifierAny tmp(other);
  swap(tmp);
  return *this;
}

void SimpleIdentifierAny::swap(SimpleIdentifierAny & other)
{
  std::swap(identifier_, other.identifier_);

}

SimpleIdentifierAny::~SimpleIdentifierAny()
{
  delete(identifier_);

}

void SimpleIdentifierAny::accept(Visitor *v)
{
  v->visitSimpleIdentifierAny(this);
}

SimpleIdentifierAny *SimpleIdentifierAny::clone() const
{
  return new SimpleIdentifierAny(*this);
}



/********************   EnsuresKeyWord    ********************/
EnsuresKeyWord::EnsuresKeyWord()
{

}

EnsuresKeyWord::EnsuresKeyWord(const EnsuresKeyWord & other)
{

}

EnsuresKeyWord &EnsuresKeyWord::operator=(const EnsuresKeyWord & other)
{
  EnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void EnsuresKeyWord::swap(EnsuresKeyWord & other)
{

}

EnsuresKeyWord::~EnsuresKeyWord()
{

}

void EnsuresKeyWord::accept(Visitor *v)
{
  v->visitEnsuresKeyWord(this);
}

EnsuresKeyWord *EnsuresKeyWord::clone() const
{
  return new EnsuresKeyWord(*this);
}



/********************   ExitsKeyWord    ********************/
ExitsKeyWord::ExitsKeyWord()
{

}

ExitsKeyWord::ExitsKeyWord(const ExitsKeyWord & other)
{

}

ExitsKeyWord &ExitsKeyWord::operator=(const ExitsKeyWord & other)
{
  ExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ExitsKeyWord::swap(ExitsKeyWord & other)
{

}

ExitsKeyWord::~ExitsKeyWord()
{

}

void ExitsKeyWord::accept(Visitor *v)
{
  v->visitExitsKeyWord(this);
}

ExitsKeyWord *ExitsKeyWord::clone() const
{
  return new ExitsKeyWord(*this);
}



/********************   BreaksKeyWord    ********************/
BreaksKeyWord::BreaksKeyWord()
{

}

BreaksKeyWord::BreaksKeyWord(const BreaksKeyWord & other)
{

}

BreaksKeyWord &BreaksKeyWord::operator=(const BreaksKeyWord & other)
{
  BreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void BreaksKeyWord::swap(BreaksKeyWord & other)
{

}

BreaksKeyWord::~BreaksKeyWord()
{

}

void BreaksKeyWord::accept(Visitor *v)
{
  v->visitBreaksKeyWord(this);
}

BreaksKeyWord *BreaksKeyWord::clone() const
{
  return new BreaksKeyWord(*this);
}



/********************   ContinuesKeyWord    ********************/
ContinuesKeyWord::ContinuesKeyWord()
{

}

ContinuesKeyWord::ContinuesKeyWord(const ContinuesKeyWord & other)
{

}

ContinuesKeyWord &ContinuesKeyWord::operator=(const ContinuesKeyWord & other)
{
  ContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ContinuesKeyWord::swap(ContinuesKeyWord & other)
{

}

ContinuesKeyWord::~ContinuesKeyWord()
{

}

void ContinuesKeyWord::accept(Visitor *v)
{
  v->visitContinuesKeyWord(this);
}

ContinuesKeyWord *ContinuesKeyWord::clone() const
{
  return new ContinuesKeyWord(*this);
}



/********************   ReturnsKeyWord    ********************/
ReturnsKeyWord::ReturnsKeyWord()
{

}

ReturnsKeyWord::ReturnsKeyWord(const ReturnsKeyWord & other)
{

}

ReturnsKeyWord &ReturnsKeyWord::operator=(const ReturnsKeyWord & other)
{
  ReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void ReturnsKeyWord::swap(ReturnsKeyWord & other)
{

}

ReturnsKeyWord::~ReturnsKeyWord()
{

}

void ReturnsKeyWord::accept(Visitor *v)
{
  v->visitReturnsKeyWord(this);
}

ReturnsKeyWord *ReturnsKeyWord::clone() const
{
  return new ReturnsKeyWord(*this);
}



/********************   CheckEnsuresKeyWord    ********************/
CheckEnsuresKeyWord::CheckEnsuresKeyWord()
{

}

CheckEnsuresKeyWord::CheckEnsuresKeyWord(const CheckEnsuresKeyWord & other)
{

}

CheckEnsuresKeyWord &CheckEnsuresKeyWord::operator=(const CheckEnsuresKeyWord & other)
{
  CheckEnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckEnsuresKeyWord::swap(CheckEnsuresKeyWord & other)
{

}

CheckEnsuresKeyWord::~CheckEnsuresKeyWord()
{

}

void CheckEnsuresKeyWord::accept(Visitor *v)
{
  v->visitCheckEnsuresKeyWord(this);
}

CheckEnsuresKeyWord *CheckEnsuresKeyWord::clone() const
{
  return new CheckEnsuresKeyWord(*this);
}



/********************   CheckExitsKeyWord    ********************/
CheckExitsKeyWord::CheckExitsKeyWord()
{

}

CheckExitsKeyWord::CheckExitsKeyWord(const CheckExitsKeyWord & other)
{

}

CheckExitsKeyWord &CheckExitsKeyWord::operator=(const CheckExitsKeyWord & other)
{
  CheckExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckExitsKeyWord::swap(CheckExitsKeyWord & other)
{

}

CheckExitsKeyWord::~CheckExitsKeyWord()
{

}

void CheckExitsKeyWord::accept(Visitor *v)
{
  v->visitCheckExitsKeyWord(this);
}

CheckExitsKeyWord *CheckExitsKeyWord::clone() const
{
  return new CheckExitsKeyWord(*this);
}



/********************   CheckBreaksKeyWord    ********************/
CheckBreaksKeyWord::CheckBreaksKeyWord()
{

}

CheckBreaksKeyWord::CheckBreaksKeyWord(const CheckBreaksKeyWord & other)
{

}

CheckBreaksKeyWord &CheckBreaksKeyWord::operator=(const CheckBreaksKeyWord & other)
{
  CheckBreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckBreaksKeyWord::swap(CheckBreaksKeyWord & other)
{

}

CheckBreaksKeyWord::~CheckBreaksKeyWord()
{

}

void CheckBreaksKeyWord::accept(Visitor *v)
{
  v->visitCheckBreaksKeyWord(this);
}

CheckBreaksKeyWord *CheckBreaksKeyWord::clone() const
{
  return new CheckBreaksKeyWord(*this);
}



/********************   CheckContinuesKeyWord    ********************/
CheckContinuesKeyWord::CheckContinuesKeyWord()
{

}

CheckContinuesKeyWord::CheckContinuesKeyWord(const CheckContinuesKeyWord & other)
{

}

CheckContinuesKeyWord &CheckContinuesKeyWord::operator=(const CheckContinuesKeyWord & other)
{
  CheckContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckContinuesKeyWord::swap(CheckContinuesKeyWord & other)
{

}

CheckContinuesKeyWord::~CheckContinuesKeyWord()
{

}

void CheckContinuesKeyWord::accept(Visitor *v)
{
  v->visitCheckContinuesKeyWord(this);
}

CheckContinuesKeyWord *CheckContinuesKeyWord::clone() const
{
  return new CheckContinuesKeyWord(*this);
}



/********************   CheckReturnsKeyWord    ********************/
CheckReturnsKeyWord::CheckReturnsKeyWord()
{

}

CheckReturnsKeyWord::CheckReturnsKeyWord(const CheckReturnsKeyWord & other)
{

}

CheckReturnsKeyWord &CheckReturnsKeyWord::operator=(const CheckReturnsKeyWord & other)
{
  CheckReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void CheckReturnsKeyWord::swap(CheckReturnsKeyWord & other)
{

}

CheckReturnsKeyWord::~CheckReturnsKeyWord()
{

}

void CheckReturnsKeyWord::accept(Visitor *v)
{
  v->visitCheckReturnsKeyWord(this);
}

CheckReturnsKeyWord *CheckReturnsKeyWord::clone() const
{
  return new CheckReturnsKeyWord(*this);
}



/********************   AdmitEnsuresKeyWord    ********************/
AdmitEnsuresKeyWord::AdmitEnsuresKeyWord()
{

}

AdmitEnsuresKeyWord::AdmitEnsuresKeyWord(const AdmitEnsuresKeyWord & other)
{

}

AdmitEnsuresKeyWord &AdmitEnsuresKeyWord::operator=(const AdmitEnsuresKeyWord & other)
{
  AdmitEnsuresKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitEnsuresKeyWord::swap(AdmitEnsuresKeyWord & other)
{

}

AdmitEnsuresKeyWord::~AdmitEnsuresKeyWord()
{

}

void AdmitEnsuresKeyWord::accept(Visitor *v)
{
  v->visitAdmitEnsuresKeyWord(this);
}

AdmitEnsuresKeyWord *AdmitEnsuresKeyWord::clone() const
{
  return new AdmitEnsuresKeyWord(*this);
}



/********************   AdmitExitsKeyWord    ********************/
AdmitExitsKeyWord::AdmitExitsKeyWord()
{

}

AdmitExitsKeyWord::AdmitExitsKeyWord(const AdmitExitsKeyWord & other)
{

}

AdmitExitsKeyWord &AdmitExitsKeyWord::operator=(const AdmitExitsKeyWord & other)
{
  AdmitExitsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitExitsKeyWord::swap(AdmitExitsKeyWord & other)
{

}

AdmitExitsKeyWord::~AdmitExitsKeyWord()
{

}

void AdmitExitsKeyWord::accept(Visitor *v)
{
  v->visitAdmitExitsKeyWord(this);
}

AdmitExitsKeyWord *AdmitExitsKeyWord::clone() const
{
  return new AdmitExitsKeyWord(*this);
}



/********************   AdmitBreaksKeyWord    ********************/
AdmitBreaksKeyWord::AdmitBreaksKeyWord()
{

}

AdmitBreaksKeyWord::AdmitBreaksKeyWord(const AdmitBreaksKeyWord & other)
{

}

AdmitBreaksKeyWord &AdmitBreaksKeyWord::operator=(const AdmitBreaksKeyWord & other)
{
  AdmitBreaksKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitBreaksKeyWord::swap(AdmitBreaksKeyWord & other)
{

}

AdmitBreaksKeyWord::~AdmitBreaksKeyWord()
{

}

void AdmitBreaksKeyWord::accept(Visitor *v)
{
  v->visitAdmitBreaksKeyWord(this);
}

AdmitBreaksKeyWord *AdmitBreaksKeyWord::clone() const
{
  return new AdmitBreaksKeyWord(*this);
}



/********************   AdmitContinuesKeyWord    ********************/
AdmitContinuesKeyWord::AdmitContinuesKeyWord()
{

}

AdmitContinuesKeyWord::AdmitContinuesKeyWord(const AdmitContinuesKeyWord & other)
{

}

AdmitContinuesKeyWord &AdmitContinuesKeyWord::operator=(const AdmitContinuesKeyWord & other)
{
  AdmitContinuesKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitContinuesKeyWord::swap(AdmitContinuesKeyWord & other)
{

}

AdmitContinuesKeyWord::~AdmitContinuesKeyWord()
{

}

void AdmitContinuesKeyWord::accept(Visitor *v)
{
  v->visitAdmitContinuesKeyWord(this);
}

AdmitContinuesKeyWord *AdmitContinuesKeyWord::clone() const
{
  return new AdmitContinuesKeyWord(*this);
}



/********************   AdmitReturnsKeyWord    ********************/
AdmitReturnsKeyWord::AdmitReturnsKeyWord()
{

}

AdmitReturnsKeyWord::AdmitReturnsKeyWord(const AdmitReturnsKeyWord & other)
{

}

AdmitReturnsKeyWord &AdmitReturnsKeyWord::operator=(const AdmitReturnsKeyWord & other)
{
  AdmitReturnsKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void AdmitReturnsKeyWord::swap(AdmitReturnsKeyWord & other)
{

}

AdmitReturnsKeyWord::~AdmitReturnsKeyWord()
{

}

void AdmitReturnsKeyWord::accept(Visitor *v)
{
  v->visitAdmitReturnsKeyWord(this);
}

AdmitReturnsKeyWord *AdmitReturnsKeyWord::clone() const
{
  return new AdmitReturnsKeyWord(*this);
}



/********************   SimpleIdentifierFull    ********************/
SimpleIdentifierFull::SimpleIdentifierFull(Identifier *p1)
{
  identifier_ = p1;

}

SimpleIdentifierFull::SimpleIdentifierFull(const SimpleIdentifierFull & other)
{
  identifier_ = other.identifier_->clone();

}

SimpleIdentifierFull &SimpleIdentifierFull::operator=(const SimpleIdentifierFull & other)
{
  SimpleIdentifierFull tmp(other);
  swap(tmp);
  return *this;
}

void SimpleIdentifierFull::swap(SimpleIdentifierFull & other)
{
  std::swap(identifier_, other.identifier_);

}

SimpleIdentifierFull::~SimpleIdentifierFull()
{
  delete(identifier_);

}

void SimpleIdentifierFull::accept(Visitor *v)
{
  v->visitSimpleIdentifierFull(this);
}

SimpleIdentifierFull *SimpleIdentifierFull::clone() const
{
  return new SimpleIdentifierFull(*this);
}



/********************   IdentifierIdent    ********************/
IdentifierIdent::IdentifierIdent(Ident p1)
{
  ident_ = p1;

}

IdentifierIdent::IdentifierIdent(const IdentifierIdent & other)
{
  ident_ = other.ident_;

}

IdentifierIdent &IdentifierIdent::operator=(const IdentifierIdent & other)
{
  IdentifierIdent tmp(other);
  swap(tmp);
  return *this;
}

void IdentifierIdent::swap(IdentifierIdent & other)
{
  std::swap(ident_, other.ident_);

}

IdentifierIdent::~IdentifierIdent()
{

}

void IdentifierIdent::accept(Visitor *v)
{
  v->visitIdentifierIdent(this);
}

IdentifierIdent *IdentifierIdent::clone() const
{
  return new IdentifierIdent(*this);
}



/********************   TypeSpecSimpleIntegerKeyWord    ********************/
TypeSpecSimpleIntegerKeyWord::TypeSpecSimpleIntegerKeyWord()
{

}

TypeSpecSimpleIntegerKeyWord::TypeSpecSimpleIntegerKeyWord(const TypeSpecSimpleIntegerKeyWord & other)
{

}

TypeSpecSimpleIntegerKeyWord &TypeSpecSimpleIntegerKeyWord::operator=(const TypeSpecSimpleIntegerKeyWord & other)
{
  TypeSpecSimpleIntegerKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleIntegerKeyWord::swap(TypeSpecSimpleIntegerKeyWord & other)
{

}

TypeSpecSimpleIntegerKeyWord::~TypeSpecSimpleIntegerKeyWord()
{

}

void TypeSpecSimpleIntegerKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleIntegerKeyWord(this);
}

TypeSpecSimpleIntegerKeyWord *TypeSpecSimpleIntegerKeyWord::clone() const
{
  return new TypeSpecSimpleIntegerKeyWord(*this);
}



/********************   TypeSpecSimpleRealKeyWord    ********************/
TypeSpecSimpleRealKeyWord::TypeSpecSimpleRealKeyWord()
{

}

TypeSpecSimpleRealKeyWord::TypeSpecSimpleRealKeyWord(const TypeSpecSimpleRealKeyWord & other)
{

}

TypeSpecSimpleRealKeyWord &TypeSpecSimpleRealKeyWord::operator=(const TypeSpecSimpleRealKeyWord & other)
{
  TypeSpecSimpleRealKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleRealKeyWord::swap(TypeSpecSimpleRealKeyWord & other)
{

}

TypeSpecSimpleRealKeyWord::~TypeSpecSimpleRealKeyWord()
{

}

void TypeSpecSimpleRealKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleRealKeyWord(this);
}

TypeSpecSimpleRealKeyWord *TypeSpecSimpleRealKeyWord::clone() const
{
  return new TypeSpecSimpleRealKeyWord(*this);
}



/********************   TypeSpecSimpleBooleanKeyWord    ********************/
TypeSpecSimpleBooleanKeyWord::TypeSpecSimpleBooleanKeyWord()
{

}

TypeSpecSimpleBooleanKeyWord::TypeSpecSimpleBooleanKeyWord(const TypeSpecSimpleBooleanKeyWord & other)
{

}

TypeSpecSimpleBooleanKeyWord &TypeSpecSimpleBooleanKeyWord::operator=(const TypeSpecSimpleBooleanKeyWord & other)
{
  TypeSpecSimpleBooleanKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleBooleanKeyWord::swap(TypeSpecSimpleBooleanKeyWord & other)
{

}

TypeSpecSimpleBooleanKeyWord::~TypeSpecSimpleBooleanKeyWord()
{

}

void TypeSpecSimpleBooleanKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleBooleanKeyWord(this);
}

TypeSpecSimpleBooleanKeyWord *TypeSpecSimpleBooleanKeyWord::clone() const
{
  return new TypeSpecSimpleBooleanKeyWord(*this);
}



/********************   TypeSpecSimpleVoidKeyWord    ********************/
TypeSpecSimpleVoidKeyWord::TypeSpecSimpleVoidKeyWord()
{

}

TypeSpecSimpleVoidKeyWord::TypeSpecSimpleVoidKeyWord(const TypeSpecSimpleVoidKeyWord & other)
{

}

TypeSpecSimpleVoidKeyWord &TypeSpecSimpleVoidKeyWord::operator=(const TypeSpecSimpleVoidKeyWord & other)
{
  TypeSpecSimpleVoidKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleVoidKeyWord::swap(TypeSpecSimpleVoidKeyWord & other)
{

}

TypeSpecSimpleVoidKeyWord::~TypeSpecSimpleVoidKeyWord()
{

}

void TypeSpecSimpleVoidKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleVoidKeyWord(this);
}

TypeSpecSimpleVoidKeyWord *TypeSpecSimpleVoidKeyWord::clone() const
{
  return new TypeSpecSimpleVoidKeyWord(*this);
}



/********************   TypeSpecSimpleBoolKeyWord    ********************/
TypeSpecSimpleBoolKeyWord::TypeSpecSimpleBoolKeyWord()
{

}

TypeSpecSimpleBoolKeyWord::TypeSpecSimpleBoolKeyWord(const TypeSpecSimpleBoolKeyWord & other)
{

}

TypeSpecSimpleBoolKeyWord &TypeSpecSimpleBoolKeyWord::operator=(const TypeSpecSimpleBoolKeyWord & other)
{
  TypeSpecSimpleBoolKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleBoolKeyWord::swap(TypeSpecSimpleBoolKeyWord & other)
{

}

TypeSpecSimpleBoolKeyWord::~TypeSpecSimpleBoolKeyWord()
{

}

void TypeSpecSimpleBoolKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleBoolKeyWord(this);
}

TypeSpecSimpleBoolKeyWord *TypeSpecSimpleBoolKeyWord::clone() const
{
  return new TypeSpecSimpleBoolKeyWord(*this);
}



/********************   TypeSpecSimpleCharKeyWord    ********************/
TypeSpecSimpleCharKeyWord::TypeSpecSimpleCharKeyWord()
{

}

TypeSpecSimpleCharKeyWord::TypeSpecSimpleCharKeyWord(const TypeSpecSimpleCharKeyWord & other)
{

}

TypeSpecSimpleCharKeyWord &TypeSpecSimpleCharKeyWord::operator=(const TypeSpecSimpleCharKeyWord & other)
{
  TypeSpecSimpleCharKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleCharKeyWord::swap(TypeSpecSimpleCharKeyWord & other)
{

}

TypeSpecSimpleCharKeyWord::~TypeSpecSimpleCharKeyWord()
{

}

void TypeSpecSimpleCharKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleCharKeyWord(this);
}

TypeSpecSimpleCharKeyWord *TypeSpecSimpleCharKeyWord::clone() const
{
  return new TypeSpecSimpleCharKeyWord(*this);
}



/********************   TypeSpecSimpleIntKeyWord    ********************/
TypeSpecSimpleIntKeyWord::TypeSpecSimpleIntKeyWord()
{

}

TypeSpecSimpleIntKeyWord::TypeSpecSimpleIntKeyWord(const TypeSpecSimpleIntKeyWord & other)
{

}

TypeSpecSimpleIntKeyWord &TypeSpecSimpleIntKeyWord::operator=(const TypeSpecSimpleIntKeyWord & other)
{
  TypeSpecSimpleIntKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleIntKeyWord::swap(TypeSpecSimpleIntKeyWord & other)
{

}

TypeSpecSimpleIntKeyWord::~TypeSpecSimpleIntKeyWord()
{

}

void TypeSpecSimpleIntKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleIntKeyWord(this);
}

TypeSpecSimpleIntKeyWord *TypeSpecSimpleIntKeyWord::clone() const
{
  return new TypeSpecSimpleIntKeyWord(*this);
}



/********************   TypeSpecSimpleDoubleKeyWord    ********************/
TypeSpecSimpleDoubleKeyWord::TypeSpecSimpleDoubleKeyWord()
{

}

TypeSpecSimpleDoubleKeyWord::TypeSpecSimpleDoubleKeyWord(const TypeSpecSimpleDoubleKeyWord & other)
{

}

TypeSpecSimpleDoubleKeyWord &TypeSpecSimpleDoubleKeyWord::operator=(const TypeSpecSimpleDoubleKeyWord & other)
{
  TypeSpecSimpleDoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleDoubleKeyWord::swap(TypeSpecSimpleDoubleKeyWord & other)
{

}

TypeSpecSimpleDoubleKeyWord::~TypeSpecSimpleDoubleKeyWord()
{

}

void TypeSpecSimpleDoubleKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleDoubleKeyWord(this);
}

TypeSpecSimpleDoubleKeyWord *TypeSpecSimpleDoubleKeyWord::clone() const
{
  return new TypeSpecSimpleDoubleKeyWord(*this);
}



/********************   TypeSpecSimpleLongDoubleKeyWord    ********************/
TypeSpecSimpleLongDoubleKeyWord::TypeSpecSimpleLongDoubleKeyWord()
{

}

TypeSpecSimpleLongDoubleKeyWord::TypeSpecSimpleLongDoubleKeyWord(const TypeSpecSimpleLongDoubleKeyWord & other)
{

}

TypeSpecSimpleLongDoubleKeyWord &TypeSpecSimpleLongDoubleKeyWord::operator=(const TypeSpecSimpleLongDoubleKeyWord & other)
{
  TypeSpecSimpleLongDoubleKeyWord tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpecSimpleLongDoubleKeyWord::swap(TypeSpecSimpleLongDoubleKeyWord & other)
{

}

TypeSpecSimpleLongDoubleKeyWord::~TypeSpecSimpleLongDoubleKeyWord()
{

}

void TypeSpecSimpleLongDoubleKeyWord::accept(Visitor *v)
{
  v->visitTypeSpecSimpleLongDoubleKeyWord(this);
}

TypeSpecSimpleLongDoubleKeyWord *TypeSpecSimpleLongDoubleKeyWord::clone() const
{
  return new TypeSpecSimpleLongDoubleKeyWord(*this);
}



/********************   AnAnnotation    ********************/
AnAnnotation::AnAnnotation(Annotation *p1)
{
  annotation_ = p1;

}

AnAnnotation::AnAnnotation(const AnAnnotation & other)
{
  annotation_ = other.annotation_->clone();

}

AnAnnotation &AnAnnotation::operator=(const AnAnnotation & other)
{
  AnAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void AnAnnotation::swap(AnAnnotation & other)
{
  std::swap(annotation_, other.annotation_);

}

AnAnnotation::~AnAnnotation()
{
  delete(annotation_);

}

void AnAnnotation::accept(Visitor *v)
{
  v->visitAnAnnotation(this);
}

AnAnnotation *AnAnnotation::clone() const
{
  return new AnAnnotation(*this);
}



/********************   LoopAnnotation    ********************/
LoopAnnotation::LoopAnnotation(LoopAnnotStack *p1)
{
  loopannotstack_ = p1;

}

LoopAnnotation::LoopAnnotation(const LoopAnnotation & other)
{
  loopannotstack_ = other.loopannotstack_->clone();

}

LoopAnnotation &LoopAnnotation::operator=(const LoopAnnotation & other)
{
  LoopAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotation::swap(LoopAnnotation & other)
{
  std::swap(loopannotstack_, other.loopannotstack_);

}

LoopAnnotation::~LoopAnnotation()
{
  delete(loopannotstack_);

}

void LoopAnnotation::accept(Visitor *v)
{
  v->visitLoopAnnotation(this);
}

LoopAnnotation *LoopAnnotation::clone() const
{
  return new LoopAnnotation(*this);
}



/********************   LoopAnnotStackInvariant    ********************/
LoopAnnotStackInvariant::LoopAnnotStackInvariant(LoopInvariant *p1, LoopAnnotOpt *p2)
{
  loopinvariant_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackInvariant::LoopAnnotStackInvariant(const LoopAnnotStackInvariant & other)
{
  loopinvariant_ = other.loopinvariant_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackInvariant &LoopAnnotStackInvariant::operator=(const LoopAnnotStackInvariant & other)
{
  LoopAnnotStackInvariant tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackInvariant::swap(LoopAnnotStackInvariant & other)
{
  std::swap(loopinvariant_, other.loopinvariant_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackInvariant::~LoopAnnotStackInvariant()
{
  delete(loopinvariant_);
  delete(loopannotopt_);

}

void LoopAnnotStackInvariant::accept(Visitor *v)
{
  v->visitLoopAnnotStackInvariant(this);
}

LoopAnnotStackInvariant *LoopAnnotStackInvariant::clone() const
{
  return new LoopAnnotStackInvariant(*this);
}



/********************   LoopAnnotStackEffects    ********************/
LoopAnnotStackEffects::LoopAnnotStackEffects(LoopEffects *p1, LoopAnnotOpt *p2)
{
  loopeffects_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackEffects::LoopAnnotStackEffects(const LoopAnnotStackEffects & other)
{
  loopeffects_ = other.loopeffects_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackEffects &LoopAnnotStackEffects::operator=(const LoopAnnotStackEffects & other)
{
  LoopAnnotStackEffects tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackEffects::swap(LoopAnnotStackEffects & other)
{
  std::swap(loopeffects_, other.loopeffects_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackEffects::~LoopAnnotStackEffects()
{
  delete(loopeffects_);
  delete(loopannotopt_);

}

void LoopAnnotStackEffects::accept(Visitor *v)
{
  v->visitLoopAnnotStackEffects(this);
}

LoopAnnotStackEffects *LoopAnnotStackEffects::clone() const
{
  return new LoopAnnotStackEffects(*this);
}



/********************   LoopAnnotStackVariant    ********************/
LoopAnnotStackVariant::LoopAnnotStackVariant(LoopVariant *p1, LoopAnnotOpt *p2)
{
  loopvariant_ = p1;
  loopannotopt_ = p2;

}

LoopAnnotStackVariant::LoopAnnotStackVariant(const LoopAnnotStackVariant & other)
{
  loopvariant_ = other.loopvariant_->clone();
  loopannotopt_ = other.loopannotopt_->clone();

}

LoopAnnotStackVariant &LoopAnnotStackVariant::operator=(const LoopAnnotStackVariant & other)
{
  LoopAnnotStackVariant tmp(other);
  swap(tmp);
  return *this;
}

void LoopAnnotStackVariant::swap(LoopAnnotStackVariant & other)
{
  std::swap(loopvariant_, other.loopvariant_);
  std::swap(loopannotopt_, other.loopannotopt_);

}

LoopAnnotStackVariant::~LoopAnnotStackVariant()
{
  delete(loopvariant_);
  delete(loopannotopt_);

}

void LoopAnnotStackVariant::accept(Visitor *v)
{
  v->visitLoopAnnotStackVariant(this);
}

LoopAnnotStackVariant *LoopAnnotStackVariant::clone() const
{
  return new LoopAnnotStackVariant(*this);
}



/********************   NoLoopAnnot    ********************/
NoLoopAnnot::NoLoopAnnot()
{

}

NoLoopAnnot::NoLoopAnnot(const NoLoopAnnot & other)
{

}

NoLoopAnnot &NoLoopAnnot::operator=(const NoLoopAnnot & other)
{
  NoLoopAnnot tmp(other);
  swap(tmp);
  return *this;
}

void NoLoopAnnot::swap(NoLoopAnnot & other)
{

}

NoLoopAnnot::~NoLoopAnnot()
{

}

void NoLoopAnnot::accept(Visitor *v)
{
  v->visitNoLoopAnnot(this);
}

NoLoopAnnot *NoLoopAnnot::clone() const
{
  return new NoLoopAnnot(*this);
}



/********************   SomeLoopAnnot    ********************/
SomeLoopAnnot::SomeLoopAnnot(LoopAnnotStack *p1)
{
  loopannotstack_ = p1;

}

SomeLoopAnnot::SomeLoopAnnot(const SomeLoopAnnot & other)
{
  loopannotstack_ = other.loopannotstack_->clone();

}

SomeLoopAnnot &SomeLoopAnnot::operator=(const SomeLoopAnnot & other)
{
  SomeLoopAnnot tmp(other);
  swap(tmp);
  return *this;
}

void SomeLoopAnnot::swap(SomeLoopAnnot & other)
{
  std::swap(loopannotstack_, other.loopannotstack_);

}

SomeLoopAnnot::~SomeLoopAnnot()
{
  delete(loopannotstack_);

}

void SomeLoopAnnot::accept(Visitor *v)
{
  v->visitSomeLoopAnnot(this);
}

SomeLoopAnnot *SomeLoopAnnot::clone() const
{
  return new SomeLoopAnnot(*this);
}



/********************   SimpleLoopInvariant    ********************/
SimpleLoopInvariant::SimpleLoopInvariant(Lexpr *p1)
{
  lexpr_ = p1;

}

SimpleLoopInvariant::SimpleLoopInvariant(const SimpleLoopInvariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

SimpleLoopInvariant &SimpleLoopInvariant::operator=(const SimpleLoopInvariant & other)
{
  SimpleLoopInvariant tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLoopInvariant::swap(SimpleLoopInvariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

SimpleLoopInvariant::~SimpleLoopInvariant()
{
  delete(lexpr_);

}

void SimpleLoopInvariant::accept(Visitor *v)
{
  v->visitSimpleLoopInvariant(this);
}

SimpleLoopInvariant *SimpleLoopInvariant::clone() const
{
  return new SimpleLoopInvariant(*this);
}



/********************   CheckLoopInvariant    ********************/
CheckLoopInvariant::CheckLoopInvariant(Lexpr *p1)
{
  lexpr_ = p1;

}

CheckLoopInvariant::CheckLoopInvariant(const CheckLoopInvariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

CheckLoopInvariant &CheckLoopInvariant::operator=(const CheckLoopInvariant & other)
{
  CheckLoopInvariant tmp(other);
  swap(tmp);
  return *this;
}

void CheckLoopInvariant::swap(CheckLoopInvariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

CheckLoopInvariant::~CheckLoopInvariant()
{
  delete(lexpr_);

}

void CheckLoopInvariant::accept(Visitor *v)
{
  v->visitCheckLoopInvariant(this);
}

CheckLoopInvariant *CheckLoopInvariant::clone() const
{
  return new CheckLoopInvariant(*this);
}



/********************   AdmitLoopInvariant    ********************/
AdmitLoopInvariant::AdmitLoopInvariant(Lexpr *p1)
{
  lexpr_ = p1;

}

AdmitLoopInvariant::AdmitLoopInvariant(const AdmitLoopInvariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

AdmitLoopInvariant &AdmitLoopInvariant::operator=(const AdmitLoopInvariant & other)
{
  AdmitLoopInvariant tmp(other);
  swap(tmp);
  return *this;
}

void AdmitLoopInvariant::swap(AdmitLoopInvariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

AdmitLoopInvariant::~AdmitLoopInvariant()
{
  delete(lexpr_);

}

void AdmitLoopInvariant::accept(Visitor *v)
{
  v->visitAdmitLoopInvariant(this);
}

AdmitLoopInvariant *AdmitLoopInvariant::clone() const
{
  return new AdmitLoopInvariant(*this);
}



/********************   SimpleLoopVariant    ********************/
SimpleLoopVariant::SimpleLoopVariant(Variant *p1)
{
  variant_ = p1;

}

SimpleLoopVariant::SimpleLoopVariant(const SimpleLoopVariant & other)
{
  variant_ = other.variant_->clone();

}

SimpleLoopVariant &SimpleLoopVariant::operator=(const SimpleLoopVariant & other)
{
  SimpleLoopVariant tmp(other);
  swap(tmp);
  return *this;
}

void SimpleLoopVariant::swap(SimpleLoopVariant & other)
{
  std::swap(variant_, other.variant_);

}

SimpleLoopVariant::~SimpleLoopVariant()
{
  delete(variant_);

}

void SimpleLoopVariant::accept(Visitor *v)
{
  v->visitSimpleLoopVariant(this);
}

SimpleLoopVariant *SimpleLoopVariant::clone() const
{
  return new SimpleLoopVariant(*this);
}



/********************   LoopAssigns    ********************/
LoopAssigns::LoopAssigns(Assigns *p1)
{
  assigns_ = p1;

}

LoopAssigns::LoopAssigns(const LoopAssigns & other)
{
  assigns_ = other.assigns_->clone();

}

LoopAssigns &LoopAssigns::operator=(const LoopAssigns & other)
{
  LoopAssigns tmp(other);
  swap(tmp);
  return *this;
}

void LoopAssigns::swap(LoopAssigns & other)
{
  std::swap(assigns_, other.assigns_);

}

LoopAssigns::~LoopAssigns()
{
  delete(assigns_);

}

void LoopAssigns::accept(Visitor *v)
{
  v->visitLoopAssigns(this);
}

LoopAssigns *LoopAssigns::clone() const
{
  return new LoopAssigns(*this);
}



/********************   ForVariant    ********************/
ForVariant::ForVariant(Lexpr *p1, AnyIdentifier *p2)
{
  lexpr_ = p1;
  anyidentifier_ = p2;

}

ForVariant::ForVariant(const ForVariant & other)
{
  lexpr_ = other.lexpr_->clone();
  anyidentifier_ = other.anyidentifier_->clone();

}

ForVariant &ForVariant::operator=(const ForVariant & other)
{
  ForVariant tmp(other);
  swap(tmp);
  return *this;
}

void ForVariant::swap(ForVariant & other)
{
  std::swap(lexpr_, other.lexpr_);
  std::swap(anyidentifier_, other.anyidentifier_);

}

ForVariant::~ForVariant()
{
  delete(lexpr_);
  delete(anyidentifier_);

}

void ForVariant::accept(Visitor *v)
{
  v->visitForVariant(this);
}

ForVariant *ForVariant::clone() const
{
  return new ForVariant(*this);
}



/********************   LexprVariant    ********************/
LexprVariant::LexprVariant(Lexpr *p1)
{
  lexpr_ = p1;

}

LexprVariant::LexprVariant(const LexprVariant & other)
{
  lexpr_ = other.lexpr_->clone();

}

LexprVariant &LexprVariant::operator=(const LexprVariant & other)
{
  LexprVariant tmp(other);
  swap(tmp);
  return *this;
}

void LexprVariant::swap(LexprVariant & other)
{
  std::swap(lexpr_, other.lexpr_);

}

LexprVariant::~LexprVariant()
{
  delete(lexpr_);

}

void LexprVariant::accept(Visitor *v)
{
  v->visitLexprVariant(this);
}

LexprVariant *LexprVariant::clone() const
{
  return new LexprVariant(*this);
}




/********************   ListParameterDecl    ********************/

void ListParameterDecl::accept(Visitor *v)
{
  v->visitListParameterDecl(this);
}

ListParameterDecl *ListParameterDecl::clone() const
{
  return new ListParameterDecl(*this);
}

ListParameterDecl* consListParameterDecl(ParameterDecl* x, ListParameterDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListInitDeclaratorAttr    ********************/

void ListInitDeclaratorAttr::accept(Visitor *v)
{
  v->visitListInitDeclaratorAttr(this);
}

ListInitDeclaratorAttr *ListInitDeclaratorAttr::clone() const
{
  return new ListInitDeclaratorAttr(*this);
}

ListInitDeclaratorAttr* consListInitDeclaratorAttr(InitDeclaratorAttr* x, ListInitDeclaratorAttr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFieldDecl    ********************/

void ListFieldDecl::accept(Visitor *v)
{
  v->visitListFieldDecl(this);
}

ListFieldDecl *ListFieldDecl::clone() const
{
  return new ListFieldDecl(*this);
}

ListFieldDecl* consListFieldDecl(FieldDecl* x, ListFieldDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAttribute    ********************/

void ListAttribute::accept(Visitor *v)
{
  v->visitListAttribute(this);
}

ListAttribute *ListAttribute::clone() const
{
  return new ListAttribute(*this);
}

ListAttribute* consListAttribute(Attribute* x, ListAttribute* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBlockElement    ********************/

void ListBlockElement::accept(Visitor *v)
{
  v->visitListBlockElement(this);
}

ListBlockElement *ListBlockElement::clone() const
{
  return new ListBlockElement(*this);
}

ListBlockElement* consListBlockElement(BlockElement* x, ListBlockElement* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAttr    ********************/

void ListAttr::accept(Visitor *v)
{
  v->visitListAttr(this);
}

ListAttr *ListAttr::clone() const
{
  return new ListAttr(*this);
}

ListAttr* consListAttr(Attr* x, ListAttr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}

ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}

ListExpression* consListExpression(Expression* x, ListExpression* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLexpr    ********************/

void ListLexpr::accept(Visitor *v)
{
  v->visitListLexpr(this);
}

ListLexpr *ListLexpr::clone() const
{
  return new ListLexpr(*this);
}

ListLexpr* consListLexpr(Lexpr* x, ListLexpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLexprRelInner    ********************/

void ListLexprRelInner::accept(Visitor *v)
{
  v->visitListLexprRelInner(this);
}

ListLexprRelInner *ListLexprRelInner::clone() const
{
  return new ListLexprRelInner(*this);
}

ListLexprRelInner* consListLexprRelInner(LexprRelInner* x, ListLexprRelInner* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBindersReentrance    ********************/

void ListBindersReentrance::accept(Visitor *v)
{
  v->visitListBindersReentrance(this);
}

ListBindersReentrance *ListBindersReentrance::clone() const
{
  return new ListBindersReentrance(*this);
}

ListBindersReentrance* consListBindersReentrance(BindersReentrance* x, ListBindersReentrance* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStars    ********************/

void ListStars::accept(Visitor *v)
{
  v->visitListStars(this);
}

ListStars *ListStars::clone() const
{
  return new ListStars(*this);
}

ListStars* consListStars(Stars* x, ListStars* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLabelName    ********************/

void ListLabelName::accept(Visitor *v)
{
  v->visitListLabelName(this);
}

ListLabelName *ListLabelName::clone() const
{
  return new ListLabelName(*this);
}

ListLabelName* consListLabelName(LabelName* x, ListLabelName* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFullIdentifier    ********************/

void ListFullIdentifier::accept(Visitor *v)
{
  v->visitListFullIdentifier(this);
}

ListFullIdentifier *ListFullIdentifier::clone() const
{
  return new ListFullIdentifier(*this);
}

ListFullIdentifier* consListFullIdentifier(FullIdentifier* x, ListFullIdentifier* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
