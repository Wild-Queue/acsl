-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module AcslHaskell.FullBnfcParser.Par
  ( happyError
  , myLexer
  , pProgram
  , pGlobals
  , pGlobal
  , pFunctionDef
  , pFunctionDefStart
  , pDeclSpecList
  , pDeclSpecListNoNamed
  , pTypeSpec
  , pDeclarator
  , pPointerOpt
  , pDirectDecl
  , pAttributesWithAsm
  , pRestParList
  , pParameterDecl
  , pListParameterDecl
  , pGhostParameterOpt
  , pIdOrTypename
  , pIdOrTypenameAsId
  , pDeclaration
  , pDeclAndInitDeclAttrList
  , pInitDeclaratorAttr
  , pListInitDeclaratorAttr
  , pInitDeclarator
  , pStructDeclList
  , pFieldDecl
  , pListFieldDecl
  , pAttribute
  , pListAttribute
  , pBlock
  , pBlockAttrs
  , pBlockElement
  , pListBlockElement
  , pStatement
  , pForClause
  , pAttr
  , pListAttr
  , pAttr1
  , pAttr2
  , pAttr3
  , pAttr4
  , pAttr5
  , pAttr6
  , pAttr7
  , pAttr8
  , pAttr9
  , pAttr10
  , pAttr11
  , pAttr12
  , pAttr13
  , pAttr14
  , pBasicAttribute
  , pAnnotatedStmt
  , pElsePart
  , pOptExpression
  , pExpression
  , pListExpression
  , pAssignExpr
  , pAssignExpr1
  , pAssignExpr2
  , pAssignExpr3
  , pAssignExpr4
  , pAssignExpr5
  , pAssignExpr6
  , pAssignExpr7
  , pAssignExpr8
  , pAssignExpr9
  , pAssignExpr10
  , pAssignExpr11
  , pAssignExpr12
  , pAssignExpr13
  , pAssignExpr14
  , pAssignExpr15
  , pConstant
  , pTypeName
  , pACSLProgram
  , pAnnot
  , pCode_Annot
  , pContract
  , pRequires
  , pNERequires
  , pTerminates
  , pDecreases
  , pSimpleClauses
  , pNESimpleClauses
  , pAssigns
  , pZones
  , pBehaviors
  , pCompleteOrDisjoint
  , pLexpr
  , pListLexpr
  , pLexpr1
  , pLexprRelInner
  , pListLexprRelInner
  , pRelation
  , pLexpr2
  , pLexprBinder
  , pBinders
  , pTypeSpecOFTYPENAME
  , pBindersReentrance
  , pListBindersReentrance
  , pVarSpec
  , pStars
  , pListStars
  , pVarSpec1
  , pArraySize
  , pLexpr3
  , pOptLabel1
  , pOptLabel2
  , pOptLabelList
  , pLabelName
  , pListLabelName
  , pRange
  , pLexprOption
  , pAnyIdentifier
  , pPostCond
  , pFullIdentifier
  , pListFullIdentifier
  , pIdentifier
  , pTypeSpecSimple
  , pLogicPTreeAnnot
  , pAnnotation
  , pLoopAnnotStack
  , pLoopAnnotOpt
  , pLoopInvariant
  , pLoopVariant
  , pLoopEffects
  , pVariant
  ) where

import Prelude

import qualified AcslHaskell.FullBnfcParser.Abs
import AcslHaskell.FullBnfcParser.Lex

}

%name pProgram Program
%name pGlobals Globals
%name pGlobal Global
%name pFunctionDef FunctionDef
%name pFunctionDefStart FunctionDefStart
%name pDeclSpecList DeclSpecList
%name pDeclSpecListNoNamed DeclSpecListNoNamed
%name pTypeSpec TypeSpec
%name pDeclarator Declarator
%name pPointerOpt PointerOpt
%name pDirectDecl DirectDecl
%name pAttributesWithAsm AttributesWithAsm
%name pRestParList RestParList
%name pParameterDecl ParameterDecl
%name pListParameterDecl ListParameterDecl
%name pGhostParameterOpt GhostParameterOpt
%name pIdOrTypename IdOrTypename
%name pIdOrTypenameAsId IdOrTypenameAsId
%name pDeclaration Declaration
%name pDeclAndInitDeclAttrList DeclAndInitDeclAttrList
%name pInitDeclaratorAttr InitDeclaratorAttr
%name pListInitDeclaratorAttr ListInitDeclaratorAttr
%name pInitDeclarator InitDeclarator
%name pStructDeclList StructDeclList
%name pFieldDecl FieldDecl
%name pListFieldDecl ListFieldDecl
%name pAttribute Attribute
%name pListAttribute ListAttribute
%name pBlock Block
%name pBlockAttrs BlockAttrs
%name pBlockElement BlockElement
%name pListBlockElement ListBlockElement
%name pStatement Statement
%name pForClause ForClause
%name pAttr Attr
%name pListAttr ListAttr
%name pAttr1 Attr1
%name pAttr2 Attr2
%name pAttr3 Attr3
%name pAttr4 Attr4
%name pAttr5 Attr5
%name pAttr6 Attr6
%name pAttr7 Attr7
%name pAttr8 Attr8
%name pAttr9 Attr9
%name pAttr10 Attr10
%name pAttr11 Attr11
%name pAttr12 Attr12
%name pAttr13 Attr13
%name pAttr14 Attr14
%name pBasicAttribute BasicAttribute
%name pAnnotatedStmt AnnotatedStmt
%name pElsePart ElsePart
%name pOptExpression OptExpression
%name pExpression Expression
%name pListExpression ListExpression
%name pAssignExpr AssignExpr
%name pAssignExpr1 AssignExpr1
%name pAssignExpr2 AssignExpr2
%name pAssignExpr3 AssignExpr3
%name pAssignExpr4 AssignExpr4
%name pAssignExpr5 AssignExpr5
%name pAssignExpr6 AssignExpr6
%name pAssignExpr7 AssignExpr7
%name pAssignExpr8 AssignExpr8
%name pAssignExpr9 AssignExpr9
%name pAssignExpr10 AssignExpr10
%name pAssignExpr11 AssignExpr11
%name pAssignExpr12 AssignExpr12
%name pAssignExpr13 AssignExpr13
%name pAssignExpr14 AssignExpr14
%name pAssignExpr15 AssignExpr15
%name pConstant Constant
%name pTypeName TypeName
%name pACSLProgram ACSLProgram
%name pAnnot Annot
%name pCode_Annot Code_Annot
%name pContract Contract
%name pRequires Requires
%name pNERequires NERequires
%name pTerminates Terminates
%name pDecreases Decreases
%name pSimpleClauses SimpleClauses
%name pNESimpleClauses NESimpleClauses
%name pAssigns Assigns
%name pZones Zones
%name pBehaviors Behaviors
%name pCompleteOrDisjoint CompleteOrDisjoint
%name pLexpr Lexpr
%name pListLexpr ListLexpr
%name pLexpr1 Lexpr1
%name pLexprRelInner LexprRelInner
%name pListLexprRelInner ListLexprRelInner
%name pRelation Relation
%name pLexpr2 Lexpr2
%name pLexprBinder LexprBinder
%name pBinders Binders
%name pTypeSpecOFTYPENAME TypeSpecOFTYPENAME
%name pBindersReentrance BindersReentrance
%name pListBindersReentrance ListBindersReentrance
%name pVarSpec VarSpec
%name pStars Stars
%name pListStars ListStars
%name pVarSpec1 VarSpec1
%name pArraySize ArraySize
%name pLexpr3 Lexpr3
%name pOptLabel1 OptLabel1
%name pOptLabel2 OptLabel2
%name pOptLabelList OptLabelList
%name pLabelName LabelName
%name pListLabelName ListLabelName
%name pRange Range
%name pLexprOption LexprOption
%name pAnyIdentifier AnyIdentifier
%name pPostCond PostCond
%name pFullIdentifier FullIdentifier
%name pListFullIdentifier ListFullIdentifier
%name pIdentifier Identifier
%name pTypeSpecSimple TypeSpecSimple
%name pLogicPTreeAnnot LogicPTreeAnnot
%name pAnnotation Annotation
%name pLoopAnnotStack LoopAnnotStack
%name pLoopAnnotOpt LoopAnnotOpt
%name pLoopInvariant LoopInvariant
%name pLoopVariant LoopVariant
%name pLoopEffects LoopEffects
%name pVariant Variant
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'              { PT _ (TS _ 1)              }
  '!='             { PT _ (TS _ 2)              }
  '%'              { PT _ (TS _ 3)              }
  '%='             { PT _ (TS _ 4)              }
  '&'              { PT _ (TS _ 5)              }
  '&&'             { PT _ (TS _ 6)              }
  '&='             { PT _ (TS _ 7)              }
  '('              { PT _ (TS _ 8)              }
  ')'              { PT _ (TS _ 9)              }
  '*'              { PT _ (TS _ 10)             }
  '*='             { PT _ (TS _ 11)             }
  '+'              { PT _ (TS _ 12)             }
  '++'             { PT _ (TS _ 13)             }
  '+='             { PT _ (TS _ 14)             }
  ','              { PT _ (TS _ 15)             }
  '-'              { PT _ (TS _ 16)             }
  '--'             { PT _ (TS _ 17)             }
  '-='             { PT _ (TS _ 18)             }
  '->'             { PT _ (TS _ 19)             }
  '.'              { PT _ (TS _ 20)             }
  '..'             { PT _ (TS _ 21)             }
  '...'            { PT _ (TS _ 22)             }
  '/'              { PT _ (TS _ 23)             }
  '/='             { PT _ (TS _ 24)             }
  ':'              { PT _ (TS _ 25)             }
  ';'              { PT _ (TS _ 26)             }
  '<'              { PT _ (TS _ 27)             }
  '<<'             { PT _ (TS _ 28)             }
  '<<='            { PT _ (TS _ 29)             }
  '<='             { PT _ (TS _ 30)             }
  '<==>'           { PT _ (TS _ 31)             }
  '='              { PT _ (TS _ 32)             }
  '=='             { PT _ (TS _ 33)             }
  '==>'            { PT _ (TS _ 34)             }
  '>'              { PT _ (TS _ 35)             }
  '>='             { PT _ (TS _ 36)             }
  '>>'             { PT _ (TS _ 37)             }
  '>>='            { PT _ (TS _ 38)             }
  '?'              { PT _ (TS _ 39)             }
  'ACSL_END'       { PT _ (TS _ 40)             }
  'ACSL_START'     { PT _ (TS _ 41)             }
  '['              { PT _ (TS _ 42)             }
  '\\automatic'    { PT _ (TS _ 43)             }
  '\\dynamic'      { PT _ (TS _ 44)             }
  '\\exists'       { PT _ (TS _ 45)             }
  '\\false'        { PT _ (TS _ 46)             }
  '\\forall'       { PT _ (TS _ 47)             }
  '\\from'         { PT _ (TS _ 48)             }
  '\\lambda'       { PT _ (TS _ 49)             }
  '\\nothing'      { PT _ (TS _ 50)             }
  '\\null'         { PT _ (TS _ 51)             }
  '\\pi'           { PT _ (TS _ 52)             }
  '\\register'     { PT _ (TS _ 53)             }
  '\\separated'    { PT _ (TS _ 54)             }
  '\\static'       { PT _ (TS _ 55)             }
  '\\true'         { PT _ (TS _ 56)             }
  '\\unallocated'  { PT _ (TS _ 57)             }
  '\\valid'        { PT _ (TS _ 58)             }
  ']'              { PT _ (TS _ 59)             }
  '^'              { PT _ (TS _ 60)             }
  '^='             { PT _ (TS _ 61)             }
  '^^'             { PT _ (TS _ 62)             }
  '_Bool'          { PT _ (TS _ 63)             }
  '__int32'        { PT _ (TS _ 64)             }
  '__int64'        { PT _ (TS _ 65)             }
  'admit'          { PT _ (TS _ 66)             }
  'assigns'        { PT _ (TS _ 67)             }
  'boolean'        { PT _ (TS _ 68)             }
  'break'          { PT _ (TS _ 69)             }
  'breaks'         { PT _ (TS _ 70)             }
  'case'           { PT _ (TS _ 71)             }
  'char'           { PT _ (TS _ 72)             }
  'check'          { PT _ (TS _ 73)             }
  'continue'       { PT _ (TS _ 74)             }
  'continues'      { PT _ (TS _ 75)             }
  'default'        { PT _ (TS _ 76)             }
  'double'         { PT _ (TS _ 77)             }
  'else'           { PT _ (TS _ 78)             }
  'ensures'        { PT _ (TS _ 79)             }
  'exits'          { PT _ (TS _ 80)             }
  'float'          { PT _ (TS _ 81)             }
  'for'            { PT _ (TS _ 82)             }
  'if'             { PT _ (TS _ 83)             }
  'int'            { PT _ (TS _ 84)             }
  'integer'        { PT _ (TS _ 85)             }
  'invariant'      { PT _ (TS _ 86)             }
  'long'           { PT _ (TS _ 87)             }
  'loop'           { PT _ (TS _ 88)             }
  'real'           { PT _ (TS _ 89)             }
  'requires'       { PT _ (TS _ 90)             }
  'return'         { PT _ (TS _ 91)             }
  'returns'        { PT _ (TS _ 92)             }
  'short'          { PT _ (TS _ 93)             }
  'size_t'         { PT _ (TS _ 94)             }
  'struct'         { PT _ (TS _ 95)             }
  'switch'         { PT _ (TS _ 96)             }
  'unsigned'       { PT _ (TS _ 97)             }
  'variant'        { PT _ (TS _ 98)             }
  'void'           { PT _ (TS _ 99)             }
  'while'          { PT _ (TS _ 100)            }
  '{'              { PT _ (TS _ 101)            }
  '|'              { PT _ (TS _ 102)            }
  '|='             { PT _ (TS _ 103)            }
  '||'             { PT _ (TS _ 104)            }
  '}'              { PT _ (TS _ 105)            }
  '~'              { PT _ (TS _ 106)            }
  L_Ident          { PT _ (TV $$)               }
  L_charac         { PT _ (TC $$)               }
  L_doubl          { PT _ (TD $$)               }
  L_integ          { PT _ (TI $$)               }
  L_quoted         { PT _ (TL $$)               }
  L_SIGNED         { PT _ (T_SIGNED $$)         }
  L_LBRACE         { PT _ (T_LBRACE $$)         }
  L_RBRACE         { PT _ (T_RBRACE $$)         }
  L_CONST          { PT _ (T_CONST $$)          }
  L_RESTRICT       { PT _ (T_RESTRICT $$)       }
  L_VOLATILE       { PT _ (T_VOLATILE $$)       }
  L_BLOCKATTRIBUTE { PT _ (T_BLOCKATTRIBUTE $$) }
  L_LBRACKET       { PT _ (T_LBRACKET $$)       }
  L_RBRACKET       { PT _ (T_RBRACKET $$)       }

%%

Ident :: { AcslHaskell.FullBnfcParser.Abs.Ident }
Ident  : L_Ident { AcslHaskell.FullBnfcParser.Abs.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

SIGNED :: { AcslHaskell.FullBnfcParser.Abs.SIGNED }
SIGNED  : L_SIGNED { AcslHaskell.FullBnfcParser.Abs.SIGNED $1 }

LBRACE :: { AcslHaskell.FullBnfcParser.Abs.LBRACE }
LBRACE  : L_LBRACE { AcslHaskell.FullBnfcParser.Abs.LBRACE $1 }

RBRACE :: { AcslHaskell.FullBnfcParser.Abs.RBRACE }
RBRACE  : L_RBRACE { AcslHaskell.FullBnfcParser.Abs.RBRACE $1 }

CONST :: { AcslHaskell.FullBnfcParser.Abs.CONST }
CONST  : L_CONST { AcslHaskell.FullBnfcParser.Abs.CONST $1 }

RESTRICT :: { AcslHaskell.FullBnfcParser.Abs.RESTRICT }
RESTRICT  : L_RESTRICT { AcslHaskell.FullBnfcParser.Abs.RESTRICT $1 }

VOLATILE :: { AcslHaskell.FullBnfcParser.Abs.VOLATILE }
VOLATILE  : L_VOLATILE { AcslHaskell.FullBnfcParser.Abs.VOLATILE $1 }

BLOCKATTRIBUTE :: { AcslHaskell.FullBnfcParser.Abs.BLOCKATTRIBUTE }
BLOCKATTRIBUTE  : L_BLOCKATTRIBUTE { AcslHaskell.FullBnfcParser.Abs.BLOCKATTRIBUTE $1 }

LBRACKET :: { AcslHaskell.FullBnfcParser.Abs.LBRACKET }
LBRACKET  : L_LBRACKET { AcslHaskell.FullBnfcParser.Abs.LBRACKET $1 }

RBRACKET :: { AcslHaskell.FullBnfcParser.Abs.RBRACKET }
RBRACKET  : L_RBRACKET { AcslHaskell.FullBnfcParser.Abs.RBRACKET $1 }

Program :: { AcslHaskell.FullBnfcParser.Abs.Program }
Program : Globals { AcslHaskell.FullBnfcParser.Abs.AProgram $1 }

Globals :: { AcslHaskell.FullBnfcParser.Abs.Globals }
Globals
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoGlobals }
  | Global Globals { AcslHaskell.FullBnfcParser.Abs.SimpleGlobals $1 $2 }
  | ';' Globals { AcslHaskell.FullBnfcParser.Abs.SemiColonGlobals $2 }

Global :: { AcslHaskell.FullBnfcParser.Abs.Global }
Global
  : FunctionDef { AcslHaskell.FullBnfcParser.Abs.GlobalsFunctionDef $1 }
  | Declaration { AcslHaskell.FullBnfcParser.Abs.GlobalsDeclataion $1 }

FunctionDef :: { AcslHaskell.FullBnfcParser.Abs.FunctionDef }
FunctionDef
  : FunctionDefStart Block { AcslHaskell.FullBnfcParser.Abs.SimpleFunctionDef $1 $2 }
  | ACSLProgram FunctionDefStart Block { AcslHaskell.FullBnfcParser.Abs.FunctionDefSpec $1 $2 $3 }

FunctionDefStart :: { AcslHaskell.FullBnfcParser.Abs.FunctionDefStart }
FunctionDefStart
  : DeclSpecList Declarator { AcslHaskell.FullBnfcParser.Abs.FunctionDefStartDeclarator $1 $2 }

DeclSpecList :: { AcslHaskell.FullBnfcParser.Abs.DeclSpecList }
DeclSpecList
  : TypeSpec { AcslHaskell.FullBnfcParser.Abs.DeclSpecTypeSpec $1 }
  | TypeSpec DeclSpecListNoNamed { AcslHaskell.FullBnfcParser.Abs.DeclSpecTypeSpecNext $1 $2 }

DeclSpecListNoNamed :: { AcslHaskell.FullBnfcParser.Abs.DeclSpecListNoNamed }
DeclSpecListNoNamed
  : TypeSpec { AcslHaskell.FullBnfcParser.Abs.DeclSpecNoNamedTypeSpec $1 }
  | TypeSpec DeclSpecListNoNamed { AcslHaskell.FullBnfcParser.Abs.DeclSpecNoNamedTypeSpecNext $1 $2 }

TypeSpec :: { AcslHaskell.FullBnfcParser.Abs.TypeSpec }
TypeSpec
  : 'void' { AcslHaskell.FullBnfcParser.Abs.TypeSpecVoidKeyWord }
  | 'char' { AcslHaskell.FullBnfcParser.Abs.TypeSpecCharKeyWord }
  | '_Bool' { AcslHaskell.FullBnfcParser.Abs.TypeSpecBoolKeyWord }
  | 'short' { AcslHaskell.FullBnfcParser.Abs.TypeSpecShortKeyWord }
  | '__int32' { AcslHaskell.FullBnfcParser.Abs.TypeSpecInt32KeyWord }
  | 'int' { AcslHaskell.FullBnfcParser.Abs.TypeSpecIntKeyWord }
  | 'size_t' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSizeTKeyWord }
  | 'long' { AcslHaskell.FullBnfcParser.Abs.TypeSpecLongKeyWord }
  | '__int64' { AcslHaskell.FullBnfcParser.Abs.TypeSpecInt64KeyWord }
  | 'float' { AcslHaskell.FullBnfcParser.Abs.TypeSpecFloatKeyWord }
  | 'double' { AcslHaskell.FullBnfcParser.Abs.TypeSpecDoubleKeyWord }
  | SIGNED { AcslHaskell.FullBnfcParser.Abs.TypeSpecSignedKeyWord $1 }
  | 'unsigned' { AcslHaskell.FullBnfcParser.Abs.TypeSpecUnsignedKeyWord }
  | 'struct' IdOrTypename { AcslHaskell.FullBnfcParser.Abs.StructId $2 }
  | 'struct' IdOrTypename '{' StructDeclList '}' { AcslHaskell.FullBnfcParser.Abs.StructIdBraces $2 $4 }
  | 'struct' '{' StructDeclList '}' { AcslHaskell.FullBnfcParser.Abs.StructBraces $3 }

Declarator :: { AcslHaskell.FullBnfcParser.Abs.Declarator }
Declarator
  : PointerOpt DirectDecl AttributesWithAsm { AcslHaskell.FullBnfcParser.Abs.ADeclarator $1 $2 $3 }

PointerOpt :: { AcslHaskell.FullBnfcParser.Abs.PointerOpt }
PointerOpt
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoPointer }
  | '*' ListAttribute PointerOpt { AcslHaskell.FullBnfcParser.Abs.SomePointer $2 $3 }

DirectDecl :: { AcslHaskell.FullBnfcParser.Abs.DirectDecl }
DirectDecl
  : IdOrTypename { AcslHaskell.FullBnfcParser.Abs.DirectDeclIdTypename $1 }
  | DirectDecl '(' ')' GhostParameterOpt { AcslHaskell.FullBnfcParser.Abs.DirectDeclGhostParam $1 $4 }
  | DirectDecl '(' RestParList ')' GhostParameterOpt { AcslHaskell.FullBnfcParser.Abs.DirectDeclGhostRestParParam $1 $3 $5 }

AttributesWithAsm :: { AcslHaskell.FullBnfcParser.Abs.AttributesWithAsm }
AttributesWithAsm
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.EmptyAttrWithASM }

RestParList :: { AcslHaskell.FullBnfcParser.Abs.RestParList }
RestParList
  : ListParameterDecl { AcslHaskell.FullBnfcParser.Abs.SimpleParameterDecl $1 }

ParameterDecl :: { AcslHaskell.FullBnfcParser.Abs.ParameterDecl }
ParameterDecl
  : DeclSpecList Declarator { AcslHaskell.FullBnfcParser.Abs.ParameterDeclSpecDeclarator $1 $2 }
  | DeclSpecList { AcslHaskell.FullBnfcParser.Abs.ParameterDeclSpec $1 }
  | '(' ParameterDecl ')' { AcslHaskell.FullBnfcParser.Abs.ParameterDeclPar $2 }

ListParameterDecl :: { [AcslHaskell.FullBnfcParser.Abs.ParameterDecl] }
ListParameterDecl
  : ParameterDecl { (:[]) $1 }
  | ParameterDecl ',' ListParameterDecl { (:) $1 $3 }

GhostParameterOpt :: { AcslHaskell.FullBnfcParser.Abs.GhostParameterOpt }
GhostParameterOpt
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoGhostParameter }

IdOrTypename :: { AcslHaskell.FullBnfcParser.Abs.IdOrTypename }
IdOrTypename
  : IdOrTypenameAsId { AcslHaskell.FullBnfcParser.Abs.IdTypename $1 }

IdOrTypenameAsId :: { AcslHaskell.FullBnfcParser.Abs.IdOrTypenameAsId }
IdOrTypenameAsId
  : Ident { AcslHaskell.FullBnfcParser.Abs.IdOrTypenameAsIdIdentifier $1 }

Declaration :: { AcslHaskell.FullBnfcParser.Abs.Declaration }
Declaration
  : DeclSpecList DeclAndInitDeclAttrList ';' { AcslHaskell.FullBnfcParser.Abs.DeclSpecInitDecl $1 $2 }
  | DeclSpecList ';' { AcslHaskell.FullBnfcParser.Abs.DeclSpec $1 }
  | ACSLProgram DeclSpecList DeclAndInitDeclAttrList ';' { AcslHaskell.FullBnfcParser.Abs.SpecDeclSpecInitDecl $1 $2 $3 }
  | ACSLProgram DeclSpecList ';' { AcslHaskell.FullBnfcParser.Abs.SpecDeclSpec $1 $2 }

DeclAndInitDeclAttrList :: { AcslHaskell.FullBnfcParser.Abs.DeclAndInitDeclAttrList }
DeclAndInitDeclAttrList
  : InitDeclarator { AcslHaskell.FullBnfcParser.Abs.InitDeclaration $1 }
  | InitDeclarator ',' ListInitDeclaratorAttr { AcslHaskell.FullBnfcParser.Abs.InitDeclarationWithAttr $1 $3 }

InitDeclaratorAttr :: { AcslHaskell.FullBnfcParser.Abs.InitDeclaratorAttr }
InitDeclaratorAttr
  : InitDeclarator { AcslHaskell.FullBnfcParser.Abs.InitDeclaratorAttribute $1 }

ListInitDeclaratorAttr :: { [AcslHaskell.FullBnfcParser.Abs.InitDeclaratorAttr] }
ListInitDeclaratorAttr
  : InitDeclaratorAttr { (:[]) $1 }
  | InitDeclaratorAttr ',' ListInitDeclaratorAttr { (:) $1 $3 }

InitDeclarator :: { AcslHaskell.FullBnfcParser.Abs.InitDeclarator }
InitDeclarator
  : Declarator { AcslHaskell.FullBnfcParser.Abs.SimpleInitDeclarator $1 }

StructDeclList :: { AcslHaskell.FullBnfcParser.Abs.StructDeclList }
StructDeclList
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.EmptyStructDecl }
  | DeclSpecList ';' StructDeclList { AcslHaskell.FullBnfcParser.Abs.DeclSpecStructDecl $1 $3 }
  | ';' StructDeclList { AcslHaskell.FullBnfcParser.Abs.SemicolonStructDecl $2 }
  | DeclSpecList ListFieldDecl ';' StructDeclList { AcslHaskell.FullBnfcParser.Abs.SpecFieldDeclStructDecl $1 $2 $4 }

FieldDecl :: { AcslHaskell.FullBnfcParser.Abs.FieldDecl }
FieldDecl
  : Declarator { AcslHaskell.FullBnfcParser.Abs.FieldDeclDeclarator $1 }

ListFieldDecl :: { [AcslHaskell.FullBnfcParser.Abs.FieldDecl] }
ListFieldDecl
  : FieldDecl { (:[]) $1 }
  | FieldDecl ',' ListFieldDecl { (:) $1 $3 }

Attribute :: { AcslHaskell.FullBnfcParser.Abs.Attribute }
Attribute
  : CONST { AcslHaskell.FullBnfcParser.Abs.AttributeConst $1 }

ListAttribute :: { [AcslHaskell.FullBnfcParser.Abs.Attribute] }
ListAttribute
  : {- empty -} { [] } | Attribute ListAttribute { (:) $1 $2 }

Block :: { AcslHaskell.FullBnfcParser.Abs.Block }
Block
  : '{' BlockAttrs ListBlockElement '}' { AcslHaskell.FullBnfcParser.Abs.ABlock $2 $3 }

BlockAttrs :: { AcslHaskell.FullBnfcParser.Abs.BlockAttrs }
BlockAttrs
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoBlockAttrs }
  | BLOCKATTRIBUTE '(' ListAttr ')' { AcslHaskell.FullBnfcParser.Abs.SomeBlockAttrs $1 $3 }

BlockElement :: { AcslHaskell.FullBnfcParser.Abs.BlockElement }
BlockElement
  : Declaration { AcslHaskell.FullBnfcParser.Abs.DeclarationElement $1 }
  | Statement { AcslHaskell.FullBnfcParser.Abs.StatementElement $1 }

ListBlockElement :: { [AcslHaskell.FullBnfcParser.Abs.BlockElement] }
ListBlockElement
  : {- empty -} { [] } | BlockElement ListBlockElement { (:) $1 $2 }

Statement :: { AcslHaskell.FullBnfcParser.Abs.Statement }
Statement
  : ';' { AcslHaskell.FullBnfcParser.Abs.SemicolonStatement }
  | ACSLProgram AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.SpecStatement $1 $2 }
  | ListExpression ';' { AcslHaskell.FullBnfcParser.Abs.ExprsStatement $1 }
  | Block { AcslHaskell.FullBnfcParser.Abs.BlockStatement $1 }
  | 'if' '(' ListExpression ')' AnnotatedStmt ElsePart { AcslHaskell.FullBnfcParser.Abs.IfStatement $3 $5 $6 }
  | 'switch' '(' ListExpression ')' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.SwitchStatement $3 $5 }
  | 'while' '(' ListExpression ')' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.WhileStatement $3 $5 }
  | 'for' '(' ForClause OptExpression ';' OptExpression ')' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.ForStatement $3 $4 $6 $8 }
  | 'case' Expression ':' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.CaseStatement $2 $4 }
  | 'case' Expression '...' Expression ':' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.CaseSliceStatement $2 $4 $6 }
  | 'default' ':' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.DefaultStatement $3 }
  | 'return' ';' { AcslHaskell.FullBnfcParser.Abs.EmptyReturnStatement }
  | 'return' ListExpression ';' { AcslHaskell.FullBnfcParser.Abs.ReturnStatement $2 }
  | 'break' ';' { AcslHaskell.FullBnfcParser.Abs.BreakStatement }
  | 'continue' ';' { AcslHaskell.FullBnfcParser.Abs.ContinueStatement }

ForClause :: { AcslHaskell.FullBnfcParser.Abs.ForClause }
ForClause
  : OptExpression ';' { AcslHaskell.FullBnfcParser.Abs.ForClauseExpression $1 }
  | Declaration { AcslHaskell.FullBnfcParser.Abs.ForClauseDeclaration $1 }

Attr :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr
  : Attr1 { $1 }
  | Attr1 '=' Attr1 { AcslHaskell.FullBnfcParser.Abs.AnAttr $1 $3 }

ListAttr :: { [AcslHaskell.FullBnfcParser.Abs.Attr] }
ListAttr : Attr { (:[]) $1 } | Attr ',' ListAttr { (:) $1 $3 }

Attr1 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr1
  : Attr2 { $1 }
  | Attr2 '?' Attr1 ':' Attr1 { AcslHaskell.FullBnfcParser.Abs.TernaryCond $1 $3 $5 }

Attr2 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr2
  : Attr3 { $1 }
  | Attr2 '||' Attr3 { AcslHaskell.FullBnfcParser.Abs.Or $1 $3 }

Attr3 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr3
  : Attr4 { $1 }
  | Attr3 '&&' Attr4 { AcslHaskell.FullBnfcParser.Abs.And $1 $3 }

Attr4 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr4
  : Attr5 { $1 }
  | Attr4 '|' Attr5 { AcslHaskell.FullBnfcParser.Abs.BitOr $1 $3 }

Attr5 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr5
  : Attr6 { $1 }
  | Attr5 '^' Attr6 { AcslHaskell.FullBnfcParser.Abs.Xor $1 $3 }

Attr6 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr6
  : Attr7 { $1 }
  | Attr6 '&' Attr7 { AcslHaskell.FullBnfcParser.Abs.BitAnd $1 $3 }

Attr7 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr7
  : Attr8 { $1 }
  | Attr7 '==' Attr8 { AcslHaskell.FullBnfcParser.Abs.EqualEqual $1 $3 }
  | Attr7 '!=' Attr8 { AcslHaskell.FullBnfcParser.Abs.NotEqual $1 $3 }

Attr8 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr8
  : Attr9 { $1 }
  | Attr8 '<' Attr9 { AcslHaskell.FullBnfcParser.Abs.Less $1 $3 }
  | Attr8 '>' Attr9 { AcslHaskell.FullBnfcParser.Abs.Greater $1 $3 }
  | Attr8 '<=' Attr9 { AcslHaskell.FullBnfcParser.Abs.LessEqual $1 $3 }
  | Attr8 '>=' Attr9 { AcslHaskell.FullBnfcParser.Abs.GreaterEqual $1 $3 }

Attr9 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr9
  : Attr10 { $1 }
  | Attr9 '<<' Attr10 { AcslHaskell.FullBnfcParser.Abs.LeftShiftOp $1 $3 }
  | Attr9 '>>' Attr10 { AcslHaskell.FullBnfcParser.Abs.RightShiftOp $1 $3 }

Attr10 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr10
  : Attr11 { $1 }
  | Attr10 '+' Attr11 { AcslHaskell.FullBnfcParser.Abs.AddOp $1 $3 }
  | Attr10 '-' Attr11 { AcslHaskell.FullBnfcParser.Abs.SubOp $1 $3 }

Attr11 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr11
  : Attr12 { $1 }
  | Attr11 '*' Attr12 { AcslHaskell.FullBnfcParser.Abs.MultOp $1 $3 }
  | Attr11 '/' Attr12 { AcslHaskell.FullBnfcParser.Abs.DivOp $1 $3 }
  | Attr11 '%' Attr12 { AcslHaskell.FullBnfcParser.Abs.ModOp $1 $3 }

Attr12 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr12
  : Attr13 { $1 }
  | '+' Attr12 { AcslHaskell.FullBnfcParser.Abs.PlusUnaryAttr $2 }
  | '-' Attr12 { AcslHaskell.FullBnfcParser.Abs.MinusUnaryAttr $2 }
  | '*' Attr12 { AcslHaskell.FullBnfcParser.Abs.MultUnaryAttr $2 }
  | '&' Attr12 { AcslHaskell.FullBnfcParser.Abs.AmpUnaryAttr $2 }
  | '!' Attr12 { AcslHaskell.FullBnfcParser.Abs.NotUnaryAttr $2 }
  | '~' Attr12 { AcslHaskell.FullBnfcParser.Abs.TildeUnaryAttr $2 }

Attr13 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr13
  : Attr14 { $1 }
  | IdOrTypenameAsId '(' ListAttr ')' { AcslHaskell.FullBnfcParser.Abs.FuncationCall $1 $3 }
  | IdOrTypenameAsId '(' ')' { AcslHaskell.FullBnfcParser.Abs.ProcedureCall $1 }
  | Attr13 '->' IdOrTypename { AcslHaskell.FullBnfcParser.Abs.ArrowAttr $1 $3 }
  | Attr13 '.' IdOrTypename { AcslHaskell.FullBnfcParser.Abs.DotAttr $1 $3 }
  | Attr13 '[' Attr ']' { AcslHaskell.FullBnfcParser.Abs.ArrayAttr $1 $3 }

Attr14 :: { AcslHaskell.FullBnfcParser.Abs.Attr }
Attr14
  : BasicAttribute { AcslHaskell.FullBnfcParser.Abs.BasicAttr $1 }
  | '(' Attr ')' { $2 }

BasicAttribute :: { AcslHaskell.FullBnfcParser.Abs.BasicAttribute }
BasicAttribute
  : Integer { AcslHaskell.FullBnfcParser.Abs.BasicAttrConsInt $1 }
  | Double { AcslHaskell.FullBnfcParser.Abs.BasicAttrConsFloat $1 }

AnnotatedStmt :: { AcslHaskell.FullBnfcParser.Abs.AnnotatedStmt }
AnnotatedStmt
  : Statement { AcslHaskell.FullBnfcParser.Abs.AnnotatedStatement $1 }

ElsePart :: { AcslHaskell.FullBnfcParser.Abs.ElsePart }
ElsePart
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoElsePart }
  | 'else' AnnotatedStmt { AcslHaskell.FullBnfcParser.Abs.SimpleElsePart $2 }

OptExpression :: { AcslHaskell.FullBnfcParser.Abs.OptExpression }
OptExpression
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoExpression }
  | ListExpression { AcslHaskell.FullBnfcParser.Abs.SomeExpression $1 }

Expression :: { AcslHaskell.FullBnfcParser.Abs.Expression }
Expression
  : AssignExpr { AcslHaskell.FullBnfcParser.Abs.AssignmentExpr $1 }

ListExpression :: { [AcslHaskell.FullBnfcParser.Abs.Expression] }
ListExpression
  : Expression { (:[]) $1 }
  | Expression ',' ListExpression { (:) $1 $3 }

AssignExpr :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr
  : AssignExpr1 { $1 }
  | AssignExpr12 '=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.EqAssignExpr $1 $3 }
  | AssignExpr12 '+=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.PlusEqAssignExpr $1 $3 }
  | AssignExpr12 '-=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.MinusEqAssignExpr $1 $3 }
  | AssignExpr12 '*=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.MultEqAssignExpr $1 $3 }
  | AssignExpr12 '/=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.DivEqAssignExpr $1 $3 }
  | AssignExpr12 '%=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.ModEqAssignExpr $1 $3 }
  | AssignExpr12 '&=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.AndEqAssignExpr $1 $3 }
  | AssignExpr12 '|=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.OrEqAssignExpr $1 $3 }
  | AssignExpr12 '^=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.XorEqAssignExpr $1 $3 }
  | AssignExpr12 '<<=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.LeftShiftEqAssignExpr $1 $3 }
  | AssignExpr12 '>>=' AssignExpr { AcslHaskell.FullBnfcParser.Abs.RightShiftEqAssignExpr $1 $3 }

AssignExpr1 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr1
  : AssignExpr2 { $1 }
  | AssignExpr2 '?' OptExpression ':' AssignExpr1 { AcslHaskell.FullBnfcParser.Abs.TernaryCondExpr $1 $3 $5 }

AssignExpr2 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr2
  : AssignExpr3 { $1 }
  | AssignExpr2 '||' AssignExpr3 { AcslHaskell.FullBnfcParser.Abs.OrExpr $1 $3 }

AssignExpr3 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr3
  : AssignExpr4 { $1 }
  | AssignExpr3 '&&' AssignExpr4 { AcslHaskell.FullBnfcParser.Abs.AndExpr $1 $3 }

AssignExpr4 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr4
  : AssignExpr5 { $1 }
  | AssignExpr4 '|' AssignExpr5 { AcslHaskell.FullBnfcParser.Abs.BitOrExpr $1 $3 }

AssignExpr5 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr5
  : AssignExpr6 { $1 }
  | AssignExpr5 '^' AssignExpr6 { AcslHaskell.FullBnfcParser.Abs.BitXorExpr $1 $3 }

AssignExpr6 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr6
  : AssignExpr7 { $1 }
  | AssignExpr6 '&' AssignExpr7 { AcslHaskell.FullBnfcParser.Abs.BitAndExpr $1 $3 }

AssignExpr7 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr7
  : AssignExpr8 { $1 }
  | AssignExpr7 '==' AssignExpr8 { AcslHaskell.FullBnfcParser.Abs.EqExpr $1 $3 }
  | AssignExpr7 '!=' AssignExpr8 { AcslHaskell.FullBnfcParser.Abs.NotEqExpr $1 $3 }

AssignExpr8 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr8
  : AssignExpr9 { $1 }
  | AssignExpr8 '<' AssignExpr9 { AcslHaskell.FullBnfcParser.Abs.LessExpr $1 $3 }
  | AssignExpr8 '>' AssignExpr9 { AcslHaskell.FullBnfcParser.Abs.GreaterExpr $1 $3 }
  | AssignExpr8 '<=' AssignExpr9 { AcslHaskell.FullBnfcParser.Abs.LessEqualExpr $1 $3 }
  | AssignExpr8 '>=' AssignExpr9 { AcslHaskell.FullBnfcParser.Abs.GreaterEqualExpr $1 $3 }

AssignExpr9 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr9
  : AssignExpr10 { $1 }
  | AssignExpr9 '<<' AssignExpr10 { AcslHaskell.FullBnfcParser.Abs.LeftShiftExpr $1 $3 }
  | AssignExpr9 '>>' AssignExpr10 { AcslHaskell.FullBnfcParser.Abs.RightShiftExpr $1 $3 }

AssignExpr10 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr10
  : AssignExpr11 { $1 }
  | AssignExpr10 '+' AssignExpr11 { AcslHaskell.FullBnfcParser.Abs.PlusExpr $1 $3 }
  | AssignExpr10 '-' AssignExpr11 { AcslHaskell.FullBnfcParser.Abs.MinusExpr $1 $3 }

AssignExpr11 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr11
  : AssignExpr12 { $1 }
  | AssignExpr11 '*' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.MulsExpr $1 $3 }
  | AssignExpr11 '/' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.DivExpr $1 $3 }
  | AssignExpr11 '%' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.ModExpr $1 $3 }

AssignExpr12 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr12
  : AssignExpr13 { $1 }
  | '(' TypeName ')' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.CastExpr $2 $4 }

AssignExpr13 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr13
  : AssignExpr14 { $1 }
  | '++' AssignExpr13 { AcslHaskell.FullBnfcParser.Abs.UnaryExprPlusPlus $2 }
  | '--' AssignExpr13 { AcslHaskell.FullBnfcParser.Abs.UnaryExprMinusMinus $2 }
  | '+' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.UnaryExprPlus $2 }
  | '-' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.UnaryExprMinus $2 }
  | '*' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.UnaryExprMult $2 }
  | '&' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.UnaryExprAmp $2 }
  | '!' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.UnaryExprNot $2 }
  | '~' AssignExpr12 { AcslHaskell.FullBnfcParser.Abs.UnaryExprTilde $2 }
  | '&&' IdOrTypenameAsId { AcslHaskell.FullBnfcParser.Abs.UnaryExprAddress $2 }

AssignExpr14 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr14
  : AssignExpr15 { $1 }
  | AssignExpr14 '[' ListExpression ']' { AcslHaskell.FullBnfcParser.Abs.BracketsPostfixExpression $1 $3 }
  | AssignExpr14 '.' IdOrTypename { AcslHaskell.FullBnfcParser.Abs.DotPostfixExpression $1 $3 }
  | AssignExpr14 '->' IdOrTypename { AcslHaskell.FullBnfcParser.Abs.ArrowPostfixExpression $1 $3 }
  | AssignExpr14 '++' { AcslHaskell.FullBnfcParser.Abs.PlusPlusPostfixExpression $1 }
  | AssignExpr14 '--' { AcslHaskell.FullBnfcParser.Abs.MinusMinusPostfixExpression $1 }

AssignExpr15 :: { AcslHaskell.FullBnfcParser.Abs.AssignExpr }
AssignExpr15
  : Ident { AcslHaskell.FullBnfcParser.Abs.IdentifierPrimaryExpression $1 }
  | Constant { AcslHaskell.FullBnfcParser.Abs.ConstantPrimaryExpressin $1 }
  | '(' ListExpression ')' { AcslHaskell.FullBnfcParser.Abs.CommaExpressionPrimaryExpressin $2 }
  | '(' Block ')' { AcslHaskell.FullBnfcParser.Abs.BlockPrimaryExpressin $2 }

Constant :: { AcslHaskell.FullBnfcParser.Abs.Constant }
Constant
  : Integer { AcslHaskell.FullBnfcParser.Abs.ConstantInt $1 }
  | Double { AcslHaskell.FullBnfcParser.Abs.ConstantFloat $1 }
  | Char { AcslHaskell.FullBnfcParser.Abs.ConstantChar $1 }

TypeName :: { AcslHaskell.FullBnfcParser.Abs.TypeName }
TypeName
  : DeclSpecList { AcslHaskell.FullBnfcParser.Abs.TypeNameDeclSpecList $1 }

ACSLProgram :: { AcslHaskell.FullBnfcParser.Abs.ACSLProgram }
ACSLProgram
  : 'ACSL_START' Annot 'ACSL_END' { AcslHaskell.FullBnfcParser.Abs.AnnotProgram $2 }
  | 'ACSL_START' LogicPTreeAnnot 'ACSL_END' { AcslHaskell.FullBnfcParser.Abs.AnnotationProgram $2 }

Annot :: { AcslHaskell.FullBnfcParser.Abs.Annot }
Annot : Code_Annot { AcslHaskell.FullBnfcParser.Abs.CodeAnnot $1 }

Code_Annot :: { AcslHaskell.FullBnfcParser.Abs.Code_Annot }
Code_Annot
  : Contract { AcslHaskell.FullBnfcParser.Abs.CodeAnnotContract $1 }

Contract :: { AcslHaskell.FullBnfcParser.Abs.Contract }
Contract
  : Requires Terminates Decreases SimpleClauses Behaviors CompleteOrDisjoint { AcslHaskell.FullBnfcParser.Abs.SimpleContract $1 $2 $3 $4 $5 $6 }

Requires :: { AcslHaskell.FullBnfcParser.Abs.Requires }
Requires
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoRequires }
  | NERequires { AcslHaskell.FullBnfcParser.Abs.SomeRequires $1 }

NERequires :: { AcslHaskell.FullBnfcParser.Abs.NERequires }
NERequires
  : 'requires' Lexpr ';' Requires { AcslHaskell.FullBnfcParser.Abs.SimpleRequires $2 $4 }
  | 'check' 'requires' Lexpr ';' Requires { AcslHaskell.FullBnfcParser.Abs.CheckRequires $3 $5 }
  | 'admit' 'requires' Lexpr ';' Requires { AcslHaskell.FullBnfcParser.Abs.AdimtRequires $3 $5 }

Terminates :: { AcslHaskell.FullBnfcParser.Abs.Terminates }
Terminates
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoTerminate }

Decreases :: { AcslHaskell.FullBnfcParser.Abs.Decreases }
Decreases
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoDecreases }

SimpleClauses :: { AcslHaskell.FullBnfcParser.Abs.SimpleClauses }
SimpleClauses
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoSimpleClauses }
  | NESimpleClauses { AcslHaskell.FullBnfcParser.Abs.SomeSimpleClauses $1 }

NESimpleClauses :: { AcslHaskell.FullBnfcParser.Abs.NESimpleClauses }
NESimpleClauses
  : PostCond Lexpr ';' SimpleClauses { AcslHaskell.FullBnfcParser.Abs.PostCondSimpleClauses $1 $2 $4 }
  | 'assigns' Assigns ';' SimpleClauses { AcslHaskell.FullBnfcParser.Abs.AssignsSimpleClauses $2 $4 }

Assigns :: { AcslHaskell.FullBnfcParser.Abs.Assigns }
Assigns
  : Zones { AcslHaskell.FullBnfcParser.Abs.AssignZone $1 }
  | ListLexpr '\\from' Zones { AcslHaskell.FullBnfcParser.Abs.AssignZoneFromZone $1 $3 }

Zones :: { AcslHaskell.FullBnfcParser.Abs.Zones }
Zones
  : ListLexpr { AcslHaskell.FullBnfcParser.Abs.SomeZone $1 }
  | '\\nothing' { AcslHaskell.FullBnfcParser.Abs.NoZone }

Behaviors :: { AcslHaskell.FullBnfcParser.Abs.Behaviors }
Behaviors
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoBehaviors }

CompleteOrDisjoint :: { AcslHaskell.FullBnfcParser.Abs.CompleteOrDisjoint }
CompleteOrDisjoint
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoComplDisj }

Lexpr :: { AcslHaskell.FullBnfcParser.Abs.Lexpr }
Lexpr
  : Lexpr '==>' Lexpr1 { AcslHaskell.FullBnfcParser.Abs.ImplLexpr $1 $3 }
  | Lexpr '<==>' Lexpr1 { AcslHaskell.FullBnfcParser.Abs.IffLexpr $1 $3 }
  | Lexpr '||' Lexpr1 { AcslHaskell.FullBnfcParser.Abs.OrLexpr $1 $3 }
  | Lexpr '&&' Lexpr1 { AcslHaskell.FullBnfcParser.Abs.AndLexpr $1 $3 }
  | Lexpr '^^' Lexpr1 { AcslHaskell.FullBnfcParser.Abs.HatHatLexpr $1 $3 }
  | Lexpr1 { $1 }

ListLexpr :: { [AcslHaskell.FullBnfcParser.Abs.Lexpr] }
ListLexpr : Lexpr { (:[]) $1 } | Lexpr ',' ListLexpr { (:) $1 $3 }

Lexpr1 :: { AcslHaskell.FullBnfcParser.Abs.Lexpr }
Lexpr1
  : Lexpr2 { $1 }
  | Lexpr3 ListLexprRelInner Relation Lexpr2 { AcslHaskell.FullBnfcParser.Abs.RelationLexpr $1 $2 $3 $4 }

LexprRelInner :: { AcslHaskell.FullBnfcParser.Abs.LexprRelInner }
LexprRelInner
  : Relation Lexpr3 { AcslHaskell.FullBnfcParser.Abs.RelInnerLexpr $1 $2 }

ListLexprRelInner :: { [AcslHaskell.FullBnfcParser.Abs.LexprRelInner] }
ListLexprRelInner
  : {- empty -} { [] }
  | LexprRelInner ListLexprRelInner { (:) $1 $2 }

Relation :: { AcslHaskell.FullBnfcParser.Abs.Relation }
Relation
  : '<' { AcslHaskell.FullBnfcParser.Abs.LessRel }
  | '>' { AcslHaskell.FullBnfcParser.Abs.GreaterRel }
  | '<=' { AcslHaskell.FullBnfcParser.Abs.LessEqRel }
  | '>=' { AcslHaskell.FullBnfcParser.Abs.GreaterEqRel }
  | '==' { AcslHaskell.FullBnfcParser.Abs.EqRel }
  | '!=' { AcslHaskell.FullBnfcParser.Abs.NotEqRel }

Lexpr2 :: { AcslHaskell.FullBnfcParser.Abs.Lexpr }
Lexpr2
  : Lexpr3 { $1 }
  | LexprBinder { AcslHaskell.FullBnfcParser.Abs.BinderLexpr $1 }
  | '!' LexprBinder { AcslHaskell.FullBnfcParser.Abs.NotBinderLexpr $2 }

LexprBinder :: { AcslHaskell.FullBnfcParser.Abs.LexprBinder }
LexprBinder
  : '\\forall' Binders ';' Lexpr { AcslHaskell.FullBnfcParser.Abs.ForallBinderLexpr $2 $4 }
  | '\\exists' Binders ';' Lexpr { AcslHaskell.FullBnfcParser.Abs.ExistBinderLexpr $2 $4 }
  | '\\lambda' Binders ';' Lexpr { AcslHaskell.FullBnfcParser.Abs.LambdaBinderLexpr $2 $4 }

Binders :: { AcslHaskell.FullBnfcParser.Abs.Binders }
Binders
  : TypeSpecOFTYPENAME VarSpec ListBindersReentrance { AcslHaskell.FullBnfcParser.Abs.TheBinders $1 $2 $3 }

TypeSpecOFTYPENAME :: { AcslHaskell.FullBnfcParser.Abs.TypeSpecOFTYPENAME }
TypeSpecOFTYPENAME
  : Ident { AcslHaskell.FullBnfcParser.Abs.TypeSpecTYPENAME $1 }
  | TypeSpecSimple { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleFromTypenameTypeSpec $1 }

BindersReentrance :: { AcslHaskell.FullBnfcParser.Abs.BindersReentrance }
BindersReentrance
  : ',' TypeSpecOFTYPENAME VarSpec { AcslHaskell.FullBnfcParser.Abs.BindersReentranceDeclSpec $2 $3 }
  | ',' VarSpec { AcslHaskell.FullBnfcParser.Abs.BindersReentranceVarSpec $2 }

ListBindersReentrance :: { [AcslHaskell.FullBnfcParser.Abs.BindersReentrance] }
ListBindersReentrance
  : {- empty -} { [] }
  | BindersReentrance ListBindersReentrance { (:) $1 $2 }

VarSpec :: { AcslHaskell.FullBnfcParser.Abs.VarSpec }
VarSpec
  : VarSpec1 { $1 }
  | ListStars VarSpec1 { AcslHaskell.FullBnfcParser.Abs.StartVarSpec $1 $2 }

Stars :: { AcslHaskell.FullBnfcParser.Abs.Stars }
Stars : '*' { AcslHaskell.FullBnfcParser.Abs.Star }

ListStars :: { [AcslHaskell.FullBnfcParser.Abs.Stars] }
ListStars : Stars { (:[]) $1 } | Stars ListStars { (:) $1 $2 }

VarSpec1 :: { AcslHaskell.FullBnfcParser.Abs.VarSpec }
VarSpec1
  : FullIdentifier { AcslHaskell.FullBnfcParser.Abs.SimpleSpec $1 }
  | VarSpec1 '[' ArraySize ']' { AcslHaskell.FullBnfcParser.Abs.ArraySpec $1 $3 }
  | '(' VarSpec ')' { $2 }

ArraySize :: { AcslHaskell.FullBnfcParser.Abs.ArraySize }
ArraySize
  : Integer { AcslHaskell.FullBnfcParser.Abs.IntConstArraySize $1 }
  | FullIdentifier { AcslHaskell.FullBnfcParser.Abs.SomeArraySize $1 }
  | {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoSize }

Lexpr3 :: { AcslHaskell.FullBnfcParser.Abs.Lexpr }
Lexpr3
  : '\\true' { AcslHaskell.FullBnfcParser.Abs.TrueLexpr }
  | '\\false' { AcslHaskell.FullBnfcParser.Abs.FalseLexpr }
  | '\\valid' OptLabel1 '(' Lexpr ')' { AcslHaskell.FullBnfcParser.Abs.ValidLexpr $2 $4 }
  | '\\automatic' { AcslHaskell.FullBnfcParser.Abs.AutomaticLexpr }
  | '\\dynamic' { AcslHaskell.FullBnfcParser.Abs.DynamicLexpr }
  | '\\register' { AcslHaskell.FullBnfcParser.Abs.RegisterLexpr }
  | '\\static' { AcslHaskell.FullBnfcParser.Abs.StaticLexpr }
  | '\\unallocated' { AcslHaskell.FullBnfcParser.Abs.UnallocatedLexpr }
  | '\\null' { AcslHaskell.FullBnfcParser.Abs.NullLexpr }
  | Integer { AcslHaskell.FullBnfcParser.Abs.LexprIntConst $1 }
  | Double { AcslHaskell.FullBnfcParser.Abs.LexprFloatConst $1 }
  | String { AcslHaskell.FullBnfcParser.Abs.LexprStringConst $1 }
  | Lexpr3 '+' Lexpr3 { AcslHaskell.FullBnfcParser.Abs.AddLexpr $1 $3 }
  | Lexpr3 '-' Lexpr3 { AcslHaskell.FullBnfcParser.Abs.SubtrLexpr $1 $3 }
  | Lexpr3 '[' Range ']' { AcslHaskell.FullBnfcParser.Abs.SquaresRangeLexpr $1 $3 }
  | Lexpr3 '[' Lexpr ']' { AcslHaskell.FullBnfcParser.Abs.SquaresLexpr $1 $3 }
  | '\\separated' '(' ListLexpr ')' { AcslHaskell.FullBnfcParser.Abs.SeparatedLexpr $3 }
  | FullIdentifier '(' ListLexpr ')' { AcslHaskell.FullBnfcParser.Abs.FullIdParenLexpr $1 $3 }
  | FullIdentifier { AcslHaskell.FullBnfcParser.Abs.FullId $1 }
  | '\\pi' { AcslHaskell.FullBnfcParser.Abs.PiLexpr }
  | '(' Lexpr ')' { $2 }
  | '(' Range ')' { AcslHaskell.FullBnfcParser.Abs.ParenRangeLexpr $2 }

OptLabel1 :: { AcslHaskell.FullBnfcParser.Abs.OptLabel }
OptLabel1
  : OptLabelList { AcslHaskell.FullBnfcParser.Abs.OptLabelOne $1 }

OptLabel2 :: { AcslHaskell.FullBnfcParser.Abs.OptLabel }
OptLabel2
  : OptLabelList { AcslHaskell.FullBnfcParser.Abs.OptLabelTwo $1 }

OptLabelList :: { AcslHaskell.FullBnfcParser.Abs.OptLabelList }
OptLabelList
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoLableList }
  | '{' ListLabelName '}' { AcslHaskell.FullBnfcParser.Abs.LableList $2 }

LabelName :: { AcslHaskell.FullBnfcParser.Abs.LabelName }
LabelName
  : AnyIdentifier { AcslHaskell.FullBnfcParser.Abs.LableName $1 }

ListLabelName :: { [AcslHaskell.FullBnfcParser.Abs.LabelName] }
ListLabelName
  : LabelName { (:[]) $1 }
  | LabelName ',' ListLabelName { (:) $1 $3 }

Range :: { AcslHaskell.FullBnfcParser.Abs.Range }
Range
  : LexprOption '..' LexprOption { AcslHaskell.FullBnfcParser.Abs.LexprRange $1 $3 }

LexprOption :: { AcslHaskell.FullBnfcParser.Abs.LexprOption }
LexprOption
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoLexprOption }
  | Lexpr { AcslHaskell.FullBnfcParser.Abs.SomeLexprOption $1 }

AnyIdentifier :: { AcslHaskell.FullBnfcParser.Abs.AnyIdentifier }
AnyIdentifier
  : Identifier { AcslHaskell.FullBnfcParser.Abs.SimpleIdentifierAny $1 }

PostCond :: { AcslHaskell.FullBnfcParser.Abs.PostCond }
PostCond
  : 'ensures' { AcslHaskell.FullBnfcParser.Abs.EnsuresKeyWord }
  | 'exits' { AcslHaskell.FullBnfcParser.Abs.ExitsKeyWord }
  | 'breaks' { AcslHaskell.FullBnfcParser.Abs.BreaksKeyWord }
  | 'continues' { AcslHaskell.FullBnfcParser.Abs.ContinuesKeyWord }
  | 'returns' { AcslHaskell.FullBnfcParser.Abs.ReturnsKeyWord }
  | 'check' 'ensures' { AcslHaskell.FullBnfcParser.Abs.CheckEnsuresKeyWord }
  | 'check' 'exits' { AcslHaskell.FullBnfcParser.Abs.CheckExitsKeyWord }
  | 'check' 'breaks' { AcslHaskell.FullBnfcParser.Abs.CheckBreaksKeyWord }
  | 'check' 'continues' { AcslHaskell.FullBnfcParser.Abs.CheckContinuesKeyWord }
  | 'check' 'returns' { AcslHaskell.FullBnfcParser.Abs.CheckReturnsKeyWord }
  | 'admit' 'ensures' { AcslHaskell.FullBnfcParser.Abs.AdmitEnsuresKeyWord }
  | 'admit' 'exits' { AcslHaskell.FullBnfcParser.Abs.AdmitExitsKeyWord }
  | 'admit' 'breaks' { AcslHaskell.FullBnfcParser.Abs.AdmitBreaksKeyWord }
  | 'admit' 'continues' { AcslHaskell.FullBnfcParser.Abs.AdmitContinuesKeyWord }
  | 'admit' 'returns' { AcslHaskell.FullBnfcParser.Abs.AdmitReturnsKeyWord }

FullIdentifier :: { AcslHaskell.FullBnfcParser.Abs.FullIdentifier }
FullIdentifier
  : Identifier { AcslHaskell.FullBnfcParser.Abs.SimpleIdentifierFull $1 }

ListFullIdentifier :: { [AcslHaskell.FullBnfcParser.Abs.FullIdentifier] }
ListFullIdentifier
  : FullIdentifier { (:[]) $1 }
  | FullIdentifier ',' ListFullIdentifier { (:) $1 $3 }

Identifier :: { AcslHaskell.FullBnfcParser.Abs.Identifier }
Identifier
  : Ident { AcslHaskell.FullBnfcParser.Abs.IdentifierIdent $1 }

TypeSpecSimple :: { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimple }
TypeSpecSimple
  : 'integer' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleIntegerKeyWord }
  | 'real' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleRealKeyWord }
  | 'boolean' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleBooleanKeyWord }
  | 'void' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleVoidKeyWord }
  | '_Bool' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleBoolKeyWord }
  | 'char' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleCharKeyWord }
  | 'int' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleIntKeyWord }
  | 'double' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleDoubleKeyWord }
  | 'long' 'double' { AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleLongDoubleKeyWord }

LogicPTreeAnnot :: { AcslHaskell.FullBnfcParser.Abs.LogicPTreeAnnot }
LogicPTreeAnnot
  : Annotation { AcslHaskell.FullBnfcParser.Abs.AnAnnotation $1 }

Annotation :: { AcslHaskell.FullBnfcParser.Abs.Annotation }
Annotation
  : LoopAnnotStack { AcslHaskell.FullBnfcParser.Abs.LoopAnnotation $1 }

LoopAnnotStack :: { AcslHaskell.FullBnfcParser.Abs.LoopAnnotStack }
LoopAnnotStack
  : LoopInvariant LoopAnnotOpt { AcslHaskell.FullBnfcParser.Abs.LoopAnnotStackInvariant $1 $2 }
  | LoopEffects LoopAnnotOpt { AcslHaskell.FullBnfcParser.Abs.LoopAnnotStackEffects $1 $2 }
  | LoopVariant LoopAnnotOpt { AcslHaskell.FullBnfcParser.Abs.LoopAnnotStackVariant $1 $2 }

LoopAnnotOpt :: { AcslHaskell.FullBnfcParser.Abs.LoopAnnotOpt }
LoopAnnotOpt
  : {- empty -} { AcslHaskell.FullBnfcParser.Abs.NoLoopAnnot }
  | LoopAnnotStack { AcslHaskell.FullBnfcParser.Abs.SomeLoopAnnot $1 }

LoopInvariant :: { AcslHaskell.FullBnfcParser.Abs.LoopInvariant }
LoopInvariant
  : 'loop' 'invariant' Lexpr ';' { AcslHaskell.FullBnfcParser.Abs.SimpleLoopInvariant $3 }
  | 'check' 'loop' 'invariant' Lexpr ';' { AcslHaskell.FullBnfcParser.Abs.CheckLoopInvariant $4 }
  | 'admit' 'loop' 'invariant' Lexpr ';' { AcslHaskell.FullBnfcParser.Abs.AdmitLoopInvariant $4 }

LoopVariant :: { AcslHaskell.FullBnfcParser.Abs.LoopVariant }
LoopVariant
  : 'loop' 'variant' Variant ';' { AcslHaskell.FullBnfcParser.Abs.SimpleLoopVariant $3 }

LoopEffects :: { AcslHaskell.FullBnfcParser.Abs.LoopEffects }
LoopEffects
  : 'loop' 'assigns' Assigns ';' { AcslHaskell.FullBnfcParser.Abs.LoopAssigns $3 }

Variant :: { AcslHaskell.FullBnfcParser.Abs.Variant }
Variant
  : Lexpr 'for' AnyIdentifier { AcslHaskell.FullBnfcParser.Abs.ForVariant $1 $3 }
  | Lexpr { AcslHaskell.FullBnfcParser.Abs.LexprVariant $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

