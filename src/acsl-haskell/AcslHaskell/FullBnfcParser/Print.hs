-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for AcslHaskell.

module AcslHaskell.FullBnfcParser.Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified AcslHaskell.FullBnfcParser.Abs

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print AcslHaskell.FullBnfcParser.Abs.Ident where
  prt _ (AcslHaskell.FullBnfcParser.Abs.Ident i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.SIGNED where
  prt _ (AcslHaskell.FullBnfcParser.Abs.SIGNED i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.LBRACE where
  prt _ (AcslHaskell.FullBnfcParser.Abs.LBRACE i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.RBRACE where
  prt _ (AcslHaskell.FullBnfcParser.Abs.RBRACE i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.CONST where
  prt _ (AcslHaskell.FullBnfcParser.Abs.CONST i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.RESTRICT where
  prt _ (AcslHaskell.FullBnfcParser.Abs.RESTRICT i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.VOLATILE where
  prt _ (AcslHaskell.FullBnfcParser.Abs.VOLATILE i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.BLOCKATTRIBUTE where
  prt _ (AcslHaskell.FullBnfcParser.Abs.BLOCKATTRIBUTE i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.LBRACKET where
  prt _ (AcslHaskell.FullBnfcParser.Abs.LBRACKET i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.RBRACKET where
  prt _ (AcslHaskell.FullBnfcParser.Abs.RBRACKET i) = doc $ showString i
instance Print AcslHaskell.FullBnfcParser.Abs.Program where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AProgram globals -> prPrec i 0 (concatD [prt 0 globals])

instance Print AcslHaskell.FullBnfcParser.Abs.Globals where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoGlobals -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SimpleGlobals global globals -> prPrec i 0 (concatD [prt 0 global, prt 0 globals])
    AcslHaskell.FullBnfcParser.Abs.SemiColonGlobals globals -> prPrec i 0 (concatD [doc (showString ";"), prt 0 globals])

instance Print AcslHaskell.FullBnfcParser.Abs.Global where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.GlobalsFunctionDef functiondef -> prPrec i 0 (concatD [prt 0 functiondef])
    AcslHaskell.FullBnfcParser.Abs.GlobalsDeclataion declaration -> prPrec i 0 (concatD [prt 0 declaration])

instance Print AcslHaskell.FullBnfcParser.Abs.FunctionDef where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleFunctionDef functiondefstart block -> prPrec i 0 (concatD [prt 0 functiondefstart, prt 0 block])
    AcslHaskell.FullBnfcParser.Abs.FunctionDefSpec acslprogram functiondefstart block -> prPrec i 0 (concatD [prt 0 acslprogram, prt 0 functiondefstart, prt 0 block])

instance Print AcslHaskell.FullBnfcParser.Abs.FunctionDefStart where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.FunctionDefStartDeclarator declspeclist declarator -> prPrec i 0 (concatD [prt 0 declspeclist, prt 0 declarator])

instance Print AcslHaskell.FullBnfcParser.Abs.DeclSpecList where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.DeclSpecTypeSpec typespec -> prPrec i 0 (concatD [prt 0 typespec])
    AcslHaskell.FullBnfcParser.Abs.DeclSpecTypeSpecNext typespec declspeclistnonamed -> prPrec i 0 (concatD [prt 0 typespec, prt 0 declspeclistnonamed])

instance Print AcslHaskell.FullBnfcParser.Abs.DeclSpecListNoNamed where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.DeclSpecNoNamedTypeSpec typespec -> prPrec i 0 (concatD [prt 0 typespec])
    AcslHaskell.FullBnfcParser.Abs.DeclSpecNoNamedTypeSpecNext typespec declspeclistnonamed -> prPrec i 0 (concatD [prt 0 typespec, prt 0 declspeclistnonamed])

instance Print AcslHaskell.FullBnfcParser.Abs.TypeSpec where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.TypeSpecVoidKeyWord -> prPrec i 0 (concatD [doc (showString "void")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecCharKeyWord -> prPrec i 0 (concatD [doc (showString "char")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecBoolKeyWord -> prPrec i 0 (concatD [doc (showString "_Bool")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecShortKeyWord -> prPrec i 0 (concatD [doc (showString "short")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecInt32KeyWord -> prPrec i 0 (concatD [doc (showString "__int32")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecIntKeyWord -> prPrec i 0 (concatD [doc (showString "int")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSizeTKeyWord -> prPrec i 0 (concatD [doc (showString "size_t")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecLongKeyWord -> prPrec i 0 (concatD [doc (showString "long")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecInt64KeyWord -> prPrec i 0 (concatD [doc (showString "__int64")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecFloatKeyWord -> prPrec i 0 (concatD [doc (showString "float")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecDoubleKeyWord -> prPrec i 0 (concatD [doc (showString "double")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSignedKeyWord signed -> prPrec i 0 (concatD [prt 0 signed])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecUnsignedKeyWord -> prPrec i 0 (concatD [doc (showString "unsigned")])
    AcslHaskell.FullBnfcParser.Abs.StructId idortypename -> prPrec i 0 (concatD [doc (showString "struct"), prt 0 idortypename])
    AcslHaskell.FullBnfcParser.Abs.StructIdBraces idortypename structdecllist -> prPrec i 0 (concatD [doc (showString "struct"), prt 0 idortypename, doc (showString "{"), prt 0 structdecllist, doc (showString "}")])
    AcslHaskell.FullBnfcParser.Abs.StructBraces structdecllist -> prPrec i 0 (concatD [doc (showString "struct"), doc (showString "{"), prt 0 structdecllist, doc (showString "}")])

instance Print AcslHaskell.FullBnfcParser.Abs.Declarator where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ADeclarator pointeropt directdecl attributeswithasm -> prPrec i 0 (concatD [prt 0 pointeropt, prt 0 directdecl, prt 0 attributeswithasm])

instance Print AcslHaskell.FullBnfcParser.Abs.PointerOpt where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoPointer -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomePointer attributes pointeropt -> prPrec i 0 (concatD [doc (showString "*"), prt 0 attributes, prt 0 pointeropt])

instance Print AcslHaskell.FullBnfcParser.Abs.DirectDecl where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.DirectDeclIdTypename idortypename -> prPrec i 0 (concatD [prt 0 idortypename])
    AcslHaskell.FullBnfcParser.Abs.DirectDeclGhostParam directdecl ghostparameteropt -> prPrec i 0 (concatD [prt 0 directdecl, doc (showString "("), doc (showString ")"), prt 0 ghostparameteropt])
    AcslHaskell.FullBnfcParser.Abs.DirectDeclGhostRestParParam directdecl restparlist ghostparameteropt -> prPrec i 0 (concatD [prt 0 directdecl, doc (showString "("), prt 0 restparlist, doc (showString ")"), prt 0 ghostparameteropt])

instance Print AcslHaskell.FullBnfcParser.Abs.AttributesWithAsm where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.EmptyAttrWithASM -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.RestParList where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleParameterDecl parameterdecls -> prPrec i 0 (concatD [prt 0 parameterdecls])

instance Print AcslHaskell.FullBnfcParser.Abs.ParameterDecl where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ParameterDeclSpecDeclarator declspeclist declarator -> prPrec i 0 (concatD [prt 0 declspeclist, prt 0 declarator])
    AcslHaskell.FullBnfcParser.Abs.ParameterDeclSpec declspeclist -> prPrec i 0 (concatD [prt 0 declspeclist])
    AcslHaskell.FullBnfcParser.Abs.ParameterDeclPar parameterdecl -> prPrec i 0 (concatD [doc (showString "("), prt 0 parameterdecl, doc (showString ")")])

instance Print [AcslHaskell.FullBnfcParser.Abs.ParameterDecl] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.GhostParameterOpt where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoGhostParameter -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.IdOrTypename where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.IdTypename idortypenameasid -> prPrec i 0 (concatD [prt 0 idortypenameasid])

instance Print AcslHaskell.FullBnfcParser.Abs.IdOrTypenameAsId where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.IdOrTypenameAsIdIdentifier id_ -> prPrec i 0 (concatD [prt 0 id_])

instance Print AcslHaskell.FullBnfcParser.Abs.Declaration where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.DeclSpecInitDecl declspeclist declandinitdeclattrlist -> prPrec i 0 (concatD [prt 0 declspeclist, prt 0 declandinitdeclattrlist, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.DeclSpec declspeclist -> prPrec i 0 (concatD [prt 0 declspeclist, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.SpecDeclSpecInitDecl acslprogram declspeclist declandinitdeclattrlist -> prPrec i 0 (concatD [prt 0 acslprogram, prt 0 declspeclist, prt 0 declandinitdeclattrlist, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.SpecDeclSpec acslprogram declspeclist -> prPrec i 0 (concatD [prt 0 acslprogram, prt 0 declspeclist, doc (showString ";")])

instance Print AcslHaskell.FullBnfcParser.Abs.DeclAndInitDeclAttrList where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.InitDeclaration initdeclarator -> prPrec i 0 (concatD [prt 0 initdeclarator])
    AcslHaskell.FullBnfcParser.Abs.InitDeclarationWithAttr initdeclarator initdeclaratorattrs -> prPrec i 0 (concatD [prt 0 initdeclarator, doc (showString ","), prt 0 initdeclaratorattrs])

instance Print AcslHaskell.FullBnfcParser.Abs.InitDeclaratorAttr where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.InitDeclaratorAttribute initdeclarator -> prPrec i 0 (concatD [prt 0 initdeclarator])

instance Print [AcslHaskell.FullBnfcParser.Abs.InitDeclaratorAttr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.InitDeclarator where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleInitDeclarator declarator -> prPrec i 0 (concatD [prt 0 declarator])

instance Print AcslHaskell.FullBnfcParser.Abs.StructDeclList where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.EmptyStructDecl -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.DeclSpecStructDecl declspeclist structdecllist -> prPrec i 0 (concatD [prt 0 declspeclist, doc (showString ";"), prt 0 structdecllist])
    AcslHaskell.FullBnfcParser.Abs.SemicolonStructDecl structdecllist -> prPrec i 0 (concatD [doc (showString ";"), prt 0 structdecllist])
    AcslHaskell.FullBnfcParser.Abs.SpecFieldDeclStructDecl declspeclist fielddecls structdecllist -> prPrec i 0 (concatD [prt 0 declspeclist, prt 0 fielddecls, doc (showString ";"), prt 0 structdecllist])

instance Print AcslHaskell.FullBnfcParser.Abs.FieldDecl where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.FieldDeclDeclarator declarator -> prPrec i 0 (concatD [prt 0 declarator])

instance Print [AcslHaskell.FullBnfcParser.Abs.FieldDecl] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.Attribute where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AttributeConst const -> prPrec i 0 (concatD [prt 0 const])

instance Print [AcslHaskell.FullBnfcParser.Abs.Attribute] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.Block where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ABlock blockattrs blockelements -> prPrec i 0 (concatD [doc (showString "{"), prt 0 blockattrs, prt 0 blockelements, doc (showString "}")])

instance Print AcslHaskell.FullBnfcParser.Abs.BlockAttrs where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoBlockAttrs -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomeBlockAttrs blockattribute attrs -> prPrec i 0 (concatD [prt 0 blockattribute, doc (showString "("), prt 0 attrs, doc (showString ")")])

instance Print AcslHaskell.FullBnfcParser.Abs.BlockElement where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.DeclarationElement declaration -> prPrec i 0 (concatD [prt 0 declaration])
    AcslHaskell.FullBnfcParser.Abs.StatementElement statement -> prPrec i 0 (concatD [prt 0 statement])

instance Print [AcslHaskell.FullBnfcParser.Abs.BlockElement] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.Statement where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SemicolonStatement -> prPrec i 0 (concatD [doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.SpecStatement acslprogram annotatedstmt -> prPrec i 0 (concatD [prt 0 acslprogram, prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.ExprsStatement expressions -> prPrec i 0 (concatD [prt 0 expressions, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.BlockStatement block -> prPrec i 0 (concatD [prt 0 block])
    AcslHaskell.FullBnfcParser.Abs.IfStatement expressions annotatedstmt elsepart -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expressions, doc (showString ")"), prt 0 annotatedstmt, prt 0 elsepart])
    AcslHaskell.FullBnfcParser.Abs.SwitchStatement expressions annotatedstmt -> prPrec i 0 (concatD [doc (showString "switch"), doc (showString "("), prt 0 expressions, doc (showString ")"), prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.WhileStatement expressions annotatedstmt -> prPrec i 0 (concatD [doc (showString "while"), doc (showString "("), prt 0 expressions, doc (showString ")"), prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.ForStatement forclause optexpression1 optexpression2 annotatedstmt -> prPrec i 0 (concatD [doc (showString "for"), doc (showString "("), prt 0 forclause, prt 0 optexpression1, doc (showString ";"), prt 0 optexpression2, doc (showString ")"), prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.CaseStatement expression annotatedstmt -> prPrec i 0 (concatD [doc (showString "case"), prt 0 expression, doc (showString ":"), prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.CaseSliceStatement expression1 expression2 annotatedstmt -> prPrec i 0 (concatD [doc (showString "case"), prt 0 expression1, doc (showString "..."), prt 0 expression2, doc (showString ":"), prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.DefaultStatement annotatedstmt -> prPrec i 0 (concatD [doc (showString "default"), doc (showString ":"), prt 0 annotatedstmt])
    AcslHaskell.FullBnfcParser.Abs.EmptyReturnStatement -> prPrec i 0 (concatD [doc (showString "return"), doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.ReturnStatement expressions -> prPrec i 0 (concatD [doc (showString "return"), prt 0 expressions, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.BreakStatement -> prPrec i 0 (concatD [doc (showString "break"), doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.ContinueStatement -> prPrec i 0 (concatD [doc (showString "continue"), doc (showString ";")])

instance Print AcslHaskell.FullBnfcParser.Abs.ForClause where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ForClauseExpression optexpression -> prPrec i 0 (concatD [prt 0 optexpression, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.ForClauseDeclaration declaration -> prPrec i 0 (concatD [prt 0 declaration])

instance Print AcslHaskell.FullBnfcParser.Abs.Attr where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AnAttr attr1 attr2 -> prPrec i 0 (concatD [prt 1 attr1, doc (showString "="), prt 1 attr2])
    AcslHaskell.FullBnfcParser.Abs.TernaryCond attr1 attr2 attr3 -> prPrec i 1 (concatD [prt 2 attr1, doc (showString "?"), prt 1 attr2, doc (showString ":"), prt 1 attr3])
    AcslHaskell.FullBnfcParser.Abs.Or attr1 attr2 -> prPrec i 2 (concatD [prt 2 attr1, doc (showString "||"), prt 3 attr2])
    AcslHaskell.FullBnfcParser.Abs.And attr1 attr2 -> prPrec i 3 (concatD [prt 3 attr1, doc (showString "&&"), prt 4 attr2])
    AcslHaskell.FullBnfcParser.Abs.BitOr attr1 attr2 -> prPrec i 4 (concatD [prt 4 attr1, doc (showString "|"), prt 5 attr2])
    AcslHaskell.FullBnfcParser.Abs.Xor attr1 attr2 -> prPrec i 5 (concatD [prt 5 attr1, doc (showString "^"), prt 6 attr2])
    AcslHaskell.FullBnfcParser.Abs.BitAnd attr1 attr2 -> prPrec i 6 (concatD [prt 6 attr1, doc (showString "&"), prt 7 attr2])
    AcslHaskell.FullBnfcParser.Abs.EqualEqual attr1 attr2 -> prPrec i 7 (concatD [prt 7 attr1, doc (showString "=="), prt 8 attr2])
    AcslHaskell.FullBnfcParser.Abs.NotEqual attr1 attr2 -> prPrec i 7 (concatD [prt 7 attr1, doc (showString "!="), prt 8 attr2])
    AcslHaskell.FullBnfcParser.Abs.Less attr1 attr2 -> prPrec i 8 (concatD [prt 8 attr1, doc (showString "<"), prt 9 attr2])
    AcslHaskell.FullBnfcParser.Abs.Greater attr1 attr2 -> prPrec i 8 (concatD [prt 8 attr1, doc (showString ">"), prt 9 attr2])
    AcslHaskell.FullBnfcParser.Abs.LessEqual attr1 attr2 -> prPrec i 8 (concatD [prt 8 attr1, doc (showString "<="), prt 9 attr2])
    AcslHaskell.FullBnfcParser.Abs.GreaterEqual attr1 attr2 -> prPrec i 8 (concatD [prt 8 attr1, doc (showString ">="), prt 9 attr2])
    AcslHaskell.FullBnfcParser.Abs.LeftShiftOp attr1 attr2 -> prPrec i 9 (concatD [prt 9 attr1, doc (showString "<<"), prt 10 attr2])
    AcslHaskell.FullBnfcParser.Abs.RightShiftOp attr1 attr2 -> prPrec i 9 (concatD [prt 9 attr1, doc (showString ">>"), prt 10 attr2])
    AcslHaskell.FullBnfcParser.Abs.AddOp attr1 attr2 -> prPrec i 10 (concatD [prt 10 attr1, doc (showString "+"), prt 11 attr2])
    AcslHaskell.FullBnfcParser.Abs.SubOp attr1 attr2 -> prPrec i 10 (concatD [prt 10 attr1, doc (showString "-"), prt 11 attr2])
    AcslHaskell.FullBnfcParser.Abs.MultOp attr1 attr2 -> prPrec i 11 (concatD [prt 11 attr1, doc (showString "*"), prt 12 attr2])
    AcslHaskell.FullBnfcParser.Abs.DivOp attr1 attr2 -> prPrec i 11 (concatD [prt 11 attr1, doc (showString "/"), prt 12 attr2])
    AcslHaskell.FullBnfcParser.Abs.ModOp attr1 attr2 -> prPrec i 11 (concatD [prt 11 attr1, doc (showString "%"), prt 12 attr2])
    AcslHaskell.FullBnfcParser.Abs.PlusUnaryAttr attr -> prPrec i 12 (concatD [doc (showString "+"), prt 12 attr])
    AcslHaskell.FullBnfcParser.Abs.MinusUnaryAttr attr -> prPrec i 12 (concatD [doc (showString "-"), prt 12 attr])
    AcslHaskell.FullBnfcParser.Abs.MultUnaryAttr attr -> prPrec i 12 (concatD [doc (showString "*"), prt 12 attr])
    AcslHaskell.FullBnfcParser.Abs.AmpUnaryAttr attr -> prPrec i 12 (concatD [doc (showString "&"), prt 12 attr])
    AcslHaskell.FullBnfcParser.Abs.NotUnaryAttr attr -> prPrec i 12 (concatD [doc (showString "!"), prt 12 attr])
    AcslHaskell.FullBnfcParser.Abs.TildeUnaryAttr attr -> prPrec i 12 (concatD [doc (showString "~"), prt 12 attr])
    AcslHaskell.FullBnfcParser.Abs.FuncationCall idortypenameasid attrs -> prPrec i 13 (concatD [prt 0 idortypenameasid, doc (showString "("), prt 0 attrs, doc (showString ")")])
    AcslHaskell.FullBnfcParser.Abs.ProcedureCall idortypenameasid -> prPrec i 13 (concatD [prt 0 idortypenameasid, doc (showString "("), doc (showString ")")])
    AcslHaskell.FullBnfcParser.Abs.ArrowAttr attr idortypename -> prPrec i 13 (concatD [prt 13 attr, doc (showString "->"), prt 0 idortypename])
    AcslHaskell.FullBnfcParser.Abs.DotAttr attr idortypename -> prPrec i 13 (concatD [prt 13 attr, doc (showString "."), prt 0 idortypename])
    AcslHaskell.FullBnfcParser.Abs.ArrayAttr attr1 attr2 -> prPrec i 13 (concatD [prt 13 attr1, doc (showString "["), prt 0 attr2, doc (showString "]")])
    AcslHaskell.FullBnfcParser.Abs.BasicAttr basicattribute -> prPrec i 14 (concatD [prt 0 basicattribute])

instance Print [AcslHaskell.FullBnfcParser.Abs.Attr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.BasicAttribute where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.BasicAttrConsInt n -> prPrec i 0 (concatD [prt 0 n])
    AcslHaskell.FullBnfcParser.Abs.BasicAttrConsFloat d -> prPrec i 0 (concatD [prt 0 d])

instance Print AcslHaskell.FullBnfcParser.Abs.AnnotatedStmt where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AnnotatedStatement statement -> prPrec i 0 (concatD [prt 0 statement])

instance Print AcslHaskell.FullBnfcParser.Abs.ElsePart where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoElsePart -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SimpleElsePart annotatedstmt -> prPrec i 0 (concatD [doc (showString "else"), prt 0 annotatedstmt])

instance Print AcslHaskell.FullBnfcParser.Abs.OptExpression where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoExpression -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomeExpression expressions -> prPrec i 0 (concatD [prt 0 expressions])

instance Print AcslHaskell.FullBnfcParser.Abs.Expression where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AssignmentExpr assignexpr -> prPrec i 0 (concatD [prt 0 assignexpr])

instance Print [AcslHaskell.FullBnfcParser.Abs.Expression] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.AssignExpr where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.EqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.PlusEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "+="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.MinusEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "-="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.MultEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "*="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.DivEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "/="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.ModEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "%="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.AndEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "&="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.OrEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "|="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.XorEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "^="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.LeftShiftEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString "<<="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.RightShiftEqAssignExpr assignexpr1 assignexpr2 -> prPrec i 0 (concatD [prt 12 assignexpr1, doc (showString ">>="), prt 0 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.TernaryCondExpr assignexpr1 optexpression assignexpr2 -> prPrec i 1 (concatD [prt 2 assignexpr1, doc (showString "?"), prt 0 optexpression, doc (showString ":"), prt 1 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.OrExpr assignexpr1 assignexpr2 -> prPrec i 2 (concatD [prt 2 assignexpr1, doc (showString "||"), prt 3 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.AndExpr assignexpr1 assignexpr2 -> prPrec i 3 (concatD [prt 3 assignexpr1, doc (showString "&&"), prt 4 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.BitOrExpr assignexpr1 assignexpr2 -> prPrec i 4 (concatD [prt 4 assignexpr1, doc (showString "|"), prt 5 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.BitXorExpr assignexpr1 assignexpr2 -> prPrec i 5 (concatD [prt 5 assignexpr1, doc (showString "^"), prt 6 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.BitAndExpr assignexpr1 assignexpr2 -> prPrec i 6 (concatD [prt 6 assignexpr1, doc (showString "&"), prt 7 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.EqExpr assignexpr1 assignexpr2 -> prPrec i 7 (concatD [prt 7 assignexpr1, doc (showString "=="), prt 8 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.NotEqExpr assignexpr1 assignexpr2 -> prPrec i 7 (concatD [prt 7 assignexpr1, doc (showString "!="), prt 8 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.LessExpr assignexpr1 assignexpr2 -> prPrec i 8 (concatD [prt 8 assignexpr1, doc (showString "<"), prt 9 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.GreaterExpr assignexpr1 assignexpr2 -> prPrec i 8 (concatD [prt 8 assignexpr1, doc (showString ">"), prt 9 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.LessEqualExpr assignexpr1 assignexpr2 -> prPrec i 8 (concatD [prt 8 assignexpr1, doc (showString "<="), prt 9 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.GreaterEqualExpr assignexpr1 assignexpr2 -> prPrec i 8 (concatD [prt 8 assignexpr1, doc (showString ">="), prt 9 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.LeftShiftExpr assignexpr1 assignexpr2 -> prPrec i 9 (concatD [prt 9 assignexpr1, doc (showString "<<"), prt 10 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.RightShiftExpr assignexpr1 assignexpr2 -> prPrec i 9 (concatD [prt 9 assignexpr1, doc (showString ">>"), prt 10 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.PlusExpr assignexpr1 assignexpr2 -> prPrec i 10 (concatD [prt 10 assignexpr1, doc (showString "+"), prt 11 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.MinusExpr assignexpr1 assignexpr2 -> prPrec i 10 (concatD [prt 10 assignexpr1, doc (showString "-"), prt 11 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.MulsExpr assignexpr1 assignexpr2 -> prPrec i 11 (concatD [prt 11 assignexpr1, doc (showString "*"), prt 12 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.DivExpr assignexpr1 assignexpr2 -> prPrec i 11 (concatD [prt 11 assignexpr1, doc (showString "/"), prt 12 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.ModExpr assignexpr1 assignexpr2 -> prPrec i 11 (concatD [prt 11 assignexpr1, doc (showString "%"), prt 12 assignexpr2])
    AcslHaskell.FullBnfcParser.Abs.CastExpr typename assignexpr -> prPrec i 12 (concatD [doc (showString "("), prt 0 typename, doc (showString ")"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprPlusPlus assignexpr -> prPrec i 13 (concatD [doc (showString "++"), prt 13 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprMinusMinus assignexpr -> prPrec i 13 (concatD [doc (showString "--"), prt 13 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprPlus assignexpr -> prPrec i 13 (concatD [doc (showString "+"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprMinus assignexpr -> prPrec i 13 (concatD [doc (showString "-"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprMult assignexpr -> prPrec i 13 (concatD [doc (showString "*"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprAmp assignexpr -> prPrec i 13 (concatD [doc (showString "&"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprNot assignexpr -> prPrec i 13 (concatD [doc (showString "!"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprTilde assignexpr -> prPrec i 13 (concatD [doc (showString "~"), prt 12 assignexpr])
    AcslHaskell.FullBnfcParser.Abs.UnaryExprAddress idortypenameasid -> prPrec i 13 (concatD [doc (showString "&&"), prt 0 idortypenameasid])
    AcslHaskell.FullBnfcParser.Abs.BracketsPostfixExpression assignexpr expressions -> prPrec i 14 (concatD [prt 14 assignexpr, doc (showString "["), prt 0 expressions, doc (showString "]")])
    AcslHaskell.FullBnfcParser.Abs.DotPostfixExpression assignexpr idortypename -> prPrec i 14 (concatD [prt 14 assignexpr, doc (showString "."), prt 0 idortypename])
    AcslHaskell.FullBnfcParser.Abs.ArrowPostfixExpression assignexpr idortypename -> prPrec i 14 (concatD [prt 14 assignexpr, doc (showString "->"), prt 0 idortypename])
    AcslHaskell.FullBnfcParser.Abs.PlusPlusPostfixExpression assignexpr -> prPrec i 14 (concatD [prt 14 assignexpr, doc (showString "++")])
    AcslHaskell.FullBnfcParser.Abs.MinusMinusPostfixExpression assignexpr -> prPrec i 14 (concatD [prt 14 assignexpr, doc (showString "--")])
    AcslHaskell.FullBnfcParser.Abs.IdentifierPrimaryExpression id_ -> prPrec i 15 (concatD [prt 0 id_])
    AcslHaskell.FullBnfcParser.Abs.ConstantPrimaryExpressin constant -> prPrec i 15 (concatD [prt 0 constant])
    AcslHaskell.FullBnfcParser.Abs.CommaExpressionPrimaryExpressin expressions -> prPrec i 15 (concatD [doc (showString "("), prt 0 expressions, doc (showString ")")])
    AcslHaskell.FullBnfcParser.Abs.BlockPrimaryExpressin block -> prPrec i 15 (concatD [doc (showString "("), prt 0 block, doc (showString ")")])

instance Print AcslHaskell.FullBnfcParser.Abs.Constant where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ConstantInt n -> prPrec i 0 (concatD [prt 0 n])
    AcslHaskell.FullBnfcParser.Abs.ConstantFloat d -> prPrec i 0 (concatD [prt 0 d])
    AcslHaskell.FullBnfcParser.Abs.ConstantChar c -> prPrec i 0 (concatD [prt 0 c])

instance Print AcslHaskell.FullBnfcParser.Abs.TypeName where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.TypeNameDeclSpecList declspeclist -> prPrec i 0 (concatD [prt 0 declspeclist])

instance Print AcslHaskell.FullBnfcParser.Abs.ACSLProgram where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AnnotProgram annot -> prPrec i 0 (concatD [doc (showString "ACSL_START"), prt 0 annot, doc (showString "ACSL_END")])
    AcslHaskell.FullBnfcParser.Abs.AnnotationProgram logicptreeannot -> prPrec i 0 (concatD [doc (showString "ACSL_START"), prt 0 logicptreeannot, doc (showString "ACSL_END")])

instance Print AcslHaskell.FullBnfcParser.Abs.Annot where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.CodeAnnot codeannot -> prPrec i 0 (concatD [prt 0 codeannot])

instance Print AcslHaskell.FullBnfcParser.Abs.Code_Annot where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.CodeAnnotContract contract -> prPrec i 0 (concatD [prt 0 contract])

instance Print AcslHaskell.FullBnfcParser.Abs.Contract where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleContract requires terminates decreases simpleclauses behaviors completeordisjoint -> prPrec i 0 (concatD [prt 0 requires, prt 0 terminates, prt 0 decreases, prt 0 simpleclauses, prt 0 behaviors, prt 0 completeordisjoint])

instance Print AcslHaskell.FullBnfcParser.Abs.Requires where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoRequires -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomeRequires nerequires -> prPrec i 0 (concatD [prt 0 nerequires])

instance Print AcslHaskell.FullBnfcParser.Abs.NERequires where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleRequires lexpr requires -> prPrec i 0 (concatD [doc (showString "requires"), prt 0 lexpr, doc (showString ";"), prt 0 requires])
    AcslHaskell.FullBnfcParser.Abs.CheckRequires lexpr requires -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "requires"), prt 0 lexpr, doc (showString ";"), prt 0 requires])
    AcslHaskell.FullBnfcParser.Abs.AdimtRequires lexpr requires -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "requires"), prt 0 lexpr, doc (showString ";"), prt 0 requires])

instance Print AcslHaskell.FullBnfcParser.Abs.Terminates where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoTerminate -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.Decreases where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoDecreases -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.SimpleClauses where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoSimpleClauses -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomeSimpleClauses nesimpleclauses -> prPrec i 0 (concatD [prt 0 nesimpleclauses])

instance Print AcslHaskell.FullBnfcParser.Abs.NESimpleClauses where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.PostCondSimpleClauses postcond lexpr simpleclauses -> prPrec i 0 (concatD [prt 0 postcond, prt 0 lexpr, doc (showString ";"), prt 0 simpleclauses])
    AcslHaskell.FullBnfcParser.Abs.AssignsSimpleClauses assigns simpleclauses -> prPrec i 0 (concatD [doc (showString "assigns"), prt 0 assigns, doc (showString ";"), prt 0 simpleclauses])

instance Print AcslHaskell.FullBnfcParser.Abs.Assigns where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AssignZone zones -> prPrec i 0 (concatD [prt 0 zones])
    AcslHaskell.FullBnfcParser.Abs.AssignZoneFromZone lexprs zones -> prPrec i 0 (concatD [prt 0 lexprs, doc (showString "\\from"), prt 0 zones])

instance Print AcslHaskell.FullBnfcParser.Abs.Zones where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SomeZone lexprs -> prPrec i 0 (concatD [prt 0 lexprs])
    AcslHaskell.FullBnfcParser.Abs.NoZone -> prPrec i 0 (concatD [doc (showString "\\nothing")])

instance Print AcslHaskell.FullBnfcParser.Abs.Behaviors where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoBehaviors -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.CompleteOrDisjoint where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoComplDisj -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.Lexpr where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ImplLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 0 lexpr1, doc (showString "==>"), prt 1 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.IffLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 0 lexpr1, doc (showString "<==>"), prt 1 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.OrLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 0 lexpr1, doc (showString "||"), prt 1 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.AndLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 0 lexpr1, doc (showString "&&"), prt 1 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.HatHatLexpr lexpr1 lexpr2 -> prPrec i 0 (concatD [prt 0 lexpr1, doc (showString "^^"), prt 1 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.RelationLexpr lexpr1 lexprrelinners relation lexpr2 -> prPrec i 1 (concatD [prt 3 lexpr1, prt 0 lexprrelinners, prt 0 relation, prt 2 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.BinderLexpr lexprbinder -> prPrec i 2 (concatD [prt 0 lexprbinder])
    AcslHaskell.FullBnfcParser.Abs.NotBinderLexpr lexprbinder -> prPrec i 2 (concatD [doc (showString "!"), prt 0 lexprbinder])
    AcslHaskell.FullBnfcParser.Abs.TrueLexpr -> prPrec i 3 (concatD [doc (showString "\\true")])
    AcslHaskell.FullBnfcParser.Abs.FalseLexpr -> prPrec i 3 (concatD [doc (showString "\\false")])
    AcslHaskell.FullBnfcParser.Abs.ValidLexpr optlabel lexpr -> prPrec i 3 (concatD [doc (showString "\\valid"), prt 1 optlabel, doc (showString "("), prt 0 lexpr, doc (showString ")")])
    AcslHaskell.FullBnfcParser.Abs.AutomaticLexpr -> prPrec i 3 (concatD [doc (showString "\\automatic")])
    AcslHaskell.FullBnfcParser.Abs.DynamicLexpr -> prPrec i 3 (concatD [doc (showString "\\dynamic")])
    AcslHaskell.FullBnfcParser.Abs.RegisterLexpr -> prPrec i 3 (concatD [doc (showString "\\register")])
    AcslHaskell.FullBnfcParser.Abs.StaticLexpr -> prPrec i 3 (concatD [doc (showString "\\static")])
    AcslHaskell.FullBnfcParser.Abs.UnallocatedLexpr -> prPrec i 3 (concatD [doc (showString "\\unallocated")])
    AcslHaskell.FullBnfcParser.Abs.NullLexpr -> prPrec i 3 (concatD [doc (showString "\\null")])
    AcslHaskell.FullBnfcParser.Abs.LexprIntConst n -> prPrec i 3 (concatD [prt 0 n])
    AcslHaskell.FullBnfcParser.Abs.LexprFloatConst d -> prPrec i 3 (concatD [prt 0 d])
    AcslHaskell.FullBnfcParser.Abs.LexprStringConst str -> prPrec i 3 (concatD [printString str])
    AcslHaskell.FullBnfcParser.Abs.AddLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "+"), prt 3 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.SubtrLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "-"), prt 3 lexpr2])
    AcslHaskell.FullBnfcParser.Abs.SquaresRangeLexpr lexpr range -> prPrec i 3 (concatD [prt 3 lexpr, doc (showString "["), prt 0 range, doc (showString "]")])
    AcslHaskell.FullBnfcParser.Abs.SquaresLexpr lexpr1 lexpr2 -> prPrec i 3 (concatD [prt 3 lexpr1, doc (showString "["), prt 0 lexpr2, doc (showString "]")])
    AcslHaskell.FullBnfcParser.Abs.SeparatedLexpr lexprs -> prPrec i 3 (concatD [doc (showString "\\separated"), doc (showString "("), prt 0 lexprs, doc (showString ")")])
    AcslHaskell.FullBnfcParser.Abs.FullIdParenLexpr fullidentifier lexprs -> prPrec i 3 (concatD [prt 0 fullidentifier, doc (showString "("), prt 0 lexprs, doc (showString ")")])
    AcslHaskell.FullBnfcParser.Abs.FullId fullidentifier -> prPrec i 3 (concatD [prt 0 fullidentifier])
    AcslHaskell.FullBnfcParser.Abs.PiLexpr -> prPrec i 3 (concatD [doc (showString "\\pi")])
    AcslHaskell.FullBnfcParser.Abs.ParenRangeLexpr range -> prPrec i 3 (concatD [doc (showString "("), prt 0 range, doc (showString ")")])

instance Print [AcslHaskell.FullBnfcParser.Abs.Lexpr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.LexprRelInner where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.RelInnerLexpr relation lexpr -> prPrec i 0 (concatD [prt 0 relation, prt 3 lexpr])

instance Print [AcslHaskell.FullBnfcParser.Abs.LexprRelInner] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.Relation where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.LessRel -> prPrec i 0 (concatD [doc (showString "<")])
    AcslHaskell.FullBnfcParser.Abs.GreaterRel -> prPrec i 0 (concatD [doc (showString ">")])
    AcslHaskell.FullBnfcParser.Abs.LessEqRel -> prPrec i 0 (concatD [doc (showString "<=")])
    AcslHaskell.FullBnfcParser.Abs.GreaterEqRel -> prPrec i 0 (concatD [doc (showString ">=")])
    AcslHaskell.FullBnfcParser.Abs.EqRel -> prPrec i 0 (concatD [doc (showString "==")])
    AcslHaskell.FullBnfcParser.Abs.NotEqRel -> prPrec i 0 (concatD [doc (showString "!=")])

instance Print AcslHaskell.FullBnfcParser.Abs.LexprBinder where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ForallBinderLexpr binders lexpr -> prPrec i 0 (concatD [doc (showString "\\forall"), prt 0 binders, doc (showString ";"), prt 0 lexpr])
    AcslHaskell.FullBnfcParser.Abs.ExistBinderLexpr binders lexpr -> prPrec i 0 (concatD [doc (showString "\\exists"), prt 0 binders, doc (showString ";"), prt 0 lexpr])
    AcslHaskell.FullBnfcParser.Abs.LambdaBinderLexpr binders lexpr -> prPrec i 0 (concatD [doc (showString "\\lambda"), prt 0 binders, doc (showString ";"), prt 0 lexpr])

instance Print AcslHaskell.FullBnfcParser.Abs.Binders where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.TheBinders typespecoftypename varspec bindersreentrances -> prPrec i 0 (concatD [prt 0 typespecoftypename, prt 0 varspec, prt 0 bindersreentrances])

instance Print AcslHaskell.FullBnfcParser.Abs.TypeSpecOFTYPENAME where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.TypeSpecTYPENAME id_ -> prPrec i 0 (concatD [prt 0 id_])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleFromTypenameTypeSpec typespecsimple -> prPrec i 0 (concatD [prt 0 typespecsimple])

instance Print AcslHaskell.FullBnfcParser.Abs.BindersReentrance where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.BindersReentranceDeclSpec typespecoftypename varspec -> prPrec i 0 (concatD [doc (showString ","), prt 0 typespecoftypename, prt 0 varspec])
    AcslHaskell.FullBnfcParser.Abs.BindersReentranceVarSpec varspec -> prPrec i 0 (concatD [doc (showString ","), prt 0 varspec])

instance Print [AcslHaskell.FullBnfcParser.Abs.BindersReentrance] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.VarSpec where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.StartVarSpec starss varspec -> prPrec i 0 (concatD [prt 0 starss, prt 1 varspec])
    AcslHaskell.FullBnfcParser.Abs.SimpleSpec fullidentifier -> prPrec i 1 (concatD [prt 0 fullidentifier])
    AcslHaskell.FullBnfcParser.Abs.ArraySpec varspec arraysize -> prPrec i 1 (concatD [prt 1 varspec, doc (showString "["), prt 0 arraysize, doc (showString "]")])

instance Print AcslHaskell.FullBnfcParser.Abs.Stars where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.Star -> prPrec i 0 (concatD [doc (showString "*")])

instance Print [AcslHaskell.FullBnfcParser.Abs.Stars] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.ArraySize where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.IntConstArraySize n -> prPrec i 0 (concatD [prt 0 n])
    AcslHaskell.FullBnfcParser.Abs.SomeArraySize fullidentifier -> prPrec i 0 (concatD [prt 0 fullidentifier])
    AcslHaskell.FullBnfcParser.Abs.NoSize -> prPrec i 0 (concatD [])

instance Print AcslHaskell.FullBnfcParser.Abs.OptLabel where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.OptLabelOne optlabellist -> prPrec i 1 (concatD [prt 0 optlabellist])
    AcslHaskell.FullBnfcParser.Abs.OptLabelTwo optlabellist -> prPrec i 2 (concatD [prt 0 optlabellist])

instance Print AcslHaskell.FullBnfcParser.Abs.OptLabelList where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoLableList -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.LableList labelnames -> prPrec i 0 (concatD [doc (showString "{"), prt 0 labelnames, doc (showString "}")])

instance Print AcslHaskell.FullBnfcParser.Abs.LabelName where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.LableName anyidentifier -> prPrec i 0 (concatD [prt 0 anyidentifier])

instance Print [AcslHaskell.FullBnfcParser.Abs.LabelName] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.Range where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.LexprRange lexproption1 lexproption2 -> prPrec i 0 (concatD [prt 0 lexproption1, doc (showString ".."), prt 0 lexproption2])

instance Print AcslHaskell.FullBnfcParser.Abs.LexprOption where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoLexprOption -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomeLexprOption lexpr -> prPrec i 0 (concatD [prt 0 lexpr])

instance Print AcslHaskell.FullBnfcParser.Abs.AnyIdentifier where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleIdentifierAny identifier -> prPrec i 0 (concatD [prt 0 identifier])

instance Print AcslHaskell.FullBnfcParser.Abs.PostCond where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.EnsuresKeyWord -> prPrec i 0 (concatD [doc (showString "ensures")])
    AcslHaskell.FullBnfcParser.Abs.ExitsKeyWord -> prPrec i 0 (concatD [doc (showString "exits")])
    AcslHaskell.FullBnfcParser.Abs.BreaksKeyWord -> prPrec i 0 (concatD [doc (showString "breaks")])
    AcslHaskell.FullBnfcParser.Abs.ContinuesKeyWord -> prPrec i 0 (concatD [doc (showString "continues")])
    AcslHaskell.FullBnfcParser.Abs.ReturnsKeyWord -> prPrec i 0 (concatD [doc (showString "returns")])
    AcslHaskell.FullBnfcParser.Abs.CheckEnsuresKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "ensures")])
    AcslHaskell.FullBnfcParser.Abs.CheckExitsKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "exits")])
    AcslHaskell.FullBnfcParser.Abs.CheckBreaksKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "breaks")])
    AcslHaskell.FullBnfcParser.Abs.CheckContinuesKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "continues")])
    AcslHaskell.FullBnfcParser.Abs.CheckReturnsKeyWord -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "returns")])
    AcslHaskell.FullBnfcParser.Abs.AdmitEnsuresKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "ensures")])
    AcslHaskell.FullBnfcParser.Abs.AdmitExitsKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "exits")])
    AcslHaskell.FullBnfcParser.Abs.AdmitBreaksKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "breaks")])
    AcslHaskell.FullBnfcParser.Abs.AdmitContinuesKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "continues")])
    AcslHaskell.FullBnfcParser.Abs.AdmitReturnsKeyWord -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "returns")])

instance Print AcslHaskell.FullBnfcParser.Abs.FullIdentifier where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleIdentifierFull identifier -> prPrec i 0 (concatD [prt 0 identifier])

instance Print [AcslHaskell.FullBnfcParser.Abs.FullIdentifier] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AcslHaskell.FullBnfcParser.Abs.Identifier where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.IdentifierIdent id_ -> prPrec i 0 (concatD [prt 0 id_])

instance Print AcslHaskell.FullBnfcParser.Abs.TypeSpecSimple where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleIntegerKeyWord -> prPrec i 0 (concatD [doc (showString "integer")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleRealKeyWord -> prPrec i 0 (concatD [doc (showString "real")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleBooleanKeyWord -> prPrec i 0 (concatD [doc (showString "boolean")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleVoidKeyWord -> prPrec i 0 (concatD [doc (showString "void")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleBoolKeyWord -> prPrec i 0 (concatD [doc (showString "_Bool")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleCharKeyWord -> prPrec i 0 (concatD [doc (showString "char")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleIntKeyWord -> prPrec i 0 (concatD [doc (showString "int")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleDoubleKeyWord -> prPrec i 0 (concatD [doc (showString "double")])
    AcslHaskell.FullBnfcParser.Abs.TypeSpecSimpleLongDoubleKeyWord -> prPrec i 0 (concatD [doc (showString "long"), doc (showString "double")])

instance Print AcslHaskell.FullBnfcParser.Abs.LogicPTreeAnnot where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.AnAnnotation annotation -> prPrec i 0 (concatD [prt 0 annotation])

instance Print AcslHaskell.FullBnfcParser.Abs.Annotation where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.LoopAnnotation loopannotstack -> prPrec i 0 (concatD [prt 0 loopannotstack])

instance Print AcslHaskell.FullBnfcParser.Abs.LoopAnnotStack where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.LoopAnnotStackInvariant loopinvariant loopannotopt -> prPrec i 0 (concatD [prt 0 loopinvariant, prt 0 loopannotopt])
    AcslHaskell.FullBnfcParser.Abs.LoopAnnotStackEffects loopeffects loopannotopt -> prPrec i 0 (concatD [prt 0 loopeffects, prt 0 loopannotopt])
    AcslHaskell.FullBnfcParser.Abs.LoopAnnotStackVariant loopvariant loopannotopt -> prPrec i 0 (concatD [prt 0 loopvariant, prt 0 loopannotopt])

instance Print AcslHaskell.FullBnfcParser.Abs.LoopAnnotOpt where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.NoLoopAnnot -> prPrec i 0 (concatD [])
    AcslHaskell.FullBnfcParser.Abs.SomeLoopAnnot loopannotstack -> prPrec i 0 (concatD [prt 0 loopannotstack])

instance Print AcslHaskell.FullBnfcParser.Abs.LoopInvariant where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleLoopInvariant lexpr -> prPrec i 0 (concatD [doc (showString "loop"), doc (showString "invariant"), prt 0 lexpr, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.CheckLoopInvariant lexpr -> prPrec i 0 (concatD [doc (showString "check"), doc (showString "loop"), doc (showString "invariant"), prt 0 lexpr, doc (showString ";")])
    AcslHaskell.FullBnfcParser.Abs.AdmitLoopInvariant lexpr -> prPrec i 0 (concatD [doc (showString "admit"), doc (showString "loop"), doc (showString "invariant"), prt 0 lexpr, doc (showString ";")])

instance Print AcslHaskell.FullBnfcParser.Abs.LoopVariant where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.SimpleLoopVariant variant -> prPrec i 0 (concatD [doc (showString "loop"), doc (showString "variant"), prt 0 variant, doc (showString ";")])

instance Print AcslHaskell.FullBnfcParser.Abs.LoopEffects where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.LoopAssigns assigns -> prPrec i 0 (concatD [doc (showString "loop"), doc (showString "assigns"), prt 0 assigns, doc (showString ";")])

instance Print AcslHaskell.FullBnfcParser.Abs.Variant where
  prt i = \case
    AcslHaskell.FullBnfcParser.Abs.ForVariant lexpr anyidentifier -> prPrec i 0 (concatD [prt 0 lexpr, doc (showString "for"), prt 0 anyidentifier])
    AcslHaskell.FullBnfcParser.Abs.LexprVariant lexpr -> prPrec i 0 (concatD [prt 0 lexpr])
