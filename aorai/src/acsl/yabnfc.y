/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"
%name-prefix = "acsl"
  /* From Bison 2.6: %define api.prefix {acsl} */

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the acsllloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE acsl_scan_string(const char *str, yyscan_t scanner);
extern void acsl_delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void acsllex_destroy(yyscan_t scanner);
extern char* acslget_text(yyscan_t scanner);

extern yyscan_t acsl_initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  acsl::ListIdent* listident_;
  acsl::Main* main_;
  acsl::AnOption* anoption_;
  acsl::ListAnOption* listanoption_;
  acsl::OptIdentifiers* optidentifiers_;
  acsl::Metavar* metavar_;
  acsl::ListMetavar* listmetavar_;
  acsl::State* state_;
  acsl::ListState* liststate_;
  acsl::Transition* transition_;
  acsl::ListTransition* listtransition_;
  acsl::Guard* guard_;
  acsl::PreCond* precond_;
  acsl::PostCond* postcond_;
  acsl::SeqElt* seqelt_;
  acsl::ListSeqElt* listseqelt_;
  acsl::Repetition* repetition_;
  acsl::Cond* cond_;
  acsl::LogicRelation* logicrelation_;
  acsl::Expr* expr_;
  acsl::Action* action_;
  acsl::ListAction* listaction_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, acslget_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG       /* ! */
%token          _BANGEQ     /* != */
%token          _DOLLAR     /* $ */
%token          _PERCENT    /* % */
%token          _AMP        /* & */
%token          _DAMP       /* && */
%token          _LPAREN     /* ( */
%token          _RPAREN     /* ) */
%token          _STAR       /* * */
%token          _PLUS       /* + */
%token          _COMMA      /* , */
%token          _MINUS      /* - */
%token          _RARROW     /* -> */
%token          _DOT        /* . */
%token          _SLASH      /* / */
%token          _COLON      /* : */
%token          _DCOLON     /* :: */
%token          _COLONEQ    /* := */
%token          _SEMI       /* ; */
%token          _LT         /* < */
%token          _LDARROW    /* <= */
%token          _DEQ        /* == */
%token          _GT         /* > */
%token          _GTEQ       /* >= */
%token          _QUESTION   /* ? */
%token          _KW_CALL    /* CALL */
%token          _KW_COR     /* COR */
%token          _KW_RETURN  /* RETURN */
%token          _LBRACK     /* [ */
%token          _RBRACK     /* ] */
%token          _CARET      /* ^ */
%token          _KW_false   /* false */
%token          _KW_other   /* other */
%token          _KW_true    /* true */
%token          _LBRACE     /* { */
%token          _SYMB_14    /* {{ */
%token          _BAR        /* | */
%token          _DBAR       /* || */
%token          _RBRACE     /* } */
%token          _SYMB_15    /* }} */
%token<_string> T_Ident     /* Ident */
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <listident_> ListIdent
%type <main_> Main
%type <anoption_> AnOption
%type <listanoption_> ListAnOption
%type <optidentifiers_> OptIdentifiers
%type <metavar_> Metavar
%type <listmetavar_> ListMetavar
%type <state_> State
%type <liststate_> ListState
%type <transition_> Transition
%type <listtransition_> ListTransition
%type <guard_> Guard
%type <precond_> PreCond
%type <postcond_> PostCond
%type <seqelt_> SeqElt
%type <listseqelt_> ListSeqElt
%type <repetition_> Repetition
%type <cond_> Cond
%type <cond_> Cond1
%type <cond_> Cond2
%type <logicrelation_> LogicRelation
%type <expr_> Expr
%type <expr_> Expr1
%type <expr_> Expr2
%type <expr_> Expr3
%type <expr_> Expr4
%type <expr_> Expr5
%type <action_> Action
%type <listaction_> ListAction

%start ListIdent

%%

ListIdent : T_Ident { $$ = new acsl::ListIdent(); $$->push_back($1); result->listident_ = $$; }
  | T_Ident _COMMA ListIdent { $3->push_back($1); $$ = $3; result->listident_ = $$; }
;
Main : ListAnOption ListMetavar ListState { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new acsl::AMain($1, $2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->main_ = $$; }
;
AnOption : _PERCENT T_Ident OptIdentifiers _SEMI { $$ = new acsl::Option($2, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->anoption_ = $$; }
;
ListAnOption : AnOption { $$ = new acsl::ListAnOption(); $$->push_back($1); result->listanoption_ = $$; }
  | AnOption ListAnOption { $2->push_back($1); $$ = $2; result->listanoption_ = $$; }
;
OptIdentifiers : /* empty */ { $$ = new acsl::EmptyOptIdent(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optidentifiers_ = $$; }
  | _COLON ListIdent { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::OptIdent($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->optidentifiers_ = $$; }
;
Metavar : _DOLLAR T_Ident _COLON T_Ident _SEMI { $$ = new acsl::AMetavar($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->metavar_ = $$; }
;
ListMetavar : /* empty */ { $$ = new acsl::ListMetavar(); result->listmetavar_ = $$; }
  | ListMetavar Metavar { $1->push_back($2); $$ = $1; result->listmetavar_ = $$; }
;
State : T_Ident _COLON ListTransition _SEMI { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::AState($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->state_ = $$; }
;
ListState : State { $$ = new acsl::ListState(); $$->push_back($1); result->liststate_ = $$; }
  | State ListState { $2->push_back($1); $$ = $2; result->liststate_ = $$; }
;
Transition : /* empty */ { $$ = new acsl::EmptyTransition(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->transition_ = $$; }
  | _LBRACE SeqElt _RBRACE ListAction _RARROW T_Ident { $$ = new acsl::SeqTransition($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->transition_ = $$; }
  | _KW_other ListAction _RARROW T_Ident { $$ = new acsl::OtherTransition($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->transition_ = $$; }
  | ListAction _RARROW T_Ident { $$ = new acsl::SimpleTransition($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->transition_ = $$; }
;
ListTransition : Transition { $$ = new acsl::ListTransition(); $$->push_back($1); result->listtransition_ = $$; }
  | Transition _BAR ListTransition { $3->push_back($1); $$ = $3; result->listtransition_ = $$; }
;
Guard : _LBRACK ListSeqElt _RBRACK { std::reverse($2->begin(),$2->end()) ;$$ = new acsl::GuardSquares($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->guard_ = $$; }
  | T_Ident PreCond _LPAREN _RPAREN PostCond { $$ = new acsl::GuardWithPreEmpty($1, $2, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->guard_ = $$; }
  | T_Ident PreCond _LPAREN ListSeqElt _RPAREN PostCond { std::reverse($4->begin(),$4->end()) ;$$ = new acsl::GuardWithPre($1, $2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->guard_ = $$; }
  | T_Ident _LPAREN ListSeqElt _RPAREN PostCond { std::reverse($3->begin(),$3->end()) ;$$ = new acsl::GuardPostOnly($1, $3, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->guard_ = $$; }
  | T_Ident _LPAREN _RPAREN PostCond { $$ = new acsl::GuardPostOnlyEmpty($1, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->guard_ = $$; }
;
PreCond : _DCOLON T_Ident { $$ = new acsl::PrecondCC($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->precond_ = $$; }
  | _SYMB_14 Cond _SYMB_15 { $$ = new acsl::PrecondBB($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->precond_ = $$; }
;
PostCond : /* empty */ { $$ = new acsl::PostcondEmpty(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
  | _SYMB_14 Cond _SYMB_15 { $$ = new acsl::PostcondSimple($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->postcond_ = $$; }
;
SeqElt : Cond { $$ = new acsl::SeqEltCond($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->seqelt_ = $$; }
  | Guard Repetition { $$ = new acsl::SeqEltGuardRep($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->seqelt_ = $$; }
;
ListSeqElt : SeqElt { $$ = new acsl::ListSeqElt(); $$->push_back($1); result->listseqelt_ = $$; }
  | SeqElt _SEMI ListSeqElt { $3->push_back($1); $$ = $3; result->listseqelt_ = $$; }
;
Repetition : /* empty */ { $$ = new acsl::RepetitionEmpty(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _PLUS { $$ = new acsl::RepetitionPlus(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _STAR { $$ = new acsl::RepetitionMinus(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _QUESTION { $$ = new acsl::RepetitionQuestion(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _LBRACE Expr _COMMA Expr _RBRACE { $$ = new acsl::RepetitionPair($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _LBRACE Expr _RBRACE { $$ = new acsl::RepetitionOne($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _LBRACE Expr _COMMA _RBRACE { $$ = new acsl::RepetitionREmpty($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
  | _LBRACE _COMMA Expr _RBRACE { $$ = new acsl::RepetitionLEmpty($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->repetition_ = $$; }
;
Cond : Cond1 _DBAR Cond { $$ = new acsl::LogicOr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | Cond1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
;
Cond1 : Cond2 _DAMP Cond1 { $$ = new acsl::LogicAnd($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | Cond2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
;
Cond2 : _KW_COR _LPAREN T_Ident _RPAREN { $$ = new acsl::ACondCOR($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | _KW_CALL _LPAREN T_Ident _RPAREN { $$ = new acsl::ACondCALL($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | _KW_RETURN _LPAREN T_Ident _RPAREN { $$ = new acsl::ACondReturn($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | _KW_true { $$ = new acsl::ACondTrue(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | _KW_false { $$ = new acsl::ACondFalse(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | _BANG Cond2 { $$ = new acsl::ACondNot($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | _LPAREN Cond _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
  | LogicRelation { $$ = new acsl::RelationCond($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->cond_ = $$; }
;
LogicRelation : Expr _DEQ Expr { $$ = new acsl::LogicEQ($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrelation_ = $$; }
  | Expr _LT Expr { $$ = new acsl::LogicLess($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrelation_ = $$; }
  | Expr _GT Expr { $$ = new acsl::LogicGreater($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrelation_ = $$; }
  | Expr _LDARROW Expr { $$ = new acsl::LogicLessEQ($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrelation_ = $$; }
  | Expr _GTEQ Expr { $$ = new acsl::LogicGreaterEQ($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrelation_ = $$; }
  | Expr _BANGEQ Expr { $$ = new acsl::LogicNotEQ($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->logicrelation_ = $$; }
;
Expr : Expr1 _PLUS Expr { $$ = new acsl::Add($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr1 _MINUS Expr { $$ = new acsl::Subtract($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr1 : Expr1 _SLASH Expr2 { $$ = new acsl::Divide($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr1 _STAR Expr2 { $$ = new acsl::Multiply($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr1 _PERCENT Expr2 { $$ = new acsl::Mod($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr2 : Expr2 _AMP Expr3 { $$ = new acsl::BitAnd($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr2 _BAR Expr3 { $$ = new acsl::BitOr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr2 _CARET Expr3 { $$ = new acsl::BitXor($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr3 : _INTEGER_ { $$ = new acsl::Int($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _DOUBLE_ { $$ = new acsl::Float($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _MINUS _INTEGER_ { $$ = new acsl::NegativeInt($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _MINUS _DOUBLE_ { $$ = new acsl::NegativeDouble($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr4 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr4 : Expr4 _DOT T_Ident { $$ = new acsl::StructFielsAccess($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr4 _RARROW T_Ident { $$ = new acsl::PointerAccess($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr4 _LBRACK Expr3 _RBRACK { $$ = new acsl::ArrayAccess($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr5 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr5 : _STAR Expr4 { $$ = new acsl::RefAccess($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | T_Ident _LPAREN _RPAREN _DOT T_Ident { $$ = new acsl::FunAccess($1, $5); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | T_Ident { $$ = new acsl::Identifier($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _DOLLAR T_Ident { $$ = new acsl::MetavarAccess($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _LPAREN Expr _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Action : _DOLLAR T_Ident _COLONEQ Expr _SEMI { $$ = new acsl::AnAction($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->action_ = $$; }
;
ListAction : /* empty */ { $$ = new acsl::ListAction(); result->listaction_ = $$; }
  | ListAction Action { $1->push_back($2); $$ = $1; result->listaction_ = $$; }
;

%%

namespace acsl
{
/* Entrypoint: parse ListIdent* from file. */
ListIdent* pListIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listident_->begin(), result.listident_->end());
    return result.listident_;
  }
}

/* Entrypoint: parse ListIdent* from string. */
ListIdent* psListIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listident_->begin(), result.listident_->end());
    return result.listident_;
  }
}

/* Entrypoint: parse Main* from file. */
Main* pMain(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.main_;
  }
}

/* Entrypoint: parse Main* from string. */
Main* psMain(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.main_;
  }
}

/* Entrypoint: parse AnOption* from file. */
AnOption* pAnOption(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.anoption_;
  }
}

/* Entrypoint: parse AnOption* from string. */
AnOption* psAnOption(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.anoption_;
  }
}

/* Entrypoint: parse ListAnOption* from file. */
ListAnOption* pListAnOption(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listanoption_->begin(), result.listanoption_->end());
    return result.listanoption_;
  }
}

/* Entrypoint: parse ListAnOption* from string. */
ListAnOption* psListAnOption(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listanoption_->begin(), result.listanoption_->end());
    return result.listanoption_;
  }
}

/* Entrypoint: parse OptIdentifiers* from file. */
OptIdentifiers* pOptIdentifiers(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optidentifiers_;
  }
}

/* Entrypoint: parse OptIdentifiers* from string. */
OptIdentifiers* psOptIdentifiers(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optidentifiers_;
  }
}

/* Entrypoint: parse Metavar* from file. */
Metavar* pMetavar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.metavar_;
  }
}

/* Entrypoint: parse Metavar* from string. */
Metavar* psMetavar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.metavar_;
  }
}

/* Entrypoint: parse ListMetavar* from file. */
ListMetavar* pListMetavar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listmetavar_;
  }
}

/* Entrypoint: parse ListMetavar* from string. */
ListMetavar* psListMetavar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listmetavar_;
  }
}

/* Entrypoint: parse State* from file. */
State* pState(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.state_;
  }
}

/* Entrypoint: parse State* from string. */
State* psState(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.state_;
  }
}

/* Entrypoint: parse ListState* from file. */
ListState* pListState(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststate_->begin(), result.liststate_->end());
    return result.liststate_;
  }
}

/* Entrypoint: parse ListState* from string. */
ListState* psListState(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststate_->begin(), result.liststate_->end());
    return result.liststate_;
  }
}

/* Entrypoint: parse Transition* from file. */
Transition* pTransition(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.transition_;
  }
}

/* Entrypoint: parse Transition* from string. */
Transition* psTransition(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.transition_;
  }
}

/* Entrypoint: parse ListTransition* from file. */
ListTransition* pListTransition(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtransition_->begin(), result.listtransition_->end());
    return result.listtransition_;
  }
}

/* Entrypoint: parse ListTransition* from string. */
ListTransition* psListTransition(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtransition_->begin(), result.listtransition_->end());
    return result.listtransition_;
  }
}

/* Entrypoint: parse Guard* from file. */
Guard* pGuard(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.guard_;
  }
}

/* Entrypoint: parse Guard* from string. */
Guard* psGuard(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.guard_;
  }
}

/* Entrypoint: parse PreCond* from file. */
PreCond* pPreCond(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.precond_;
  }
}

/* Entrypoint: parse PreCond* from string. */
PreCond* psPreCond(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.precond_;
  }
}

/* Entrypoint: parse PostCond* from file. */
PostCond* pPostCond(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.postcond_;
  }
}

/* Entrypoint: parse PostCond* from string. */
PostCond* psPostCond(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.postcond_;
  }
}

/* Entrypoint: parse SeqElt* from file. */
SeqElt* pSeqElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.seqelt_;
  }
}

/* Entrypoint: parse SeqElt* from string. */
SeqElt* psSeqElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.seqelt_;
  }
}

/* Entrypoint: parse ListSeqElt* from file. */
ListSeqElt* pListSeqElt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listseqelt_->begin(), result.listseqelt_->end());
    return result.listseqelt_;
  }
}

/* Entrypoint: parse ListSeqElt* from string. */
ListSeqElt* psListSeqElt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listseqelt_->begin(), result.listseqelt_->end());
    return result.listseqelt_;
  }
}

/* Entrypoint: parse Repetition* from file. */
Repetition* pRepetition(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.repetition_;
  }
}

/* Entrypoint: parse Repetition* from string. */
Repetition* psRepetition(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.repetition_;
  }
}

/* Entrypoint: parse Cond* from file. */
Cond* pCond(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse Cond* from string. */
Cond* psCond(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse Cond* from file. */
Cond* pCond1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse Cond* from string. */
Cond* psCond1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse Cond* from file. */
Cond* pCond2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse Cond* from string. */
Cond* psCond2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse LogicRelation* from file. */
LogicRelation* pLogicRelation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicrelation_;
  }
}

/* Entrypoint: parse LogicRelation* from string. */
LogicRelation* psLogicRelation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicrelation_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Action* from file. */
Action* pAction(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.action_;
  }
}

/* Entrypoint: parse Action* from string. */
Action* psAction(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.action_;
  }
}

/* Entrypoint: parse ListAction* from file. */
ListAction* pListAction(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listaction_;
  }
}

/* Entrypoint: parse ListAction* from string. */
ListAction* psListAction(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = acsl_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = acsl_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  acsl_delete_buffer(buf, scanner);
  acsllex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listaction_;
  }
}


}
