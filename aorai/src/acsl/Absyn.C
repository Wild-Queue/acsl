/* File generated by the BNF Converter (bnfc 2.9.4.1). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace acsl
{
/********************   AMain    ********************/
AMain::AMain(ListAnOption *p1, ListMetavar *p2, ListState *p3)
{
  listanoption_ = p1;
  listmetavar_ = p2;
  liststate_ = p3;

}

AMain::AMain(const AMain & other)
{
  listanoption_ = other.listanoption_->clone();
  listmetavar_ = other.listmetavar_->clone();
  liststate_ = other.liststate_->clone();

}

AMain &AMain::operator=(const AMain & other)
{
  AMain tmp(other);
  swap(tmp);
  return *this;
}

void AMain::swap(AMain & other)
{
  std::swap(listanoption_, other.listanoption_);
  std::swap(listmetavar_, other.listmetavar_);
  std::swap(liststate_, other.liststate_);

}

AMain::~AMain()
{
  delete(listanoption_);
  delete(listmetavar_);
  delete(liststate_);

}

void AMain::accept(Visitor *v)
{
  v->visitAMain(this);
}

AMain *AMain::clone() const
{
  return new AMain(*this);
}



/********************   Option    ********************/
Option::Option(Ident p1, OptIdentifiers *p2)
{
  ident_ = p1;
  optidentifiers_ = p2;

}

Option::Option(const Option & other)
{
  ident_ = other.ident_;
  optidentifiers_ = other.optidentifiers_->clone();

}

Option &Option::operator=(const Option & other)
{
  Option tmp(other);
  swap(tmp);
  return *this;
}

void Option::swap(Option & other)
{
  std::swap(ident_, other.ident_);
  std::swap(optidentifiers_, other.optidentifiers_);

}

Option::~Option()
{
  delete(optidentifiers_);

}

void Option::accept(Visitor *v)
{
  v->visitOption(this);
}

Option *Option::clone() const
{
  return new Option(*this);
}



/********************   EmptyOptIdent    ********************/
EmptyOptIdent::EmptyOptIdent()
{

}

EmptyOptIdent::EmptyOptIdent(const EmptyOptIdent & other)
{

}

EmptyOptIdent &EmptyOptIdent::operator=(const EmptyOptIdent & other)
{
  EmptyOptIdent tmp(other);
  swap(tmp);
  return *this;
}

void EmptyOptIdent::swap(EmptyOptIdent & other)
{

}

EmptyOptIdent::~EmptyOptIdent()
{

}

void EmptyOptIdent::accept(Visitor *v)
{
  v->visitEmptyOptIdent(this);
}

EmptyOptIdent *EmptyOptIdent::clone() const
{
  return new EmptyOptIdent(*this);
}



/********************   OptIdent    ********************/
OptIdent::OptIdent(ListIdent *p1)
{
  listident_ = p1;

}

OptIdent::OptIdent(const OptIdent & other)
{
  listident_ = other.listident_->clone();

}

OptIdent &OptIdent::operator=(const OptIdent & other)
{
  OptIdent tmp(other);
  swap(tmp);
  return *this;
}

void OptIdent::swap(OptIdent & other)
{
  std::swap(listident_, other.listident_);

}

OptIdent::~OptIdent()
{
  delete(listident_);

}

void OptIdent::accept(Visitor *v)
{
  v->visitOptIdent(this);
}

OptIdent *OptIdent::clone() const
{
  return new OptIdent(*this);
}



/********************   AMetavar    ********************/
AMetavar::AMetavar(Ident p1, Ident p2)
{
  ident_1 = p1;
  ident_2 = p2;

}

AMetavar::AMetavar(const AMetavar & other)
{
  ident_1 = other.ident_1;
  ident_2 = other.ident_2;

}

AMetavar &AMetavar::operator=(const AMetavar & other)
{
  AMetavar tmp(other);
  swap(tmp);
  return *this;
}

void AMetavar::swap(AMetavar & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(ident_2, other.ident_2);

}

AMetavar::~AMetavar()
{

}

void AMetavar::accept(Visitor *v)
{
  v->visitAMetavar(this);
}

AMetavar *AMetavar::clone() const
{
  return new AMetavar(*this);
}



/********************   AState    ********************/
AState::AState(Ident p1, ListTransition *p2)
{
  ident_ = p1;
  listtransition_ = p2;

}

AState::AState(const AState & other)
{
  ident_ = other.ident_;
  listtransition_ = other.listtransition_->clone();

}

AState &AState::operator=(const AState & other)
{
  AState tmp(other);
  swap(tmp);
  return *this;
}

void AState::swap(AState & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listtransition_, other.listtransition_);

}

AState::~AState()
{
  delete(listtransition_);

}

void AState::accept(Visitor *v)
{
  v->visitAState(this);
}

AState *AState::clone() const
{
  return new AState(*this);
}



/********************   EmptyTransition    ********************/
EmptyTransition::EmptyTransition()
{

}

EmptyTransition::EmptyTransition(const EmptyTransition & other)
{

}

EmptyTransition &EmptyTransition::operator=(const EmptyTransition & other)
{
  EmptyTransition tmp(other);
  swap(tmp);
  return *this;
}

void EmptyTransition::swap(EmptyTransition & other)
{

}

EmptyTransition::~EmptyTransition()
{

}

void EmptyTransition::accept(Visitor *v)
{
  v->visitEmptyTransition(this);
}

EmptyTransition *EmptyTransition::clone() const
{
  return new EmptyTransition(*this);
}



/********************   SeqTransition    ********************/
SeqTransition::SeqTransition(SeqElt *p1, ListAction *p2, Ident p3)
{
  seqelt_ = p1;
  listaction_ = p2;
  ident_ = p3;

}

SeqTransition::SeqTransition(const SeqTransition & other)
{
  seqelt_ = other.seqelt_->clone();
  listaction_ = other.listaction_->clone();
  ident_ = other.ident_;

}

SeqTransition &SeqTransition::operator=(const SeqTransition & other)
{
  SeqTransition tmp(other);
  swap(tmp);
  return *this;
}

void SeqTransition::swap(SeqTransition & other)
{
  std::swap(seqelt_, other.seqelt_);
  std::swap(listaction_, other.listaction_);
  std::swap(ident_, other.ident_);

}

SeqTransition::~SeqTransition()
{
  delete(seqelt_);
  delete(listaction_);

}

void SeqTransition::accept(Visitor *v)
{
  v->visitSeqTransition(this);
}

SeqTransition *SeqTransition::clone() const
{
  return new SeqTransition(*this);
}



/********************   OtherTransition    ********************/
OtherTransition::OtherTransition(ListAction *p1, Ident p2)
{
  listaction_ = p1;
  ident_ = p2;

}

OtherTransition::OtherTransition(const OtherTransition & other)
{
  listaction_ = other.listaction_->clone();
  ident_ = other.ident_;

}

OtherTransition &OtherTransition::operator=(const OtherTransition & other)
{
  OtherTransition tmp(other);
  swap(tmp);
  return *this;
}

void OtherTransition::swap(OtherTransition & other)
{
  std::swap(listaction_, other.listaction_);
  std::swap(ident_, other.ident_);

}

OtherTransition::~OtherTransition()
{
  delete(listaction_);

}

void OtherTransition::accept(Visitor *v)
{
  v->visitOtherTransition(this);
}

OtherTransition *OtherTransition::clone() const
{
  return new OtherTransition(*this);
}



/********************   SimpleTransition    ********************/
SimpleTransition::SimpleTransition(ListAction *p1, Ident p2)
{
  listaction_ = p1;
  ident_ = p2;

}

SimpleTransition::SimpleTransition(const SimpleTransition & other)
{
  listaction_ = other.listaction_->clone();
  ident_ = other.ident_;

}

SimpleTransition &SimpleTransition::operator=(const SimpleTransition & other)
{
  SimpleTransition tmp(other);
  swap(tmp);
  return *this;
}

void SimpleTransition::swap(SimpleTransition & other)
{
  std::swap(listaction_, other.listaction_);
  std::swap(ident_, other.ident_);

}

SimpleTransition::~SimpleTransition()
{
  delete(listaction_);

}

void SimpleTransition::accept(Visitor *v)
{
  v->visitSimpleTransition(this);
}

SimpleTransition *SimpleTransition::clone() const
{
  return new SimpleTransition(*this);
}



/********************   GuardSquares    ********************/
GuardSquares::GuardSquares(ListSeqElt *p1)
{
  listseqelt_ = p1;

}

GuardSquares::GuardSquares(const GuardSquares & other)
{
  listseqelt_ = other.listseqelt_->clone();

}

GuardSquares &GuardSquares::operator=(const GuardSquares & other)
{
  GuardSquares tmp(other);
  swap(tmp);
  return *this;
}

void GuardSquares::swap(GuardSquares & other)
{
  std::swap(listseqelt_, other.listseqelt_);

}

GuardSquares::~GuardSquares()
{
  delete(listseqelt_);

}

void GuardSquares::accept(Visitor *v)
{
  v->visitGuardSquares(this);
}

GuardSquares *GuardSquares::clone() const
{
  return new GuardSquares(*this);
}



/********************   GuardWithPreEmpty    ********************/
GuardWithPreEmpty::GuardWithPreEmpty(Ident p1, PreCond *p2, PostCond *p3)
{
  ident_ = p1;
  precond_ = p2;
  postcond_ = p3;

}

GuardWithPreEmpty::GuardWithPreEmpty(const GuardWithPreEmpty & other)
{
  ident_ = other.ident_;
  precond_ = other.precond_->clone();
  postcond_ = other.postcond_->clone();

}

GuardWithPreEmpty &GuardWithPreEmpty::operator=(const GuardWithPreEmpty & other)
{
  GuardWithPreEmpty tmp(other);
  swap(tmp);
  return *this;
}

void GuardWithPreEmpty::swap(GuardWithPreEmpty & other)
{
  std::swap(ident_, other.ident_);
  std::swap(precond_, other.precond_);
  std::swap(postcond_, other.postcond_);

}

GuardWithPreEmpty::~GuardWithPreEmpty()
{
  delete(precond_);
  delete(postcond_);

}

void GuardWithPreEmpty::accept(Visitor *v)
{
  v->visitGuardWithPreEmpty(this);
}

GuardWithPreEmpty *GuardWithPreEmpty::clone() const
{
  return new GuardWithPreEmpty(*this);
}



/********************   GuardWithPre    ********************/
GuardWithPre::GuardWithPre(Ident p1, PreCond *p2, ListSeqElt *p3, PostCond *p4)
{
  ident_ = p1;
  precond_ = p2;
  listseqelt_ = p3;
  postcond_ = p4;

}

GuardWithPre::GuardWithPre(const GuardWithPre & other)
{
  ident_ = other.ident_;
  precond_ = other.precond_->clone();
  listseqelt_ = other.listseqelt_->clone();
  postcond_ = other.postcond_->clone();

}

GuardWithPre &GuardWithPre::operator=(const GuardWithPre & other)
{
  GuardWithPre tmp(other);
  swap(tmp);
  return *this;
}

void GuardWithPre::swap(GuardWithPre & other)
{
  std::swap(ident_, other.ident_);
  std::swap(precond_, other.precond_);
  std::swap(listseqelt_, other.listseqelt_);
  std::swap(postcond_, other.postcond_);

}

GuardWithPre::~GuardWithPre()
{
  delete(precond_);
  delete(listseqelt_);
  delete(postcond_);

}

void GuardWithPre::accept(Visitor *v)
{
  v->visitGuardWithPre(this);
}

GuardWithPre *GuardWithPre::clone() const
{
  return new GuardWithPre(*this);
}



/********************   GuardPostOnly    ********************/
GuardPostOnly::GuardPostOnly(Ident p1, ListSeqElt *p2, PostCond *p3)
{
  ident_ = p1;
  listseqelt_ = p2;
  postcond_ = p3;

}

GuardPostOnly::GuardPostOnly(const GuardPostOnly & other)
{
  ident_ = other.ident_;
  listseqelt_ = other.listseqelt_->clone();
  postcond_ = other.postcond_->clone();

}

GuardPostOnly &GuardPostOnly::operator=(const GuardPostOnly & other)
{
  GuardPostOnly tmp(other);
  swap(tmp);
  return *this;
}

void GuardPostOnly::swap(GuardPostOnly & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listseqelt_, other.listseqelt_);
  std::swap(postcond_, other.postcond_);

}

GuardPostOnly::~GuardPostOnly()
{
  delete(listseqelt_);
  delete(postcond_);

}

void GuardPostOnly::accept(Visitor *v)
{
  v->visitGuardPostOnly(this);
}

GuardPostOnly *GuardPostOnly::clone() const
{
  return new GuardPostOnly(*this);
}



/********************   GuardPostOnlyEmpty    ********************/
GuardPostOnlyEmpty::GuardPostOnlyEmpty(Ident p1, PostCond *p2)
{
  ident_ = p1;
  postcond_ = p2;

}

GuardPostOnlyEmpty::GuardPostOnlyEmpty(const GuardPostOnlyEmpty & other)
{
  ident_ = other.ident_;
  postcond_ = other.postcond_->clone();

}

GuardPostOnlyEmpty &GuardPostOnlyEmpty::operator=(const GuardPostOnlyEmpty & other)
{
  GuardPostOnlyEmpty tmp(other);
  swap(tmp);
  return *this;
}

void GuardPostOnlyEmpty::swap(GuardPostOnlyEmpty & other)
{
  std::swap(ident_, other.ident_);
  std::swap(postcond_, other.postcond_);

}

GuardPostOnlyEmpty::~GuardPostOnlyEmpty()
{
  delete(postcond_);

}

void GuardPostOnlyEmpty::accept(Visitor *v)
{
  v->visitGuardPostOnlyEmpty(this);
}

GuardPostOnlyEmpty *GuardPostOnlyEmpty::clone() const
{
  return new GuardPostOnlyEmpty(*this);
}



/********************   PrecondCC    ********************/
PrecondCC::PrecondCC(Ident p1)
{
  ident_ = p1;

}

PrecondCC::PrecondCC(const PrecondCC & other)
{
  ident_ = other.ident_;

}

PrecondCC &PrecondCC::operator=(const PrecondCC & other)
{
  PrecondCC tmp(other);
  swap(tmp);
  return *this;
}

void PrecondCC::swap(PrecondCC & other)
{
  std::swap(ident_, other.ident_);

}

PrecondCC::~PrecondCC()
{

}

void PrecondCC::accept(Visitor *v)
{
  v->visitPrecondCC(this);
}

PrecondCC *PrecondCC::clone() const
{
  return new PrecondCC(*this);
}



/********************   PrecondBB    ********************/
PrecondBB::PrecondBB(Cond *p1)
{
  cond_ = p1;

}

PrecondBB::PrecondBB(const PrecondBB & other)
{
  cond_ = other.cond_->clone();

}

PrecondBB &PrecondBB::operator=(const PrecondBB & other)
{
  PrecondBB tmp(other);
  swap(tmp);
  return *this;
}

void PrecondBB::swap(PrecondBB & other)
{
  std::swap(cond_, other.cond_);

}

PrecondBB::~PrecondBB()
{
  delete(cond_);

}

void PrecondBB::accept(Visitor *v)
{
  v->visitPrecondBB(this);
}

PrecondBB *PrecondBB::clone() const
{
  return new PrecondBB(*this);
}



/********************   PostcondEmpty    ********************/
PostcondEmpty::PostcondEmpty()
{

}

PostcondEmpty::PostcondEmpty(const PostcondEmpty & other)
{

}

PostcondEmpty &PostcondEmpty::operator=(const PostcondEmpty & other)
{
  PostcondEmpty tmp(other);
  swap(tmp);
  return *this;
}

void PostcondEmpty::swap(PostcondEmpty & other)
{

}

PostcondEmpty::~PostcondEmpty()
{

}

void PostcondEmpty::accept(Visitor *v)
{
  v->visitPostcondEmpty(this);
}

PostcondEmpty *PostcondEmpty::clone() const
{
  return new PostcondEmpty(*this);
}



/********************   PostcondSimple    ********************/
PostcondSimple::PostcondSimple(Cond *p1)
{
  cond_ = p1;

}

PostcondSimple::PostcondSimple(const PostcondSimple & other)
{
  cond_ = other.cond_->clone();

}

PostcondSimple &PostcondSimple::operator=(const PostcondSimple & other)
{
  PostcondSimple tmp(other);
  swap(tmp);
  return *this;
}

void PostcondSimple::swap(PostcondSimple & other)
{
  std::swap(cond_, other.cond_);

}

PostcondSimple::~PostcondSimple()
{
  delete(cond_);

}

void PostcondSimple::accept(Visitor *v)
{
  v->visitPostcondSimple(this);
}

PostcondSimple *PostcondSimple::clone() const
{
  return new PostcondSimple(*this);
}



/********************   SeqEltCond    ********************/
SeqEltCond::SeqEltCond(Cond *p1)
{
  cond_ = p1;

}

SeqEltCond::SeqEltCond(const SeqEltCond & other)
{
  cond_ = other.cond_->clone();

}

SeqEltCond &SeqEltCond::operator=(const SeqEltCond & other)
{
  SeqEltCond tmp(other);
  swap(tmp);
  return *this;
}

void SeqEltCond::swap(SeqEltCond & other)
{
  std::swap(cond_, other.cond_);

}

SeqEltCond::~SeqEltCond()
{
  delete(cond_);

}

void SeqEltCond::accept(Visitor *v)
{
  v->visitSeqEltCond(this);
}

SeqEltCond *SeqEltCond::clone() const
{
  return new SeqEltCond(*this);
}



/********************   SeqEltGuardRep    ********************/
SeqEltGuardRep::SeqEltGuardRep(Guard *p1, Repetition *p2)
{
  guard_ = p1;
  repetition_ = p2;

}

SeqEltGuardRep::SeqEltGuardRep(const SeqEltGuardRep & other)
{
  guard_ = other.guard_->clone();
  repetition_ = other.repetition_->clone();

}

SeqEltGuardRep &SeqEltGuardRep::operator=(const SeqEltGuardRep & other)
{
  SeqEltGuardRep tmp(other);
  swap(tmp);
  return *this;
}

void SeqEltGuardRep::swap(SeqEltGuardRep & other)
{
  std::swap(guard_, other.guard_);
  std::swap(repetition_, other.repetition_);

}

SeqEltGuardRep::~SeqEltGuardRep()
{
  delete(guard_);
  delete(repetition_);

}

void SeqEltGuardRep::accept(Visitor *v)
{
  v->visitSeqEltGuardRep(this);
}

SeqEltGuardRep *SeqEltGuardRep::clone() const
{
  return new SeqEltGuardRep(*this);
}



/********************   RepetitionEmpty    ********************/
RepetitionEmpty::RepetitionEmpty()
{

}

RepetitionEmpty::RepetitionEmpty(const RepetitionEmpty & other)
{

}

RepetitionEmpty &RepetitionEmpty::operator=(const RepetitionEmpty & other)
{
  RepetitionEmpty tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionEmpty::swap(RepetitionEmpty & other)
{

}

RepetitionEmpty::~RepetitionEmpty()
{

}

void RepetitionEmpty::accept(Visitor *v)
{
  v->visitRepetitionEmpty(this);
}

RepetitionEmpty *RepetitionEmpty::clone() const
{
  return new RepetitionEmpty(*this);
}



/********************   RepetitionPlus    ********************/
RepetitionPlus::RepetitionPlus()
{

}

RepetitionPlus::RepetitionPlus(const RepetitionPlus & other)
{

}

RepetitionPlus &RepetitionPlus::operator=(const RepetitionPlus & other)
{
  RepetitionPlus tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionPlus::swap(RepetitionPlus & other)
{

}

RepetitionPlus::~RepetitionPlus()
{

}

void RepetitionPlus::accept(Visitor *v)
{
  v->visitRepetitionPlus(this);
}

RepetitionPlus *RepetitionPlus::clone() const
{
  return new RepetitionPlus(*this);
}



/********************   RepetitionMinus    ********************/
RepetitionMinus::RepetitionMinus()
{

}

RepetitionMinus::RepetitionMinus(const RepetitionMinus & other)
{

}

RepetitionMinus &RepetitionMinus::operator=(const RepetitionMinus & other)
{
  RepetitionMinus tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionMinus::swap(RepetitionMinus & other)
{

}

RepetitionMinus::~RepetitionMinus()
{

}

void RepetitionMinus::accept(Visitor *v)
{
  v->visitRepetitionMinus(this);
}

RepetitionMinus *RepetitionMinus::clone() const
{
  return new RepetitionMinus(*this);
}



/********************   RepetitionQuestion    ********************/
RepetitionQuestion::RepetitionQuestion()
{

}

RepetitionQuestion::RepetitionQuestion(const RepetitionQuestion & other)
{

}

RepetitionQuestion &RepetitionQuestion::operator=(const RepetitionQuestion & other)
{
  RepetitionQuestion tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionQuestion::swap(RepetitionQuestion & other)
{

}

RepetitionQuestion::~RepetitionQuestion()
{

}

void RepetitionQuestion::accept(Visitor *v)
{
  v->visitRepetitionQuestion(this);
}

RepetitionQuestion *RepetitionQuestion::clone() const
{
  return new RepetitionQuestion(*this);
}



/********************   RepetitionPair    ********************/
RepetitionPair::RepetitionPair(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

RepetitionPair::RepetitionPair(const RepetitionPair & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

RepetitionPair &RepetitionPair::operator=(const RepetitionPair & other)
{
  RepetitionPair tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionPair::swap(RepetitionPair & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

RepetitionPair::~RepetitionPair()
{
  delete(expr_1);
  delete(expr_2);

}

void RepetitionPair::accept(Visitor *v)
{
  v->visitRepetitionPair(this);
}

RepetitionPair *RepetitionPair::clone() const
{
  return new RepetitionPair(*this);
}



/********************   RepetitionOne    ********************/
RepetitionOne::RepetitionOne(Expr *p1)
{
  expr_ = p1;

}

RepetitionOne::RepetitionOne(const RepetitionOne & other)
{
  expr_ = other.expr_->clone();

}

RepetitionOne &RepetitionOne::operator=(const RepetitionOne & other)
{
  RepetitionOne tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionOne::swap(RepetitionOne & other)
{
  std::swap(expr_, other.expr_);

}

RepetitionOne::~RepetitionOne()
{
  delete(expr_);

}

void RepetitionOne::accept(Visitor *v)
{
  v->visitRepetitionOne(this);
}

RepetitionOne *RepetitionOne::clone() const
{
  return new RepetitionOne(*this);
}



/********************   RepetitionREmpty    ********************/
RepetitionREmpty::RepetitionREmpty(Expr *p1)
{
  expr_ = p1;

}

RepetitionREmpty::RepetitionREmpty(const RepetitionREmpty & other)
{
  expr_ = other.expr_->clone();

}

RepetitionREmpty &RepetitionREmpty::operator=(const RepetitionREmpty & other)
{
  RepetitionREmpty tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionREmpty::swap(RepetitionREmpty & other)
{
  std::swap(expr_, other.expr_);

}

RepetitionREmpty::~RepetitionREmpty()
{
  delete(expr_);

}

void RepetitionREmpty::accept(Visitor *v)
{
  v->visitRepetitionREmpty(this);
}

RepetitionREmpty *RepetitionREmpty::clone() const
{
  return new RepetitionREmpty(*this);
}



/********************   RepetitionLEmpty    ********************/
RepetitionLEmpty::RepetitionLEmpty(Expr *p1)
{
  expr_ = p1;

}

RepetitionLEmpty::RepetitionLEmpty(const RepetitionLEmpty & other)
{
  expr_ = other.expr_->clone();

}

RepetitionLEmpty &RepetitionLEmpty::operator=(const RepetitionLEmpty & other)
{
  RepetitionLEmpty tmp(other);
  swap(tmp);
  return *this;
}

void RepetitionLEmpty::swap(RepetitionLEmpty & other)
{
  std::swap(expr_, other.expr_);

}

RepetitionLEmpty::~RepetitionLEmpty()
{
  delete(expr_);

}

void RepetitionLEmpty::accept(Visitor *v)
{
  v->visitRepetitionLEmpty(this);
}

RepetitionLEmpty *RepetitionLEmpty::clone() const
{
  return new RepetitionLEmpty(*this);
}



/********************   LogicOr    ********************/
LogicOr::LogicOr(Cond *p1, Cond *p2)
{
  cond_1 = p1;
  cond_2 = p2;

}

LogicOr::LogicOr(const LogicOr & other)
{
  cond_1 = other.cond_1->clone();
  cond_2 = other.cond_2->clone();

}

LogicOr &LogicOr::operator=(const LogicOr & other)
{
  LogicOr tmp(other);
  swap(tmp);
  return *this;
}

void LogicOr::swap(LogicOr & other)
{
  std::swap(cond_1, other.cond_1);
  std::swap(cond_2, other.cond_2);

}

LogicOr::~LogicOr()
{
  delete(cond_1);
  delete(cond_2);

}

void LogicOr::accept(Visitor *v)
{
  v->visitLogicOr(this);
}

LogicOr *LogicOr::clone() const
{
  return new LogicOr(*this);
}



/********************   LogicAnd    ********************/
LogicAnd::LogicAnd(Cond *p1, Cond *p2)
{
  cond_1 = p1;
  cond_2 = p2;

}

LogicAnd::LogicAnd(const LogicAnd & other)
{
  cond_1 = other.cond_1->clone();
  cond_2 = other.cond_2->clone();

}

LogicAnd &LogicAnd::operator=(const LogicAnd & other)
{
  LogicAnd tmp(other);
  swap(tmp);
  return *this;
}

void LogicAnd::swap(LogicAnd & other)
{
  std::swap(cond_1, other.cond_1);
  std::swap(cond_2, other.cond_2);

}

LogicAnd::~LogicAnd()
{
  delete(cond_1);
  delete(cond_2);

}

void LogicAnd::accept(Visitor *v)
{
  v->visitLogicAnd(this);
}

LogicAnd *LogicAnd::clone() const
{
  return new LogicAnd(*this);
}



/********************   ACondCOR    ********************/
ACondCOR::ACondCOR(Ident p1)
{
  ident_ = p1;

}

ACondCOR::ACondCOR(const ACondCOR & other)
{
  ident_ = other.ident_;

}

ACondCOR &ACondCOR::operator=(const ACondCOR & other)
{
  ACondCOR tmp(other);
  swap(tmp);
  return *this;
}

void ACondCOR::swap(ACondCOR & other)
{
  std::swap(ident_, other.ident_);

}

ACondCOR::~ACondCOR()
{

}

void ACondCOR::accept(Visitor *v)
{
  v->visitACondCOR(this);
}

ACondCOR *ACondCOR::clone() const
{
  return new ACondCOR(*this);
}



/********************   ACondCALL    ********************/
ACondCALL::ACondCALL(Ident p1)
{
  ident_ = p1;

}

ACondCALL::ACondCALL(const ACondCALL & other)
{
  ident_ = other.ident_;

}

ACondCALL &ACondCALL::operator=(const ACondCALL & other)
{
  ACondCALL tmp(other);
  swap(tmp);
  return *this;
}

void ACondCALL::swap(ACondCALL & other)
{
  std::swap(ident_, other.ident_);

}

ACondCALL::~ACondCALL()
{

}

void ACondCALL::accept(Visitor *v)
{
  v->visitACondCALL(this);
}

ACondCALL *ACondCALL::clone() const
{
  return new ACondCALL(*this);
}



/********************   ACondReturn    ********************/
ACondReturn::ACondReturn(Ident p1)
{
  ident_ = p1;

}

ACondReturn::ACondReturn(const ACondReturn & other)
{
  ident_ = other.ident_;

}

ACondReturn &ACondReturn::operator=(const ACondReturn & other)
{
  ACondReturn tmp(other);
  swap(tmp);
  return *this;
}

void ACondReturn::swap(ACondReturn & other)
{
  std::swap(ident_, other.ident_);

}

ACondReturn::~ACondReturn()
{

}

void ACondReturn::accept(Visitor *v)
{
  v->visitACondReturn(this);
}

ACondReturn *ACondReturn::clone() const
{
  return new ACondReturn(*this);
}



/********************   ACondTrue    ********************/
ACondTrue::ACondTrue()
{

}

ACondTrue::ACondTrue(const ACondTrue & other)
{

}

ACondTrue &ACondTrue::operator=(const ACondTrue & other)
{
  ACondTrue tmp(other);
  swap(tmp);
  return *this;
}

void ACondTrue::swap(ACondTrue & other)
{

}

ACondTrue::~ACondTrue()
{

}

void ACondTrue::accept(Visitor *v)
{
  v->visitACondTrue(this);
}

ACondTrue *ACondTrue::clone() const
{
  return new ACondTrue(*this);
}



/********************   ACondFalse    ********************/
ACondFalse::ACondFalse()
{

}

ACondFalse::ACondFalse(const ACondFalse & other)
{

}

ACondFalse &ACondFalse::operator=(const ACondFalse & other)
{
  ACondFalse tmp(other);
  swap(tmp);
  return *this;
}

void ACondFalse::swap(ACondFalse & other)
{

}

ACondFalse::~ACondFalse()
{

}

void ACondFalse::accept(Visitor *v)
{
  v->visitACondFalse(this);
}

ACondFalse *ACondFalse::clone() const
{
  return new ACondFalse(*this);
}



/********************   ACondNot    ********************/
ACondNot::ACondNot(Cond *p1)
{
  cond_ = p1;

}

ACondNot::ACondNot(const ACondNot & other)
{
  cond_ = other.cond_->clone();

}

ACondNot &ACondNot::operator=(const ACondNot & other)
{
  ACondNot tmp(other);
  swap(tmp);
  return *this;
}

void ACondNot::swap(ACondNot & other)
{
  std::swap(cond_, other.cond_);

}

ACondNot::~ACondNot()
{
  delete(cond_);

}

void ACondNot::accept(Visitor *v)
{
  v->visitACondNot(this);
}

ACondNot *ACondNot::clone() const
{
  return new ACondNot(*this);
}



/********************   RelationCond    ********************/
RelationCond::RelationCond(LogicRelation *p1)
{
  logicrelation_ = p1;

}

RelationCond::RelationCond(const RelationCond & other)
{
  logicrelation_ = other.logicrelation_->clone();

}

RelationCond &RelationCond::operator=(const RelationCond & other)
{
  RelationCond tmp(other);
  swap(tmp);
  return *this;
}

void RelationCond::swap(RelationCond & other)
{
  std::swap(logicrelation_, other.logicrelation_);

}

RelationCond::~RelationCond()
{
  delete(logicrelation_);

}

void RelationCond::accept(Visitor *v)
{
  v->visitRelationCond(this);
}

RelationCond *RelationCond::clone() const
{
  return new RelationCond(*this);
}



/********************   LogicEQ    ********************/
LogicEQ::LogicEQ(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicEQ::LogicEQ(const LogicEQ & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicEQ &LogicEQ::operator=(const LogicEQ & other)
{
  LogicEQ tmp(other);
  swap(tmp);
  return *this;
}

void LogicEQ::swap(LogicEQ & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicEQ::~LogicEQ()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicEQ::accept(Visitor *v)
{
  v->visitLogicEQ(this);
}

LogicEQ *LogicEQ::clone() const
{
  return new LogicEQ(*this);
}



/********************   LogicLess    ********************/
LogicLess::LogicLess(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicLess::LogicLess(const LogicLess & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicLess &LogicLess::operator=(const LogicLess & other)
{
  LogicLess tmp(other);
  swap(tmp);
  return *this;
}

void LogicLess::swap(LogicLess & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicLess::~LogicLess()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicLess::accept(Visitor *v)
{
  v->visitLogicLess(this);
}

LogicLess *LogicLess::clone() const
{
  return new LogicLess(*this);
}



/********************   LogicGreater    ********************/
LogicGreater::LogicGreater(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicGreater::LogicGreater(const LogicGreater & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicGreater &LogicGreater::operator=(const LogicGreater & other)
{
  LogicGreater tmp(other);
  swap(tmp);
  return *this;
}

void LogicGreater::swap(LogicGreater & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicGreater::~LogicGreater()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicGreater::accept(Visitor *v)
{
  v->visitLogicGreater(this);
}

LogicGreater *LogicGreater::clone() const
{
  return new LogicGreater(*this);
}



/********************   LogicLessEQ    ********************/
LogicLessEQ::LogicLessEQ(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicLessEQ::LogicLessEQ(const LogicLessEQ & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicLessEQ &LogicLessEQ::operator=(const LogicLessEQ & other)
{
  LogicLessEQ tmp(other);
  swap(tmp);
  return *this;
}

void LogicLessEQ::swap(LogicLessEQ & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicLessEQ::~LogicLessEQ()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicLessEQ::accept(Visitor *v)
{
  v->visitLogicLessEQ(this);
}

LogicLessEQ *LogicLessEQ::clone() const
{
  return new LogicLessEQ(*this);
}



/********************   LogicGreaterEQ    ********************/
LogicGreaterEQ::LogicGreaterEQ(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicGreaterEQ::LogicGreaterEQ(const LogicGreaterEQ & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicGreaterEQ &LogicGreaterEQ::operator=(const LogicGreaterEQ & other)
{
  LogicGreaterEQ tmp(other);
  swap(tmp);
  return *this;
}

void LogicGreaterEQ::swap(LogicGreaterEQ & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicGreaterEQ::~LogicGreaterEQ()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicGreaterEQ::accept(Visitor *v)
{
  v->visitLogicGreaterEQ(this);
}

LogicGreaterEQ *LogicGreaterEQ::clone() const
{
  return new LogicGreaterEQ(*this);
}



/********************   LogicNotEQ    ********************/
LogicNotEQ::LogicNotEQ(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicNotEQ::LogicNotEQ(const LogicNotEQ & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicNotEQ &LogicNotEQ::operator=(const LogicNotEQ & other)
{
  LogicNotEQ tmp(other);
  swap(tmp);
  return *this;
}

void LogicNotEQ::swap(LogicNotEQ & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicNotEQ::~LogicNotEQ()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicNotEQ::accept(Visitor *v)
{
  v->visitLogicNotEQ(this);
}

LogicNotEQ *LogicNotEQ::clone() const
{
  return new LogicNotEQ(*this);
}



/********************   Add    ********************/
Add::Add(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Add::Add(const Add & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Add &Add::operator=(const Add & other)
{
  Add tmp(other);
  swap(tmp);
  return *this;
}

void Add::swap(Add & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Add::~Add()
{
  delete(expr_1);
  delete(expr_2);

}

void Add::accept(Visitor *v)
{
  v->visitAdd(this);
}

Add *Add::clone() const
{
  return new Add(*this);
}



/********************   Subtract    ********************/
Subtract::Subtract(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Subtract::Subtract(const Subtract & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Subtract &Subtract::operator=(const Subtract & other)
{
  Subtract tmp(other);
  swap(tmp);
  return *this;
}

void Subtract::swap(Subtract & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Subtract::~Subtract()
{
  delete(expr_1);
  delete(expr_2);

}

void Subtract::accept(Visitor *v)
{
  v->visitSubtract(this);
}

Subtract *Subtract::clone() const
{
  return new Subtract(*this);
}



/********************   Divide    ********************/
Divide::Divide(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Divide::Divide(const Divide & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Divide &Divide::operator=(const Divide & other)
{
  Divide tmp(other);
  swap(tmp);
  return *this;
}

void Divide::swap(Divide & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Divide::~Divide()
{
  delete(expr_1);
  delete(expr_2);

}

void Divide::accept(Visitor *v)
{
  v->visitDivide(this);
}

Divide *Divide::clone() const
{
  return new Divide(*this);
}



/********************   Multiply    ********************/
Multiply::Multiply(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Multiply::Multiply(const Multiply & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Multiply &Multiply::operator=(const Multiply & other)
{
  Multiply tmp(other);
  swap(tmp);
  return *this;
}

void Multiply::swap(Multiply & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Multiply::~Multiply()
{
  delete(expr_1);
  delete(expr_2);

}

void Multiply::accept(Visitor *v)
{
  v->visitMultiply(this);
}

Multiply *Multiply::clone() const
{
  return new Multiply(*this);
}



/********************   Mod    ********************/
Mod::Mod(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Mod::Mod(const Mod & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Mod &Mod::operator=(const Mod & other)
{
  Mod tmp(other);
  swap(tmp);
  return *this;
}

void Mod::swap(Mod & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Mod::~Mod()
{
  delete(expr_1);
  delete(expr_2);

}

void Mod::accept(Visitor *v)
{
  v->visitMod(this);
}

Mod *Mod::clone() const
{
  return new Mod(*this);
}



/********************   BitAnd    ********************/
BitAnd::BitAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

BitAnd::BitAnd(const BitAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

BitAnd &BitAnd::operator=(const BitAnd & other)
{
  BitAnd tmp(other);
  swap(tmp);
  return *this;
}

void BitAnd::swap(BitAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

BitAnd::~BitAnd()
{
  delete(expr_1);
  delete(expr_2);

}

void BitAnd::accept(Visitor *v)
{
  v->visitBitAnd(this);
}

BitAnd *BitAnd::clone() const
{
  return new BitAnd(*this);
}



/********************   BitOr    ********************/
BitOr::BitOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

BitOr::BitOr(const BitOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

BitOr &BitOr::operator=(const BitOr & other)
{
  BitOr tmp(other);
  swap(tmp);
  return *this;
}

void BitOr::swap(BitOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

BitOr::~BitOr()
{
  delete(expr_1);
  delete(expr_2);

}

void BitOr::accept(Visitor *v)
{
  v->visitBitOr(this);
}

BitOr *BitOr::clone() const
{
  return new BitOr(*this);
}



/********************   BitXor    ********************/
BitXor::BitXor(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

BitXor::BitXor(const BitXor & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

BitXor &BitXor::operator=(const BitXor & other)
{
  BitXor tmp(other);
  swap(tmp);
  return *this;
}

void BitXor::swap(BitXor & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

BitXor::~BitXor()
{
  delete(expr_1);
  delete(expr_2);

}

void BitXor::accept(Visitor *v)
{
  v->visitBitXor(this);
}

BitXor *BitXor::clone() const
{
  return new BitXor(*this);
}



/********************   Int    ********************/
Int::Int(Integer p1)
{
  integer_ = p1;

}

Int::Int(const Int & other)
{
  integer_ = other.integer_;

}

Int &Int::operator=(const Int & other)
{
  Int tmp(other);
  swap(tmp);
  return *this;
}

void Int::swap(Int & other)
{
  std::swap(integer_, other.integer_);

}

Int::~Int()
{

}

void Int::accept(Visitor *v)
{
  v->visitInt(this);
}

Int *Int::clone() const
{
  return new Int(*this);
}



/********************   Float    ********************/
Float::Float(Double p1)
{
  double_ = p1;

}

Float::Float(const Float & other)
{
  double_ = other.double_;

}

Float &Float::operator=(const Float & other)
{
  Float tmp(other);
  swap(tmp);
  return *this;
}

void Float::swap(Float & other)
{
  std::swap(double_, other.double_);

}

Float::~Float()
{

}

void Float::accept(Visitor *v)
{
  v->visitFloat(this);
}

Float *Float::clone() const
{
  return new Float(*this);
}



/********************   NegativeInt    ********************/
NegativeInt::NegativeInt(Integer p1)
{
  integer_ = p1;

}

NegativeInt::NegativeInt(const NegativeInt & other)
{
  integer_ = other.integer_;

}

NegativeInt &NegativeInt::operator=(const NegativeInt & other)
{
  NegativeInt tmp(other);
  swap(tmp);
  return *this;
}

void NegativeInt::swap(NegativeInt & other)
{
  std::swap(integer_, other.integer_);

}

NegativeInt::~NegativeInt()
{

}

void NegativeInt::accept(Visitor *v)
{
  v->visitNegativeInt(this);
}

NegativeInt *NegativeInt::clone() const
{
  return new NegativeInt(*this);
}



/********************   NegativeDouble    ********************/
NegativeDouble::NegativeDouble(Double p1)
{
  double_ = p1;

}

NegativeDouble::NegativeDouble(const NegativeDouble & other)
{
  double_ = other.double_;

}

NegativeDouble &NegativeDouble::operator=(const NegativeDouble & other)
{
  NegativeDouble tmp(other);
  swap(tmp);
  return *this;
}

void NegativeDouble::swap(NegativeDouble & other)
{
  std::swap(double_, other.double_);

}

NegativeDouble::~NegativeDouble()
{

}

void NegativeDouble::accept(Visitor *v)
{
  v->visitNegativeDouble(this);
}

NegativeDouble *NegativeDouble::clone() const
{
  return new NegativeDouble(*this);
}



/********************   StructFielsAccess    ********************/
StructFielsAccess::StructFielsAccess(Expr *p1, Ident p2)
{
  expr_ = p1;
  ident_ = p2;

}

StructFielsAccess::StructFielsAccess(const StructFielsAccess & other)
{
  expr_ = other.expr_->clone();
  ident_ = other.ident_;

}

StructFielsAccess &StructFielsAccess::operator=(const StructFielsAccess & other)
{
  StructFielsAccess tmp(other);
  swap(tmp);
  return *this;
}

void StructFielsAccess::swap(StructFielsAccess & other)
{
  std::swap(expr_, other.expr_);
  std::swap(ident_, other.ident_);

}

StructFielsAccess::~StructFielsAccess()
{
  delete(expr_);

}

void StructFielsAccess::accept(Visitor *v)
{
  v->visitStructFielsAccess(this);
}

StructFielsAccess *StructFielsAccess::clone() const
{
  return new StructFielsAccess(*this);
}



/********************   PointerAccess    ********************/
PointerAccess::PointerAccess(Expr *p1, Ident p2)
{
  expr_ = p1;
  ident_ = p2;

}

PointerAccess::PointerAccess(const PointerAccess & other)
{
  expr_ = other.expr_->clone();
  ident_ = other.ident_;

}

PointerAccess &PointerAccess::operator=(const PointerAccess & other)
{
  PointerAccess tmp(other);
  swap(tmp);
  return *this;
}

void PointerAccess::swap(PointerAccess & other)
{
  std::swap(expr_, other.expr_);
  std::swap(ident_, other.ident_);

}

PointerAccess::~PointerAccess()
{
  delete(expr_);

}

void PointerAccess::accept(Visitor *v)
{
  v->visitPointerAccess(this);
}

PointerAccess *PointerAccess::clone() const
{
  return new PointerAccess(*this);
}



/********************   ArrayAccess    ********************/
ArrayAccess::ArrayAccess(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

ArrayAccess::ArrayAccess(const ArrayAccess & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

ArrayAccess &ArrayAccess::operator=(const ArrayAccess & other)
{
  ArrayAccess tmp(other);
  swap(tmp);
  return *this;
}

void ArrayAccess::swap(ArrayAccess & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

ArrayAccess::~ArrayAccess()
{
  delete(expr_1);
  delete(expr_2);

}

void ArrayAccess::accept(Visitor *v)
{
  v->visitArrayAccess(this);
}

ArrayAccess *ArrayAccess::clone() const
{
  return new ArrayAccess(*this);
}



/********************   RefAccess    ********************/
RefAccess::RefAccess(Expr *p1)
{
  expr_ = p1;

}

RefAccess::RefAccess(const RefAccess & other)
{
  expr_ = other.expr_->clone();

}

RefAccess &RefAccess::operator=(const RefAccess & other)
{
  RefAccess tmp(other);
  swap(tmp);
  return *this;
}

void RefAccess::swap(RefAccess & other)
{
  std::swap(expr_, other.expr_);

}

RefAccess::~RefAccess()
{
  delete(expr_);

}

void RefAccess::accept(Visitor *v)
{
  v->visitRefAccess(this);
}

RefAccess *RefAccess::clone() const
{
  return new RefAccess(*this);
}



/********************   FunAccess    ********************/
FunAccess::FunAccess(Ident p1, Ident p2)
{
  ident_1 = p1;
  ident_2 = p2;

}

FunAccess::FunAccess(const FunAccess & other)
{
  ident_1 = other.ident_1;
  ident_2 = other.ident_2;

}

FunAccess &FunAccess::operator=(const FunAccess & other)
{
  FunAccess tmp(other);
  swap(tmp);
  return *this;
}

void FunAccess::swap(FunAccess & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(ident_2, other.ident_2);

}

FunAccess::~FunAccess()
{

}

void FunAccess::accept(Visitor *v)
{
  v->visitFunAccess(this);
}

FunAccess *FunAccess::clone() const
{
  return new FunAccess(*this);
}



/********************   Identifier    ********************/
Identifier::Identifier(Ident p1)
{
  ident_ = p1;

}

Identifier::Identifier(const Identifier & other)
{
  ident_ = other.ident_;

}

Identifier &Identifier::operator=(const Identifier & other)
{
  Identifier tmp(other);
  swap(tmp);
  return *this;
}

void Identifier::swap(Identifier & other)
{
  std::swap(ident_, other.ident_);

}

Identifier::~Identifier()
{

}

void Identifier::accept(Visitor *v)
{
  v->visitIdentifier(this);
}

Identifier *Identifier::clone() const
{
  return new Identifier(*this);
}



/********************   MetavarAccess    ********************/
MetavarAccess::MetavarAccess(Ident p1)
{
  ident_ = p1;

}

MetavarAccess::MetavarAccess(const MetavarAccess & other)
{
  ident_ = other.ident_;

}

MetavarAccess &MetavarAccess::operator=(const MetavarAccess & other)
{
  MetavarAccess tmp(other);
  swap(tmp);
  return *this;
}

void MetavarAccess::swap(MetavarAccess & other)
{
  std::swap(ident_, other.ident_);

}

MetavarAccess::~MetavarAccess()
{

}

void MetavarAccess::accept(Visitor *v)
{
  v->visitMetavarAccess(this);
}

MetavarAccess *MetavarAccess::clone() const
{
  return new MetavarAccess(*this);
}



/********************   AnAction    ********************/
AnAction::AnAction(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

AnAction::AnAction(const AnAction & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

AnAction &AnAction::operator=(const AnAction & other)
{
  AnAction tmp(other);
  swap(tmp);
  return *this;
}

void AnAction::swap(AnAction & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

AnAction::~AnAction()
{
  delete(expr_);

}

void AnAction::accept(Visitor *v)
{
  v->visitAnAction(this);
}

AnAction *AnAction::clone() const
{
  return new AnAction(*this);
}




/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}

ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}

ListIdent* consListIdent(Ident x, ListIdent* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAnOption    ********************/

void ListAnOption::accept(Visitor *v)
{
  v->visitListAnOption(this);
}

ListAnOption *ListAnOption::clone() const
{
  return new ListAnOption(*this);
}

ListAnOption* consListAnOption(AnOption* x, ListAnOption* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListMetavar    ********************/

void ListMetavar::accept(Visitor *v)
{
  v->visitListMetavar(this);
}

ListMetavar *ListMetavar::clone() const
{
  return new ListMetavar(*this);
}

ListMetavar* consListMetavar(Metavar* x, ListMetavar* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListState    ********************/

void ListState::accept(Visitor *v)
{
  v->visitListState(this);
}

ListState *ListState::clone() const
{
  return new ListState(*this);
}

ListState* consListState(State* x, ListState* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListTransition    ********************/

void ListTransition::accept(Visitor *v)
{
  v->visitListTransition(this);
}

ListTransition *ListTransition::clone() const
{
  return new ListTransition(*this);
}

ListTransition* consListTransition(Transition* x, ListTransition* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListSeqElt    ********************/

void ListSeqElt::accept(Visitor *v)
{
  v->visitListSeqElt(this);
}

ListSeqElt *ListSeqElt::clone() const
{
  return new ListSeqElt(*this);
}

ListSeqElt* consListSeqElt(SeqElt* x, ListSeqElt* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAction    ********************/

void ListAction::accept(Visitor *v)
{
  v->visitListAction(this);
}

ListAction *ListAction::clone() const
{
  return new ListAction(*this);
}

ListAction* consListAction(Action* x, ListAction* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
