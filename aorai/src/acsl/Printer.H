/* File generated by the BNF Converter (bnfc 2.9.4.1). */

#ifndef ACSL_PRINTER_HEADER
#define ACSL_PRINTER_HEADER

#include "Absyn.H"
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

namespace acsl
{
/* Certain applications may improve performance by changing the buffer size */
#define ACSL_BUFFER_INITIAL 2000
/* You may wish to change _L_PAREN or _R_PAREN */
#define ACSL__L_PAREN '('
#define ACSL__R_PAREN ')'

class PrintAbsyn : public Visitor
{
 protected:
  int _n_, _i_;
  /* The following are simple heuristics for rendering terminals */
  /* You may wish to change them */
  void render(Char c);
  void render(String s);
  void render(const char *s);
  void indent(void);
  void backup(void);
  void onEmptyLine(void);
  void removeTrailingSpaces(void);
  void removeTrailingWhitespace(void);
 public:
  PrintAbsyn(void);
  ~PrintAbsyn(void);
  char *print(Visitable *v);

  void visitListIdent(ListIdent *p);
  void iterListIdent(ListIdent::const_iterator i, ListIdent::const_iterator j);
  void visitMain(Main *p); /* abstract class */
  void visitAMain(AMain *p);
  void visitAnOption(AnOption *p); /* abstract class */
  void visitOption(Option *p);
  void visitListAnOption(ListAnOption *p);
  void iterListAnOption(ListAnOption::const_iterator i, ListAnOption::const_iterator j);
  void visitOptIdentifiers(OptIdentifiers *p); /* abstract class */
  void visitEmptyOptIdent(EmptyOptIdent *p);
  void visitOptIdent(OptIdent *p);
  void visitMetavar(Metavar *p); /* abstract class */
  void visitAMetavar(AMetavar *p);
  void visitListMetavar(ListMetavar *p);
  void iterListMetavar(ListMetavar::const_iterator i, ListMetavar::const_iterator j);
  void visitState(State *p); /* abstract class */
  void visitAState(AState *p);
  void visitListState(ListState *p);
  void iterListState(ListState::const_iterator i, ListState::const_iterator j);
  void visitTransition(Transition *p); /* abstract class */
  void visitEmptyTransition(EmptyTransition *p);
  void visitSeqTransition(SeqTransition *p);
  void visitOtherTransition(OtherTransition *p);
  void visitSimpleTransition(SimpleTransition *p);
  void visitListTransition(ListTransition *p);
  void iterListTransition(ListTransition::const_iterator i, ListTransition::const_iterator j);
  void visitGuard(Guard *p); /* abstract class */
  void visitGuardSquares(GuardSquares *p);
  void visitGuardWithPreEmpty(GuardWithPreEmpty *p);
  void visitGuardWithPre(GuardWithPre *p);
  void visitGuardPostOnly(GuardPostOnly *p);
  void visitGuardPostOnlyEmpty(GuardPostOnlyEmpty *p);
  void visitPreCond(PreCond *p); /* abstract class */
  void visitPrecondCC(PrecondCC *p);
  void visitPrecondBB(PrecondBB *p);
  void visitPostCond(PostCond *p); /* abstract class */
  void visitPostcondEmpty(PostcondEmpty *p);
  void visitPostcondSimple(PostcondSimple *p);
  void visitSeqElt(SeqElt *p); /* abstract class */
  void visitSeqEltCond(SeqEltCond *p);
  void visitSeqEltGuardRep(SeqEltGuardRep *p);
  void visitListSeqElt(ListSeqElt *p);
  void iterListSeqElt(ListSeqElt::const_iterator i, ListSeqElt::const_iterator j);
  void visitRepetition(Repetition *p); /* abstract class */
  void visitRepetitionEmpty(RepetitionEmpty *p);
  void visitRepetitionPlus(RepetitionPlus *p);
  void visitRepetitionMinus(RepetitionMinus *p);
  void visitRepetitionQuestion(RepetitionQuestion *p);
  void visitRepetitionPair(RepetitionPair *p);
  void visitRepetitionOne(RepetitionOne *p);
  void visitRepetitionREmpty(RepetitionREmpty *p);
  void visitRepetitionLEmpty(RepetitionLEmpty *p);
  void visitCond(Cond *p); /* abstract class */
  void visitLogicOr(LogicOr *p);
  void visitLogicAnd(LogicAnd *p);
  void visitACondCOR(ACondCOR *p);
  void visitACondCALL(ACondCALL *p);
  void visitACondReturn(ACondReturn *p);
  void visitACondTrue(ACondTrue *p);
  void visitACondFalse(ACondFalse *p);
  void visitACondNot(ACondNot *p);
  void visitRelationCond(RelationCond *p);
  void visitLogicRelation(LogicRelation *p); /* abstract class */
  void visitLogicEQ(LogicEQ *p);
  void visitLogicLess(LogicLess *p);
  void visitLogicGreater(LogicGreater *p);
  void visitLogicLessEQ(LogicLessEQ *p);
  void visitLogicGreaterEQ(LogicGreaterEQ *p);
  void visitLogicNotEQ(LogicNotEQ *p);
  void visitExpr(Expr *p); /* abstract class */
  void visitAdd(Add *p);
  void visitSubtract(Subtract *p);
  void visitDivide(Divide *p);
  void visitMultiply(Multiply *p);
  void visitMod(Mod *p);
  void visitBitAnd(BitAnd *p);
  void visitBitOr(BitOr *p);
  void visitBitXor(BitXor *p);
  void visitInt(Int *p);
  void visitFloat(Float *p);
  void visitNegativeInt(NegativeInt *p);
  void visitNegativeDouble(NegativeDouble *p);
  void visitStructFielsAccess(StructFielsAccess *p);
  void visitPointerAccess(PointerAccess *p);
  void visitArrayAccess(ArrayAccess *p);
  void visitRefAccess(RefAccess *p);
  void visitFunAccess(FunAccess *p);
  void visitIdentifier(Identifier *p);
  void visitMetavarAccess(MetavarAccess *p);
  void visitAction(Action *p); /* abstract class */
  void visitAnAction(AnAction *p);
  void visitListAction(ListAction *p);
  void iterListAction(ListAction::const_iterator i, ListAction::const_iterator j);

  void visitInteger(Integer i);
  void visitDouble(Double d);
  void visitChar(Char c);
  void visitString(String s);
  void visitIdent(String s);
  void visitIdent(String s);
 protected:
  char *buf_;
  size_t cur_, buf_size;

  void inline bufAppend(const char *s)
  {
    size_t end = cur_ + strlen(s);
    if (end >= buf_size) {
      do buf_size *= 2; /* Double the buffer size */
      while (end >= buf_size);
      resizeBuffer();
    }
    strcpy(&buf_[cur_], s);
    cur_ = end;
  }

  void inline bufAppend(const char c)
  {
    if (cur_ + 1 >= buf_size)
    {
      buf_size *= 2; /* Double the buffer size */
      resizeBuffer();
    }
    buf_[cur_] = c;
    buf_[++cur_] = 0;
  }

  void inline bufAppend(String str)
  {
    const char *s = str.c_str();
    bufAppend(s);
  }
  void inline bufReset(void)
  {
    if (buf_) delete[] buf_;
    buf_size = ACSL_BUFFER_INITIAL;
    buf_ = new char[buf_size];
    memset(buf_, 0, buf_size);
    cur_ = 0;
  }

  void inline resizeBuffer(void)
  {
    char *temp = new char[buf_size];
    if (buf_)
    {
      strcpy(temp, buf_);
      delete[] buf_;
    }
    buf_ = temp;
  }
};



class ShowAbsyn : public Visitor
{
 public:
  ShowAbsyn(void);
  ~ShowAbsyn(void);
  char *show(Visitable *v);

  void visitListIdent(ListIdent *p);
  void iterListIdent(ListIdent::const_iterator i, ListIdent::const_iterator j);
  void visitMain(Main *p); /* abstract class */
  void visitAMain(AMain *p);
  void visitAnOption(AnOption *p); /* abstract class */
  void visitOption(Option *p);
  void visitListAnOption(ListAnOption *p);
  void iterListAnOption(ListAnOption::const_iterator i, ListAnOption::const_iterator j);
  void visitOptIdentifiers(OptIdentifiers *p); /* abstract class */
  void visitEmptyOptIdent(EmptyOptIdent *p);
  void visitOptIdent(OptIdent *p);
  void visitMetavar(Metavar *p); /* abstract class */
  void visitAMetavar(AMetavar *p);
  void visitListMetavar(ListMetavar *p);
  void iterListMetavar(ListMetavar::const_iterator i, ListMetavar::const_iterator j);
  void visitState(State *p); /* abstract class */
  void visitAState(AState *p);
  void visitListState(ListState *p);
  void iterListState(ListState::const_iterator i, ListState::const_iterator j);
  void visitTransition(Transition *p); /* abstract class */
  void visitEmptyTransition(EmptyTransition *p);
  void visitSeqTransition(SeqTransition *p);
  void visitOtherTransition(OtherTransition *p);
  void visitSimpleTransition(SimpleTransition *p);
  void visitListTransition(ListTransition *p);
  void iterListTransition(ListTransition::const_iterator i, ListTransition::const_iterator j);
  void visitGuard(Guard *p); /* abstract class */
  void visitGuardSquares(GuardSquares *p);
  void visitGuardWithPreEmpty(GuardWithPreEmpty *p);
  void visitGuardWithPre(GuardWithPre *p);
  void visitGuardPostOnly(GuardPostOnly *p);
  void visitGuardPostOnlyEmpty(GuardPostOnlyEmpty *p);
  void visitPreCond(PreCond *p); /* abstract class */
  void visitPrecondCC(PrecondCC *p);
  void visitPrecondBB(PrecondBB *p);
  void visitPostCond(PostCond *p); /* abstract class */
  void visitPostcondEmpty(PostcondEmpty *p);
  void visitPostcondSimple(PostcondSimple *p);
  void visitSeqElt(SeqElt *p); /* abstract class */
  void visitSeqEltCond(SeqEltCond *p);
  void visitSeqEltGuardRep(SeqEltGuardRep *p);
  void visitListSeqElt(ListSeqElt *p);
  void iterListSeqElt(ListSeqElt::const_iterator i, ListSeqElt::const_iterator j);
  void visitRepetition(Repetition *p); /* abstract class */
  void visitRepetitionEmpty(RepetitionEmpty *p);
  void visitRepetitionPlus(RepetitionPlus *p);
  void visitRepetitionMinus(RepetitionMinus *p);
  void visitRepetitionQuestion(RepetitionQuestion *p);
  void visitRepetitionPair(RepetitionPair *p);
  void visitRepetitionOne(RepetitionOne *p);
  void visitRepetitionREmpty(RepetitionREmpty *p);
  void visitRepetitionLEmpty(RepetitionLEmpty *p);
  void visitCond(Cond *p); /* abstract class */
  void visitLogicOr(LogicOr *p);
  void visitLogicAnd(LogicAnd *p);
  void visitACondCOR(ACondCOR *p);
  void visitACondCALL(ACondCALL *p);
  void visitACondReturn(ACondReturn *p);
  void visitACondTrue(ACondTrue *p);
  void visitACondFalse(ACondFalse *p);
  void visitACondNot(ACondNot *p);
  void visitRelationCond(RelationCond *p);
  void visitLogicRelation(LogicRelation *p); /* abstract class */
  void visitLogicEQ(LogicEQ *p);
  void visitLogicLess(LogicLess *p);
  void visitLogicGreater(LogicGreater *p);
  void visitLogicLessEQ(LogicLessEQ *p);
  void visitLogicGreaterEQ(LogicGreaterEQ *p);
  void visitLogicNotEQ(LogicNotEQ *p);
  void visitExpr(Expr *p); /* abstract class */
  void visitAdd(Add *p);
  void visitSubtract(Subtract *p);
  void visitDivide(Divide *p);
  void visitMultiply(Multiply *p);
  void visitMod(Mod *p);
  void visitBitAnd(BitAnd *p);
  void visitBitOr(BitOr *p);
  void visitBitXor(BitXor *p);
  void visitInt(Int *p);
  void visitFloat(Float *p);
  void visitNegativeInt(NegativeInt *p);
  void visitNegativeDouble(NegativeDouble *p);
  void visitStructFielsAccess(StructFielsAccess *p);
  void visitPointerAccess(PointerAccess *p);
  void visitArrayAccess(ArrayAccess *p);
  void visitRefAccess(RefAccess *p);
  void visitFunAccess(FunAccess *p);
  void visitIdentifier(Identifier *p);
  void visitMetavarAccess(MetavarAccess *p);
  void visitAction(Action *p); /* abstract class */
  void visitAnAction(AnAction *p);
  void visitListAction(ListAction *p);
  void iterListAction(ListAction::const_iterator i, ListAction::const_iterator j);

  void visitInteger(Integer i);
  void visitDouble(Double d);
  void visitChar(Char c);
  void visitString(String s);
  void visitIdent(String s);
  void visitIdent(String s);
 protected:
  char *buf_;
  size_t cur_, buf_size;

  void inline bufAppend(const char *s)
  {
    size_t end = cur_ + strlen(s);
    if (end >= buf_size) {
      do buf_size *= 2; /* Double the buffer size */
      while (end >= buf_size);
      resizeBuffer();
    }
    strcpy(&buf_[cur_], s);
    cur_ = end;
  }

  void inline bufAppend(const char c)
  {
    if (cur_ + 1 >= buf_size)
    {
      buf_size *= 2; /* Double the buffer size */
      resizeBuffer();
    }
    buf_[cur_] = c;
    buf_[++cur_] = 0;
  }

  void inline bufAppend(String str)
  {
    const char *s = str.c_str();
    bufAppend(s);
  }
  void inline bufReset(void)
  {
    if (buf_) delete[] buf_;
    buf_size = ACSL_BUFFER_INITIAL;
    buf_ = new char[buf_size];
    memset(buf_, 0, buf_size);
    cur_ = 0;
  }

  void inline resizeBuffer(void)
  {
    char *temp = new char[buf_size];
    if (buf_)
    {
      strcpy(temp, buf_);
      delete[] buf_;
    }
    buf_ = temp;
  }
};


}

#endif

