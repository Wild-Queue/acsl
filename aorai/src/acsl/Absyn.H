/* File generated by the BNF Converter (bnfc 2.9.4.1). */

#ifndef ACSL_ABSYN_HEADER
#define ACSL_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.
namespace acsl
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string Ident;


/********************   Forward Declarations    ********************/

class Main;
class AnOption;
class OptIdentifiers;
class Metavar;
class State;
class Transition;
class Guard;
class PreCond;
class PostCond;
class SeqElt;
class Repetition;
class Cond;
class LogicRelation;
class Expr;
class Action;
class AMain;
class Option;
class EmptyOptIdent;
class OptIdent;
class AMetavar;
class AState;
class EmptyTransition;
class SeqTransition;
class OtherTransition;
class SimpleTransition;
class GuardSquares;
class GuardWithPreEmpty;
class GuardWithPre;
class GuardPostOnly;
class GuardPostOnlyEmpty;
class PrecondCC;
class PrecondBB;
class PostcondEmpty;
class PostcondSimple;
class SeqEltCond;
class SeqEltGuardRep;
class RepetitionEmpty;
class RepetitionPlus;
class RepetitionMinus;
class RepetitionQuestion;
class RepetitionPair;
class RepetitionOne;
class RepetitionREmpty;
class RepetitionLEmpty;
class LogicOr;
class LogicAnd;
class ACondCOR;
class ACondCALL;
class ACondReturn;
class ACondTrue;
class ACondFalse;
class ACondNot;
class RelationCond;
class LogicEQ;
class LogicLess;
class LogicGreater;
class LogicLessEQ;
class LogicGreaterEQ;
class LogicNotEQ;
class Add;
class Subtract;
class Divide;
class Multiply;
class Mod;
class BitAnd;
class BitOr;
class BitXor;
class Int;
class Float;
class NegativeInt;
class NegativeDouble;
class StructFielsAccess;
class PointerAccess;
class ArrayAccess;
class RefAccess;
class FunAccess;
class Identifier;
class MetavarAccess;
class AnAction;
class ListIdent;
class ListAnOption;
class ListMetavar;
class ListState;
class ListTransition;
class ListSeqElt;
class ListAction;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitMain(Main *p) = 0;
  virtual void visitAnOption(AnOption *p) = 0;
  virtual void visitOptIdentifiers(OptIdentifiers *p) = 0;
  virtual void visitMetavar(Metavar *p) = 0;
  virtual void visitState(State *p) = 0;
  virtual void visitTransition(Transition *p) = 0;
  virtual void visitGuard(Guard *p) = 0;
  virtual void visitPreCond(PreCond *p) = 0;
  virtual void visitPostCond(PostCond *p) = 0;
  virtual void visitSeqElt(SeqElt *p) = 0;
  virtual void visitRepetition(Repetition *p) = 0;
  virtual void visitCond(Cond *p) = 0;
  virtual void visitLogicRelation(LogicRelation *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitAction(Action *p) = 0;
  virtual void visitAMain(AMain *p) = 0;
  virtual void visitOption(Option *p) = 0;
  virtual void visitEmptyOptIdent(EmptyOptIdent *p) = 0;
  virtual void visitOptIdent(OptIdent *p) = 0;
  virtual void visitAMetavar(AMetavar *p) = 0;
  virtual void visitAState(AState *p) = 0;
  virtual void visitEmptyTransition(EmptyTransition *p) = 0;
  virtual void visitSeqTransition(SeqTransition *p) = 0;
  virtual void visitOtherTransition(OtherTransition *p) = 0;
  virtual void visitSimpleTransition(SimpleTransition *p) = 0;
  virtual void visitGuardSquares(GuardSquares *p) = 0;
  virtual void visitGuardWithPreEmpty(GuardWithPreEmpty *p) = 0;
  virtual void visitGuardWithPre(GuardWithPre *p) = 0;
  virtual void visitGuardPostOnly(GuardPostOnly *p) = 0;
  virtual void visitGuardPostOnlyEmpty(GuardPostOnlyEmpty *p) = 0;
  virtual void visitPrecondCC(PrecondCC *p) = 0;
  virtual void visitPrecondBB(PrecondBB *p) = 0;
  virtual void visitPostcondEmpty(PostcondEmpty *p) = 0;
  virtual void visitPostcondSimple(PostcondSimple *p) = 0;
  virtual void visitSeqEltCond(SeqEltCond *p) = 0;
  virtual void visitSeqEltGuardRep(SeqEltGuardRep *p) = 0;
  virtual void visitRepetitionEmpty(RepetitionEmpty *p) = 0;
  virtual void visitRepetitionPlus(RepetitionPlus *p) = 0;
  virtual void visitRepetitionMinus(RepetitionMinus *p) = 0;
  virtual void visitRepetitionQuestion(RepetitionQuestion *p) = 0;
  virtual void visitRepetitionPair(RepetitionPair *p) = 0;
  virtual void visitRepetitionOne(RepetitionOne *p) = 0;
  virtual void visitRepetitionREmpty(RepetitionREmpty *p) = 0;
  virtual void visitRepetitionLEmpty(RepetitionLEmpty *p) = 0;
  virtual void visitLogicOr(LogicOr *p) = 0;
  virtual void visitLogicAnd(LogicAnd *p) = 0;
  virtual void visitACondCOR(ACondCOR *p) = 0;
  virtual void visitACondCALL(ACondCALL *p) = 0;
  virtual void visitACondReturn(ACondReturn *p) = 0;
  virtual void visitACondTrue(ACondTrue *p) = 0;
  virtual void visitACondFalse(ACondFalse *p) = 0;
  virtual void visitACondNot(ACondNot *p) = 0;
  virtual void visitRelationCond(RelationCond *p) = 0;
  virtual void visitLogicEQ(LogicEQ *p) = 0;
  virtual void visitLogicLess(LogicLess *p) = 0;
  virtual void visitLogicGreater(LogicGreater *p) = 0;
  virtual void visitLogicLessEQ(LogicLessEQ *p) = 0;
  virtual void visitLogicGreaterEQ(LogicGreaterEQ *p) = 0;
  virtual void visitLogicNotEQ(LogicNotEQ *p) = 0;
  virtual void visitAdd(Add *p) = 0;
  virtual void visitSubtract(Subtract *p) = 0;
  virtual void visitDivide(Divide *p) = 0;
  virtual void visitMultiply(Multiply *p) = 0;
  virtual void visitMod(Mod *p) = 0;
  virtual void visitBitAnd(BitAnd *p) = 0;
  virtual void visitBitOr(BitOr *p) = 0;
  virtual void visitBitXor(BitXor *p) = 0;
  virtual void visitInt(Int *p) = 0;
  virtual void visitFloat(Float *p) = 0;
  virtual void visitNegativeInt(NegativeInt *p) = 0;
  virtual void visitNegativeDouble(NegativeDouble *p) = 0;
  virtual void visitStructFielsAccess(StructFielsAccess *p) = 0;
  virtual void visitPointerAccess(PointerAccess *p) = 0;
  virtual void visitArrayAccess(ArrayAccess *p) = 0;
  virtual void visitRefAccess(RefAccess *p) = 0;
  virtual void visitFunAccess(FunAccess *p) = 0;
  virtual void visitIdentifier(Identifier *p) = 0;
  virtual void visitMetavarAccess(MetavarAccess *p) = 0;
  virtual void visitAnAction(AnAction *p) = 0;
  virtual void visitListIdent(ListIdent *p) = 0;
  virtual void visitListAnOption(ListAnOption *p) = 0;
  virtual void visitListMetavar(ListMetavar *p) = 0;
  virtual void visitListState(ListState *p) = 0;
  virtual void visitListTransition(ListTransition *p) = 0;
  virtual void visitListSeqElt(ListSeqElt *p) = 0;
  virtual void visitListAction(ListAction *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Main : public Visitable
{
public:
  virtual Main *clone() const = 0;
  int line_number, char_number;
};

class AnOption : public Visitable
{
public:
  virtual AnOption *clone() const = 0;
  int line_number, char_number;
};

class OptIdentifiers : public Visitable
{
public:
  virtual OptIdentifiers *clone() const = 0;
  int line_number, char_number;
};

class Metavar : public Visitable
{
public:
  virtual Metavar *clone() const = 0;
  int line_number, char_number;
};

class State : public Visitable
{
public:
  virtual State *clone() const = 0;
  int line_number, char_number;
};

class Transition : public Visitable
{
public:
  virtual Transition *clone() const = 0;
  int line_number, char_number;
};

class Guard : public Visitable
{
public:
  virtual Guard *clone() const = 0;
  int line_number, char_number;
};

class PreCond : public Visitable
{
public:
  virtual PreCond *clone() const = 0;
  int line_number, char_number;
};

class PostCond : public Visitable
{
public:
  virtual PostCond *clone() const = 0;
  int line_number, char_number;
};

class SeqElt : public Visitable
{
public:
  virtual SeqElt *clone() const = 0;
  int line_number, char_number;
};

class Repetition : public Visitable
{
public:
  virtual Repetition *clone() const = 0;
  int line_number, char_number;
};

class Cond : public Visitable
{
public:
  virtual Cond *clone() const = 0;
  int line_number, char_number;
};

class LogicRelation : public Visitable
{
public:
  virtual LogicRelation *clone() const = 0;
  int line_number, char_number;
};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;
  int line_number, char_number;
};

class Action : public Visitable
{
public:
  virtual Action *clone() const = 0;
  int line_number, char_number;
};



class AMain : public Main
{
public:
  ListAnOption *listanoption_;
  ListMetavar *listmetavar_;
  ListState *liststate_;

  AMain(const AMain &);
  AMain &operator=(const AMain &);
  AMain(ListAnOption *p1, ListMetavar *p2, ListState *p3);
  ~AMain();
  virtual void accept(Visitor *v);
  virtual AMain *clone() const;
  void swap(AMain &);
};

class Option : public AnOption
{
public:
  Ident ident_;
  OptIdentifiers *optidentifiers_;

  Option(const Option &);
  Option &operator=(const Option &);
  Option(Ident p1, OptIdentifiers *p2);
  ~Option();
  virtual void accept(Visitor *v);
  virtual Option *clone() const;
  void swap(Option &);
};

class EmptyOptIdent : public OptIdentifiers
{
public:

  EmptyOptIdent(const EmptyOptIdent &);
  EmptyOptIdent &operator=(const EmptyOptIdent &);
  EmptyOptIdent();
  ~EmptyOptIdent();
  virtual void accept(Visitor *v);
  virtual EmptyOptIdent *clone() const;
  void swap(EmptyOptIdent &);
};

class OptIdent : public OptIdentifiers
{
public:
  ListIdent *listident_;

  OptIdent(const OptIdent &);
  OptIdent &operator=(const OptIdent &);
  OptIdent(ListIdent *p1);
  ~OptIdent();
  virtual void accept(Visitor *v);
  virtual OptIdent *clone() const;
  void swap(OptIdent &);
};

class AMetavar : public Metavar
{
public:
  Ident ident_1;
  Ident ident_2;

  AMetavar(const AMetavar &);
  AMetavar &operator=(const AMetavar &);
  AMetavar(Ident p1, Ident p2);
  ~AMetavar();
  virtual void accept(Visitor *v);
  virtual AMetavar *clone() const;
  void swap(AMetavar &);
};

class AState : public State
{
public:
  Ident ident_;
  ListTransition *listtransition_;

  AState(const AState &);
  AState &operator=(const AState &);
  AState(Ident p1, ListTransition *p2);
  ~AState();
  virtual void accept(Visitor *v);
  virtual AState *clone() const;
  void swap(AState &);
};

class EmptyTransition : public Transition
{
public:

  EmptyTransition(const EmptyTransition &);
  EmptyTransition &operator=(const EmptyTransition &);
  EmptyTransition();
  ~EmptyTransition();
  virtual void accept(Visitor *v);
  virtual EmptyTransition *clone() const;
  void swap(EmptyTransition &);
};

class SeqTransition : public Transition
{
public:
  SeqElt *seqelt_;
  ListAction *listaction_;
  Ident ident_;

  SeqTransition(const SeqTransition &);
  SeqTransition &operator=(const SeqTransition &);
  SeqTransition(SeqElt *p1, ListAction *p2, Ident p3);
  ~SeqTransition();
  virtual void accept(Visitor *v);
  virtual SeqTransition *clone() const;
  void swap(SeqTransition &);
};

class OtherTransition : public Transition
{
public:
  ListAction *listaction_;
  Ident ident_;

  OtherTransition(const OtherTransition &);
  OtherTransition &operator=(const OtherTransition &);
  OtherTransition(ListAction *p1, Ident p2);
  ~OtherTransition();
  virtual void accept(Visitor *v);
  virtual OtherTransition *clone() const;
  void swap(OtherTransition &);
};

class SimpleTransition : public Transition
{
public:
  ListAction *listaction_;
  Ident ident_;

  SimpleTransition(const SimpleTransition &);
  SimpleTransition &operator=(const SimpleTransition &);
  SimpleTransition(ListAction *p1, Ident p2);
  ~SimpleTransition();
  virtual void accept(Visitor *v);
  virtual SimpleTransition *clone() const;
  void swap(SimpleTransition &);
};

class GuardSquares : public Guard
{
public:
  ListSeqElt *listseqelt_;

  GuardSquares(const GuardSquares &);
  GuardSquares &operator=(const GuardSquares &);
  GuardSquares(ListSeqElt *p1);
  ~GuardSquares();
  virtual void accept(Visitor *v);
  virtual GuardSquares *clone() const;
  void swap(GuardSquares &);
};

class GuardWithPreEmpty : public Guard
{
public:
  Ident ident_;
  PreCond *precond_;
  PostCond *postcond_;

  GuardWithPreEmpty(const GuardWithPreEmpty &);
  GuardWithPreEmpty &operator=(const GuardWithPreEmpty &);
  GuardWithPreEmpty(Ident p1, PreCond *p2, PostCond *p3);
  ~GuardWithPreEmpty();
  virtual void accept(Visitor *v);
  virtual GuardWithPreEmpty *clone() const;
  void swap(GuardWithPreEmpty &);
};

class GuardWithPre : public Guard
{
public:
  Ident ident_;
  PreCond *precond_;
  ListSeqElt *listseqelt_;
  PostCond *postcond_;

  GuardWithPre(const GuardWithPre &);
  GuardWithPre &operator=(const GuardWithPre &);
  GuardWithPre(Ident p1, PreCond *p2, ListSeqElt *p3, PostCond *p4);
  ~GuardWithPre();
  virtual void accept(Visitor *v);
  virtual GuardWithPre *clone() const;
  void swap(GuardWithPre &);
};

class GuardPostOnly : public Guard
{
public:
  Ident ident_;
  ListSeqElt *listseqelt_;
  PostCond *postcond_;

  GuardPostOnly(const GuardPostOnly &);
  GuardPostOnly &operator=(const GuardPostOnly &);
  GuardPostOnly(Ident p1, ListSeqElt *p2, PostCond *p3);
  ~GuardPostOnly();
  virtual void accept(Visitor *v);
  virtual GuardPostOnly *clone() const;
  void swap(GuardPostOnly &);
};

class GuardPostOnlyEmpty : public Guard
{
public:
  Ident ident_;
  PostCond *postcond_;

  GuardPostOnlyEmpty(const GuardPostOnlyEmpty &);
  GuardPostOnlyEmpty &operator=(const GuardPostOnlyEmpty &);
  GuardPostOnlyEmpty(Ident p1, PostCond *p2);
  ~GuardPostOnlyEmpty();
  virtual void accept(Visitor *v);
  virtual GuardPostOnlyEmpty *clone() const;
  void swap(GuardPostOnlyEmpty &);
};

class PrecondCC : public PreCond
{
public:
  Ident ident_;

  PrecondCC(const PrecondCC &);
  PrecondCC &operator=(const PrecondCC &);
  PrecondCC(Ident p1);
  ~PrecondCC();
  virtual void accept(Visitor *v);
  virtual PrecondCC *clone() const;
  void swap(PrecondCC &);
};

class PrecondBB : public PreCond
{
public:
  Cond *cond_;

  PrecondBB(const PrecondBB &);
  PrecondBB &operator=(const PrecondBB &);
  PrecondBB(Cond *p1);
  ~PrecondBB();
  virtual void accept(Visitor *v);
  virtual PrecondBB *clone() const;
  void swap(PrecondBB &);
};

class PostcondEmpty : public PostCond
{
public:

  PostcondEmpty(const PostcondEmpty &);
  PostcondEmpty &operator=(const PostcondEmpty &);
  PostcondEmpty();
  ~PostcondEmpty();
  virtual void accept(Visitor *v);
  virtual PostcondEmpty *clone() const;
  void swap(PostcondEmpty &);
};

class PostcondSimple : public PostCond
{
public:
  Cond *cond_;

  PostcondSimple(const PostcondSimple &);
  PostcondSimple &operator=(const PostcondSimple &);
  PostcondSimple(Cond *p1);
  ~PostcondSimple();
  virtual void accept(Visitor *v);
  virtual PostcondSimple *clone() const;
  void swap(PostcondSimple &);
};

class SeqEltCond : public SeqElt
{
public:
  Cond *cond_;

  SeqEltCond(const SeqEltCond &);
  SeqEltCond &operator=(const SeqEltCond &);
  SeqEltCond(Cond *p1);
  ~SeqEltCond();
  virtual void accept(Visitor *v);
  virtual SeqEltCond *clone() const;
  void swap(SeqEltCond &);
};

class SeqEltGuardRep : public SeqElt
{
public:
  Guard *guard_;
  Repetition *repetition_;

  SeqEltGuardRep(const SeqEltGuardRep &);
  SeqEltGuardRep &operator=(const SeqEltGuardRep &);
  SeqEltGuardRep(Guard *p1, Repetition *p2);
  ~SeqEltGuardRep();
  virtual void accept(Visitor *v);
  virtual SeqEltGuardRep *clone() const;
  void swap(SeqEltGuardRep &);
};

class RepetitionEmpty : public Repetition
{
public:

  RepetitionEmpty(const RepetitionEmpty &);
  RepetitionEmpty &operator=(const RepetitionEmpty &);
  RepetitionEmpty();
  ~RepetitionEmpty();
  virtual void accept(Visitor *v);
  virtual RepetitionEmpty *clone() const;
  void swap(RepetitionEmpty &);
};

class RepetitionPlus : public Repetition
{
public:

  RepetitionPlus(const RepetitionPlus &);
  RepetitionPlus &operator=(const RepetitionPlus &);
  RepetitionPlus();
  ~RepetitionPlus();
  virtual void accept(Visitor *v);
  virtual RepetitionPlus *clone() const;
  void swap(RepetitionPlus &);
};

class RepetitionMinus : public Repetition
{
public:

  RepetitionMinus(const RepetitionMinus &);
  RepetitionMinus &operator=(const RepetitionMinus &);
  RepetitionMinus();
  ~RepetitionMinus();
  virtual void accept(Visitor *v);
  virtual RepetitionMinus *clone() const;
  void swap(RepetitionMinus &);
};

class RepetitionQuestion : public Repetition
{
public:

  RepetitionQuestion(const RepetitionQuestion &);
  RepetitionQuestion &operator=(const RepetitionQuestion &);
  RepetitionQuestion();
  ~RepetitionQuestion();
  virtual void accept(Visitor *v);
  virtual RepetitionQuestion *clone() const;
  void swap(RepetitionQuestion &);
};

class RepetitionPair : public Repetition
{
public:
  Expr *expr_1;
  Expr *expr_2;

  RepetitionPair(const RepetitionPair &);
  RepetitionPair &operator=(const RepetitionPair &);
  RepetitionPair(Expr *p1, Expr *p2);
  ~RepetitionPair();
  virtual void accept(Visitor *v);
  virtual RepetitionPair *clone() const;
  void swap(RepetitionPair &);
};

class RepetitionOne : public Repetition
{
public:
  Expr *expr_;

  RepetitionOne(const RepetitionOne &);
  RepetitionOne &operator=(const RepetitionOne &);
  RepetitionOne(Expr *p1);
  ~RepetitionOne();
  virtual void accept(Visitor *v);
  virtual RepetitionOne *clone() const;
  void swap(RepetitionOne &);
};

class RepetitionREmpty : public Repetition
{
public:
  Expr *expr_;

  RepetitionREmpty(const RepetitionREmpty &);
  RepetitionREmpty &operator=(const RepetitionREmpty &);
  RepetitionREmpty(Expr *p1);
  ~RepetitionREmpty();
  virtual void accept(Visitor *v);
  virtual RepetitionREmpty *clone() const;
  void swap(RepetitionREmpty &);
};

class RepetitionLEmpty : public Repetition
{
public:
  Expr *expr_;

  RepetitionLEmpty(const RepetitionLEmpty &);
  RepetitionLEmpty &operator=(const RepetitionLEmpty &);
  RepetitionLEmpty(Expr *p1);
  ~RepetitionLEmpty();
  virtual void accept(Visitor *v);
  virtual RepetitionLEmpty *clone() const;
  void swap(RepetitionLEmpty &);
};

class LogicOr : public Cond
{
public:
  Cond *cond_1;
  Cond *cond_2;

  LogicOr(const LogicOr &);
  LogicOr &operator=(const LogicOr &);
  LogicOr(Cond *p1, Cond *p2);
  ~LogicOr();
  virtual void accept(Visitor *v);
  virtual LogicOr *clone() const;
  void swap(LogicOr &);
};

class LogicAnd : public Cond
{
public:
  Cond *cond_1;
  Cond *cond_2;

  LogicAnd(const LogicAnd &);
  LogicAnd &operator=(const LogicAnd &);
  LogicAnd(Cond *p1, Cond *p2);
  ~LogicAnd();
  virtual void accept(Visitor *v);
  virtual LogicAnd *clone() const;
  void swap(LogicAnd &);
};

class ACondCOR : public Cond
{
public:
  Ident ident_;

  ACondCOR(const ACondCOR &);
  ACondCOR &operator=(const ACondCOR &);
  ACondCOR(Ident p1);
  ~ACondCOR();
  virtual void accept(Visitor *v);
  virtual ACondCOR *clone() const;
  void swap(ACondCOR &);
};

class ACondCALL : public Cond
{
public:
  Ident ident_;

  ACondCALL(const ACondCALL &);
  ACondCALL &operator=(const ACondCALL &);
  ACondCALL(Ident p1);
  ~ACondCALL();
  virtual void accept(Visitor *v);
  virtual ACondCALL *clone() const;
  void swap(ACondCALL &);
};

class ACondReturn : public Cond
{
public:
  Ident ident_;

  ACondReturn(const ACondReturn &);
  ACondReturn &operator=(const ACondReturn &);
  ACondReturn(Ident p1);
  ~ACondReturn();
  virtual void accept(Visitor *v);
  virtual ACondReturn *clone() const;
  void swap(ACondReturn &);
};

class ACondTrue : public Cond
{
public:

  ACondTrue(const ACondTrue &);
  ACondTrue &operator=(const ACondTrue &);
  ACondTrue();
  ~ACondTrue();
  virtual void accept(Visitor *v);
  virtual ACondTrue *clone() const;
  void swap(ACondTrue &);
};

class ACondFalse : public Cond
{
public:

  ACondFalse(const ACondFalse &);
  ACondFalse &operator=(const ACondFalse &);
  ACondFalse();
  ~ACondFalse();
  virtual void accept(Visitor *v);
  virtual ACondFalse *clone() const;
  void swap(ACondFalse &);
};

class ACondNot : public Cond
{
public:
  Cond *cond_;

  ACondNot(const ACondNot &);
  ACondNot &operator=(const ACondNot &);
  ACondNot(Cond *p1);
  ~ACondNot();
  virtual void accept(Visitor *v);
  virtual ACondNot *clone() const;
  void swap(ACondNot &);
};

class RelationCond : public Cond
{
public:
  LogicRelation *logicrelation_;

  RelationCond(const RelationCond &);
  RelationCond &operator=(const RelationCond &);
  RelationCond(LogicRelation *p1);
  ~RelationCond();
  virtual void accept(Visitor *v);
  virtual RelationCond *clone() const;
  void swap(RelationCond &);
};

class LogicEQ : public LogicRelation
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicEQ(const LogicEQ &);
  LogicEQ &operator=(const LogicEQ &);
  LogicEQ(Expr *p1, Expr *p2);
  ~LogicEQ();
  virtual void accept(Visitor *v);
  virtual LogicEQ *clone() const;
  void swap(LogicEQ &);
};

class LogicLess : public LogicRelation
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicLess(const LogicLess &);
  LogicLess &operator=(const LogicLess &);
  LogicLess(Expr *p1, Expr *p2);
  ~LogicLess();
  virtual void accept(Visitor *v);
  virtual LogicLess *clone() const;
  void swap(LogicLess &);
};

class LogicGreater : public LogicRelation
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicGreater(const LogicGreater &);
  LogicGreater &operator=(const LogicGreater &);
  LogicGreater(Expr *p1, Expr *p2);
  ~LogicGreater();
  virtual void accept(Visitor *v);
  virtual LogicGreater *clone() const;
  void swap(LogicGreater &);
};

class LogicLessEQ : public LogicRelation
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicLessEQ(const LogicLessEQ &);
  LogicLessEQ &operator=(const LogicLessEQ &);
  LogicLessEQ(Expr *p1, Expr *p2);
  ~LogicLessEQ();
  virtual void accept(Visitor *v);
  virtual LogicLessEQ *clone() const;
  void swap(LogicLessEQ &);
};

class LogicGreaterEQ : public LogicRelation
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicGreaterEQ(const LogicGreaterEQ &);
  LogicGreaterEQ &operator=(const LogicGreaterEQ &);
  LogicGreaterEQ(Expr *p1, Expr *p2);
  ~LogicGreaterEQ();
  virtual void accept(Visitor *v);
  virtual LogicGreaterEQ *clone() const;
  void swap(LogicGreaterEQ &);
};

class LogicNotEQ : public LogicRelation
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicNotEQ(const LogicNotEQ &);
  LogicNotEQ &operator=(const LogicNotEQ &);
  LogicNotEQ(Expr *p1, Expr *p2);
  ~LogicNotEQ();
  virtual void accept(Visitor *v);
  virtual LogicNotEQ *clone() const;
  void swap(LogicNotEQ &);
};

class Add : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Add(const Add &);
  Add &operator=(const Add &);
  Add(Expr *p1, Expr *p2);
  ~Add();
  virtual void accept(Visitor *v);
  virtual Add *clone() const;
  void swap(Add &);
};

class Subtract : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Subtract(const Subtract &);
  Subtract &operator=(const Subtract &);
  Subtract(Expr *p1, Expr *p2);
  ~Subtract();
  virtual void accept(Visitor *v);
  virtual Subtract *clone() const;
  void swap(Subtract &);
};

class Divide : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Divide(const Divide &);
  Divide &operator=(const Divide &);
  Divide(Expr *p1, Expr *p2);
  ~Divide();
  virtual void accept(Visitor *v);
  virtual Divide *clone() const;
  void swap(Divide &);
};

class Multiply : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Multiply(const Multiply &);
  Multiply &operator=(const Multiply &);
  Multiply(Expr *p1, Expr *p2);
  ~Multiply();
  virtual void accept(Visitor *v);
  virtual Multiply *clone() const;
  void swap(Multiply &);
};

class Mod : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Mod(const Mod &);
  Mod &operator=(const Mod &);
  Mod(Expr *p1, Expr *p2);
  ~Mod();
  virtual void accept(Visitor *v);
  virtual Mod *clone() const;
  void swap(Mod &);
};

class BitAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  BitAnd(const BitAnd &);
  BitAnd &operator=(const BitAnd &);
  BitAnd(Expr *p1, Expr *p2);
  ~BitAnd();
  virtual void accept(Visitor *v);
  virtual BitAnd *clone() const;
  void swap(BitAnd &);
};

class BitOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  BitOr(const BitOr &);
  BitOr &operator=(const BitOr &);
  BitOr(Expr *p1, Expr *p2);
  ~BitOr();
  virtual void accept(Visitor *v);
  virtual BitOr *clone() const;
  void swap(BitOr &);
};

class BitXor : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  BitXor(const BitXor &);
  BitXor &operator=(const BitXor &);
  BitXor(Expr *p1, Expr *p2);
  ~BitXor();
  virtual void accept(Visitor *v);
  virtual BitXor *clone() const;
  void swap(BitXor &);
};

class Int : public Expr
{
public:
  Integer integer_;

  Int(const Int &);
  Int &operator=(const Int &);
  Int(Integer p1);
  ~Int();
  virtual void accept(Visitor *v);
  virtual Int *clone() const;
  void swap(Int &);
};

class Float : public Expr
{
public:
  Double double_;

  Float(const Float &);
  Float &operator=(const Float &);
  Float(Double p1);
  ~Float();
  virtual void accept(Visitor *v);
  virtual Float *clone() const;
  void swap(Float &);
};

class NegativeInt : public Expr
{
public:
  Integer integer_;

  NegativeInt(const NegativeInt &);
  NegativeInt &operator=(const NegativeInt &);
  NegativeInt(Integer p1);
  ~NegativeInt();
  virtual void accept(Visitor *v);
  virtual NegativeInt *clone() const;
  void swap(NegativeInt &);
};

class NegativeDouble : public Expr
{
public:
  Double double_;

  NegativeDouble(const NegativeDouble &);
  NegativeDouble &operator=(const NegativeDouble &);
  NegativeDouble(Double p1);
  ~NegativeDouble();
  virtual void accept(Visitor *v);
  virtual NegativeDouble *clone() const;
  void swap(NegativeDouble &);
};

class StructFielsAccess : public Expr
{
public:
  Expr *expr_;
  Ident ident_;

  StructFielsAccess(const StructFielsAccess &);
  StructFielsAccess &operator=(const StructFielsAccess &);
  StructFielsAccess(Expr *p1, Ident p2);
  ~StructFielsAccess();
  virtual void accept(Visitor *v);
  virtual StructFielsAccess *clone() const;
  void swap(StructFielsAccess &);
};

class PointerAccess : public Expr
{
public:
  Expr *expr_;
  Ident ident_;

  PointerAccess(const PointerAccess &);
  PointerAccess &operator=(const PointerAccess &);
  PointerAccess(Expr *p1, Ident p2);
  ~PointerAccess();
  virtual void accept(Visitor *v);
  virtual PointerAccess *clone() const;
  void swap(PointerAccess &);
};

class ArrayAccess : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  ArrayAccess(const ArrayAccess &);
  ArrayAccess &operator=(const ArrayAccess &);
  ArrayAccess(Expr *p1, Expr *p2);
  ~ArrayAccess();
  virtual void accept(Visitor *v);
  virtual ArrayAccess *clone() const;
  void swap(ArrayAccess &);
};

class RefAccess : public Expr
{
public:
  Expr *expr_;

  RefAccess(const RefAccess &);
  RefAccess &operator=(const RefAccess &);
  RefAccess(Expr *p1);
  ~RefAccess();
  virtual void accept(Visitor *v);
  virtual RefAccess *clone() const;
  void swap(RefAccess &);
};

class FunAccess : public Expr
{
public:
  Ident ident_1;
  Ident ident_2;

  FunAccess(const FunAccess &);
  FunAccess &operator=(const FunAccess &);
  FunAccess(Ident p1, Ident p2);
  ~FunAccess();
  virtual void accept(Visitor *v);
  virtual FunAccess *clone() const;
  void swap(FunAccess &);
};

class Identifier : public Expr
{
public:
  Ident ident_;

  Identifier(const Identifier &);
  Identifier &operator=(const Identifier &);
  Identifier(Ident p1);
  ~Identifier();
  virtual void accept(Visitor *v);
  virtual Identifier *clone() const;
  void swap(Identifier &);
};

class MetavarAccess : public Expr
{
public:
  Ident ident_;

  MetavarAccess(const MetavarAccess &);
  MetavarAccess &operator=(const MetavarAccess &);
  MetavarAccess(Ident p1);
  ~MetavarAccess();
  virtual void accept(Visitor *v);
  virtual MetavarAccess *clone() const;
  void swap(MetavarAccess &);
};

class AnAction : public Action
{
public:
  Ident ident_;
  Expr *expr_;

  AnAction(const AnAction &);
  AnAction &operator=(const AnAction &);
  AnAction(Ident p1, Expr *p2);
  ~AnAction();
  virtual void accept(Visitor *v);
  virtual AnAction *clone() const;
  void swap(AnAction &);
};



class ListIdent : public Visitable, public std::vector<Ident>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdent *clone() const;
};

ListIdent* consListIdent(Ident x, ListIdent* xs);

class ListAnOption : public Visitable, public std::vector<AnOption*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListAnOption *clone() const;
};

ListAnOption* consListAnOption(AnOption* x, ListAnOption* xs);

class ListMetavar : public Visitable, public std::vector<Metavar*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListMetavar *clone() const;
};

ListMetavar* consListMetavar(Metavar* x, ListMetavar* xs);

class ListState : public Visitable, public std::vector<State*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListState *clone() const;
};

ListState* consListState(State* x, ListState* xs);

class ListTransition : public Visitable, public std::vector<Transition*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTransition *clone() const;
};

ListTransition* consListTransition(Transition* x, ListTransition* xs);

class ListSeqElt : public Visitable, public std::vector<SeqElt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListSeqElt *clone() const;
};

ListSeqElt* consListSeqElt(SeqElt* x, ListSeqElt* xs);

class ListAction : public Visitable, public std::vector<Action*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListAction *clone() const;
};

ListAction* consListAction(Action* x, ListAction* xs);




}
#endif
